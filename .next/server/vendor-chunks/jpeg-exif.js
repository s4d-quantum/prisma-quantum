"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jpeg-exif";
exports.ids = ["vendor-chunks/jpeg-exif"];
exports.modules = {

/***/ "(rsc)/./node_modules/jpeg-exif/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/jpeg-exif/lib/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar _fs = __webpack_require__(/*! fs */ \"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar tags = __webpack_require__(/*! ./tags.json */ \"(rsc)/./node_modules/jpeg-exif/lib/tags.json\");\n\n/*\n unsignedByte,\n asciiStrings,\n unsignedShort,\n unsignedLong,\n unsignedRational,\n signedByte,\n undefined,\n signedShort,\n signedLong,\n signedRational,\n singleFloat,\n doubleFloat\n */\nvar bytes = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8];\nvar SOIMarkerLength = 2;\nvar JPEGSOIMarker = 0xffd8;\nvar TIFFINTEL = 0x4949;\nvar TIFFMOTOROLA = 0x4d4d;\nvar APPMarkerLength = 2;\nvar APPMarkerBegin = 0xffe0;\nvar APPMarkerEnd = 0xffef;\nvar data = void 0;\n/**\n * @param buffer {Buffer}\n * @returns {Boolean}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var isImage = isValid(content);\n * console.log(isImage);\n */\nvar isValid = function isValid(buffer) {\n  try {\n    var SOIMarker = buffer.readUInt16BE(0);\n    return SOIMarker === JPEGSOIMarker;\n  } catch (e) {\n    throw new Error('Unsupport file format.');\n  }\n};\n/**\n * @param buffer {Buffer}\n * @returns {Boolean}\n * @example\n */\nvar isTiff = function isTiff(buffer) {\n  try {\n    var SOIMarker = buffer.readUInt16BE(0);\n    return SOIMarker === TIFFINTEL || SOIMarker === TIFFMOTOROLA;\n  } catch (e) {\n    throw new Error('Unsupport file format.');\n  }\n};\n/**\n * @param buffer {Buffer}\n * @returns {Number}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var APPNumber = checkAPPn(content);\n * console.log(APPNumber);\n */\nvar checkAPPn = function checkAPPn(buffer) {\n  try {\n    var APPMarkerTag = buffer.readUInt16BE(0);\n    var isInRange = APPMarkerTag >= APPMarkerBegin && APPMarkerTag <= APPMarkerEnd;\n    return isInRange ? APPMarkerTag - APPMarkerBegin : false;\n  } catch (e) {\n    throw new Error('Invalid APP Tag.');\n  }\n};\n/**\n * @param buffer {Buffer}\n * @param tagCollection {Object}\n * @param order {Boolean}\n * @param offset {Number}\n * @returns {Object}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = IFDHandler(content, 0, true, 8);\n * console.log(exifFragments.value);\n */\nvar IFDHandler = function IFDHandler(buffer, tagCollection, order, offset) {\n  var entriesNumber = order ? buffer.readUInt16BE(0) : buffer.readUInt16LE(0);\n\n  if (entriesNumber === 0) {\n    return {};\n  }\n\n  var entriesNumberLength = 2;\n  var entries = buffer.slice(entriesNumberLength);\n  var entryLength = 12;\n  // let nextIFDPointerBegin = entriesNumberLength + entryLength * entriesNumber;\n  // let bigNextIFDPointer= buffer.readUInt32BE(nextIFDPointerBegin) ;\n  // let littleNextIFDPointer= buffer.readUInt32LE(nextIFDPointerBegin);\n  // let nextIFDPointer = order ?bigNextIFDPointer:littleNextIFDPointer;\n  var exif = {};\n  var entryCount = 0;\n\n  for (entryCount; entryCount < entriesNumber; entryCount += 1) {\n    var entryBegin = entryCount * entryLength;\n    var entry = entries.slice(entryBegin, entryBegin + entryLength);\n    var tagBegin = 0;\n    var tagLength = 2;\n    var dataFormatBegin = tagBegin + tagLength;\n    var dataFormatLength = 2;\n    var componentsBegin = dataFormatBegin + dataFormatLength;\n    var componentsNumberLength = 4;\n    var dataValueBegin = componentsBegin + componentsNumberLength;\n    var dataValueLength = 4;\n    var tagAddress = entry.slice(tagBegin, dataFormatBegin);\n    var tagNumber = order ? tagAddress.toString('hex') : tagAddress.reverse().toString('hex');\n    var tagName = tagCollection[tagNumber];\n    var bigDataFormat = entry.readUInt16BE(dataFormatBegin);\n    var littleDataFormat = entry.readUInt16LE(dataFormatBegin);\n    var dataFormat = order ? bigDataFormat : littleDataFormat;\n    var componentsByte = bytes[dataFormat];\n    var bigComponentsNumber = entry.readUInt32BE(componentsBegin);\n    var littleComponentNumber = entry.readUInt32LE(componentsBegin);\n    var componentsNumber = order ? bigComponentsNumber : littleComponentNumber;\n    var dataLength = componentsNumber * componentsByte;\n    var dataValue = entry.slice(dataValueBegin, dataValueBegin + dataValueLength);\n\n    if (dataLength > 4) {\n      var dataOffset = (order ? dataValue.readUInt32BE(0) : dataValue.readUInt32LE(0)) - offset;\n      dataValue = buffer.slice(dataOffset, dataOffset + dataLength);\n    }\n\n    var tagValue = void 0;\n\n    if (tagName) {\n      switch (dataFormat) {\n        case 1:\n          tagValue = dataValue.readUInt8(0);\n          break;\n        case 2:\n          tagValue = dataValue.toString('ascii').replace(/\\0+$/, '');\n          break;\n        case 3:\n          tagValue = order ? dataValue.readUInt16BE(0) : dataValue.readUInt16LE(0);\n          break;\n        case 4:\n          tagValue = order ? dataValue.readUInt32BE(0) : dataValue.readUInt32LE(0);\n          break;\n        case 5:\n          tagValue = [];\n\n          for (var i = 0; i < dataValue.length; i += 8) {\n            var bigTagValue = dataValue.readUInt32BE(i) / dataValue.readUInt32BE(i + 4);\n            var littleTagValue = dataValue.readUInt32LE(i) / dataValue.readUInt32LE(i + 4);\n            tagValue.push(order ? bigTagValue : littleTagValue);\n          }\n\n          break;\n        case 7:\n          switch (tagName) {\n            case 'ExifVersion':\n              tagValue = dataValue.toString();\n              break;\n            case 'FlashPixVersion':\n              tagValue = dataValue.toString();\n              break;\n            case 'SceneType':\n              tagValue = dataValue.readUInt8(0);\n              break;\n            default:\n              tagValue = '0x' + dataValue.toString('hex', 0, 15);\n              break;\n          }\n          break;\n        case 10:\n          {\n            var bigOrder = dataValue.readInt32BE(0) / dataValue.readInt32BE(4);\n            var littleOrder = dataValue.readInt32LE(0) / dataValue.readInt32LE(4);\n            tagValue = order ? bigOrder : littleOrder;\n            break;\n          }\n        default:\n          tagValue = '0x' + dataValue.toString('hex');\n          break;\n      }\n      exif[tagName] = tagValue;\n    }\n    /*\n     else {\n     console.log(`Unkown Tag [0x${tagNumber}].`);\n     }\n     */\n  }\n  return exif;\n};\n\n/**\n * @param buf {Buffer}\n * @returns {Undefined}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = EXIFHandler(content);\n */\nvar EXIFHandler = function EXIFHandler(buf) {\n  var pad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  var buffer = buf;\n\n  if (pad) {\n    buffer = buf.slice(APPMarkerLength);\n    var length = buffer.readUInt16BE(0);\n    buffer = buffer.slice(0, length);\n    var lengthLength = 2;\n    buffer = buffer.slice(lengthLength);\n    var identifierLength = 5;\n    buffer = buffer.slice(identifierLength);\n    var padLength = 1;\n    buffer = buffer.slice(padLength);\n  }\n\n  var byteOrderLength = 2;\n  var byteOrder = buffer.toString('ascii', 0, byteOrderLength) === 'MM';\n  var fortyTwoLength = 2;\n  var fortyTwoEnd = byteOrderLength + fortyTwoLength;\n  var big42 = buffer.readUInt32BE(fortyTwoEnd);\n  var little42 = buffer.readUInt32LE(fortyTwoEnd);\n  var offsetOfIFD = byteOrder ? big42 : little42;\n\n  buffer = buffer.slice(offsetOfIFD);\n\n  if (buffer.length > 0) {\n    data = IFDHandler(buffer, tags.ifd, byteOrder, offsetOfIFD);\n\n    if (data.ExifIFDPointer) {\n      buffer = buffer.slice(data.ExifIFDPointer - offsetOfIFD);\n      data.SubExif = IFDHandler(buffer, tags.ifd, byteOrder, data.ExifIFDPointer);\n    }\n\n    if (data.GPSInfoIFDPointer) {\n      var gps = data.GPSInfoIFDPointer;\n      buffer = buffer.slice(data.ExifIFDPointer ? gps - data.ExifIFDPointer : gps - offsetOfIFD);\n      data.GPSInfo = IFDHandler(buffer, tags.gps, byteOrder, gps);\n    }\n  }\n};\n\n/**\n * @param buffer {Buffer}\n * @returns {Undefined}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = APPnHandler(content);\n */\nvar APPnHandler = function APPnHandler(buffer) {\n  var APPMarkerTag = checkAPPn(buffer);\n\n  if (APPMarkerTag !== false) {\n    // APP0 is 0, and 0==false\n    var length = buffer.readUInt16BE(APPMarkerLength);\n\n    switch (APPMarkerTag) {\n      case 1:\n        // EXIF\n        EXIFHandler(buffer);\n        break;\n      default:\n        APPnHandler(buffer.slice(APPMarkerLength + length));\n        break;\n    }\n  }\n};\n\n/**\n * @param buffer {Buffer}\n * @returns {Object}\n * @example\n */\nvar fromBuffer = function fromBuffer(buffer) {\n  if (!buffer) {\n    throw new Error('buffer not found');\n  }\n\n  data = undefined;\n\n  if (isValid(buffer)) {\n    buffer = buffer.slice(SOIMarkerLength);\n    data = {};\n    APPnHandler(buffer);\n  } else if (isTiff(buffer)) {\n    data = {};\n    EXIFHandler(buffer, false);\n  }\n\n  return data;\n};\n\n/**\n * @param file {String}\n * @returns {Object}\n * @example\n * var exif = sync(\"~/Picture/IMG_1981.JPG\");\n * console.log(exif.createTime);\n */\nvar sync = function sync(file) {\n  if (!file) {\n    throw new Error('File not found');\n  }\n\n  var buffer = _fs2.default.readFileSync(file);\n\n  return fromBuffer(buffer);\n};\n\n/**\n * @param file {String}\n * @param callback {Function}\n * @example\n * async(\"~/Picture/IMG_0707.JPG\", (err, data) => {\n *     if(err) {\n *         console.log(err);\n *     }\n *     if(data) {\n *         console.log(data.ExifOffset.createTime);\n *     }\n * }\n */\nvar async = function async(file, callback) {\n  data = undefined;\n\n  new Promise(function (resolve, reject) {\n    if (!file) {\n      reject(new Error('❓File not found.'));\n    }\n\n    _fs2.default.readFile(file, function (err, buffer) {\n      if (err) {\n        reject(err);\n      } else {\n        try {\n          if (isValid(buffer)) {\n            var buf = buffer.slice(SOIMarkerLength);\n\n            data = {};\n\n            APPnHandler(buf);\n            resolve(data);\n          } else if (isTiff(buffer)) {\n            data = {};\n\n            EXIFHandler(buffer, false);\n            resolve(data);\n          } else {\n            reject(new Error('😱Unsupport file type.'));\n          }\n        } catch (e) {\n          reject(e);\n        }\n      }\n    });\n  }, function (error) {\n    callback(error, undefined);\n  }).then(function (d) {\n    callback(undefined, d);\n  }).catch(function (error) {\n    callback(error, undefined);\n  });\n};\n\nexports.fromBuffer = fromBuffer;\nexports.parse = async;\nexports.parseSync = sync;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvanBlZy1leGlmL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixVQUFVLG1CQUFPLENBQUMsY0FBSTs7QUFFdEI7O0FBRUEsdUNBQXVDLHVDQUF1Qzs7QUFFOUUsV0FBVyxtQkFBTyxDQUFDLGlFQUFhOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQix5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxVQUFVO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsa0JBQWtCO0FBQ2xCLGFBQWE7QUFDYixpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIi9ob21lL2dhc2NhdC9wcmlzbWFxdWFudC9wcmlzbWEtcXVhbnR1bS9ub2RlX21vZHVsZXMvanBlZy1leGlmL2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfZnMgPSByZXF1aXJlKCdmcycpO1xuXG52YXIgX2ZzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHRhZ3MgPSByZXF1aXJlKCcuL3RhZ3MuanNvbicpO1xuXG4vKlxuIHVuc2lnbmVkQnl0ZSxcbiBhc2NpaVN0cmluZ3MsXG4gdW5zaWduZWRTaG9ydCxcbiB1bnNpZ25lZExvbmcsXG4gdW5zaWduZWRSYXRpb25hbCxcbiBzaWduZWRCeXRlLFxuIHVuZGVmaW5lZCxcbiBzaWduZWRTaG9ydCxcbiBzaWduZWRMb25nLFxuIHNpZ25lZFJhdGlvbmFsLFxuIHNpbmdsZUZsb2F0LFxuIGRvdWJsZUZsb2F0XG4gKi9cbnZhciBieXRlcyA9IFswLCAxLCAxLCAyLCA0LCA4LCAxLCAxLCAyLCA0LCA4LCA0LCA4XTtcbnZhciBTT0lNYXJrZXJMZW5ndGggPSAyO1xudmFyIEpQRUdTT0lNYXJrZXIgPSAweGZmZDg7XG52YXIgVElGRklOVEVMID0gMHg0OTQ5O1xudmFyIFRJRkZNT1RPUk9MQSA9IDB4NGQ0ZDtcbnZhciBBUFBNYXJrZXJMZW5ndGggPSAyO1xudmFyIEFQUE1hcmtlckJlZ2luID0gMHhmZmUwO1xudmFyIEFQUE1hcmtlckVuZCA9IDB4ZmZlZjtcbnZhciBkYXRhID0gdm9pZCAwO1xuLyoqXG4gKiBAcGFyYW0gYnVmZmVyIHtCdWZmZXJ9XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBleGFtcGxlXG4gKiB2YXIgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhcIn4vUGljdHVyZS9JTUdfMDkxMS5KUEdcIik7XG4gKiB2YXIgaXNJbWFnZSA9IGlzVmFsaWQoY29udGVudCk7XG4gKiBjb25zb2xlLmxvZyhpc0ltYWdlKTtcbiAqL1xudmFyIGlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkKGJ1ZmZlcikge1xuICB0cnkge1xuICAgIHZhciBTT0lNYXJrZXIgPSBidWZmZXIucmVhZFVJbnQxNkJFKDApO1xuICAgIHJldHVybiBTT0lNYXJrZXIgPT09IEpQRUdTT0lNYXJrZXI7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydCBmaWxlIGZvcm1hdC4nKTtcbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIGJ1ZmZlciB7QnVmZmVyfVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAZXhhbXBsZVxuICovXG52YXIgaXNUaWZmID0gZnVuY3Rpb24gaXNUaWZmKGJ1ZmZlcikge1xuICB0cnkge1xuICAgIHZhciBTT0lNYXJrZXIgPSBidWZmZXIucmVhZFVJbnQxNkJFKDApO1xuICAgIHJldHVybiBTT0lNYXJrZXIgPT09IFRJRkZJTlRFTCB8fCBTT0lNYXJrZXIgPT09IFRJRkZNT1RPUk9MQTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0IGZpbGUgZm9ybWF0LicpO1xuICB9XG59O1xuLyoqXG4gKiBAcGFyYW0gYnVmZmVyIHtCdWZmZXJ9XG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICogQGV4YW1wbGVcbiAqIHZhciBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKFwifi9QaWN0dXJlL0lNR18wOTExLkpQR1wiKTtcbiAqIHZhciBBUFBOdW1iZXIgPSBjaGVja0FQUG4oY29udGVudCk7XG4gKiBjb25zb2xlLmxvZyhBUFBOdW1iZXIpO1xuICovXG52YXIgY2hlY2tBUFBuID0gZnVuY3Rpb24gY2hlY2tBUFBuKGJ1ZmZlcikge1xuICB0cnkge1xuICAgIHZhciBBUFBNYXJrZXJUYWcgPSBidWZmZXIucmVhZFVJbnQxNkJFKDApO1xuICAgIHZhciBpc0luUmFuZ2UgPSBBUFBNYXJrZXJUYWcgPj0gQVBQTWFya2VyQmVnaW4gJiYgQVBQTWFya2VyVGFnIDw9IEFQUE1hcmtlckVuZDtcbiAgICByZXR1cm4gaXNJblJhbmdlID8gQVBQTWFya2VyVGFnIC0gQVBQTWFya2VyQmVnaW4gOiBmYWxzZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBBUFAgVGFnLicpO1xuICB9XG59O1xuLyoqXG4gKiBAcGFyYW0gYnVmZmVyIHtCdWZmZXJ9XG4gKiBAcGFyYW0gdGFnQ29sbGVjdGlvbiB7T2JqZWN0fVxuICogQHBhcmFtIG9yZGVyIHtCb29sZWFufVxuICogQHBhcmFtIG9mZnNldCB7TnVtYmVyfVxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhcIn4vUGljdHVyZS9JTUdfMDkxMS5KUEdcIik7XG4gKiB2YXIgZXhpZkZyYWdtZW50cyA9IElGREhhbmRsZXIoY29udGVudCwgMCwgdHJ1ZSwgOCk7XG4gKiBjb25zb2xlLmxvZyhleGlmRnJhZ21lbnRzLnZhbHVlKTtcbiAqL1xudmFyIElGREhhbmRsZXIgPSBmdW5jdGlvbiBJRkRIYW5kbGVyKGJ1ZmZlciwgdGFnQ29sbGVjdGlvbiwgb3JkZXIsIG9mZnNldCkge1xuICB2YXIgZW50cmllc051bWJlciA9IG9yZGVyID8gYnVmZmVyLnJlYWRVSW50MTZCRSgwKSA6IGJ1ZmZlci5yZWFkVUludDE2TEUoMCk7XG5cbiAgaWYgKGVudHJpZXNOdW1iZXIgPT09IDApIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICB2YXIgZW50cmllc051bWJlckxlbmd0aCA9IDI7XG4gIHZhciBlbnRyaWVzID0gYnVmZmVyLnNsaWNlKGVudHJpZXNOdW1iZXJMZW5ndGgpO1xuICB2YXIgZW50cnlMZW5ndGggPSAxMjtcbiAgLy8gbGV0IG5leHRJRkRQb2ludGVyQmVnaW4gPSBlbnRyaWVzTnVtYmVyTGVuZ3RoICsgZW50cnlMZW5ndGggKiBlbnRyaWVzTnVtYmVyO1xuICAvLyBsZXQgYmlnTmV4dElGRFBvaW50ZXI9IGJ1ZmZlci5yZWFkVUludDMyQkUobmV4dElGRFBvaW50ZXJCZWdpbikgO1xuICAvLyBsZXQgbGl0dGxlTmV4dElGRFBvaW50ZXI9IGJ1ZmZlci5yZWFkVUludDMyTEUobmV4dElGRFBvaW50ZXJCZWdpbik7XG4gIC8vIGxldCBuZXh0SUZEUG9pbnRlciA9IG9yZGVyID9iaWdOZXh0SUZEUG9pbnRlcjpsaXR0bGVOZXh0SUZEUG9pbnRlcjtcbiAgdmFyIGV4aWYgPSB7fTtcbiAgdmFyIGVudHJ5Q291bnQgPSAwO1xuXG4gIGZvciAoZW50cnlDb3VudDsgZW50cnlDb3VudCA8IGVudHJpZXNOdW1iZXI7IGVudHJ5Q291bnQgKz0gMSkge1xuICAgIHZhciBlbnRyeUJlZ2luID0gZW50cnlDb3VudCAqIGVudHJ5TGVuZ3RoO1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXMuc2xpY2UoZW50cnlCZWdpbiwgZW50cnlCZWdpbiArIGVudHJ5TGVuZ3RoKTtcbiAgICB2YXIgdGFnQmVnaW4gPSAwO1xuICAgIHZhciB0YWdMZW5ndGggPSAyO1xuICAgIHZhciBkYXRhRm9ybWF0QmVnaW4gPSB0YWdCZWdpbiArIHRhZ0xlbmd0aDtcbiAgICB2YXIgZGF0YUZvcm1hdExlbmd0aCA9IDI7XG4gICAgdmFyIGNvbXBvbmVudHNCZWdpbiA9IGRhdGFGb3JtYXRCZWdpbiArIGRhdGFGb3JtYXRMZW5ndGg7XG4gICAgdmFyIGNvbXBvbmVudHNOdW1iZXJMZW5ndGggPSA0O1xuICAgIHZhciBkYXRhVmFsdWVCZWdpbiA9IGNvbXBvbmVudHNCZWdpbiArIGNvbXBvbmVudHNOdW1iZXJMZW5ndGg7XG4gICAgdmFyIGRhdGFWYWx1ZUxlbmd0aCA9IDQ7XG4gICAgdmFyIHRhZ0FkZHJlc3MgPSBlbnRyeS5zbGljZSh0YWdCZWdpbiwgZGF0YUZvcm1hdEJlZ2luKTtcbiAgICB2YXIgdGFnTnVtYmVyID0gb3JkZXIgPyB0YWdBZGRyZXNzLnRvU3RyaW5nKCdoZXgnKSA6IHRhZ0FkZHJlc3MucmV2ZXJzZSgpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB2YXIgdGFnTmFtZSA9IHRhZ0NvbGxlY3Rpb25bdGFnTnVtYmVyXTtcbiAgICB2YXIgYmlnRGF0YUZvcm1hdCA9IGVudHJ5LnJlYWRVSW50MTZCRShkYXRhRm9ybWF0QmVnaW4pO1xuICAgIHZhciBsaXR0bGVEYXRhRm9ybWF0ID0gZW50cnkucmVhZFVJbnQxNkxFKGRhdGFGb3JtYXRCZWdpbik7XG4gICAgdmFyIGRhdGFGb3JtYXQgPSBvcmRlciA/IGJpZ0RhdGFGb3JtYXQgOiBsaXR0bGVEYXRhRm9ybWF0O1xuICAgIHZhciBjb21wb25lbnRzQnl0ZSA9IGJ5dGVzW2RhdGFGb3JtYXRdO1xuICAgIHZhciBiaWdDb21wb25lbnRzTnVtYmVyID0gZW50cnkucmVhZFVJbnQzMkJFKGNvbXBvbmVudHNCZWdpbik7XG4gICAgdmFyIGxpdHRsZUNvbXBvbmVudE51bWJlciA9IGVudHJ5LnJlYWRVSW50MzJMRShjb21wb25lbnRzQmVnaW4pO1xuICAgIHZhciBjb21wb25lbnRzTnVtYmVyID0gb3JkZXIgPyBiaWdDb21wb25lbnRzTnVtYmVyIDogbGl0dGxlQ29tcG9uZW50TnVtYmVyO1xuICAgIHZhciBkYXRhTGVuZ3RoID0gY29tcG9uZW50c051bWJlciAqIGNvbXBvbmVudHNCeXRlO1xuICAgIHZhciBkYXRhVmFsdWUgPSBlbnRyeS5zbGljZShkYXRhVmFsdWVCZWdpbiwgZGF0YVZhbHVlQmVnaW4gKyBkYXRhVmFsdWVMZW5ndGgpO1xuXG4gICAgaWYgKGRhdGFMZW5ndGggPiA0KSB7XG4gICAgICB2YXIgZGF0YU9mZnNldCA9IChvcmRlciA/IGRhdGFWYWx1ZS5yZWFkVUludDMyQkUoMCkgOiBkYXRhVmFsdWUucmVhZFVJbnQzMkxFKDApKSAtIG9mZnNldDtcbiAgICAgIGRhdGFWYWx1ZSA9IGJ1ZmZlci5zbGljZShkYXRhT2Zmc2V0LCBkYXRhT2Zmc2V0ICsgZGF0YUxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIHRhZ1ZhbHVlID0gdm9pZCAwO1xuXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIHN3aXRjaCAoZGF0YUZvcm1hdCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGFnVmFsdWUgPSBkYXRhVmFsdWUucmVhZFVJbnQ4KDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGFnVmFsdWUgPSBkYXRhVmFsdWUudG9TdHJpbmcoJ2FzY2lpJykucmVwbGFjZSgvXFwwKyQvLCAnJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB0YWdWYWx1ZSA9IG9yZGVyID8gZGF0YVZhbHVlLnJlYWRVSW50MTZCRSgwKSA6IGRhdGFWYWx1ZS5yZWFkVUludDE2TEUoMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICB0YWdWYWx1ZSA9IG9yZGVyID8gZGF0YVZhbHVlLnJlYWRVSW50MzJCRSgwKSA6IGRhdGFWYWx1ZS5yZWFkVUludDMyTEUoMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICB0YWdWYWx1ZSA9IFtdO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhVmFsdWUubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgICAgIHZhciBiaWdUYWdWYWx1ZSA9IGRhdGFWYWx1ZS5yZWFkVUludDMyQkUoaSkgLyBkYXRhVmFsdWUucmVhZFVJbnQzMkJFKGkgKyA0KTtcbiAgICAgICAgICAgIHZhciBsaXR0bGVUYWdWYWx1ZSA9IGRhdGFWYWx1ZS5yZWFkVUludDMyTEUoaSkgLyBkYXRhVmFsdWUucmVhZFVJbnQzMkxFKGkgKyA0KTtcbiAgICAgICAgICAgIHRhZ1ZhbHVlLnB1c2gob3JkZXIgPyBiaWdUYWdWYWx1ZSA6IGxpdHRsZVRhZ1ZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHN3aXRjaCAodGFnTmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnRXhpZlZlcnNpb24nOlxuICAgICAgICAgICAgICB0YWdWYWx1ZSA9IGRhdGFWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0ZsYXNoUGl4VmVyc2lvbic6XG4gICAgICAgICAgICAgIHRhZ1ZhbHVlID0gZGF0YVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnU2NlbmVUeXBlJzpcbiAgICAgICAgICAgICAgdGFnVmFsdWUgPSBkYXRhVmFsdWUucmVhZFVJbnQ4KDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRhZ1ZhbHVlID0gJzB4JyArIGRhdGFWYWx1ZS50b1N0cmluZygnaGV4JywgMCwgMTUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGJpZ09yZGVyID0gZGF0YVZhbHVlLnJlYWRJbnQzMkJFKDApIC8gZGF0YVZhbHVlLnJlYWRJbnQzMkJFKDQpO1xuICAgICAgICAgICAgdmFyIGxpdHRsZU9yZGVyID0gZGF0YVZhbHVlLnJlYWRJbnQzMkxFKDApIC8gZGF0YVZhbHVlLnJlYWRJbnQzMkxFKDQpO1xuICAgICAgICAgICAgdGFnVmFsdWUgPSBvcmRlciA/IGJpZ09yZGVyIDogbGl0dGxlT3JkZXI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGFnVmFsdWUgPSAnMHgnICsgZGF0YVZhbHVlLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGV4aWZbdGFnTmFtZV0gPSB0YWdWYWx1ZTtcbiAgICB9XG4gICAgLypcbiAgICAgZWxzZSB7XG4gICAgIGNvbnNvbGUubG9nKGBVbmtvd24gVGFnIFsweCR7dGFnTnVtYmVyfV0uYCk7XG4gICAgIH1cbiAgICAgKi9cbiAgfVxuICByZXR1cm4gZXhpZjtcbn07XG5cbi8qKlxuICogQHBhcmFtIGJ1ZiB7QnVmZmVyfVxuICogQHJldHVybnMge1VuZGVmaW5lZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhcIn4vUGljdHVyZS9JTUdfMDkxMS5KUEdcIik7XG4gKiB2YXIgZXhpZkZyYWdtZW50cyA9IEVYSUZIYW5kbGVyKGNvbnRlbnQpO1xuICovXG52YXIgRVhJRkhhbmRsZXIgPSBmdW5jdGlvbiBFWElGSGFuZGxlcihidWYpIHtcbiAgdmFyIHBhZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICB2YXIgYnVmZmVyID0gYnVmO1xuXG4gIGlmIChwYWQpIHtcbiAgICBidWZmZXIgPSBidWYuc2xpY2UoQVBQTWFya2VyTGVuZ3RoKTtcbiAgICB2YXIgbGVuZ3RoID0gYnVmZmVyLnJlYWRVSW50MTZCRSgwKTtcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB2YXIgbGVuZ3RoTGVuZ3RoID0gMjtcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UobGVuZ3RoTGVuZ3RoKTtcbiAgICB2YXIgaWRlbnRpZmllckxlbmd0aCA9IDU7XG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGlkZW50aWZpZXJMZW5ndGgpO1xuICAgIHZhciBwYWRMZW5ndGggPSAxO1xuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShwYWRMZW5ndGgpO1xuICB9XG5cbiAgdmFyIGJ5dGVPcmRlckxlbmd0aCA9IDI7XG4gIHZhciBieXRlT3JkZXIgPSBidWZmZXIudG9TdHJpbmcoJ2FzY2lpJywgMCwgYnl0ZU9yZGVyTGVuZ3RoKSA9PT0gJ01NJztcbiAgdmFyIGZvcnR5VHdvTGVuZ3RoID0gMjtcbiAgdmFyIGZvcnR5VHdvRW5kID0gYnl0ZU9yZGVyTGVuZ3RoICsgZm9ydHlUd29MZW5ndGg7XG4gIHZhciBiaWc0MiA9IGJ1ZmZlci5yZWFkVUludDMyQkUoZm9ydHlUd29FbmQpO1xuICB2YXIgbGl0dGxlNDIgPSBidWZmZXIucmVhZFVJbnQzMkxFKGZvcnR5VHdvRW5kKTtcbiAgdmFyIG9mZnNldE9mSUZEID0gYnl0ZU9yZGVyID8gYmlnNDIgOiBsaXR0bGU0MjtcblxuICBidWZmZXIgPSBidWZmZXIuc2xpY2Uob2Zmc2V0T2ZJRkQpO1xuXG4gIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgIGRhdGEgPSBJRkRIYW5kbGVyKGJ1ZmZlciwgdGFncy5pZmQsIGJ5dGVPcmRlciwgb2Zmc2V0T2ZJRkQpO1xuXG4gICAgaWYgKGRhdGEuRXhpZklGRFBvaW50ZXIpIHtcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShkYXRhLkV4aWZJRkRQb2ludGVyIC0gb2Zmc2V0T2ZJRkQpO1xuICAgICAgZGF0YS5TdWJFeGlmID0gSUZESGFuZGxlcihidWZmZXIsIHRhZ3MuaWZkLCBieXRlT3JkZXIsIGRhdGEuRXhpZklGRFBvaW50ZXIpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLkdQU0luZm9JRkRQb2ludGVyKSB7XG4gICAgICB2YXIgZ3BzID0gZGF0YS5HUFNJbmZvSUZEUG9pbnRlcjtcbiAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShkYXRhLkV4aWZJRkRQb2ludGVyID8gZ3BzIC0gZGF0YS5FeGlmSUZEUG9pbnRlciA6IGdwcyAtIG9mZnNldE9mSUZEKTtcbiAgICAgIGRhdGEuR1BTSW5mbyA9IElGREhhbmRsZXIoYnVmZmVyLCB0YWdzLmdwcywgYnl0ZU9yZGVyLCBncHMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0gYnVmZmVyIHtCdWZmZXJ9XG4gKiBAcmV0dXJucyB7VW5kZWZpbmVkfVxuICogQGV4YW1wbGVcbiAqIHZhciBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKFwifi9QaWN0dXJlL0lNR18wOTExLkpQR1wiKTtcbiAqIHZhciBleGlmRnJhZ21lbnRzID0gQVBQbkhhbmRsZXIoY29udGVudCk7XG4gKi9cbnZhciBBUFBuSGFuZGxlciA9IGZ1bmN0aW9uIEFQUG5IYW5kbGVyKGJ1ZmZlcikge1xuICB2YXIgQVBQTWFya2VyVGFnID0gY2hlY2tBUFBuKGJ1ZmZlcik7XG5cbiAgaWYgKEFQUE1hcmtlclRhZyAhPT0gZmFsc2UpIHtcbiAgICAvLyBBUFAwIGlzIDAsIGFuZCAwPT1mYWxzZVxuICAgIHZhciBsZW5ndGggPSBidWZmZXIucmVhZFVJbnQxNkJFKEFQUE1hcmtlckxlbmd0aCk7XG5cbiAgICBzd2l0Y2ggKEFQUE1hcmtlclRhZykge1xuICAgICAgY2FzZSAxOlxuICAgICAgICAvLyBFWElGXG4gICAgICAgIEVYSUZIYW5kbGVyKGJ1ZmZlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgQVBQbkhhbmRsZXIoYnVmZmVyLnNsaWNlKEFQUE1hcmtlckxlbmd0aCArIGxlbmd0aCkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIGJ1ZmZlciB7QnVmZmVyfVxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBleGFtcGxlXG4gKi9cbnZhciBmcm9tQnVmZmVyID0gZnVuY3Rpb24gZnJvbUJ1ZmZlcihidWZmZXIpIHtcbiAgaWYgKCFidWZmZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2J1ZmZlciBub3QgZm91bmQnKTtcbiAgfVxuXG4gIGRhdGEgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzVmFsaWQoYnVmZmVyKSkge1xuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShTT0lNYXJrZXJMZW5ndGgpO1xuICAgIGRhdGEgPSB7fTtcbiAgICBBUFBuSGFuZGxlcihidWZmZXIpO1xuICB9IGVsc2UgaWYgKGlzVGlmZihidWZmZXIpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIEVYSUZIYW5kbGVyKGJ1ZmZlciwgZmFsc2UpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuXG4vKipcbiAqIEBwYXJhbSBmaWxlIHtTdHJpbmd9XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGV4YW1wbGVcbiAqIHZhciBleGlmID0gc3luYyhcIn4vUGljdHVyZS9JTUdfMTk4MS5KUEdcIik7XG4gKiBjb25zb2xlLmxvZyhleGlmLmNyZWF0ZVRpbWUpO1xuICovXG52YXIgc3luYyA9IGZ1bmN0aW9uIHN5bmMoZmlsZSkge1xuICBpZiAoIWZpbGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbGUgbm90IGZvdW5kJyk7XG4gIH1cblxuICB2YXIgYnVmZmVyID0gX2ZzMi5kZWZhdWx0LnJlYWRGaWxlU3luYyhmaWxlKTtcblxuICByZXR1cm4gZnJvbUJ1ZmZlcihidWZmZXIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gZmlsZSB7U3RyaW5nfVxuICogQHBhcmFtIGNhbGxiYWNrIHtGdW5jdGlvbn1cbiAqIEBleGFtcGxlXG4gKiBhc3luYyhcIn4vUGljdHVyZS9JTUdfMDcwNy5KUEdcIiwgKGVyciwgZGF0YSkgPT4ge1xuICogICAgIGlmKGVycikge1xuICogICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICogICAgIH1cbiAqICAgICBpZihkYXRhKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEuRXhpZk9mZnNldC5jcmVhdGVUaW1lKTtcbiAqICAgICB9XG4gKiB9XG4gKi9cbnZhciBhc3luYyA9IGZ1bmN0aW9uIGFzeW5jKGZpbGUsIGNhbGxiYWNrKSB7XG4gIGRhdGEgPSB1bmRlZmluZWQ7XG5cbiAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmICghZmlsZSkge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcign4p2TRmlsZSBub3QgZm91bmQuJykpO1xuICAgIH1cblxuICAgIF9mczIuZGVmYXVsdC5yZWFkRmlsZShmaWxlLCBmdW5jdGlvbiAoZXJyLCBidWZmZXIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBidWZmZXIuc2xpY2UoU09JTWFya2VyTGVuZ3RoKTtcblxuICAgICAgICAgICAgZGF0YSA9IHt9O1xuXG4gICAgICAgICAgICBBUFBuSGFuZGxlcihidWYpO1xuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzVGlmZihidWZmZXIpKSB7XG4gICAgICAgICAgICBkYXRhID0ge307XG5cbiAgICAgICAgICAgIEVYSUZIYW5kbGVyKGJ1ZmZlciwgZmFsc2UpO1xuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcign8J+YsVVuc3VwcG9ydCBmaWxlIHR5cGUuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBjYWxsYmFjayhlcnJvciwgdW5kZWZpbmVkKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoZCkge1xuICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgZCk7XG4gIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgIGNhbGxiYWNrKGVycm9yLCB1bmRlZmluZWQpO1xuICB9KTtcbn07XG5cbmV4cG9ydHMuZnJvbUJ1ZmZlciA9IGZyb21CdWZmZXI7XG5leHBvcnRzLnBhcnNlID0gYXN5bmM7XG5leHBvcnRzLnBhcnNlU3luYyA9IHN5bmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/jpeg-exif/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/jpeg-exif/lib/tags.json":
/*!**********************************************!*\
  !*** ./node_modules/jpeg-exif/lib/tags.json ***!
  \**********************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"ifd":{"8298":"Copyright","8769":"ExifIFDPointer","8822":"ExposureProgram","8824":"SpectralSensitivity","8825":"GPSInfoIFDPointer","8827":"PhotographicSensitivity","8828":"OECF","8830":"SensitivityType","8831":"StandardOutputSensitivity","8832":"RecommendedExposureIndex","8833":"ISOSpeed","8834":"ISOSpeedLatitudeyyy","8835":"ISOSpeedLatitudezzz","9000":"ExifVersion","9003":"DateTimeOriginal","9004":"DateTimeDigitized","9101":"ComponentsConfiguration","9102":"CompressedBitsPerPixel","9201":"ShutterSpeedValue","9202":"ApertureValue","9203":"BrightnessValue","9204":"ExposureBiasValue","9205":"MaxApertureValue","9206":"SubjectDistance","9207":"MeteringMode","9208":"LightSource","9209":"Flash","9214":"SubjectArea","9286":"UserComment","9290":"SubSecTime","9291":"SubSecTimeOriginal","9292":"SubSecTimeDigitized","010e":"ImageDescription","010f":"Make","011a":"XResolution","011b":"YResolution","011c":"PlanarConfiguration","012d":"TransferFunction","013b":"Artist","013e":"WhitePoint","013f":"PrimaryChromaticities","0100":"ImageWidth","0101":"ImageHeight","0102":"BitsPerSample","0103":"Compression","0106":"PhotometricInterpretation","0110":"Model","0111":"StripOffsets","0112":"Orientation","0115":"SamplesPerPixel","0116":"RowsPerStrip","0117":"StripByteCounts","0128":"ResolutionUnit","0131":"Software","0132":"DateTime","0201":"JPEGInterchangeFormat","0202":"JPEGInterchangeFormatLength","0211":"YCbCrCoefficients","0212":"YCbCrSubSampling","0213":"YCbCrPositioning","0214":"ReferenceBlackWhite","829a":"ExposureTime","829d":"FNumber","920a":"FocalLength","927c":"MakerNote","a000":"FlashpixVersion","a001":"ColorSpace","a002":"PixelXDimension","a003":"PixelYDimension","a004":"RelatedSoundFile","a005":"InteroperabilityIFDPointer","a20b":"FlashEnergy","a20c":"SpatialFrequencyResponse","a20e":"FocalPlaneXResolution","a20f":"FocalPlaneYResolution","a40a":"Sharpness","a40b":"DeviceSettingDescription","a40c":"SubjectDistanceRange","a210":"FocalPlaneResolutionUnit","a214":"SubjectLocation","a215":"ExposureIndex","a217":"SensingMethod","a300":"FileSource","a301":"SceneType","a302":"CFAPattern","a401":"CustomRendered","a402":"ExposureMode","a403":"WhiteBalance","a404":"DigitalZoomRatio","a405":"FocalLengthIn35mmFilm","a406":"SceneCaptureType","a407":"GainControl","a408":"Contrast","a409":"Saturation","a420":"ImageUniqueID","a430":"CameraOwnerName","a431":"BodySerialNumber","a432":"LensSpecification","a433":"LensMake","a434":"LensModel","a435":"LensSerialNumber","a500":"Gamma"},"gps":{"0000":"GPSVersionID","0001":"GPSLatitudeRef","0002":"GPSLatitude","0003":"GPSLongitudeRef","0004":"GPSLongitude","0005":"GPSAltitudeRef","0006":"GPSAltitude","0007":"GPSTimeStamp","0008":"GPSSatellites","0009":"GPSStatus","000a":"GPSMeasureMode","000b":"GPSDOP","000c":"GPSSpeedRef","000d":"GPSSpeed","000e":"GPSTrackRef","000f":"GPSTrack","0010":"GPSImgDirectionRef","0011":"GPSImgDirection","0012":"GPSMapDatum","0013":"GPSDestLatitudeRef","0014":"GPSDestLatitude","0015":"GPSDestLongitudeRef","0016":"GPSDestLongitude","0017":"GPSDestBearingRef","0018":"GPSDestBearing","0019":"GPSDestDistanceRef","001a":"GPSDestDistance","001b":"GPSProcessingMethod","001c":"GPSAreaInformation","001d":"GPSDateStamp","001e":"GPSDifferential","001f":"GPSHPositioningError"}}');

/***/ })

};
;