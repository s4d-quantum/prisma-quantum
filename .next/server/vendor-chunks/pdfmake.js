/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdfmake";
exports.ids = ["vendor-chunks/pdfmake"];
exports.modules = {

/***/ "(rsc)/./node_modules/pdfmake/src/3rd-party/svg-to-pdfkit.js":
/*!*************************************************************!*\
  !*** ./node_modules/pdfmake/src/3rd-party/svg-to-pdfkit.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var SVGtoPDF = __webpack_require__(/*! ./svg-to-pdfkit/source.js */ \"(rsc)/./node_modules/pdfmake/src/3rd-party/svg-to-pdfkit/source.js\");\r\n\r\nmodule.exports = SVGtoPDF;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvM3JkLXBhcnR5L3N2Zy10by1wZGZraXQuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLHFHQUEyQjtBQUNsRDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9nYXNjYXQvcHJpc21hcXVhbnQvcHJpc21hLXF1YW50dW0vbm9kZV9tb2R1bGVzL3BkZm1ha2Uvc3JjLzNyZC1wYXJ0eS9zdmctdG8tcGRma2l0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBTVkd0b1BERiA9IHJlcXVpcmUoJy4vc3ZnLXRvLXBkZmtpdC9zb3VyY2UuanMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU1ZHdG9QREY7XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/3rd-party/svg-to-pdfkit.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/3rd-party/svg-to-pdfkit/source.js":
/*!********************************************************************!*\
  !*** ./node_modules/pdfmake/src/3rd-party/svg-to-pdfkit/source.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar SVGtoPDF = function(doc, svg, x, y, options) {\r\n    \"use strict\";\r\n\r\n    const NamedColors = {aliceblue: [240,248,255], antiquewhite: [250,235,215], aqua: [0,255,255], aquamarine: [127,255,212], azure: [240,255,255], beige: [245,245,220], bisque: [255,228,196], black: [0,0,0], blanchedalmond: [255,235,205], blue: [0,0,255], blueviolet: [138,43,226], brown: [165,42,42], burlywood: [222,184,135], cadetblue: [95,158,160], chartreuse: [127,255,0],\r\n      chocolate: [210,105,30], coral: [255,127,80], cornflowerblue: [100,149,237], cornsilk: [255,248,220], crimson: [220,20,60], cyan: [0,255,255], darkblue: [0,0,139], darkcyan: [0,139,139], darkgoldenrod: [184,134,11], darkgray: [169,169,169], darkgrey: [169,169,169], darkgreen: [0,100,0], darkkhaki: [189,183,107], darkmagenta: [139,0,139], darkolivegreen: [85,107,47],\r\n      darkorange: [255,140,0], darkorchid: [153,50,204], darkred: [139,0,0], darksalmon: [233,150,122], darkseagreen: [143,188,143], darkslateblue: [72,61,139], darkslategray: [47,79,79], darkslategrey: [47,79,79], darkturquoise: [0,206,209], darkviolet: [148,0,211], deeppink: [255,20,147], deepskyblue: [0,191,255], dimgray: [105,105,105], dimgrey: [105,105,105],\r\n      dodgerblue: [30,144,255], firebrick: [178,34,34], floralwhite: [255,250,240], forestgreen: [34,139,34], fuchsia: [255,0,255], gainsboro: [220,220,220], ghostwhite: [248,248,255], gold: [255,215,0], goldenrod: [218,165,32], gray: [128,128,128], grey: [128,128,128], green: [0,128,0], greenyellow: [173,255,47], honeydew: [240,255,240], hotpink: [255,105,180],\r\n      indianred: [205,92,92], indigo: [75,0,130], ivory: [255,255,240], khaki: [240,230,140], lavender: [230,230,250], lavenderblush: [255,240,245], lawngreen: [124,252,0], lemonchiffon: [255,250,205], lightblue: [173,216,230], lightcoral: [240,128,128], lightcyan: [224,255,255], lightgoldenrodyellow: [250,250,210], lightgray: [211,211,211], lightgrey: [211,211,211],\r\n      lightgreen: [144,238,144], lightpink: [255,182,193], lightsalmon: [255,160,122], lightseagreen: [32,178,170], lightskyblue: [135,206,250], lightslategray: [119,136,153], lightslategrey: [119,136,153], lightsteelblue: [176,196,222], lightyellow: [255,255,224], lime: [0,255,0], limegreen: [50,205,50], linen: [250,240,230], magenta: [255,0,255], maroon: [128,0,0],\r\n      mediumaquamarine: [102,205,170], mediumblue: [0,0,205], mediumorchid: [186,85,211], mediumpurple: [147,112,219], mediumseagreen: [60,179,113], mediumslateblue: [123,104,238], mediumspringgreen: [0,250,154], mediumturquoise: [72,209,204], mediumvioletred: [199,21,133], midnightblue: [25,25,112], mintcream: [245,255,250], mistyrose: [255,228,225], moccasin: [255,228,181],\r\n      navajowhite: [255,222,173], navy: [0,0,128], oldlace: [253,245,230], olive: [128,128,0], olivedrab: [107,142,35], orange: [255,165,0], orangered: [255,69,0], orchid: [218,112,214], palegoldenrod: [238,232,170], palegreen: [152,251,152], paleturquoise: [175,238,238], palevioletred: [219,112,147], papayawhip: [255,239,213], peachpuff: [255,218,185], peru: [205,133,63],\r\n      pink: [255,192,203], plum: [221,160,221], powderblue: [176,224,230], purple: [128,0,128], rebeccapurple: [102,51,153], red: [255,0,0], rosybrown: [188,143,143], royalblue: [65,105,225], saddlebrown: [139,69,19], salmon: [250,128,114], sandybrown: [244,164,96], seagreen: [46,139,87], seashell: [255,245,238], sienna: [160,82,45], silver: [192,192,192], skyblue: [135,206,235],\r\n      slateblue: [106,90,205], slategray: [112,128,144], slategrey: [112,128,144], snow: [255,250,250], springgreen: [0,255,127], steelblue: [70,130,180], tan: [210,180,140], teal: [0,128,128], thistle: [216,191,216], tomato: [255,99,71], turquoise: [64,224,208], violet: [238,130,238], wheat: [245,222,179], white: [255,255,255], whitesmoke: [245,245,245], yellow: [255,255,0]};\r\n    const DefaultColors = {black: [NamedColors.black, 1], white: [NamedColors.white, 1], transparent: [NamedColors.black, 0]};\r\n    const Entities = {quot: 34, amp: 38, lt: 60, gt: 62, apos: 39, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, circ: 710, tilde: 732, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, permil: 8240, lsaquo: 8249,\r\n      rsaquo: 8250, euro: 8364, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, copy: 169, ordf: 170, laquo: 171, not: 172, shy: 173, reg: 174, macr: 175, deg: 176, plusmn: 177, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, sup1: 185, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190,\r\n      iquest: 191, Agrave: 192, Aacute: 193, Acirc: 194, Atilde: 195, Auml: 196, Aring: 197, AElig: 198, Ccedil: 199, Egrave: 200, Eacute: 201, Ecirc: 202, Euml: 203, Igrave: 204, Iacute: 205, Icirc: 206, Iuml: 207, ETH: 208, Ntilde: 209, Ograve: 210, Oacute: 211, Ocirc: 212, Otilde: 213, Ouml: 214, times: 215, Oslash: 216, Ugrave: 217, Uacute: 218, Ucirc: 219, Uuml: 220, Yacute: 221,\r\n      THORN: 222, szlig: 223, agrave: 224, aacute: 225, acirc: 226, atilde: 227, auml: 228, aring: 229, aelig: 230, ccedil: 231, egrave: 232, eacute: 233, ecirc: 234, euml: 235, igrave: 236, iacute: 237, icirc: 238, iuml: 239, eth: 240, ntilde: 241, ograve: 242, oacute: 243, ocirc: 244, otilde: 245, ouml: 246, divide: 247, oslash: 248, ugrave: 249, uacute: 250, ucirc: 251, uuml: 252,\r\n      yacute: 253, thorn: 254, yuml: 255, fnof: 402, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949,\r\n      zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, bull: 8226, hellip: 8230, prime: 8242, Prime: 8243, oline: 8254, frasl: 8260, weierp: 8472, image: 8465, real: 8476,\r\n      trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744,\r\n      cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830};\r\n    const PathArguments = {A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0};\r\n    const PathFlags = {A3: true, A4: true, a3: true, a4: true};\r\n    const Properties = {\r\n      'color':              {inherit: true, initial: undefined},\r\n      'visibility':         {inherit: true, initial: 'visible', values: {'hidden': 'hidden', 'collapse': 'hidden', 'visible':'visible'}},\r\n      'fill':               {inherit: true, initial: DefaultColors.black},\r\n      'stroke':             {inherit: true, initial: 'none'},\r\n      'stop-color':         {inherit: false, initial: DefaultColors.black},\r\n      'fill-opacity':       {inherit: true, initial: 1},\r\n      'stroke-opacity':     {inherit: true, initial: 1},\r\n      'stop-opacity':       {inherit: false, initial: 1},\r\n      'fill-rule':          {inherit: true, initial: 'nonzero', values: {'nonzero':'nonzero', 'evenodd':'evenodd'}},\r\n      'clip-rule':          {inherit: true, initial: 'nonzero', values: {'nonzero':'nonzero', 'evenodd':'evenodd'}},\r\n      'stroke-width':       {inherit: true, initial: 1},\r\n      'stroke-dasharray':   {inherit: true, initial: []},\r\n      'stroke-dashoffset':  {inherit: true, initial: 0},\r\n      'stroke-miterlimit':  {inherit: true, initial: 4},\r\n      'stroke-linejoin':    {inherit: true, initial: 'miter', values: {'miter':'miter', 'round':'round', 'bevel':'bevel'}},\r\n      'stroke-linecap':     {inherit: true, initial: 'butt', values: {'butt':'butt', 'round':'round', 'square':'square'}},\r\n      'font-size':          {inherit: true, initial: 16, values: {'xx-small':9, 'x-small':10, 'small':13, 'medium':16, 'large':18, 'x-large':24, 'xx-large':32}},\r\n      'font-family':        {inherit: true, initial: 'sans-serif'},\r\n      'font-weight':        {inherit: true, initial: 'normal', values: {'600':'bold', '700':'bold', '800':'bold', '900':'bold', 'bold':'bold', 'bolder':'bold', '500':'normal', '400':'normal', '300':'normal', '200':'normal', '100':'normal', 'normal':'normal', 'lighter':'normal'}},\r\n      'font-style':         {inherit: true, initial: 'normal', values: {'italic':'italic', 'oblique':'italic', 'normal':'normal'}},\r\n      'text-anchor':        {inherit: true, initial: 'start', values: {'start':'start', 'middle':'middle', 'end':'end'}},\r\n      'direction':          {inherit: true, initial: 'ltr', values: {'ltr':'ltr', 'rtl':'rtl'}},\r\n      'dominant-baseline':  {inherit: true, initial: 'baseline', values: {'auto':'baseline', 'baseline':'baseline', 'before-edge':'before-edge', 'text-before-edge':'before-edge', 'middle':'middle', 'central':'central', 'after-edge':'after-edge', 'text-after-edge':'after-edge', 'ideographic':'ideographic', 'alphabetic':'alphabetic', 'hanging':'hanging', 'mathematical':'mathematical'}},\r\n      'alignment-baseline': {inherit: false, initial: undefined, values: {'auto':'baseline', 'baseline':'baseline', 'before-edge':'before-edge', 'text-before-edge':'before-edge', 'middle':'middle', 'central':'central', 'after-edge':'after-edge', 'text-after-edge':'after-edge', 'ideographic':'ideographic', 'alphabetic':'alphabetic', 'hanging':'hanging', 'mathematical':'mathematical'}},\r\n      'baseline-shift':     {inherit: true, initial: 'baseline', values: {'baseline':'baseline', 'sub':'sub', 'super':'super'}},\r\n      'word-spacing':       {inherit: true, initial: 0, values: {normal:0}},\r\n      'letter-spacing':     {inherit: true, initial: 0, values: {normal:0}},\r\n      'text-decoration':    {inherit: false, initial: 'none', values: {'none':'none', 'underline':'underline', 'overline':'overline', 'line-through':'line-through'}},\r\n      'xml:space':          {inherit: true, initial: 'default', css: 'white-space', values: {'preserve':'preserve', 'default':'default', 'pre':'preserve', 'pre-line':'preserve', 'pre-wrap':'preserve', 'nowrap': 'default'}},\r\n      'marker-start':       {inherit: true, initial: 'none'},\r\n      'marker-mid':         {inherit: true, initial: 'none'},\r\n      'marker-end':         {inherit: true, initial: 'none'},\r\n      'opacity':            {inherit: false, initial: 1},\r\n      'transform':          {inherit: false, initial: [1, 0, 0, 1, 0, 0]},\r\n      'display':            {inherit: false, initial: 'inline', values: {'none':'none', 'inline':'inline', 'block':'inline'}},\r\n      'clip-path':          {inherit: false, initial: 'none'},\r\n      'mask':               {inherit: false, initial: 'none'},\r\n      'overflow':           {inherit: false, initial: 'hidden', values: {'hidden':'hidden', 'scroll':'hidden', 'visible':'visible'}}\r\n    };\r\n\r\n    function docBeginGroup(bbox) {\r\n      let group = new (function PDFGroup() {})();\r\n      group.name = 'G' + (doc._groupCount = (doc._groupCount || 0) + 1);\r\n      group.resources = doc.ref();\r\n      group.xobj = doc.ref({\r\n        Type: 'XObject',\r\n        Subtype: 'Form',\r\n        FormType: 1,\r\n        BBox: bbox,\r\n        Group: {S: 'Transparency', CS: 'DeviceRGB', I: true, K: false},\r\n        Resources: group.resources\r\n      });\r\n      group.xobj.write('');\r\n      group.savedMatrix = doc._ctm;\r\n      group.savedPage = doc.page;\r\n      groupStack.push(group);\r\n      doc._ctm = [1, 0, 0, 1, 0, 0];\r\n      doc.page = {\r\n        width: doc.page.width, height: doc.page.height,\r\n        write: function(data) {group.xobj.write(data);},\r\n        fonts: {}, xobjects: {}, ext_gstates: {}, patterns: {}\r\n      };\r\n      return group;\r\n    }\r\n    function docEndGroup(group) {\r\n      if (group !== groupStack.pop()) {throw('Group not matching');}\r\n      if (Object.keys(doc.page.fonts).length) {group.resources.data.Font = doc.page.fonts;}\r\n      if (Object.keys(doc.page.xobjects).length) {group.resources.data.XObject = doc.page.xobjects;}\r\n      if (Object.keys(doc.page.ext_gstates).length) {group.resources.data.ExtGState = doc.page.ext_gstates;}\r\n      if (Object.keys(doc.page.patterns).length) {group.resources.data.Pattern = doc.page.patterns;}\r\n      group.resources.end();\r\n      group.xobj.end();\r\n      doc._ctm = group.savedMatrix;\r\n      doc.page = group.savedPage;\r\n    }\r\n    function docInsertGroup(group) {\r\n      doc.page.xobjects[group.name] = group.xobj;\r\n      doc.addContent('/' + group.name + ' Do');\r\n    }\r\n    function docApplyMask(group, clip) {\r\n      let name = 'M' + (doc._maskCount = (doc._maskCount || 0) + 1);\r\n      let gstate = doc.ref({\r\n        Type: 'ExtGState', CA: 1, ca: 1, BM: 'Normal',\r\n        SMask: {S: 'Luminosity', G: group.xobj, BC: (clip ? [0, 0, 0] : [1, 1, 1])}\r\n      });\r\n      gstate.end();\r\n      doc.page.ext_gstates[name] = gstate;\r\n      doc.addContent('/' + name + ' gs');\r\n    }\r\n    function docCreatePattern(group, dx, dy, matrix) {\r\n      let pattern = new (function PDFPattern() {})();\r\n      pattern.group = group;\r\n      pattern.dx = dx;\r\n      pattern.dy = dy;\r\n      pattern.matrix = matrix || [1, 0, 0, 1, 0, 0];\r\n      return pattern;\r\n    }\r\n    function docUsePattern(pattern, stroke) {\r\n      let name = 'P' + (doc._patternCount = (doc._patternCount || 0) + 1);\r\n      let ref = doc.ref({\r\n        Type: 'Pattern', PatternType: 1, PaintType: 1, TilingType: 2,\r\n        BBox: [0, 0, pattern.dx, pattern.dy], XStep: pattern.dx, YStep: pattern.dy,\r\n        Matrix: multiplyMatrix(doc._ctm, pattern.matrix),\r\n        Resources: {\r\n          ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\r\n          XObject: (function() {let temp = {}; temp[pattern.group.name] = pattern.group.xobj; return temp;})()\r\n        }\r\n      });\r\n      ref.write('/' + pattern.group.name + ' Do');\r\n      ref.end();\r\n      doc.page.patterns[name] = ref;\r\n      if (stroke) {\r\n        doc.addContent('/Pattern CS');\r\n        doc.addContent('/' + name + ' SCN');\r\n      } else {\r\n        doc.addContent('/Pattern cs');\r\n        doc.addContent('/' + name + ' scn');\r\n      }\r\n    }\r\n    function docBeginText(font, size) {\r\n      if (!doc.page.fonts[font.id]) {doc.page.fonts[font.id] = font.ref();}\r\n      doc.addContent('BT').addContent('/' + font.id + ' ' + size + ' Tf');\r\n    }\r\n    function docSetTextMatrix(a, b, c, d, e, f) {\r\n      doc.addContent(validateNumber(a) + ' ' + validateNumber(b) + ' ' + validateNumber(-c) + ' '  + validateNumber(-d) + ' ' + validateNumber(e) + ' ' + validateNumber(f) + ' Tm');\r\n    }\r\n    function docSetTextMode(fill, stroke) {\r\n      let mode = fill && stroke ? 2 : stroke ? 1 : fill ? 0 : 3;\r\n      doc.addContent(mode + ' Tr');\r\n    }\r\n    function docWriteGlyph(glyph) {\r\n      doc.addContent('<' + glyph + '> Tj');\r\n    }\r\n    function docEndText() {\r\n      doc.addContent('ET');\r\n    }\r\n    function docFillColor(color) {\r\n      if (color[0].constructor.name === 'PDFPattern') {\r\n        doc.fillOpacity(color[1]);\r\n        docUsePattern(color[0], false);\r\n      } else {\r\n        doc.fillColor(color[0], color[1]);\r\n      }\r\n    }\r\n    function docStrokeColor(color) {\r\n      if (color[0].constructor.name === 'PDFPattern') {\r\n        doc.strokeOpacity(color[1]);\r\n        docUsePattern(color[0], true);\r\n      } else {\r\n        doc.strokeColor(color[0], color[1]);\r\n      }\r\n    }\r\n    function docInsertLink(x, y, w, h, url) {\r\n      let ref = doc.ref({\r\n        Type: 'Annot',\r\n        Subtype: 'Link',\r\n        Rect: [x, y, w, h],\r\n        Border: [0, 0, 0],\r\n        A: {\r\n          S: 'URI',\r\n          URI: new String(url)\r\n        }\r\n      });\r\n      ref.end();\r\n      links.push(ref);\r\n    }\r\n    function parseXml(xml) {\r\n      let SvgNode = function(tag, type, value, error) {\r\n        this.error = error;\r\n        this.nodeName = tag;\r\n        this.nodeValue = value;\r\n        this.nodeType = type;\r\n        this.attributes = Object.create(null);\r\n        this.childNodes = [];\r\n        this.parentNode = null;\r\n        this.id = '';\r\n        this.textContent = '';\r\n        this.classList = [];\r\n      };\r\n      SvgNode.prototype.getAttribute = function(attr) {\r\n        return this.attributes[attr] != null ? this.attributes[attr] : null;\r\n      };\r\n      SvgNode.prototype.getElementById = function(id) {\r\n        let result = null;\r\n        (function recursive(node) {\r\n          if (result) {return;}\r\n          if (node.nodeType === 1) {\r\n            if (node.id === id) {result = node;}\r\n            for (let i = 0; i < node.childNodes.length; i++) {\r\n              recursive(node.childNodes[i]);\r\n            }\r\n          }\r\n        })(this);\r\n        return result;\r\n      };\r\n      SvgNode.prototype.getElementsByTagName = function(tag) {\r\n        let result = [];\r\n        (function recursive(node) {\r\n          if (node.nodeType === 1) {\r\n            if (node.nodeName === tag) {result.push(node);}\r\n            for (let i = 0; i < node.childNodes.length; i++) {\r\n              recursive(node.childNodes[i]);\r\n            }\r\n          }\r\n        })(this);\r\n        return result;\r\n      };\r\n      let parser = new StringParser(xml.trim()), result, child, error = false; \r\n      let recursive = function() {\r\n        let temp, child;\r\n        if (temp = parser.match(/^<([\\w:.-]+)\\s*/, true)) { // Opening tag\r\n          let node = new SvgNode(temp[1], 1, null, error);\r\n          while (temp = parser.match(/^([\\w:.-]+)(?:\\s*=\\s*\"([^\"]*)\"|\\s*=\\s*'([^']*)')?\\s*/, true)) { // Attribute\r\n            let attr = temp[1], value = decodeEntities(temp[2] || temp[3] || '');\r\n            if (!node.attributes[attr]) {\r\n              node.attributes[attr] = value;\r\n              if (attr === 'id') {node.id = value;}\r\n              if (attr === 'class') {node.classList = value.split(' ');}\r\n            } else {\r\n              warningCallback('parseXml: duplicate attribute \"' + attr + '\"');\r\n              error = true;\r\n            }\r\n          }\r\n          if (parser.match(/^>/)) { // End of opening tag\r\n            while (child = recursive()) {\r\n              node.childNodes.push(child);\r\n              child.parentNode = node;\r\n              node.textContent += (child.nodeType === 3 || child.nodeType === 4 ? child.nodeValue : child.textContent);\r\n            }\r\n            if (temp = parser.match(/^<\\/([\\w:.-]+)\\s*>/, true)) { // Closing tag\r\n              if (temp[1] === node.nodeName) {\r\n                return node;\r\n              } else {\r\n                warningCallback('parseXml: tag not matching, opening \"' + node.nodeName + '\" & closing \"' + temp[1] + '\"');\r\n                error = true;\r\n                return node;\r\n              }\r\n            } else {\r\n              warningCallback('parseXml: tag not matching, opening \"' + node.nodeName + '\" & not closing');\r\n              error = true;\r\n              return node;\r\n            }\r\n          } else if (parser.match(/^\\/>/)) { // Self-closing tag\r\n            return node;\r\n          } else {\r\n            warningCallback('parseXml: tag could not be parsed \"' + node.nodeName + '\"');\r\n            error = true;\r\n          }\r\n        } else if (temp = parser.match(/^<!--[\\s\\S]*?-->/)) { // Comment\r\n          return new SvgNode(null, 8, temp, error);\r\n        } else if (temp = parser.match(/^<\\?[\\s\\S]*?\\?>/)) { // Processing instructions\r\n          return new SvgNode(null, 7, temp, error);\r\n        } else if (temp = parser.match(/^<!DOCTYPE\\s*([\\s\\S]*?)>/)) { // Doctype\r\n          return new SvgNode(null, 10, temp, error);\r\n        } else if (temp = parser.match(/^<!\\[CDATA\\[([\\s\\S]*?)\\]\\]>/, true)) { // Cdata node\r\n          return new SvgNode('#cdata-section', 4, temp[1], error);\r\n        } else if (temp = parser.match(/^([^<]+)/, true)) { // Text node\r\n          return new SvgNode('#text', 3, decodeEntities(temp[1]), error);\r\n        }\r\n      };\r\n      while (child = recursive()) {\r\n        if (child.nodeType === 1 && !result) {\r\n          result = child;\r\n        } else if (child.nodeType === 1 || (child.nodeType === 3 && child.nodeValue.trim() !== '')) {\r\n          warningCallback('parseXml: data after document end has been discarded');\r\n        }\r\n      }\r\n      if (parser.matchAll()) {\r\n        warningCallback('parseXml: parsing error');\r\n      }\r\n      return result;\r\n    };\r\n    function decodeEntities(str) {\r\n      return(str.replace(/&(?:#([0-9]+)|#[xX]([0-9A-Fa-f]+)|([0-9A-Za-z]+));/g, function(mt, m0, m1, m2) {\r\n        if (m0) {return String.fromCharCode(parseInt(m0, 10));}\r\n        else if (m1) {return String.fromCharCode(parseInt(m1, 16));}\r\n        else if (m2 && Entities[m2]) {return String.fromCharCode(Entities[m2]);}\r\n        else {return mt;}\r\n      }));\r\n    }\r\n    function parseColor(raw) {\r\n      let temp, result;\r\n      raw = (raw || '').trim();\r\n      if (temp = NamedColors[raw]) {\r\n        result = [temp.slice(), 1];\r\n      } else if (temp = raw.match(/^rgba\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9.]+)\\s*\\)$/i)) {\r\n        temp[1] = parseInt(temp[1]); temp[2] = parseInt(temp[2]); temp[3] = parseInt(temp[3]); temp[4] = parseFloat(temp[4]);\r\n        if (temp[1] < 256 && temp[2] < 256 && temp[3] < 256 && temp[4] <= 1) {\r\n          result = [temp.slice(1, 4), temp[4]];\r\n        }\r\n      } else if (temp = raw.match(/^rgb\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)$/i)) {\r\n        temp[1] = parseInt(temp[1]); temp[2] = parseInt(temp[2]); temp[3] = parseInt(temp[3]);\r\n        if (temp[1] < 256 && temp[2] < 256 && temp[3] < 256) {\r\n          result = [temp.slice(1, 4), 1];\r\n        }\r\n      } else if (temp = raw.match(/^rgb\\(\\s*([0-9.]+)%\\s*,\\s*([0-9.]+)%\\s*,\\s*([0-9.]+)%\\s*\\)$/i)) {\r\n        temp[1] = 2.55 * parseFloat(temp[1]); temp[2] = 2.55 * parseFloat(temp[2]); temp[3] = 2.55 * parseFloat(temp[3]);\r\n        if (temp[1] < 256 && temp[2] < 256 && temp[3] < 256) {\r\n          result = [temp.slice(1, 4), 1];\r\n        }\r\n      } else if (temp = raw.match(/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i)) {\r\n        result = [[parseInt(temp[1], 16), parseInt(temp[2], 16), parseInt(temp[3], 16)], 1];\r\n      } else if (temp = raw.match(/^#([0-9a-f])([0-9a-f])([0-9a-f])$/i)) {\r\n        result = [[0x11 * parseInt(temp[1], 16), 0x11 * parseInt(temp[2], 16), 0x11 * parseInt(temp[3], 16)], 1];\r\n      }\r\n      return colorCallback ? colorCallback(result, raw) : result;\r\n    }\r\n    function opacityToColor(color, opacity, isMask) {\r\n      let newColor = color[0].slice(),\r\n          newOpacity = color[1] * opacity;\r\n      if (isMask) {\r\n        for (let i = 0; i < color.length; i++) {\r\n          newColor[i] *= newOpacity;\r\n        }\r\n        return [newColor, 1];\r\n      } else {\r\n        return [newColor, newOpacity];\r\n      }\r\n    }\r\n    function multiplyMatrix() {\r\n      function multiply(a, b) {\r\n        return [ a[0]*b[0]+a[2]*b[1], a[1]*b[0]+a[3]*b[1], a[0]*b[2]+a[2]*b[3],\r\n                 a[1]*b[2]+a[3]*b[3], a[0]*b[4]+a[2]*b[5]+a[4], a[1]*b[4]+a[3]*b[5]+a[5] ];\r\n      }\r\n      let result = arguments[0];\r\n      for (let i = 1; i < arguments.length; i++) {\r\n        result = multiply(result, arguments[i]);\r\n      }\r\n      return result;\r\n    }\r\n    function transformPoint(p, m) {\r\n      return [m[0] * p[0] + m[2] * p[1] + m[4], m[1] * p[0] + m[3] * p[1] + m[5]];\r\n    }\r\n    function getGlobalMatrix() {\r\n      let ctm = doc._ctm;\r\n      for (let i = groupStack.length - 1; i >= 0; i--) {\r\n        ctm = multiplyMatrix(groupStack[i].savedMatrix, ctm);\r\n      }\r\n      return ctm;\r\n    }\r\n    function getPageBBox() {\r\n      return new SvgShape().M(0, 0).L(doc.page.width, 0).L(doc.page.width, doc.page.height).L(0, doc.page.height)\r\n                           .transform(inverseMatrix(getGlobalMatrix())).getBoundingBox();\r\n    }\r\n    function inverseMatrix(m) {\r\n      let dt = m[0] * m[3] - m[1] * m[2];\r\n      return [m[3] / dt, -m[1] / dt, -m[2] / dt, m[0] / dt, (m[2]*m[5] - m[3]*m[4]) / dt, (m[1]*m[4] - m[0]*m[5]) / dt];\r\n    }\r\n    function validateMatrix(m) {\r\n      let m0 = validateNumber(m[0]), m1 = validateNumber(m[1]), m2 = validateNumber(m[2]),\r\n          m3 = validateNumber(m[3]), m4 = validateNumber(m[4]), m5 = validateNumber(m[5]);\r\n      if (isNotEqual(m0 * m3 - m1 * m2, 0)) {\r\n        return [m0, m1, m2, m3, m4, m5];\r\n      }\r\n    }\r\n    function solveEquation(curve) {\r\n      let a = curve[2] || 0, b = curve[1] || 0, c = curve[0] || 0;\r\n      if (isEqual(a, 0) && isEqual(b, 0)) {\r\n        return [];\r\n      } else if (isEqual(a, 0)) {\r\n        return [(-c) / b];\r\n      } else {\r\n        let d = b * b - 4 * a * c;\r\n        if (isNotEqual(d, 0) && d > 0) {\r\n          return [(-b + Math.sqrt(d)) / (2 * a), (-b - Math.sqrt(d)) / (2 * a)];\r\n        } else if (isEqual(d, 0)) {\r\n          return [(-b) / (2 * a)];\r\n        } else {\r\n          return [];\r\n        }\r\n      }\r\n    }\r\n    function getCurveValue(t, curve) {\r\n      return (curve[0] || 0) + (curve[1] || 0) * t + (curve[2] || 0) * t * t + (curve[3] || 0) * t * t * t;\r\n    }\r\n    function isEqual(number, ref) {\r\n      return Math.abs(number - ref) < 1e-10;\r\n    }\r\n    function isNotEqual(number, ref) {\r\n      return Math.abs(number - ref) >= 1e-10;\r\n    }\r\n    function validateNumber(n) {\r\n      return n > -1e21 && n < 1e21 ? Math.round(n * 1e6) / 1e6 : 0;\r\n    }\r\n    function isArrayLike(v) {\r\n      return typeof v === 'object' && v !== null && typeof v.length === 'number';\r\n    }\r\n    function parseTranform(v) {\r\n      let parser = new StringParser((v || '').trim()), result = [1, 0, 0, 1, 0, 0], temp;\r\n      while (temp = parser.match(/^([A-Za-z]+)\\s*[(]([^(]+)[)]/, true)) {\r\n        let func = temp[1], nums = [], parser2 = new StringParser(temp[2].trim()), temp2;\r\n        while (temp2 = parser2.matchNumber()) {\r\n          nums.push(Number(temp2));\r\n          parser2.matchSeparator();\r\n        }\r\n        if (func === 'matrix' && nums.length === 6) {\r\n          result = multiplyMatrix(result, [nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]]);\r\n        } else if (func === 'translate' && nums.length === 2) {\r\n          result = multiplyMatrix(result, [1, 0, 0, 1, nums[0], nums[1]]);\r\n        } else if (func === 'translate' && nums.length === 1) {\r\n          result = multiplyMatrix(result, [1, 0, 0, 1, nums[0], 0]);\r\n        } else if (func === 'scale' && nums.length === 2) {\r\n          result = multiplyMatrix(result, [nums[0], 0, 0, nums[1], 0, 0]);\r\n        } else if (func === 'scale' && nums.length === 1) {\r\n          result = multiplyMatrix(result, [nums[0], 0, 0, nums[0], 0, 0]);\r\n        } else if (func === 'rotate' && nums.length === 3) {\r\n          let a = nums[0] * Math.PI / 180;\r\n          result = multiplyMatrix(result, [1, 0, 0, 1, nums[1], nums[2]], [Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0], [1, 0, 0, 1, -nums[1], -nums[2]]);\r\n        } else if (func === 'rotate' && nums.length === 1) {\r\n          let a = nums[0] * Math.PI / 180;\r\n          result = multiplyMatrix(result, [Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);\r\n        } else if (func === 'skewX' && nums.length === 1) {\r\n          let a = nums[0] * Math.PI / 180;\r\n          result = multiplyMatrix(result, [1, 0, Math.tan(a), 1, 0, 0]);\r\n        } else if (func === 'skewY' && nums.length === 1) {\r\n          let a = nums[0] * Math.PI / 180;\r\n          result = multiplyMatrix(result, [1, Math.tan(a), 0, 1, 0, 0]);\r\n        } else {return;}\r\n        parser.matchSeparator();\r\n      }\r\n      if (parser.matchAll()) {return;}\r\n      return result;\r\n    }\r\n    function parseAspectRatio(aspectRatio, availWidth, availHeight, elemWidth, elemHeight, initAlign) {\r\n      let temp = (aspectRatio || '').trim().match(/^(none)$|^x(Min|Mid|Max)Y(Min|Mid|Max)(?:\\s+(meet|slice))?$/) || [],\r\n          ratioType = temp[1] || temp[4] || 'meet',\r\n          xAlign = temp[2] || 'Mid',\r\n          yAlign = temp[3] || 'Mid',\r\n          scaleX = availWidth / elemWidth,\r\n          scaleY = availHeight / elemHeight,\r\n          dx = {'Min':0, 'Mid':0.5, 'Max':1}[xAlign] - (initAlign || 0),\r\n          dy = {'Min':0, 'Mid':0.5, 'Max':1}[yAlign] - (initAlign || 0);\r\n      if (ratioType === 'slice') {\r\n        scaleY = scaleX = Math.max(scaleX, scaleY);\r\n      } else if (ratioType === 'meet') {\r\n        scaleY = scaleX = Math.min(scaleX, scaleY);\r\n      }\r\n      return [scaleX, 0, 0, scaleY, dx * (availWidth - elemWidth * scaleX), dy * (availHeight - elemHeight * scaleY)];\r\n    }\r\n    function parseStyleAttr(v) {\r\n      let result = Object.create(null);\r\n      v = (v || '').trim().split(/;/);\r\n      for (let i = 0; i < v.length; i++) {\r\n        let key = (v[i].split(':')[0] || '').trim(),\r\n            value = (v[i].split(':')[1] || '').trim();\r\n        if (key) {\r\n          result[key] = value;\r\n        }\r\n      }\r\n      if (result['marker']) {\r\n        if (!result['marker-start']) {result['marker-start'] = result['marker'];}\r\n        if (!result['marker-mid']) {result['marker-mid'] = result['marker'];}\r\n        if (!result['marker-end']) {result['marker-end'] = result['marker'];}\r\n      }\r\n      if (result['font']) {\r\n        let fontFamily = null, fontSize = null, fontStyle = \"normal\", fontWeight = \"normal\", fontVariant = \"normal\";\r\n        let parts = result['font'].split(/\\s+/);\r\n        for (let i = 0; i < parts.length; i++) {\r\n          switch (parts[i]) {\r\n            case \"normal\":\r\n              break;\r\n            case \"italic\": case \"oblique\":\r\n              fontStyle = parts[i];\r\n              break;\r\n            case \"small-caps\":\r\n              fontVariant = parts[i];\r\n              break;\r\n            case \"bold\": case \"bolder\": case \"lighter\": case \"100\": case \"200\": case \"300\":\r\n            case \"400\": case \"500\": case \"600\": case \"700\": case \"800\": case \"900\":\r\n              fontWeight = parts[i];\r\n              break;\r\n            default:\r\n              if (!fontSize) {\r\n                fontSize = parts[i].split('/')[0];\r\n              } else {\r\n                if (!fontFamily) {\r\n                  fontFamily = parts[i];\r\n                } else {\r\n                  fontFamily += ' ' + parts[i];\r\n                }\r\n              }\r\n              break;\r\n          }\r\n        }\r\n        if (!result['font-style']) {result['font-style'] = fontStyle;}\r\n        if (!result['font-variant']) {result['font-variant'] = fontVariant;}\r\n        if (!result['font-weight']) {result['font-weight'] = fontWeight;}\r\n        if (!result['font-size']) {result['font-size'] = fontSize;}\r\n        if (!result['font-family']) {result['font-family'] = fontFamily;}\r\n      }\r\n      return result;\r\n    }\r\n    function parseSelector(v) {\r\n      let parts = v.split(/(?=[.#])/g), ids = [], classes = [], tags = [], temp;\r\n      for (let i = 0; i < parts.length; i++) {\r\n        if (temp = parts[i].match(/^[#]([_A-Za-z0-9-]+)$/)) {\r\n          ids.push(temp[1]);\r\n        } else if (temp = parts[i].match(/^[.]([_A-Za-z0-9-]+)$/)) {\r\n          classes.push(temp[1]);\r\n        } else if (temp = parts[i].match(/^([_A-Za-z0-9-]+)$/)) {\r\n          tags.push(temp[1]);\r\n        } else if (parts[i] !== '*') {\r\n          return;\r\n        }\r\n      }\r\n      return {\r\n        tags: tags, ids: ids, classes: classes,\r\n        specificity: ids.length * 10000 + classes.length * 100 + tags.length\r\n      };\r\n    }\r\n    function parseStyleSheet(v) {\r\n      let parser = new StringParser(v.trim()), rules = [], rule;\r\n      while (rule = parser.match(/^\\s*([^\\{\\}]*?)\\s*\\{([^\\{\\}]*?)\\}/, true)) {\r\n        let selectors = rule[1].split(/\\s*,\\s*/g),\r\n            css = parseStyleAttr(rule[2]);\r\n        for (let i = 0; i < selectors.length; i++) {\r\n          let selector = parseSelector(selectors[i]);\r\n          if (selector) {\r\n            rules.push({selector: selector, css:css});\r\n          }\r\n        }\r\n      }\r\n      return rules;\r\n    }\r\n    function matchesSelector(elem, selector) {\r\n      if (elem.nodeType !== 1) {return false;}\r\n      for (let i = 0; i < selector.tags.length; i++) {\r\n        if (selector.tags[i] !== elem.nodeName) {return false;}\r\n      }\r\n      for (let i = 0; i < selector.ids.length; i++) {\r\n        if (selector.ids[i] !== elem.id) {return false;}\r\n      }\r\n      for (let i = 0; i < selector.classes.length; i++) {\r\n        if (elem.classList.indexOf(selector.classes[i]) === -1) {return false;}\r\n      }\r\n      return true;\r\n    }\r\n    function getStyle(elem) {\r\n      let result = Object.create(null);\r\n      let specificities = Object.create(null);\r\n      for (let i = 0; i < styleRules.length; i++) {\r\n        let rule = styleRules[i];\r\n        if (matchesSelector(elem, rule.selector)) {\r\n          for (let key in rule.css) {\r\n            if (!(specificities[key] > rule.selector.specificity)) {\r\n              result[key] = rule.css[key];\r\n              specificities[key] = rule.selector.specificity;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n    function combineArrays(array1, array2) {\r\n      return array1.concat(array2.slice(array1.length));\r\n    }\r\n    function getAscent(font, size) {\r\n      return Math.max(font.ascender, (font.bbox[3] || font.bbox.maxY) * (font.scale || 1)) * size / 1000;\r\n    }\r\n    function getDescent(font, size) {\r\n      return Math.min(font.descender, (font.bbox[1] || font.bbox.minY) * (font.scale || 1)) * size / 1000;\r\n    }\r\n    function getXHeight(font, size) {\r\n      return (font.xHeight || 0.5 * (font.ascender - font.descender)) * size / 1000;\r\n    }\r\n    function getBaseline(font, size, baseline, shift) {\r\n      let dy1, dy2;\r\n      switch (baseline) {\r\n        case 'middle': dy1 = 0.5 * getXHeight(font, size); break;\r\n        case 'central': dy1 = 0.5 * (getDescent(font, size) + getAscent(font, size)); break;\r\n        case 'after-edge': case 'text-after-edge': dy1 = getDescent(font, size); break;\r\n        case 'alphabetic': case 'auto': case 'baseline': dy1 = 0; break;\r\n        case 'mathematical': dy1 = 0.5 * getAscent(font, size); break;\r\n        case 'hanging': dy1 = 0.8 * getAscent(font, size); break;\r\n        case 'before-edge': case 'text-before-edge': dy1 = getAscent(font, size); break;\r\n        default: dy1 = 0; break;\r\n      }\r\n      switch (shift) {\r\n        case 'baseline': dy2 = 0; break;\r\n        case 'super': dy2 = 0.6 * size; break;\r\n        case 'sub': dy2 = -0.6 * size; break;\r\n        default: dy2 = shift; break;\r\n      }\r\n      return dy1 - dy2;\r\n    }\r\n    function getTextPos(font, size, text) {\r\n      let encoded = font.encode('' + text), hex = encoded[0], pos = encoded[1], data = [];\r\n      for (let i = 0; i < hex.length; i++) {\r\n        let unicode = font.unicode ? font.unicode[parseInt(hex[i], 16)] : [text.charCodeAt(i)];\r\n        data.push({\r\n          glyph: hex[i],\r\n          unicode: unicode,\r\n          width: pos[i].advanceWidth * size / 1000,\r\n          xOffset: pos[i].xOffset * size / 1000,\r\n          yOffset: pos[i].yOffset * size / 1000,\r\n          xAdvance: pos[i].xAdvance * size / 1000,\r\n          yAdvance: pos[i].yAdvance * size / 1000\r\n        });\r\n      }\r\n      return data;\r\n    }\r\n    function createSVGElement(obj, inherits) {\r\n      switch (obj.nodeName) {\r\n        case 'use': return new SvgElemUse(obj, inherits);\r\n        case 'symbol': return new SvgElemSymbol(obj, inherits);\r\n        case 'g': return new SvgElemGroup(obj, inherits);\r\n        case 'a': return new SvgElemLink(obj, inherits);\r\n        case 'svg': return new SvgElemSvg(obj, inherits);\r\n        case 'image': return new SVGElemImage(obj, inherits);\r\n        case 'rect': return new SvgElemRect(obj, inherits);\r\n        case 'circle': return new SvgElemCircle(obj, inherits);\r\n        case 'ellipse': return new SvgElemEllipse(obj, inherits);\r\n        case 'line': return new SvgElemLine(obj, inherits);\r\n        case 'polyline': return new SvgElemPolyline(obj, inherits);\r\n        case 'polygon': return new SvgElemPolygon(obj, inherits);\r\n        case 'path': return new SvgElemPath(obj, inherits);\r\n        case 'text': return new SvgElemText(obj, inherits);\r\n        case 'tspan': return new SvgElemTspan(obj, inherits);\r\n        case 'textPath': return new SvgElemTextPath(obj, inherits);\r\n        case '#text': case '#cdata-section': return new SvgElemTextNode(obj, inherits);\r\n        default: return new SvgElem(obj, inherits);\r\n      }\r\n    }\r\n\r\n    var StringParser = function(str) {\r\n      this.match = function(exp, all) {\r\n        let temp = str.match(exp);\r\n        if (!temp || temp.index !== 0) {return;}\r\n        str = str.substring(temp[0].length);\r\n        return (all ? temp : temp[0]);\r\n      };\r\n      this.matchSeparator = function() {\r\n        return this.match(/^(?:\\s*,\\s*|\\s*|)/);\r\n      };\r\n      this.matchSpace = function() {\r\n        return this.match(/^(?:\\s*)/);\r\n      };\r\n      this.matchLengthUnit = function() {\r\n        return this.match(/^(?:px|pt|cm|mm|in|pc|em|ex|%|)/);\r\n      };\r\n      this.matchNumber = function() {\r\n        return this.match(/^(?:[-+]?(?:[0-9]+[.][0-9]+|[0-9]+[.]|[.][0-9]+|[0-9]+)(?:[eE][-+]?[0-9]+)?)/);\r\n      };\r\n      this.matchAll = function() {\r\n        return this.match(/^[\\s\\S]+/);\r\n      };\r\n    };\r\n\r\n    var BezierSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\r\n      let divisions = 6 * precision;\r\n      let equationX = [p1x, -3 * p1x + 3 * c1x, 3 * p1x - 6 * c1x + 3 * c2x, -p1x + 3 * c1x - 3 * c2x + p2x];\r\n      let equationY = [p1y, -3 * p1y + 3 * c1y, 3 * p1y - 6 * c1y + 3 * c2y, -p1y + 3 * c1y - 3 * c2y + p2y];\r\n      let derivativeX = [-3 * p1x + 3 * c1x, 6 * p1x - 12 * c1x + 6 * c2x, -3 * p1x + 9 * c1x - 9 * c2x + 3 * p2x];\r\n      let derivativeY = [-3 * p1y + 3 * c1y, 6 * p1y - 12 * c1y + 6 * c2y, -3 * p1y + 9 * c1y - 9 * c2y + 3 * p2y];\r\n      let lengthMap = [0];\r\n      for (let i = 1; i <= divisions; i++) {\r\n        let t = (i - 0.5) / divisions;\r\n        let dx = getCurveValue(t, derivativeX) / divisions,\r\n            dy = getCurveValue(t, derivativeY) / divisions,\r\n            l = Math.sqrt(dx * dx + dy * dy);\r\n        lengthMap[i] = lengthMap[i - 1] + l;\r\n      }\r\n      this.totalLength = lengthMap[divisions];\r\n      this.startPoint = [p1x, p1y, isEqual(p1x, c1x) && isEqual(p1y, c1y) ? Math.atan2(c2y - c1y, c2x - c1x) : Math.atan2(c1y - p1y, c1x - p1x)];\r\n      this.endPoint = [p2x, p2y, isEqual(c2x, p2x) && isEqual(c2y, p2y) ? Math.atan2(c2y - c1y, c2x - c1x) : Math.atan2(p2y - c2y, p2x - c2x)];\r\n      this.getBoundingBox = function() {\r\n        let temp;\r\n        let minX = getCurveValue(0, equationX), minY = getCurveValue(0, equationY),\r\n            maxX = getCurveValue(1, equationX), maxY = getCurveValue(1, equationY);\r\n        if (minX > maxX) {temp = maxX; maxX = minX; minX = temp;}\r\n        if (minY > maxY) {temp = maxY; maxY = minY; minY = temp;}\r\n        let rootsX = solveEquation(derivativeX);\r\n        for (let i = 0; i < rootsX.length; i++) {\r\n          if (rootsX[i] >= 0 && rootsX[i] <= 1) {\r\n            let x = getCurveValue(rootsX[i], equationX);\r\n            if (x < minX) {minX = x;}\r\n            if (x > maxX) {maxX = x;}\r\n          }\r\n        }\r\n        let rootsY = solveEquation(derivativeY);\r\n        for (let i = 0; i < rootsY.length; i++) {\r\n          if (rootsY[i] >= 0 && rootsY[i] <= 1) {\r\n            let y = getCurveValue(rootsY[i], equationY);\r\n            if (y < minY) {minY = y;}\r\n            if (y > maxY) {maxY = y;}\r\n          }\r\n        }\r\n        return [minX, minY, maxX, maxY];\r\n      };\r\n      this.getPointAtLength = function(l) {\r\n        if (isEqual(l, 0)) {return this.startPoint;}\r\n        if (isEqual(l, this.totalLength)) {return this.endPoint;}\r\n        if (l < 0 || l > this.totalLength) {return;}\r\n        for (let i = 1; i <= divisions; i++) {\r\n          let l1 = lengthMap[i-1], l2 = lengthMap[i];\r\n          if (l1 <= l && l <= l2) {\r\n            let t = (i - (l2 - l) / (l2 - l1)) / divisions,\r\n                x = getCurveValue(t, equationX), y = getCurveValue(t, equationY),\r\n                dx = getCurveValue(t, derivativeX), dy = getCurveValue(t, derivativeY);\r\n            return [x, y, Math.atan2(dy, dx)];\r\n          }\r\n        }\r\n      };\r\n    };\r\n\r\n    var LineSegment = function(p1x, p1y, p2x, p2y) {\r\n      this.totalLength = Math.sqrt((p2x - p1x) * (p2x - p1x) + (p2y - p1y) * (p2y - p1y));\r\n      this.startPoint = [p1x, p1y, Math.atan2(p2y - p1y, p2x - p1x)];\r\n      this.endPoint = [p2x, p2y, Math.atan2(p2y - p1y, p2x - p1x)];\r\n      this.getBoundingBox = function() {\r\n        return [Math.min(this.startPoint[0], this.endPoint[0]), Math.min(this.startPoint[1], this.endPoint[1]),\r\n                Math.max(this.startPoint[0], this.endPoint[0]), Math.max(this.startPoint[1], this.endPoint[1])];\r\n      };\r\n      this.getPointAtLength = function(l) {\r\n        if (l >= 0 && l <= this.totalLength) {\r\n          let r = l / this.totalLength || 0,\r\n              x = this.startPoint[0] + r * (this.endPoint[0] - this.startPoint[0]),\r\n              y = this.startPoint[1] + r * (this.endPoint[1] - this.startPoint[1]);\r\n          return [x, y, this.startPoint[2]];\r\n        }\r\n      };\r\n    };\r\n\r\n    var SvgShape = function() {\r\n      this.pathCommands = [];\r\n      this.pathSegments = [];\r\n      this.startPoint = null;\r\n      this.endPoint = null;\r\n      this.totalLength = 0;\r\n      let startX = 0, startY = 0, currX = 0, currY = 0, lastCom, lastCtrlX, lastCtrlY;\r\n      this.move = function(x, y) {\r\n        startX = currX = x; startY = currY = y;\r\n        return null;\r\n      };\r\n      this.line = function(x, y) {\r\n        let segment = new LineSegment(currX, currY, x, y);\r\n        currX = x; currY = y;\r\n        return segment;\r\n      };\r\n      this.curve = function(c1x, c1y, c2x, c2y, x, y) {\r\n        let segment = new BezierSegment(currX, currY, c1x, c1y, c2x, c2y, x, y);\r\n        currX = x; currY = y;\r\n        return segment;\r\n      };\r\n      this.close = function() {\r\n        let segment = new LineSegment(currX, currY, startX, startY);\r\n        currX = startX; currY = startY;\r\n        return segment;\r\n      };\r\n      this.addCommand = function(data) {\r\n        this.pathCommands.push(data);\r\n        let segment = this[data[0]].apply(this, data.slice(3));\r\n        if (segment) {\r\n          segment.hasStart = data[1];\r\n          segment.hasEnd = data[2];\r\n          this.startPoint = this.startPoint || segment.startPoint;\r\n          this.endPoint = segment.endPoint;\r\n          this.pathSegments.push(segment);\r\n          this.totalLength += segment.totalLength;\r\n        }\r\n      };\r\n      this.M = function(x, y) {\r\n        this.addCommand(['move', true, true, x, y]);\r\n        lastCom = 'M';\r\n        return this;\r\n      };\r\n      this.m = function(x, y) {\r\n        return this.M(currX + x, currY + y);\r\n      };\r\n      this.Z = this.z = function() {\r\n        this.addCommand(['close', true, true]);\r\n        lastCom = 'Z';\r\n        return this;\r\n      };\r\n      this.L = function(x, y) {\r\n        this.addCommand(['line', true, true, x, y]);\r\n        lastCom = 'L';\r\n        return this;\r\n      };\r\n      this.l = function(x, y) {\r\n        return this.L(currX + x, currY + y);\r\n      };\r\n      this.H = function(x) {\r\n        return this.L(x, currY);\r\n      };\r\n      this.h = function(x) {\r\n        return this.L(currX + x, currY);\r\n      };\r\n      this.V = function(y) {\r\n        return this.L(currX, y);\r\n      };\r\n      this.v = function(y) {\r\n        return this.L(currX, currY + y);\r\n      };\r\n      this.C = function(c1x, c1y, c2x, c2y, x, y) {\r\n        this.addCommand(['curve', true, true, c1x, c1y, c2x, c2y, x, y]);\r\n        lastCom = 'C'; lastCtrlX = c2x; lastCtrlY = c2y;\r\n        return this;\r\n      };\r\n      this.c = function(c1x, c1y, c2x, c2y, x, y) {\r\n        return this.C(currX + c1x, currY + c1y, currX + c2x, currY + c2y, currX + x, currY + y);\r\n      };\r\n      this.S = function(c1x, c1y, x, y) {\r\n        return this.C(currX + (lastCom === 'C' ? currX - lastCtrlX : 0), currY + (lastCom === 'C' ? currY - lastCtrlY : 0), c1x, c1y, x, y);\r\n      };\r\n      this.s = function(c1x, c1y, x, y) {\r\n        return this.C(currX + (lastCom === 'C' ? currX - lastCtrlX : 0), currY + (lastCom === 'C' ? currY - lastCtrlY : 0), currX + c1x, currY + c1y, currX + x, currY + y);\r\n      };\r\n      this.Q = function(cx, cy, x, y) {\r\n        let c1x = currX + 2 / 3 * (cx - currX), c1y = currY + 2 / 3 * (cy - currY),\r\n            c2x = x + 2 / 3 * (cx - x), c2y = y + 2 / 3 * (cy - y);\r\n        this.addCommand(['curve', true, true, c1x, c1y, c2x, c2y, x, y]);\r\n        lastCom = 'Q'; lastCtrlX = cx; lastCtrlY = cy;\r\n        return this;\r\n      };\r\n      this.q = function(c1x, c1y, x, y) {\r\n        return this.Q(currX + c1x, currY + c1y, currX + x, currY + y);\r\n      };\r\n      this.T = function(x, y) {\r\n        return this.Q(currX + (lastCom === 'Q' ? currX - lastCtrlX : 0), currY + (lastCom === 'Q' ? currY - lastCtrlY : 0), x, y);\r\n      };\r\n      this.t = function(x, y) {\r\n        return this.Q(currX + (lastCom === 'Q' ? currX - lastCtrlX : 0), currY + (lastCom === 'Q' ? currY - lastCtrlY : 0), currX + x, currY + y);\r\n      };\r\n      this.A = function(rx, ry, fi, fa, fs, x, y) {\r\n        if (isEqual(rx, 0) || isEqual(ry, 0)) {\r\n          this.addCommand(['line', true, true, x, y]);\r\n        } else {\r\n          fi = fi * (Math.PI / 180);\r\n          rx = Math.abs(rx);\r\n          ry = Math.abs(ry);\r\n          fa = 1 * !!fa;\r\n          fs = 1 * !!fs;\r\n          let x1 = Math.cos(fi) * (currX - x) / 2 + Math.sin(fi) * (currY - y) / 2,\r\n              y1 = Math.cos(fi) * (currY - y) / 2 - Math.sin(fi) * (currX - x) / 2,\r\n              lambda = (x1 * x1) / (rx * rx) + (y1 * y1) / (ry * ry);\r\n          if (lambda > 1) {\r\n            rx *= Math.sqrt(lambda);\r\n            ry *= Math.sqrt(lambda);\r\n          }\r\n          let r = Math.sqrt(Math.max(0, rx * rx * ry * ry - rx * rx * y1 * y1 - ry * ry * x1 * x1) / (rx * rx * y1 * y1 + ry * ry * x1 * x1)),\r\n              x2 = (fa === fs ? -1 : 1) * r * rx * y1 / ry,\r\n              y2 = (fa === fs ? 1 : -1) * r * ry * x1 / rx;\r\n          let cx = Math.cos(fi) * x2 - Math.sin(fi) * y2 + (currX + x) / 2,\r\n              cy = Math.sin(fi) * x2 + Math.cos(fi) * y2 + (currY + y) / 2,\r\n              th1 = Math.atan2((y1 - y2) / ry, (x1 - x2) / rx),\r\n              th2 = Math.atan2((-y1 - y2) / ry, (-x1 - x2) / rx);\r\n          if (fs === 0 && th2 - th1 > 0) {\r\n            th2 -= 2 * Math.PI;\r\n          } else if (fs === 1 && th2 - th1 < 0) {\r\n            th2 += 2 * Math.PI;\r\n          }\r\n          let segms = Math.ceil(Math.abs(th2 - th1) / (Math.PI / precision));\r\n          for (let i = 0; i < segms; i++) {\r\n            let th3 = th1 + i * (th2 - th1) / segms,\r\n                th4 = th1 + (i + 1) * (th2 - th1) / segms,\r\n                t = 4/3 * Math.tan((th4 - th3) / 4);\r\n            let c1x = cx + Math.cos(fi) * rx * (Math.cos(th3) - t * Math.sin(th3)) - Math.sin(fi) * ry * (Math.sin(th3) + t * Math.cos(th3)),\r\n                c1y = cy + Math.sin(fi) * rx * (Math.cos(th3) - t * Math.sin(th3)) + Math.cos(fi) * ry * (Math.sin(th3) + t * Math.cos(th3)),\r\n                c2x = cx + Math.cos(fi) * rx * (Math.cos(th4) + t * Math.sin(th4)) - Math.sin(fi) * ry * (Math.sin(th4) - t * Math.cos(th4)),\r\n                c2y = cy + Math.sin(fi) * rx * (Math.cos(th4) + t * Math.sin(th4)) + Math.cos(fi) * ry * (Math.sin(th4) - t * Math.cos(th4)),\r\n                endX = cx + Math.cos(fi) * rx * Math.cos(th4) - Math.sin(fi) * ry * Math.sin(th4),\r\n                endY = cy + Math.sin(fi) * rx * Math.cos(th4) + Math.cos(fi) * ry * Math.sin(th4);\r\n            this.addCommand(['curve', (i === 0), (i === segms - 1), c1x, c1y, c2x, c2y, endX, endY]);\r\n          }\r\n        }\r\n        lastCom = 'A';\r\n        return this;\r\n      };\r\n      this.a = function(rx, ry, fi, fa, fs, x, y) {\r\n        return this.A(rx, ry, fi, fa, fs, currX + x, currY + y);\r\n      };\r\n      this.path = function(d) {\r\n        let command, value, temp,\r\n            parser = new StringParser((d || '').trim());\r\n        while (command = parser.match(/^[astvzqmhlcASTVZQMHLC]/)) {\r\n          parser.matchSeparator();\r\n          let values = [];\r\n          while (value = (PathFlags[command + values.length] ? parser.match(/^[01]/) : parser.matchNumber())) {\r\n            parser.matchSeparator();\r\n            if (values.length === PathArguments[command]) {\r\n              this[command].apply(this, values);\r\n              values = [];\r\n              if (command === 'M') {command = 'L';}\r\n              else if (command === 'm') {command = 'l';}\r\n            }\r\n            values.push(Number(value));\r\n          }\r\n          if (values.length === PathArguments[command]) {\r\n            this[command].apply(this, values);\r\n          } else {\r\n            warningCallback('SvgPath: command ' + command + ' with ' + values.length + ' numbers'); return;\r\n          }\r\n        }\r\n        if (temp = parser.matchAll()) {\r\n          warningCallback('SvgPath: unexpected string ' + temp);\r\n        }\r\n        return this;\r\n      };\r\n      this.getBoundingBox = function() {\r\n        let bbox = [Infinity, Infinity, -Infinity, -Infinity];\r\n        function addBounds(bbox1) {\r\n          if (bbox1[0] < bbox[0]) {bbox[0] = bbox1[0];}\r\n          if (bbox1[2] > bbox[2]) {bbox[2] = bbox1[2];}\r\n          if (bbox1[1] < bbox[1]) {bbox[1] = bbox1[1];}\r\n          if (bbox1[3] > bbox[3]) {bbox[3] = bbox1[3];}\r\n        }\r\n        for (let i = 0; i < this.pathSegments.length; i++) {\r\n          addBounds(this.pathSegments[i].getBoundingBox());\r\n        }\r\n        if (bbox[0] === Infinity) {bbox[0] = 0;}\r\n        if (bbox[1] === Infinity) {bbox[1] = 0;}\r\n        if (bbox[2] === -Infinity) {bbox[2] = 0;}\r\n        if (bbox[3] === -Infinity) {bbox[3] = 0;}\r\n        return bbox;\r\n      };\r\n      this.getPointAtLength = function(l) {\r\n        if (l >= 0 && l <= this.totalLength) {\r\n          let temp;\r\n          for (let i = 0; i < this.pathSegments.length; i++) {\r\n            if (temp = this.pathSegments[i].getPointAtLength(l)) {\r\n              return temp;\r\n            }\r\n            l -= this.pathSegments[i].totalLength;\r\n          }\r\n          return this.endPoint;\r\n        }\r\n      };\r\n      this.transform = function(m) {\r\n        this.pathSegments = [];\r\n        this.startPoint = null;\r\n        this.endPoint = null;\r\n        this.totalLength = 0;\r\n        for (let i = 0; i < this.pathCommands.length; i++) {\r\n          let data = this.pathCommands.shift();\r\n          for (let j = 3; j < data.length; j+=2) {\r\n            let p = transformPoint([data[j], data[j + 1]], m)\r\n            data[j] = p[0];\r\n            data[j + 1] = p[1];\r\n          }\r\n          this.addCommand(data);\r\n        }\r\n        return this;        \r\n      };\r\n      this.mergeShape = function(shape) {\r\n        for (let i = 0; i < shape.pathCommands.length; i++) {\r\n          this.addCommand(shape.pathCommands[i].slice());\r\n        }\r\n        return this;\r\n      };\r\n      this.clone = function() {\r\n        return new SvgShape().mergeShape(this);\r\n      };\r\n      this.insertInDocument = function() {\r\n        for (let i = 0; i < this.pathCommands.length; i++) {\r\n          let command = this.pathCommands[i][0], values = this.pathCommands[i].slice(3);\r\n          switch(command) {\r\n            case 'move':  doc.moveTo(values[0], values[1]);  break;\r\n            case 'line':  doc.lineTo(values[0], values[1]);  break;\r\n            case 'curve':  doc.bezierCurveTo(values[0], values[1], values[2], values[3], values[4], values[5]);  break;\r\n            case 'close':  doc.closePath();  break;\r\n          }\r\n        }\r\n      };\r\n      this.getSubPaths = function() {\r\n        let subPaths = [], shape = new SvgShape();\r\n        for (let i = 0; i < this.pathCommands.length; i++) {\r\n          let data = this.pathCommands[i], command = this.pathCommands[i][0];\r\n          if (command === 'move' && i !== 0) {\r\n            subPaths.push(shape);\r\n            shape = new SvgShape();\r\n          }\r\n          shape.addCommand(data);\r\n        }\r\n        subPaths.push(shape);\r\n        return subPaths;\r\n      };\r\n      this.getMarkers = function() {\r\n        let markers = [], subPaths = this.getSubPaths();\r\n        for (let i = 0; i < subPaths.length; i++) {\r\n          let subPath = subPaths[i], subPathMarkers = [];\r\n          for (let j = 0; j < subPath.pathSegments.length; j++) {\r\n            let segment = subPath.pathSegments[j];\r\n            if (isNotEqual(segment.totalLength, 0) || j === 0 || j === subPath.pathSegments.length - 1) {\r\n              if (segment.hasStart) {\r\n                let startMarker = segment.getPointAtLength(0), prevEndMarker = subPathMarkers.pop();\r\n                if (prevEndMarker) {startMarker[2] = 0.5 * (prevEndMarker[2] + startMarker[2]);}\r\n                subPathMarkers.push(startMarker);\r\n              }\r\n              if (segment.hasEnd) {\r\n                let endMarker = segment.getPointAtLength(segment.totalLength);\r\n                subPathMarkers.push(endMarker);\r\n              }\r\n            }\r\n          }\r\n          markers = markers.concat(subPathMarkers);\r\n        }\r\n        return markers;\r\n      };\r\n    };\r\n\r\n    var SvgElem = function(obj, inherits) {\r\n      let styleCache = Object.create(null);\r\n      let childrenCache = null;\r\n      this.name = obj.nodeName;\r\n      this.isOuterElement = obj === svg || !obj.parentNode;\r\n      this.inherits = inherits || (!this.isOuterElement ? createSVGElement(obj.parentNode, null) : null);\r\n      this.stack = (this.inherits ? this.inherits.stack.concat(obj) : [obj]);\r\n      this.style = parseStyleAttr(typeof obj.getAttribute === 'function' && obj.getAttribute('style'));\r\n      this.css = useCSS ? getComputedStyle(obj) : getStyle(obj);\r\n      this.allowedChildren = [];\r\n      this.attr = function(key) {\r\n        if (typeof obj.getAttribute === 'function') {\r\n          return obj.getAttribute(key);\r\n        }\r\n      };\r\n      this.resolveUrl = function(value) {\r\n        let temp = (value || '').match(/^\\s*(?:url\\(\"(.*)#(.*)\"\\)|url\\('(.*)#(.*)'\\)|url\\((.*)#(.*)\\)|(.*)#(.*))\\s*$/) || [];\r\n        let file = temp[1] || temp[3] || temp[5] || temp[7],\r\n            id = temp[2] || temp[4] || temp[6] || temp[8];\r\n        if (id) {\r\n          if (!file) {\r\n            let svgObj = svg.getElementById(id);\r\n            if (svgObj) {\r\n              if (this.stack.indexOf(svgObj) === -1) {\r\n                return svgObj;\r\n              } else {\r\n                warningCallback('SVGtoPDF: loop of circular references for id \"' + id + '\"');\r\n                return;\r\n              }\r\n            }\r\n          }\r\n          if (documentCallback) {\r\n            let svgs = documentCache[file];\r\n            if (!svgs) {\r\n              svgs = documentCallback(file);\r\n              if (!isArrayLike(svgs)) {svgs = [svgs];}\r\n              for (let i = 0; i < svgs.length; i++) {\r\n                if (typeof svgs[i] === 'string') {svgs[i] = parseXml(svgs[i]);}\r\n              }\r\n              documentCache[file] = svgs;\r\n            }\r\n            for (let i = 0; i < svgs.length; i++) {\r\n              let svgObj = svgs[i].getElementById(id);\r\n              if (svgObj) {\r\n                if (this.stack.indexOf(svgObj) === -1) {\r\n                  return svgObj;\r\n                } else {\r\n                  warningCallback('SVGtoPDF: loop of circular references for id \"' + file + '#' + id + '\"');\r\n                  return;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      };\r\n      this.computeUnits = function(value, unit, percent, isFontSize) {\r\n        if (unit === '%') {\r\n          return parseFloat(value) / 100 * (isFontSize || percent != null ? percent : this.getViewport());\r\n        } else if (unit === 'ex' || unit === 'em') {\r\n          return value * {'em':1, 'ex':0.5}[unit] * (isFontSize ? percent : this.get('font-size'));\r\n        } else {\r\n          return value * {'':1, 'px':1, 'pt':96/72, 'cm':96/2.54, 'mm':96/25.4, 'in':96, 'pc':96/6}[unit];\r\n        }\r\n      };\r\n      this.computeLength = function(value, percent, initial, isFontSize) {\r\n        let parser = new StringParser((value || '').trim()), temp1, temp2;\r\n        if (typeof (temp1 = parser.matchNumber()) === 'string' && typeof (temp2 = parser.matchLengthUnit()) === 'string' && !parser.matchAll()) {\r\n          return this.computeUnits(temp1, temp2, percent, isFontSize);\r\n        }\r\n        return initial;\r\n      };\r\n      this.computeLengthList = function(value, percent, strict) {\r\n        let parser = new StringParser((value || '').trim()), result = [], temp1, temp2;\r\n        while (typeof (temp1 = parser.matchNumber()) === 'string' && typeof (temp2 = parser.matchLengthUnit()) === 'string') {\r\n          result.push(this.computeUnits(temp1, temp2, percent));\r\n          parser.matchSeparator();\r\n        }\r\n        if (strict && parser.matchAll()) {return;}\r\n        return result;\r\n      };\r\n      this.getLength = function(key, percent, initial) {\r\n        return this.computeLength(this.attr(key), percent, initial);\r\n      };\r\n      this.getLengthList = function(key, percent) {\r\n        return this.computeLengthList(this.attr(key), percent);\r\n      };\r\n      this.getUrl = function(key) {\r\n        return this.resolveUrl(this.attr(key))\r\n      };\r\n      this.getNumberList = function(key) {\r\n        let parser = new StringParser((this.attr(key) || '').trim()), result = [], temp;\r\n        while (temp = parser.matchNumber()) {\r\n          result.push(Number(temp));\r\n          parser.matchSeparator();\r\n        }\r\n        result.error = parser.matchAll();\r\n        return result;\r\n      }\r\n      this.getViewbox = function(key, initial) {\r\n        let viewBox = this.getNumberList(key);\r\n        if (viewBox.length === 4 && viewBox[2] >= 0 && viewBox[3] >= 0) {return viewBox;}\r\n        return initial;\r\n      };\r\n      this.getPercent = function(key, initial) {\r\n        let value = this.attr(key);\r\n        let parser = new StringParser((value || '').trim()), temp1, temp2;\r\n        let number = parser.matchNumber();\r\n        if (!number) {return initial;}\r\n        if (parser.match('%')) {number *= 0.01;}\r\n        if (parser.matchAll()) {return initial;}\r\n        return Math.max(0, Math.min(1, number));\r\n      };\r\n      this.chooseValue = function(args) {\r\n        for (let i = 0; i < arguments.length; i++) {\r\n          if (arguments[i] != null && arguments[i] === arguments[i]) {return arguments[i];}\r\n        }\r\n        return arguments[arguments.length - 1];\r\n      };\r\n      this.get = function(key) {\r\n        if (styleCache[key] !== undefined) {return styleCache[key];}\r\n        let keyInfo = Properties[key] || {}, value, result;\r\n        for (let i = 0; i < 3; i++) {\r\n          switch (i) {\r\n            case 0:\r\n              if (key !== 'transform') { // the CSS transform behaves strangely\r\n                value = this.css[keyInfo.css || key];\r\n              }\r\n              break;\r\n            case 1:\r\n              value = this.style[key];\r\n              break;\r\n            case 2:\r\n              value = this.attr(key);\r\n              break;\r\n          }\r\n          if (value === 'inherit') {\r\n            result = (this.inherits ? this.inherits.get(key) : keyInfo.initial);\r\n            if (result != null) {return styleCache[key] = result;}\r\n          }\r\n          if (keyInfo.values != null) {\r\n            result = keyInfo.values[value];\r\n            if (result != null) {return styleCache[key] = result;}\r\n          }\r\n          if (value != null) {\r\n            let parsed;\r\n            switch (key) {\r\n              case 'font-size':\r\n                result = this.computeLength(value, this.inherits ? this.inherits.get(key) : keyInfo.initial, undefined, true);\r\n                break;\r\n              case 'baseline-shift':\r\n                result = this.computeLength(value, this.get('font-size'));\r\n                break;\r\n              case 'font-family':\r\n                result = value || undefined;\r\n                break;\r\n              case 'opacity': case 'stroke-opacity': case 'fill-opacity': case 'stop-opacity':\r\n                parsed = parseFloat(value);\r\n                if (!isNaN(parsed)) {\r\n                  result = Math.max(0, Math.min(1, parsed));\r\n                }\r\n                break;\r\n              case 'transform':\r\n                result = parseTranform(value);\r\n                break;\r\n              case 'stroke-dasharray':\r\n                if (value === 'none') {\r\n                  result = [];\r\n                } else if (parsed = this.computeLengthList(value, this.getViewport(), true)) {\r\n                  let sum = 0, error = false;\r\n                  for (let j = 0; j < parsed.length; j++) {\r\n                    if (parsed[j] < 0) {error = true;}\r\n                    sum += parsed[j];\r\n                  }\r\n                  if (!error) {\r\n                    if (parsed.length % 2 === 1) {\r\n                      parsed = parsed.concat(parsed);\r\n                    }\r\n                    result = (sum === 0 ? [] : parsed);\r\n                  }\r\n                }\r\n                break;\r\n              case 'color':\r\n                if (value === 'none' || value === 'transparent') {\r\n                  result = 'none';\r\n                } else {\r\n                  result = parseColor(value);\r\n                }\r\n                break;\r\n              case 'fill': case 'stroke':\r\n                if (value === 'none' || value === 'transparent') {\r\n                  result = 'none';\r\n                } else if (value === 'currentColor') {\r\n                  result = this.get('color');\r\n                } else if (parsed = parseColor(value)) {\r\n                  return parsed;\r\n                } else if (parsed = (value || '').split(' ')) {\r\n                  let object = this.resolveUrl(parsed[0]),\r\n                      fallbackColor = parseColor(parsed[1]);\r\n                  if (object == null) {\r\n                    result = fallbackColor;\r\n                  } else if (object.nodeName === 'linearGradient' || object.nodeName === 'radialGradient') {\r\n                    result = new SvgElemGradient(object, null, fallbackColor);\r\n                  } else if (object.nodeName === 'pattern') {\r\n                    result = new SvgElemPattern(object, null, fallbackColor);\r\n                  } else {\r\n                    result = fallbackColor;\r\n                  }\r\n                }\r\n                break;\r\n              case 'stop-color':\r\n                if (value === 'none' || value === 'transparent') {\r\n                  result = 'none';\r\n                } else if (value === 'currentColor') {\r\n                  result = this.get('color');\r\n                } else {\r\n                  result = parseColor(value);\r\n                }\r\n                break;\r\n              case 'marker-start': case 'marker-mid': case 'marker-end': case 'clip-path': case 'mask':\r\n                if (value === 'none') {\r\n                  result = 'none';\r\n                } else {\r\n                  result = this.resolveUrl(value);\r\n                }\r\n                break;\r\n              case 'stroke-width':\r\n                parsed = this.computeLength(value, this.getViewport());\r\n                if (parsed != null && parsed >= 0) {\r\n                  result = parsed;\r\n                }\r\n                break;\r\n              case 'stroke-miterlimit':\r\n                parsed = parseFloat(value);\r\n                if (parsed != null && parsed >= 1) {\r\n                  result = parsed;\r\n                }\r\n                break;\r\n              case 'word-spacing': case 'letter-spacing':\r\n                result = this.computeLength(value, this.getViewport());\r\n                break;\r\n              case 'stroke-dashoffset':\r\n                result = this.computeLength(value, this.getViewport());\r\n                if (result != null) {\r\n                  if (result < 0) { // fix for crbug.com/660850\r\n                    let dasharray = this.get('stroke-dasharray');\r\n                    for (let j = 0; j < dasharray.length; j++) {result += dasharray[j];}\r\n                  }\r\n                }\r\n                break;\r\n            }\r\n            if (result != null) {return styleCache[key] = result;}\r\n          }\r\n        }\r\n        return styleCache[key] = (keyInfo.inherit && this.inherits ? this.inherits.get(key) : keyInfo.initial);\r\n      };\r\n      this.getChildren = function() {\r\n        if (childrenCache != null) {return childrenCache;}\r\n        let children = [];\r\n        for (let i = 0; i < obj.childNodes.length; i++) {\r\n          let child = obj.childNodes[i];\r\n          if (!child.error && this.allowedChildren.indexOf(child.nodeName) !== -1) {\r\n            children.push(createSVGElement(child, this));\r\n          }\r\n        }\r\n        return childrenCache = children;\r\n      };\r\n      this.getParentVWidth = function() {\r\n        return (this.inherits ? this.inherits.getVWidth(): viewportWidth);\r\n      };\r\n      this.getParentVHeight = function() {\r\n        return (this.inherits ? this.inherits.getVHeight() : viewportHeight);\r\n      };\r\n      this.getParentViewport = function() {\r\n        return Math.sqrt(0.5 * this.getParentVWidth() * this.getParentVWidth() + 0.5 * this.getParentVHeight() * this.getParentVHeight());\r\n      };\r\n      this.getVWidth = function() {\r\n        return this.getParentVWidth();\r\n      };\r\n      this.getVHeight = function() {\r\n        return this.getParentVHeight();\r\n      };\r\n      this.getViewport = function() {\r\n        return Math.sqrt(0.5 * this.getVWidth() * this.getVWidth() + 0.5 * this.getVHeight() * this.getVHeight());\r\n      };\r\n      this.getBoundingBox = function() {\r\n        let shape = this.getBoundingShape();\r\n        return shape.getBoundingBox();\r\n      };\r\n    };\r\n\r\n    var SvgElemStylable = function(obj, inherits) {\r\n      SvgElem.call(this, obj, inherits);\r\n      this.transform = function() {\r\n        doc.transform.apply(doc, this.getTransformation());\r\n      };\r\n      this.clip = function() {\r\n        if (this.get('clip-path') !== 'none') {\r\n          let clipPath = new SvgElemClipPath(this.get('clip-path'), null);\r\n          clipPath.useMask(this.getBoundingBox());\r\n          return true;\r\n        }\r\n      };\r\n      this.mask = function() {\r\n        if (this.get('mask') !== 'none') {\r\n          let mask = new SvgElemMask(this.get('mask'), null);\r\n          mask.useMask(this.getBoundingBox());\r\n          return true;\r\n        }\r\n      };\r\n      this.getFill = function(isClip, isMask) {\r\n        let opacity = this.get('opacity'),\r\n            fill = this.get('fill'),\r\n            fillOpacity = this.get('fill-opacity');\r\n        if (isClip) {return DefaultColors.white;}\r\n        if (fill !== 'none' && opacity && fillOpacity) {\r\n          if (fill instanceof SvgElemGradient || fill instanceof SvgElemPattern) {\r\n            return fill.getPaint(this.getBoundingBox(), fillOpacity * opacity, isClip, isMask);\r\n          }\r\n          return opacityToColor(fill, fillOpacity * opacity, isMask);\r\n        }\r\n      };\r\n      this.getStroke = function(isClip, isMask) {\r\n        let opacity = this.get('opacity'),\r\n            stroke = this.get('stroke'),\r\n            strokeOpacity = this.get('stroke-opacity');\r\n        if (isClip || isEqual(this.get('stroke-width'), 0)) {return;}\r\n        if (stroke !== 'none' && opacity && strokeOpacity) {\r\n          if (stroke instanceof SvgElemGradient || stroke instanceof SvgElemPattern) {\r\n            return stroke.getPaint(this.getBoundingBox(), strokeOpacity * opacity, isClip, isMask);\r\n          }\r\n          return opacityToColor(stroke, strokeOpacity * opacity, isMask);\r\n        }\r\n      };\r\n    };\r\n\r\n    var SvgElemHasChildren = function(obj, inherits) {\r\n      SvgElemStylable.call(this, obj, inherits);\r\n      this.allowedChildren = ['use', 'g', 'a', 'svg', 'image', 'rect', 'circle', 'ellipse', 'line', 'polyline', 'polygon', 'path', 'text'];\r\n      this.getBoundingShape = function() {\r\n        let shape = new SvgShape(),\r\n            children = this.getChildren();\r\n        for (let i = 0; i < children.length; i++) {\r\n          if (children[i].get('display') !== 'none') {\r\n            if (typeof children[i].getBoundingShape === 'function') {\r\n              let childShape = children[i].getBoundingShape().clone();\r\n              if (typeof children[i].getTransformation === 'function') {\r\n                childShape.transform(children[i].getTransformation());\r\n              }\r\n              shape.mergeShape(childShape);\r\n            }\r\n          }\r\n        }\r\n        return shape;\r\n      };\r\n      this.drawChildren = function(isClip, isMask) {\r\n        let children = this.getChildren();\r\n        for (let i = 0; i < children.length; i++) {\r\n          if (children[i].get('display') !== 'none') {\r\n            if (typeof children[i].drawInDocument === 'function') {\r\n              children[i].drawInDocument(isClip, isMask);\r\n            }\r\n          }\r\n        }\r\n      };\r\n    };\r\n\r\n    var SvgElemContainer = function(obj, inherits) {\r\n      SvgElemHasChildren.call(this, obj, inherits);\r\n      this.drawContent = function(isClip, isMask) {\r\n        this.transform();\r\n        let clipped = this.clip(),\r\n            masked = this.mask(),\r\n            group;\r\n        if ((this.get('opacity') < 1 || clipped || masked) && !isClip) {\r\n          group = docBeginGroup(getPageBBox());\r\n        }\r\n        this.drawChildren(isClip, isMask);\r\n        if (group) {\r\n          docEndGroup(group);\r\n          doc.fillOpacity(this.get('opacity'));\r\n          docInsertGroup(group);\r\n        }\r\n      };\r\n    };\r\n\r\n    var SvgElemUse = function(obj, inherits) {\r\n      SvgElemContainer.call(this, obj, inherits);\r\n      let x = this.getLength('x', this.getVWidth(), 0),\r\n          y = this.getLength('y', this.getVHeight(), 0),\r\n          child = this.getUrl('href') || this.getUrl('xlink:href');\r\n      if (child) {child = createSVGElement(child, this);}\r\n      this.getChildren  = function() {\r\n        return child ? [child] : [];\r\n      };\r\n      this.drawInDocument = function(isClip, isMask) {\r\n        doc.save();\r\n        this.drawContent(isClip, isMask);\r\n        doc.restore();\r\n      };\r\n      this.getTransformation = function() {\r\n        return multiplyMatrix(this.get('transform'), [1, 0, 0, 1, x, y]);\r\n      };\r\n    };\r\n\r\n    var SvgElemSymbol = function(obj, inherits) {\r\n      SvgElemContainer.call(this, obj, inherits);\r\n      let width = this.getLength('width', this.getParentVWidth(), this.getParentVWidth()),\r\n          height = this.getLength('height', this.getParentVHeight(), this.getParentVHeight());\r\n      if (inherits instanceof SvgElemUse) {\r\n        width = inherits.getLength('width', inherits.getParentVWidth(), width);\r\n        height = inherits.getLength('height', inherits.getParentVHeight(), height);\r\n      }\r\n      let aspectRatio = (this.attr('preserveAspectRatio') || '').trim(),\r\n          viewBox = this.getViewbox('viewBox', [0, 0, width, height]);\r\n      this.getVWidth = function() {\r\n        return viewBox[2];\r\n      };\r\n      this.getVHeight = function() {\r\n        return viewBox[3];\r\n      };\r\n      this.drawInDocument = function(isClip, isMask) {\r\n        doc.save();\r\n        this.drawContent(isClip, isMask);\r\n        doc.restore();\r\n      };\r\n      this.getTransformation = function() {\r\n        return multiplyMatrix(parseAspectRatio(aspectRatio, width, height, viewBox[2], viewBox[3]), [1, 0, 0, 1, -viewBox[0], -viewBox[1]]);\r\n      };\r\n    };\r\n\r\n    var SvgElemGroup = function(obj, inherits) {\r\n      SvgElemContainer.call(this, obj, inherits);\r\n      this.drawInDocument = function(isClip, isMask) {\r\n        doc.save();\r\n        if (this.link && !isClip && !isMask) {this.addLink();}\r\n        this.drawContent(isClip, isMask);\r\n        doc.restore();\r\n      };\r\n      this.getTransformation = function() {\r\n        return this.get('transform');\r\n      };\r\n    };\r\n\r\n    var SvgElemLink = function(obj, inherits) {\r\n      if (inherits && inherits.isText) {\r\n        SvgElemTspan.call(this, obj, inherits);\r\n        this.allowedChildren = ['textPath', 'tspan', '#text', '#cdata-section', 'a'];\r\n      } else {\r\n        SvgElemGroup.call(this, obj, inherits);\r\n      }\r\n      this.link = this.attr('href') || this.attr('xlink:href');\r\n      this.addLink = function() {\r\n        if (this.link.match(/^(?:[a-z][a-z0-9+.-]*:|\\/\\/)?/i) && this.getChildren().length) {\r\n          let bbox = this.getBoundingShape().transform(getGlobalMatrix()).getBoundingBox();\r\n          docInsertLink(bbox[0], bbox[1], bbox[2], bbox[3], this.link);\r\n        }\r\n      }\r\n    };\r\n\r\n    var SvgElemSvg = function(obj, inherits) {\r\n      SvgElemContainer.call(this, obj, inherits);\r\n      let width = this.getLength('width', this.getParentVWidth(), this.getParentVWidth()),\r\n          height = this.getLength('height', this.getParentVHeight(), this.getParentVHeight()),\r\n          x = this.getLength('x', this.getParentVWidth(), 0),\r\n          y = this.getLength('y', this.getParentVHeight(), 0);\r\n      if (inherits instanceof SvgElemUse) {\r\n        width = inherits.getLength('width', inherits.getParentVWidth(), width);\r\n        height = inherits.getLength('height', inherits.getParentVHeight(), height);\r\n      }\r\n      let aspectRatio = this.attr('preserveAspectRatio'),\r\n          viewBox = this.getViewbox('viewBox', [0, 0, width, height]);\r\n      if (this.isOuterElement && preserveAspectRatio) {\r\n        x = y = 0;\r\n        width = viewportWidth;\r\n        height = viewportHeight;\r\n        aspectRatio = preserveAspectRatio;\r\n      }\r\n      this.getVWidth = function() {\r\n        return viewBox[2];\r\n      };\r\n      this.getVHeight = function() {\r\n        return viewBox[3];\r\n      };\r\n      this.drawInDocument = function(isClip, isMask) {\r\n        doc.save();\r\n        if (this.get('overflow') === 'hidden') {\r\n          new SvgShape().M(x, y).L(x + width, y).L(x + width, y + height).L(x, y + height).Z()\r\n                        .transform(this.get('transform'))\r\n                        .insertInDocument();\r\n          doc.clip();\r\n        }\r\n        this.drawContent(isClip, isMask);\r\n        doc.restore();\r\n      };\r\n      this.getTransformation = function() {\r\n        return multiplyMatrix(\r\n          this.get('transform'),\r\n          [1, 0, 0, 1, x, y],\r\n          parseAspectRatio(aspectRatio, width, height, viewBox[2], viewBox[3]),\r\n          [1, 0, 0, 1, -viewBox[0], -viewBox[1]]\r\n        );\r\n      };\r\n    };\r\n\r\n    var SVGElemImage = function(obj, inherits) {\r\n      SvgElemStylable.call(this, obj, inherits);\r\n      let link = imageCallback(this.attr('href') || this.attr('xlink:href') || ''),\r\n          x = this.getLength('x', this.getVWidth(), 0),\r\n          y = this.getLength('y', this.getVHeight(), 0),\r\n          width = this.getLength('width', this.getVWidth(), 'auto'),\r\n          height = this.getLength('height', this.getVHeight(), 'auto'),\r\n          image;\r\n      try {\r\n        image = doc.openImage(link);\r\n      } catch(e) {\r\n        warningCallback('SVGElemImage: failed to open image \"' + link + '\" in PDFKit');\r\n      }\r\n      if (image) {\r\n        if (width === 'auto' && height !== 'auto') {\r\n          width = height * image.width / image.height;\r\n        } else if (height === 'auto' && width !== 'auto') {\r\n          height = width * image.height / image.width;\r\n        } else if (width === 'auto' && height === 'auto') {\r\n          width = image.width;\r\n          height = image.height;\r\n        }\r\n      }\r\n      if (width === 'auto' || width < 0) {width = 0;}\r\n      if (height === 'auto' || height < 0) {height = 0;}\r\n      this.getTransformation = function() {\r\n        return this.get('transform');\r\n      };\r\n      this.getBoundingShape = function() {\r\n        return new SvgShape().M(x, y).L(x + width, y).M(x + width, y + height).L(x, y + height);\r\n      };\r\n      this.drawInDocument = function(isClip, isMask) {\r\n        if (this.get('visibility') === 'hidden' || !image) {return;}\r\n        doc.save();\r\n        this.transform();\r\n        if (this.get('overflow') === 'hidden') {\r\n          doc.rect(x, y, width, height).clip();\r\n        }\r\n        this.clip();\r\n        this.mask();\r\n        doc.translate(x, y);\r\n        doc.transform.apply(doc, parseAspectRatio(this.attr('preserveAspectRatio'), width, height, image ? image.width : width, image ? image.height : height));\r\n        if (!isClip) {\r\n          doc.fillOpacity(this.get('opacity'));\r\n          doc.image(image, 0, 0);\r\n        } else {\r\n          doc.rect(0, 0, image.width, image.height);\r\n          docFillColor(DefaultColors.white).fill();\r\n        }\r\n        doc.restore();\r\n      };\r\n    };\r\n\r\n    var SvgElemPattern = function(obj, inherits, fallback) {\r\n      SvgElemHasChildren.call(this, obj, inherits);\r\n      this.ref = (function() {\r\n        let ref = this.getUrl('href') || this.getUrl('xlink:href');\r\n        if (ref && ref.nodeName === obj.nodeName) {\r\n          return new SvgElemPattern(ref, inherits, fallback);\r\n        }\r\n      }).call(this);\r\n      let _attr = this.attr;\r\n      this.attr = function(key) {\r\n        let attr = _attr.call(this, key);\r\n        if (attr != null || key === 'href' || key === 'xlink:href') {return attr;}\r\n        return this.ref ? this.ref.attr(key) : null;\r\n      };\r\n      let _getChildren = this.getChildren;\r\n      this.getChildren = function() {\r\n        let children = _getChildren.call(this);\r\n        if (children.length > 0) {return children;}\r\n        return this.ref ? this.ref.getChildren() : [];\r\n      };\r\n      this.getPaint = function(bBox, gOpacity, isClip, isMask) {\r\n        let bBoxUnitsPattern = (this.attr('patternUnits') !== 'userSpaceOnUse'),\r\n            bBoxUnitsContent = (this.attr('patternContentUnits') === 'objectBoundingBox'),\r\n            x = this.getLength('x', (bBoxUnitsPattern ? 1 : this.getParentVWidth()), 0),\r\n            y = this.getLength('y', (bBoxUnitsPattern ? 1 : this.getParentVHeight()), 0),\r\n            width = this.getLength('width', (bBoxUnitsPattern ? 1 : this.getParentVWidth()), 0),\r\n            height = this.getLength('height', (bBoxUnitsPattern ? 1 : this.getParentVHeight()), 0);\r\n        if (bBoxUnitsContent && !bBoxUnitsPattern) { // Use the same units for pattern & pattern content\r\n          x = (x - bBox[0]) / (bBox[2] - bBox[0]) || 0;\r\n          y = (y - bBox[1]) / (bBox[3] - bBox[1]) || 0;\r\n          width = width / (bBox[2] - bBox[0]) || 0;\r\n          height = height / (bBox[3] - bBox[1]) || 0;\r\n        } else if (!bBoxUnitsContent && bBoxUnitsPattern) {\r\n          x = bBox[0] + x * (bBox[2] - bBox[0]);\r\n          y = bBox[1] + y * (bBox[3] - bBox[1]);\r\n          width = width * (bBox[2] - bBox[0]);\r\n          height = height * (bBox[3] - bBox[1]);\r\n        }\r\n        let viewBox = this.getViewbox('viewBox', [0, 0, width, height]),\r\n            aspectRatio = (this.attr('preserveAspectRatio') || '').trim(),\r\n            aspectRatioMatrix = multiplyMatrix(\r\n              parseAspectRatio(aspectRatio, width, height, viewBox[2], viewBox[3], 0),\r\n              [1, 0, 0, 1, -viewBox[0], -viewBox[1]]\r\n            ),\r\n            matrix = parseTranform(this.attr('patternTransform'));\r\n        if (bBoxUnitsContent) {\r\n          matrix = multiplyMatrix([bBox[2] - bBox[0], 0, 0, bBox[3] - bBox[1], bBox[0], bBox[1]], matrix);\r\n        }\r\n        matrix = multiplyMatrix(matrix, [1, 0, 0, 1, x, y]);\r\n        if ((matrix = validateMatrix(matrix)) && (aspectRatioMatrix = validateMatrix(aspectRatioMatrix)) && (width = validateNumber(width)) && (height = validateNumber(height))) {\r\n          let group = docBeginGroup([0, 0, width, height]);\r\n          doc.transform.apply(doc, aspectRatioMatrix);\r\n          this.drawChildren(isClip, isMask);\r\n          docEndGroup(group);\r\n          return [docCreatePattern(group, width, height, matrix), gOpacity];\r\n        } else {\r\n          return fallback ? [fallback[0], fallback[1] * gOpacity] : undefined;\r\n        }\r\n      };\r\n      this.getVWidth = function() {\r\n        let bBoxUnitsPattern = (this.attr('patternUnits') !== 'userSpaceOnUse'),\r\n            width = this.getLength('width', (bBoxUnitsPattern ? 1 : this.getParentVWidth()), 0);\r\n        return this.getViewbox('viewBox', [0, 0, width, 0])[2];\r\n      };\r\n      this.getVHeight = function() {\r\n        let bBoxUnitsPattern = (this.attr('patternUnits') !== 'userSpaceOnUse'),\r\n            height = this.getLength('height', (bBoxUnitsPattern ? 1 : this.getParentVHeight()), 0);\r\n        return this.getViewbox('viewBox', [0, 0, 0, height])[3];\r\n      };\r\n    };\r\n\r\n    var SvgElemGradient = function(obj, inherits, fallback) {\r\n      SvgElem.call(this, obj, inherits);\r\n      this.allowedChildren = ['stop'];\r\n      this.ref = (function() {\r\n        let ref = this.getUrl('href') || this.getUrl('xlink:href');\r\n        if (ref && ref.nodeName === obj.nodeName) {\r\n          return new SvgElemGradient(ref, inherits, fallback);\r\n        }\r\n      }).call(this);\r\n      let _attr = this.attr;\r\n      this.attr = function(key) {\r\n        let attr = _attr.call(this, key);\r\n        if (attr != null || key === 'href' || key === 'xlink:href') {return attr;}\r\n        return this.ref ? this.ref.attr(key) : null;\r\n      };\r\n      let _getChildren = this.getChildren;\r\n      this.getChildren = function() {\r\n        let children = _getChildren.call(this);\r\n        if (children.length > 0) {return children;}\r\n        return this.ref ? this.ref.getChildren() : [];\r\n      };\r\n      this.getPaint = function(bBox, gOpacity, isClip, isMask) {\r\n        let children = this.getChildren();\r\n        if (children.length === 0) {return;}\r\n        if (children.length === 1) {\r\n          let child = children[0],\r\n              stopColor = child.get('stop-color');\r\n          if (stopColor === 'none') {return;}\r\n          return opacityToColor(stopColor, child.get('stop-opacity') * gOpacity, isMask);\r\n        }\r\n        let bBoxUnits = (this.attr('gradientUnits') !== 'userSpaceOnUse'),\r\n            matrix = parseTranform(this.attr('gradientTransform')),\r\n            spread = this.attr('spreadMethod'),\r\n            grad,\r\n            x1, x2, y1, y2, r2,\r\n            nAfter = 0,\r\n            nBefore = 0,\r\n            nTotal = 1;\r\n        if (bBoxUnits) {\r\n          matrix = multiplyMatrix([bBox[2] - bBox[0], 0, 0, bBox[3] - bBox[1], bBox[0], bBox[1]], matrix);\r\n        }\r\n        if (matrix = validateMatrix(matrix)) {\r\n          if (this.name === 'linearGradient') {\r\n            x1 = this.getLength('x1', (bBoxUnits ? 1 : this.getVWidth()), 0);\r\n            x2 = this.getLength('x2', (bBoxUnits ? 1 : this.getVWidth()), (bBoxUnits ? 1 : this.getVWidth()));\r\n            y1 = this.getLength('y1', (bBoxUnits ? 1 : this.getVHeight()), 0);\r\n            y2 = this.getLength('y2', (bBoxUnits ? 1 : this.getVHeight()), 0);\r\n          } else {\r\n            x2 = this.getLength('cx', (bBoxUnits ? 1 : this.getVWidth()), (bBoxUnits ? 0.5 : 0.5 * this.getVWidth()));\r\n            y2 = this.getLength('cy', (bBoxUnits ? 1 : this.getVHeight()), (bBoxUnits ? 0.5 : 0.5 * this.getVHeight()));\r\n            r2 = this.getLength('r', (bBoxUnits ? 1 : this.getViewport()), (bBoxUnits ? 0.5 : 0.5 * this.getViewport()));\r\n            x1 = this.getLength('fx', (bBoxUnits ? 1 : this.getVWidth()), x2);\r\n            y1 = this.getLength('fy', (bBoxUnits ? 1 : this.getVHeight()), y2);\r\n            if (r2 < 0) {\r\n              warningCallback('SvgElemGradient: negative r value');\r\n            }\r\n            let d = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)),\r\n                multiplier = 1;\r\n            if (d > r2) { // according to specification\r\n              multiplier = r2 / d;\r\n              x1 = x2 + (x1 - x2) * multiplier;\r\n              y1 = y2 + (y1 - y2) * multiplier;\r\n            }\r\n            r2 = Math.max(r2, d * multiplier * (1 + 1e-6)); // fix for edge-case gradients see issue #84\r\n          }\r\n          if (spread === 'reflect' || spread === 'repeat') {\r\n            let inv = inverseMatrix(matrix),\r\n                corner1 = transformPoint([bBox[0], bBox[1]], inv),\r\n                corner2 = transformPoint([bBox[2], bBox[1]], inv),\r\n                corner3 = transformPoint([bBox[2], bBox[3]], inv),\r\n                corner4 = transformPoint([bBox[0], bBox[3]], inv);\r\n            if (this.name === 'linearGradient') { // See file 'gradient-repeat-maths.png'\r\n              nAfter  = Math.max((corner1[0] - x2) * (x2 - x1) + (corner1[1] - y2) * (y2 - y1),\r\n                                 (corner2[0] - x2) * (x2 - x1) + (corner2[1] - y2) * (y2 - y1),\r\n                                 (corner3[0] - x2) * (x2 - x1) + (corner3[1] - y2) * (y2 - y1),\r\n                                 (corner4[0] - x2) * (x2 - x1) + (corner4[1] - y2) * (y2 - y1))\r\n                                / (Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\r\n              nBefore = Math.max((corner1[0] - x1) * (x1 - x2) + (corner1[1] - y1) * (y1 - y2),\r\n                                 (corner2[0] - x1) * (x1 - x2) + (corner2[1] - y1) * (y1 - y2),\r\n                                 (corner3[0] - x1) * (x1 - x2) + (corner3[1] - y1) * (y1 - y2),\r\n                                 (corner4[0] - x1) * (x1 - x2) + (corner4[1] - y1) * (y1 - y2))\r\n                                / (Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\r\n            } else {\r\n              nAfter  = Math.sqrt(Math.max(Math.pow(corner1[0] - x2, 2) + Math.pow(corner1[1] - y2, 2),\r\n                                           Math.pow(corner2[0] - x2, 2) + Math.pow(corner2[1] - y2, 2),\r\n                                           Math.pow(corner3[0] - x2, 2) + Math.pow(corner3[1] - y2, 2),\r\n                                           Math.pow(corner4[0] - x2, 2) + Math.pow(corner4[1] - y2, 2))) / r2 - 1;\r\n            }\r\n            nAfter = Math.ceil(nAfter + 0.5); // Add a little more because the stroke can extend outside of the bounding box\r\n            nBefore = Math.ceil(nBefore + 0.5);\r\n            nTotal = nBefore + 1 + nAfter; // How many times the gradient needs to be repeated to fill the object bounding box\r\n          }\r\n          if (this.name === 'linearGradient') {\r\n            grad = doc.linearGradient(x1 - nBefore * (x2 - x1), y1 - nBefore * (y2 - y1), x2 + nAfter * (x2 - x1), y2 + nAfter * (y2 - y1));\r\n          } else {\r\n            grad = doc.radialGradient(x1, y1, 0, x2, y2, r2 + nAfter * r2);\r\n          }\r\n          for (let n = 0; n < nTotal; n++) {\r\n            let offset = 0,\r\n                inOrder = (spread !== 'reflect' || (n - nBefore) % 2 === 0);\r\n            for (let i = 0; i < children.length; i++) {\r\n              let child = children[inOrder ? i : children.length - 1 - i],\r\n                  stopColor = child.get('stop-color');\r\n              if (stopColor === 'none') {stopColor = DefaultColors.transparent;}\r\n              stopColor = opacityToColor(stopColor, child.get('stop-opacity') * gOpacity, isMask);\r\n              offset = Math.max(offset, inOrder ? child.getPercent('offset', 0) : 1 - child.getPercent('offset', 0));\r\n              if (i === 0 && stopColor[0].length === 4) {grad._colorSpace = 'DeviceCMYK';} // Fix until PR #763 is merged into PDFKit\r\n              if (i === 0 && offset > 0) {\r\n                grad.stop((n + 0) / nTotal, stopColor[0], stopColor[1]);\r\n              }\r\n              grad.stop((n + offset) / (nAfter + nBefore + 1), stopColor[0], stopColor[1]);\r\n              if (i === children.length - 1 && offset < 1) {\r\n                grad.stop((n + 1) / nTotal, stopColor[0], stopColor[1]);\r\n              }\r\n            }\r\n          }\r\n          grad.setTransform.apply(grad, matrix);\r\n          return [grad, 1];\r\n        } else {\r\n          return fallback ? [fallback[0], fallback[1] * gOpacity] : undefined;\r\n        }\r\n      }\r\n    };\r\n\r\n    var SvgElemBasicShape = function(obj, inherits) {\r\n      SvgElemStylable.call(this, obj, inherits);\r\n      this.dashScale = 1;\r\n      this.getBoundingShape = function() {\r\n        return this.shape;\r\n      };\r\n      this.getTransformation = function() {\r\n        return this.get('transform');\r\n      };\r\n      this.drawInDocument = function(isClip, isMask) {\r\n        if (this.get('visibility') === 'hidden' || !this.shape) {return;}\r\n        doc.save();\r\n        this.transform();\r\n        this.clip();\r\n        if (!isClip) {\r\n          let masked = this.mask(),\r\n              group;\r\n          if (masked) {\r\n            group = docBeginGroup(getPageBBox());\r\n          }\r\n          let subPaths = this.shape.getSubPaths(),\r\n              fill = this.getFill(isClip, isMask),\r\n              stroke = this.getStroke(isClip, isMask),\r\n              lineWidth = this.get('stroke-width'),\r\n              lineCap = this.get('stroke-linecap');\r\n          if (fill || stroke) {\r\n            if (fill) {\r\n              docFillColor(fill);\r\n            }\r\n            if (stroke) {\r\n              for (let j = 0; j < subPaths.length; j++) {\r\n                if (isEqual(subPaths[j].totalLength, 0)) {\r\n                  if ((lineCap === 'square' || lineCap === 'round') && lineWidth > 0) {\r\n                    if (subPaths[j].startPoint && subPaths[j].startPoint.length > 1) {\r\n                      let x = subPaths[j].startPoint[0],\r\n                          y = subPaths[j].startPoint[1];\r\n                      docFillColor(stroke);\r\n                      if (lineCap === 'square') {\r\n                        doc.rect(x - 0.5 * lineWidth, y - 0.5 * lineWidth, lineWidth, lineWidth);\r\n                      } else if (lineCap === 'round') {\r\n                        doc.circle(x, y, 0.5 * lineWidth);\r\n                      }\r\n                      doc.fill();\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n              let dashArray = this.get('stroke-dasharray'),\r\n                  dashOffset = this.get('stroke-dashoffset');\r\n              if (isNotEqual(this.dashScale, 1)) {\r\n                for (let j = 0; j < dashArray.length; j++) {\r\n                  dashArray[j] *= this.dashScale;\r\n                }\r\n                dashOffset *= this.dashScale;\r\n              }\r\n              docStrokeColor(stroke);\r\n              doc.lineWidth(lineWidth)\r\n                 .miterLimit(this.get('stroke-miterlimit'))\r\n                 .lineJoin(this.get('stroke-linejoin'))\r\n                 .lineCap(lineCap)\r\n                 .dash(dashArray, {phase: dashOffset});\r\n            }\r\n            for (let j = 0; j < subPaths.length; j++) {\r\n              if (subPaths[j].totalLength > 0) {\r\n                subPaths[j].insertInDocument();\r\n              }\r\n            }\r\n            if (fill && stroke) {\r\n              doc.fillAndStroke(this.get('fill-rule'));\r\n            } else if (fill) {\r\n              doc.fill(this.get('fill-rule'));\r\n            } else if (stroke) {\r\n              doc.stroke();\r\n            }\r\n          }\r\n          let markerStart = this.get('marker-start'),\r\n              markerMid = this.get('marker-mid'),\r\n              markerEnd = this.get('marker-end');\r\n          if (markerStart !== 'none' || markerMid !== 'none' || markerEnd !== 'none') {\r\n            let markersPos = this.shape.getMarkers();\r\n            if (markerStart !== 'none') {\r\n              let marker = new SvgElemMarker(markerStart, null);\r\n              marker.drawMarker(false, isMask, markersPos[0], lineWidth);\r\n            }\r\n            if (markerMid !== 'none') {\r\n              for (let i = 1; i < markersPos.length - 1; i++) {\r\n                let marker = new SvgElemMarker(markerMid, null);\r\n                marker.drawMarker(false, isMask, markersPos[i], lineWidth);\r\n              }\r\n            }\r\n            if (markerEnd !== 'none') {\r\n              let marker = new SvgElemMarker(markerEnd, null);\r\n              marker.drawMarker(false, isMask, markersPos[markersPos.length - 1], lineWidth);\r\n            }\r\n          }\r\n          if (group) {\r\n            docEndGroup(group);\r\n            docInsertGroup(group);\r\n          }\r\n        } else {\r\n          this.shape.insertInDocument();\r\n          docFillColor(DefaultColors.white);\r\n          doc.fill(this.get('clip-rule'));\r\n        }\r\n        doc.restore();\r\n      };\r\n    };\r\n\r\n    var SvgElemRect = function(obj, inherits) {\r\n      SvgElemBasicShape.call(this, obj, inherits);\r\n      let x = this.getLength('x', this.getVWidth(), 0),\r\n          y = this.getLength('y', this.getVHeight(), 0),\r\n          w = this.getLength('width', this.getVWidth(), 0),\r\n          h = this.getLength('height', this.getVHeight(), 0),\r\n          rx = this.getLength('rx', this.getVWidth()),\r\n          ry = this.getLength('ry', this.getVHeight());\r\n      if (rx === undefined && ry === undefined) {rx = ry = 0;}\r\n      else if (rx === undefined && ry !== undefined) {rx = ry;}\r\n      else if (rx !== undefined && ry === undefined) {ry = rx;}\r\n      if (w > 0 && h > 0) {\r\n        if (rx && ry) {\r\n          rx = Math.min(rx, 0.5 * w);\r\n          ry = Math.min(ry, 0.5 * h);\r\n          this.shape = new SvgShape().M(x + rx, y).L(x + w - rx, y).A(rx, ry, 0, 0, 1, x + w, y + ry)\r\n                            .L(x + w, y + h - ry).A(rx, ry, 0, 0, 1, x + w - rx, y + h).L(x + rx, y + h)\r\n                            .A(rx, ry, 0, 0, 1, x, y + h - ry).L(x, y + ry).A(rx, ry, 0, 0, 1, x + rx, y).Z();\r\n        } else {\r\n          this.shape = new SvgShape().M(x, y).L(x + w, y).L(x + w, y + h).L(x, y + h).Z();\r\n        }\r\n      } else {\r\n        this.shape = new SvgShape();\r\n      }\r\n    };\r\n\r\n    var SvgElemCircle = function(obj, inherits) {\r\n      SvgElemBasicShape.call(this, obj, inherits);\r\n      let cx = this.getLength('cx', this.getVWidth(), 0),\r\n          cy = this.getLength('cy', this.getVHeight(), 0),\r\n          r = this.getLength('r', this.getViewport(), 0);\r\n      if (r > 0) {\r\n        this.shape = new SvgShape().M(cx + r, cy).A(r, r, 0, 0, 1, cx - r, cy).A(r, r, 0, 0, 1, cx + r, cy).Z();\r\n      } else {\r\n        this.shape = new SvgShape();\r\n      }\r\n    };\r\n\r\n    var SvgElemEllipse = function(obj, inherits) {\r\n      SvgElemBasicShape.call(this, obj, inherits);\r\n      let cx = this.getLength('cx', this.getVWidth(), 0),\r\n          cy = this.getLength('cy', this.getVHeight(), 0),\r\n          rx = this.getLength('rx', this.getVWidth(), 0),\r\n          ry = this.getLength('ry', this.getVHeight(), 0);\r\n      if (rx > 0 && ry > 0) {\r\n        this.shape = new SvgShape().M(cx + rx, cy).A(rx, ry, 0, 0, 1, cx - rx, cy).A(rx, ry, 0, 0, 1, cx + rx, cy).Z();\r\n      } else {\r\n        this.shape = new SvgShape();\r\n      }\r\n    };\r\n\r\n    var SvgElemLine = function(obj, inherits) {\r\n      SvgElemBasicShape.call(this, obj, inherits);\r\n      let x1 = this.getLength('x1', this.getVWidth(), 0),\r\n          y1 = this.getLength('y1', this.getVHeight(), 0),\r\n          x2 = this.getLength('x2', this.getVWidth(), 0),\r\n          y2 = this.getLength('y2', this.getVHeight(), 0);\r\n      this.shape = new SvgShape().M(x1, y1).L(x2, y2);\r\n    };\r\n\r\n    var SvgElemPolyline = function(obj, inherits) {\r\n      SvgElemBasicShape.call(this, obj, inherits);\r\n      let points = this.getNumberList('points');\r\n      this.shape = new SvgShape();\r\n      for (let i = 0; i < points.length - 1; i += 2) {\r\n        if (i === 0) {\r\n          this.shape.M(points[i], points[i+1]);\r\n        } else {\r\n          this.shape.L(points[i], points[i+1]);\r\n        }\r\n      }\r\n      if (points.error) {warningCallback('SvgElemPolygon: unexpected string ' + points.error);}\r\n      if (points.length % 2 === 1) {warningCallback('SvgElemPolyline: uneven number of coordinates');}\r\n    };\r\n\r\n    var SvgElemPolygon = function(obj, inherits) {\r\n      SvgElemBasicShape.call(this, obj, inherits);\r\n      let points = this.getNumberList('points');\r\n      this.shape = new SvgShape();\r\n      for (let i = 0; i < points.length - 1; i += 2) {\r\n        if (i === 0) {\r\n          this.shape.M(points[i], points[i+1]);\r\n        } else {\r\n          this.shape.L(points[i], points[i+1]);\r\n        }\r\n      }\r\n      this.shape.Z();\r\n      if (points.error) {warningCallback('SvgElemPolygon: unexpected string ' + points.error);}\r\n      if (points.length % 2 === 1) {warningCallback('SvgElemPolygon: uneven number of coordinates');}\r\n    };\r\n\r\n    var SvgElemPath = function(obj, inherits) {\r\n      SvgElemBasicShape.call(this, obj, inherits);\r\n      this.shape = new SvgShape().path(this.attr('d'));\r\n      let pathLength = this.getLength('pathLength', this.getViewport());\r\n      this.pathLength = pathLength > 0 ? pathLength : undefined;\r\n      this.dashScale = (this.pathLength !== undefined ? this.shape.totalLength / this.pathLength : 1);\r\n    };\r\n\r\n    var SvgElemMarker = function(obj, inherits) {\r\n      SvgElemHasChildren.call(this, obj, inherits);\r\n      let width = this.getLength('markerWidth', this.getParentVWidth(), 3),\r\n          height = this.getLength('markerHeight', this.getParentVHeight(), 3),\r\n          viewBox = this.getViewbox('viewBox', [0, 0, width, height]);\r\n      this.getVWidth = function() {\r\n        return viewBox[2];\r\n      };\r\n      this.getVHeight = function() {\r\n        return viewBox[3];\r\n      };\r\n      this.drawMarker = function(isClip, isMask, posArray, strokeWidth) {\r\n        doc.save();\r\n        let orient = this.attr('orient'),\r\n            units = this.attr('markerUnits'),\r\n            rotate = (orient === 'auto' ? posArray[2] : (parseFloat(orient) || 0) * Math.PI / 180),\r\n            scale = (units === 'userSpaceOnUse' ? 1 : strokeWidth);\r\n        doc.transform(Math.cos(rotate) * scale, Math.sin(rotate) * scale, -Math.sin(rotate) * scale, Math.cos(rotate) * scale, posArray[0], posArray[1]);\r\n        let refX = this.getLength('refX', this.getVWidth(), 0),\r\n            refY = this.getLength('refY', this.getVHeight(), 0),\r\n            aspectRatioMatrix = parseAspectRatio(this.attr('preserveAspectRatio'), width, height, viewBox[2], viewBox[3], 0.5);\r\n        if (this.get('overflow') === 'hidden') {\r\n          doc.rect(aspectRatioMatrix[0] * (viewBox[0] + viewBox[2] / 2 - refX) - width / 2, aspectRatioMatrix[3] * (viewBox[1] + viewBox[3] / 2 - refY) - height / 2, width, height).clip();\r\n        }\r\n        doc.transform.apply(doc, aspectRatioMatrix);\r\n        doc.translate(-refX, -refY);\r\n        let group;\r\n        if (this.get('opacity') < 1 && !isClip) {\r\n          group = docBeginGroup(getPageBBox());\r\n        }\r\n        this.drawChildren(isClip, isMask);\r\n        if (group) {\r\n          docEndGroup(group);\r\n          doc.fillOpacity(this.get('opacity'));\r\n          docInsertGroup(group);\r\n        }\r\n        doc.restore();\r\n      };\r\n    };\r\n\r\n    var SvgElemClipPath = function(obj, inherits) {\r\n      SvgElemHasChildren.call(this, obj, inherits);\r\n      this.useMask = function(bBox) {\r\n        let group = docBeginGroup(getPageBBox());\r\n        doc.save();\r\n        if (this.attr('clipPathUnits') === 'objectBoundingBox') {\r\n          doc.transform(bBox[2] - bBox[0], 0, 0, bBox[3] - bBox[1], bBox[0], bBox[1]);\r\n        }\r\n        this.clip();\r\n        this.drawChildren(true, false);\r\n        doc.restore();\r\n        docEndGroup(group);\r\n        docApplyMask(group, true);\r\n      };\r\n    };\r\n\r\n    var SvgElemMask = function(obj, inherits) {\r\n      SvgElemHasChildren.call(this, obj, inherits);\r\n      this.useMask = function(bBox) {\r\n        let group = docBeginGroup(getPageBBox());\r\n        doc.save();\r\n        let x, y, w, h;\r\n        if (this.attr('maskUnits') === 'userSpaceOnUse') {\r\n          x = this.getLength('x', this.getVWidth(), -0.1 * (bBox[2] - bBox[0]) + bBox[0]);\r\n          y = this.getLength('y', this.getVHeight(), -0.1 * (bBox[3] - bBox[1]) + bBox[1]);\r\n          w = this.getLength('width', this.getVWidth(), 1.2 * (bBox[2] - bBox[0]));\r\n          h = this.getLength('height', this.getVHeight(), 1.2 * (bBox[3] - bBox[1]));\r\n        } else {\r\n          x = this.getLength('x', this.getVWidth(), -0.1) * (bBox[2] - bBox[0]) + bBox[0];\r\n          y = this.getLength('y', this.getVHeight(), -0.1) * (bBox[3] - bBox[1]) + bBox[1];\r\n          w = this.getLength('width', this.getVWidth(), 1.2) * (bBox[2] - bBox[0]);\r\n          h = this.getLength('height', this.getVHeight(), 1.2) * (bBox[3] - bBox[1]);\r\n        }\r\n        doc.rect(x, y, w, h).clip();\r\n        if (this.attr('maskContentUnits') === 'objectBoundingBox') {\r\n          doc.transform(bBox[2] - bBox[0], 0, 0, bBox[3] - bBox[1], bBox[0], bBox[1]);\r\n        }\r\n        this.clip();\r\n        this.drawChildren(false, true);\r\n        doc.restore();\r\n        docEndGroup(group);\r\n        docApplyMask(group, true);\r\n      };\r\n    };\r\n\r\n    var SvgElemTextContainer = function(obj, inherits) {\r\n      SvgElemStylable.call(this, obj, inherits);\r\n      this.allowedChildren = ['tspan', '#text', '#cdata-section', 'a'];\r\n      this.isText = true;\r\n      this.getBoundingShape = function() {\r\n        let shape = new SvgShape();\r\n        for (let i = 0; i < this._pos.length; i++) {\r\n          let pos = this._pos[i];\r\n          if (!pos.hidden) {\r\n            let dx0 = pos.ascent * Math.sin(pos.rotate), dy0 = -pos.ascent * Math.cos(pos.rotate),\r\n                dx1 = pos.descent * Math.sin(pos.rotate), dy1 = -pos.descent * Math.cos(pos.rotate),\r\n                dx2 = pos.width * Math.cos(pos.rotate), dy2 = pos.width * Math.sin(pos.rotate);\r\n            shape.M(pos.x + dx0, pos.y + dy0).L(pos.x + dx0 + dx2, pos.y + dy0 + dy2)\r\n                 .M(pos.x + dx1 + dx2, pos.y + dy1 + dy2).L(pos.x + dx1, pos.y + dy1);\r\n          }\r\n        }\r\n        return shape;\r\n      };\r\n      this.drawTextInDocument = function(isClip, isMask) {\r\n        if (this.link && !isClip && !isMask) {this.addLink();}\r\n        if (this.get('text-decoration') === 'underline') {\r\n          this.decorate(0.05 * this._font.size, -0.075 * this._font.size, isClip, isMask);\r\n        }\r\n        if (this.get('text-decoration') === 'overline') {\r\n          this.decorate(0.05 * this._font.size, getAscent(this._font.font, this._font.size) + 0.075 * this._font.size, isClip, isMask);\r\n        }\r\n        let fill = this.getFill(isClip, isMask),\r\n            stroke = this.getStroke(isClip, isMask),\r\n            strokeWidth = this.get('stroke-width');\r\n        if (this._font.fauxBold) {\r\n          if (!stroke) {\r\n            stroke = fill;\r\n            strokeWidth = this._font.size * 0.03;\r\n          } else {\r\n            strokeWidth += this._font.size * 0.03;\r\n          }\r\n        }\r\n        let children = this.getChildren();\r\n        for (let i = 0; i < children.length; i++) {\r\n          let childElem = children[i];\r\n          switch(childElem.name) {\r\n            case 'tspan': case 'textPath': case 'a':\r\n              if (childElem.get('display') !== 'none') {\r\n                childElem.drawTextInDocument(isClip, isMask);\r\n              }\r\n              break;\r\n            case '#text': case '#cdata-section':\r\n              if (this.get('visibility') === 'hidden') {continue;}\r\n              if (fill || stroke || isClip) {\r\n                if (fill) {\r\n                  docFillColor(fill);\r\n                }\r\n                if (stroke && strokeWidth) {\r\n                  docStrokeColor(stroke);\r\n                  doc.lineWidth(strokeWidth)\r\n                     .miterLimit(this.get('stroke-miterlimit'))\r\n                     .lineJoin(this.get('stroke-linejoin'))\r\n                     .lineCap(this.get('stroke-linecap'))\r\n                     .dash(this.get('stroke-dasharray'), {phase:this.get('stroke-dashoffset')});\r\n                }\r\n                docBeginText(this._font.font, this._font.size);\r\n                docSetTextMode(!!fill, !!stroke);\r\n                for (let j = 0, pos = childElem._pos; j < pos.length; j++) {\r\n                  if (!pos[j].hidden && isNotEqual(pos[j].width, 0)) {\r\n                    let cos = Math.cos(pos[j].rotate), sin = Math.sin(pos[j].rotate), skew = (this._font.fauxItalic ? -0.25 : 0);\r\n                    docSetTextMatrix(cos * pos[j].scale, sin * pos[j].scale, cos * skew - sin, sin * skew + cos, pos[j].x, pos[j].y);\r\n                    docWriteGlyph(pos[j].glyph);\r\n                  }\r\n                }\r\n                docEndText();\r\n              }\r\n              break;\r\n          }\r\n        }\r\n        if (this.get('text-decoration') === 'line-through') {\r\n          this.decorate(0.05 * this._font.size, 0.5 * (getAscent(this._font.font, this._font.size) + getDescent(this._font.font, this._font.size)), isClip, isMask);\r\n        }\r\n      };\r\n      this.decorate = function(lineWidth, linePosition, isClip, isMask) {\r\n        let fill = this.getFill(isClip, isMask),\r\n            stroke = this.getStroke(isClip, isMask);\r\n        if (fill) {\r\n          docFillColor(fill);\r\n        }\r\n        if (stroke) {\r\n          docStrokeColor(stroke);\r\n          doc.lineWidth(this.get('stroke-width'))\r\n             .miterLimit(this.get('stroke-miterlimit'))\r\n             .lineJoin(this.get('stroke-linejoin'))\r\n             .lineCap(this.get('stroke-linecap'))\r\n             .dash(this.get('stroke-dasharray'), {phase:this.get('stroke-dashoffset')});\r\n        }\r\n        for (let j = 0, pos = this._pos; j < pos.length; j++) {\r\n          if (!pos[j].hidden && isNotEqual(pos[j].width, 0)) {\r\n            let dx0 = (linePosition + lineWidth / 2) * Math.sin(pos[j].rotate),\r\n                dy0 = -(linePosition + lineWidth / 2) * Math.cos(pos[j].rotate),\r\n                dx1 = (linePosition - lineWidth / 2) * Math.sin(pos[j].rotate),\r\n                dy1 = -(linePosition - lineWidth / 2) * Math.cos(pos[j].rotate),\r\n                dx2 = pos[j].width * Math.cos(pos[j].rotate),\r\n                dy2 = pos[j].width * Math.sin(pos[j].rotate);\r\n            new SvgShape().M(pos[j].x + dx0, pos[j].y + dy0)\r\n                          .L(pos[j].x + dx0 + dx2, pos[j].y + dy0 + dy2)\r\n                          .L(pos[j].x + dx1 + dx2, pos[j].y + dy1 + dy2)\r\n                          .L(pos[j].x + dx1, pos[j].y + dy1).Z()\r\n                          .insertInDocument();\r\n            if (fill && stroke) {\r\n              doc.fillAndStroke();\r\n            } else if (fill) {\r\n              doc.fill();\r\n            } else if (stroke) {\r\n              doc.stroke();\r\n            }\r\n          }\r\n        }\r\n      };\r\n    };\r\n\r\n    var SvgElemTextNode = function(obj, inherits) {\r\n      this.name = obj.nodeName;\r\n      this.textContent = obj.nodeValue;\r\n    };\r\n\r\n    var SvgElemTspan = function(obj, inherits) {\r\n      SvgElemTextContainer.call(this, obj, inherits);\r\n    };\r\n\r\n    var SvgElemTextPath = function(obj, inherits) {\r\n      SvgElemTextContainer.call(this, obj, inherits);\r\n      let pathObject, pathLength, temp;\r\n      if ((temp = this.attr('path')) && temp.trim() !== '') {\r\n        let pathLength = this.getLength('pathLength', this.getViewport());\r\n        this.pathObject = new SvgShape().path(temp);\r\n        this.pathLength = pathLength > 0 ? pathLength : this.pathObject.totalLength;\r\n        this.pathScale = this.pathObject.totalLength / this.pathLength;\r\n      } else if ((temp = this.getUrl('href') || this.getUrl('xlink:href')) && temp.nodeName === 'path') {\r\n        let pathElem = new SvgElemPath(temp, this);\r\n        this.pathObject = pathElem.shape.clone().transform(pathElem.get('transform'));\r\n        this.pathLength = this.chooseValue(pathElem.pathLength, this.pathObject.totalLength);\r\n        this.pathScale = this.pathObject.totalLength / this.pathLength;\r\n      }\r\n    };\r\n\r\n    var SvgElemText = function(obj, inherits) {\r\n      SvgElemTextContainer.call(this, obj, inherits);\r\n      this.allowedChildren = ['textPath', 'tspan', '#text', '#cdata-section', 'a'];\r\n      (function (textParentElem) {\r\n        let processedText = '', remainingText = obj.textContent, textPaths = [], currentChunk = [], currentAnchor, currentDirection, currentX = 0, currentY = 0;\r\n        function doAnchoring() {\r\n          if (currentChunk.length) {\r\n            let last = currentChunk[currentChunk.length - 1];\r\n            let first = currentChunk[0]\r\n            let width = last.x + last.width - first.x;\r\n            let anchordx = {'startltr': 0, 'middleltr': 0.5, 'endltr': 1, 'startrtl': 1, 'middlertl': 0.5, 'endrtl': 0}[currentAnchor + currentDirection] * width || 0;\r\n            for (let i = 0; i < currentChunk.length; i++) {\r\n              currentChunk[i].x -= anchordx;\r\n            }\r\n          }\r\n          currentChunk = [];\r\n        }\r\n        function adjustLength(pos, length, spacingAndGlyphs) {\r\n          let firstChar = pos[0], lastChar = pos[pos.length - 1],\r\n              startX = firstChar.x, endX = lastChar.x + lastChar.width;\r\n          if (spacingAndGlyphs) {\r\n            let textScale = length / (endX - startX);\r\n            if (textScale > 0 && textScale < Infinity) {\r\n              for (let j = 0; j < pos.length; j++) {\r\n                pos[j].x = startX + textScale * (pos[j].x - startX);\r\n                pos[j].scale *= textScale;\r\n                pos[j].width *= textScale;\r\n              }\r\n            }\r\n          } else {\r\n            if (pos.length >= 2) {\r\n              let spaceDiff = (length - (endX - startX)) / (pos.length - 1);\r\n              for (let j = 0; j < pos.length; j++) {\r\n                pos[j].x += j * spaceDiff;\r\n              }\r\n            }\r\n          }\r\n          currentX += length - (endX - startX);\r\n        }\r\n        function recursive(currentElem, parentElem) {\r\n          currentElem._x = combineArrays(currentElem.getLengthList('x', currentElem.getVWidth()), (parentElem ? parentElem._x.slice(parentElem._pos.length) : []));\r\n          currentElem._y = combineArrays(currentElem.getLengthList('y', currentElem.getVHeight()), (parentElem ? parentElem._y.slice(parentElem._pos.length) : []));\r\n          currentElem._dx = combineArrays(currentElem.getLengthList('dx', currentElem.getVWidth()), (parentElem ? parentElem._dx.slice(parentElem._pos.length) : []));\r\n          currentElem._dy = combineArrays(currentElem.getLengthList('dy', currentElem.getVHeight()), (parentElem ? parentElem._dy.slice(parentElem._pos.length) : []));\r\n          currentElem._rot = combineArrays(currentElem.getNumberList('rotate'), (parentElem ? parentElem._rot.slice(parentElem._pos.length) : []));\r\n          currentElem._defRot = currentElem.chooseValue(currentElem._rot[currentElem._rot.length - 1], parentElem && parentElem._defRot, 0);\r\n          if (currentElem.name === 'textPath') {currentElem._y = [];}\r\n          let fontOptions = {fauxItalic: false, fauxBold: false},\r\n              fontNameorLink = fontCallback(currentElem.get('font-family'), currentElem.get('font-weight') === 'bold', currentElem.get('font-style') === 'italic', fontOptions);\r\n          try {\r\n            doc.font(fontNameorLink);\r\n          } catch(e) {\r\n            warningCallback('SVGElemText: failed to open font \"' + fontNameorLink + '\" in PDFKit');\r\n          }\r\n          currentElem._pos = [];\r\n          currentElem._index = 0;\r\n          currentElem._font = {font: doc._font, size: currentElem.get('font-size'), fauxItalic: fontOptions.fauxItalic, fauxBold: fontOptions.fauxBold};\r\n          let textLength = currentElem.getLength('textLength', currentElem.getVWidth(), undefined),\r\n              spacingAndGlyphs = currentElem.attr('lengthAdjust') === 'spacingAndGlyphs',\r\n              wordSpacing = currentElem.get('word-spacing'),\r\n              letterSpacing = currentElem.get('letter-spacing'),\r\n              textAnchor = currentElem.get('text-anchor'),\r\n              textDirection = currentElem.get('direction'),\r\n              baseline = getBaseline(currentElem._font.font, currentElem._font.size, currentElem.get('alignment-baseline') || currentElem.get('dominant-baseline'), currentElem.get('baseline-shift'));\r\n          if (currentElem.name === 'textPath') {\r\n            doAnchoring();\r\n            currentX = currentY = 0;\r\n          }\r\n          let children = currentElem.getChildren();\r\n          for (let i = 0; i < children.length; i++) {\r\n            let childElem = children[i];\r\n            switch(childElem.name) {\r\n              case 'tspan': case 'textPath': case 'a':\r\n                recursive(childElem, currentElem);\r\n                break;\r\n              case '#text': case '#cdata-section':\r\n                let rawText = childElem.textContent, renderedText = rawText, words;\r\n                childElem._font = currentElem._font;\r\n                childElem._pos = [];\r\n                remainingText = remainingText.substring(rawText.length);\r\n                if (currentElem.get('xml:space') === 'preserve') {\r\n                  renderedText = renderedText.replace(/[\\s]/g, ' ');\r\n                } else {\r\n                  renderedText = renderedText.replace(/[\\s]+/g, ' ');\r\n                  if (processedText.match(/[\\s]$|^$/)) {renderedText = renderedText.replace(/^[\\s]/, '');}\r\n                  if (remainingText.match(/^[\\s]*$/)) {renderedText = renderedText.replace(/[\\s]$/, '');}\r\n                }\r\n                processedText += rawText;\r\n                if (wordSpacing === 0) {\r\n                  words = [renderedText];\r\n                } else {\r\n                  words = renderedText.split(/(\\s)/);\r\n                }\r\n                for (let w = 0; w < words.length; w++) {\r\n                  let pos = getTextPos(currentElem._font.font, currentElem._font.size, words[w]);\r\n                  for (let j = 0; j < pos.length; j++) {\r\n                    let index = currentElem._index,\r\n                        xAttr = currentElem._x[index],\r\n                        yAttr = currentElem._y[index],\r\n                        dxAttr = currentElem._dx[index],\r\n                        dyAttr = currentElem._dy[index],\r\n                        rotAttr = currentElem._rot[index],\r\n                        continuous = !(w === 0 && j === 0);\r\n                    if (xAttr !== undefined) {continuous = false; doAnchoring(); currentX = xAttr;}\r\n                    if (yAttr !== undefined) {continuous = false; doAnchoring(); currentY = yAttr;}\r\n                    if (dxAttr !== undefined) {continuous = false; currentX += dxAttr;}\r\n                    if (dyAttr !== undefined) {continuous = false; currentY += dyAttr;}\r\n                    if (rotAttr !== undefined || currentElem._defRot !== 0) {continuous = false;}\r\n                    let position = {\r\n                      glyph: pos[j].glyph,\r\n                      rotate: (Math.PI / 180) * currentElem.chooseValue(rotAttr, currentElem._defRot),\r\n                      x: currentX + pos[j].xOffset,\r\n                      y: currentY + baseline + pos[j].yOffset,\r\n                      width: pos[j].width,\r\n                      ascent: getAscent(currentElem._font.font, currentElem._font.size),\r\n                      descent: getDescent(currentElem._font.font, currentElem._font.size),\r\n                      scale: 1,\r\n                      hidden: false,\r\n                      continuous: continuous\r\n                    };\r\n                    currentChunk.push(position);\r\n                    childElem._pos.push(position);\r\n                    currentElem._pos.push(position);\r\n                    currentElem._index += pos[j].unicode.length;\r\n                    if (currentChunk.length === 1) {\r\n                      currentAnchor = textAnchor;\r\n                      currentDirection = textDirection;\r\n                    }\r\n                    currentX += pos[j].xAdvance + letterSpacing;\r\n                    currentY += pos[j].yAdvance;\r\n                  }\r\n                  if (words[w] === ' ') {\r\n                    currentX += wordSpacing;\r\n                  }\r\n                }\r\n                break;\r\n              default:\r\n                remainingText = remainingText.substring(childElem.textContent.length);\r\n            }\r\n          }\r\n          if (textLength && currentElem._pos.length) {\r\n            adjustLength(currentElem._pos, textLength, spacingAndGlyphs);\r\n          }\r\n          if (currentElem.name === 'textPath' || currentElem.name === 'text') {\r\n            doAnchoring();\r\n          }\r\n          if (currentElem.name === 'textPath') {\r\n            textPaths.push(currentElem);\r\n            let pathObject = currentElem.pathObject;\r\n            if (pathObject) {\r\n              currentX = pathObject.endPoint[0]; currentY = pathObject.endPoint[1];\r\n            }\r\n          }\r\n          if (parentElem) {\r\n            parentElem._pos = parentElem._pos.concat(currentElem._pos);\r\n            parentElem._index += currentElem._index;\r\n          }\r\n        }\r\n        function textOnPath(currentElem) {\r\n          let pathObject = currentElem.pathObject,\r\n              pathLength = currentElem.pathLength,\r\n              pathScale = currentElem.pathScale;\r\n          if (pathObject) {\r\n            let textOffset = currentElem.getLength('startOffset', pathLength, 0);\r\n            for (let j = 0; j < currentElem._pos.length; j++) {\r\n              let charMidX = textOffset + currentElem._pos[j].x + 0.5 * currentElem._pos[j].width;\r\n              if (charMidX > pathLength || charMidX < 0) {\r\n                currentElem._pos[j].hidden = true;\r\n              } else {\r\n                let pointOnPath = pathObject.getPointAtLength(charMidX * pathScale);\r\n                if (isNotEqual(pathScale, 1)) {\r\n                  currentElem._pos[j].scale *= pathScale;\r\n                  currentElem._pos[j].width *= pathScale;\r\n                }\r\n                currentElem._pos[j].x = pointOnPath[0] - 0.5 * currentElem._pos[j].width * Math.cos(pointOnPath[2]) - currentElem._pos[j].y * Math.sin(pointOnPath[2]);\r\n                currentElem._pos[j].y = pointOnPath[1] - 0.5 * currentElem._pos[j].width * Math.sin(pointOnPath[2]) + currentElem._pos[j].y * Math.cos(pointOnPath[2]);\r\n                currentElem._pos[j].rotate = pointOnPath[2] + currentElem._pos[j].rotate;\r\n                currentElem._pos[j].continuous = false;\r\n              }\r\n            }\r\n          } else {\r\n            for (let j = 0; j < currentElem._pos.length; j++) {\r\n              currentElem._pos[j].hidden = true;\r\n            }\r\n          }\r\n        }\r\n        recursive(textParentElem, null);\r\n        for (let i = 0; i < textPaths.length; i++) {\r\n          textOnPath(textPaths[i]);\r\n        }\r\n      })(this);\r\n      this.getTransformation = function() {\r\n        return this.get('transform');\r\n      };\r\n      this.drawInDocument = function(isClip, isMask) {\r\n        doc.save();\r\n        this.transform();\r\n        this.clip();\r\n        let masked = this.mask(), group;\r\n        if (masked) {\r\n          group = docBeginGroup(getPageBBox());\r\n        }\r\n        this.drawTextInDocument(isClip, isMask);\r\n        if (group) {\r\n          docEndGroup(group);\r\n          docInsertGroup(group);\r\n        }\r\n        doc.restore();\r\n      };\r\n    };\r\n\r\n    options = options || {};\r\n    var pxToPt = options.assumePt ? 1 : (72/96), // 1px = 72/96pt, but only if assumePt is false\r\n        viewportWidth = (options.width || doc.page.width) / pxToPt,\r\n        viewportHeight = (options.height || doc.page.height) / pxToPt,\r\n        preserveAspectRatio = options.preserveAspectRatio || null, // default to null so that the attr can override if not passed\r\n        useCSS = options.useCSS && typeof SVGElement !== 'undefined' && svg instanceof SVGElement && typeof getComputedStyle === 'function',\r\n        warningCallback = options.warningCallback,\r\n        fontCallback = options.fontCallback,\r\n        imageCallback = options.imageCallback,\r\n        colorCallback = options.colorCallback,\r\n        documentCallback = options.documentCallback,\r\n        precision = Math.ceil(Math.max(1, options.precision)) || 3,\r\n        groupStack = [],\r\n        documentCache = {},\r\n        links = [],\r\n        styleRules = [];\r\n\r\n    if (typeof warningCallback !== 'function') {\r\n      warningCallback = function(str) {\r\n        if (typeof console !== undefined && typeof console.warn === 'function') {console.warn(str);}\r\n      };\r\n    }\r\n    if (typeof fontCallback !== 'function') {\r\n      fontCallback = function(family, bold, italic, fontOptions) {\r\n        // Check if the font is already registered in the document\r\n        if (bold && italic) {\r\n          if (doc._registeredFonts.hasOwnProperty(family + '-BoldItalic')) {\r\n            return family + '-BoldItalic';\r\n          } else if (doc._registeredFonts.hasOwnProperty(family + '-Italic')) {\r\n            fontOptions.fauxBold = true;\r\n            return family + '-Italic';\r\n          } else if (doc._registeredFonts.hasOwnProperty(family + '-Bold')) {\r\n            fontOptions.fauxItalic = true;\r\n            return family + '-Bold';\r\n          } else if (doc._registeredFonts.hasOwnProperty(family)) {\r\n            fontOptions.fauxBold = true;\r\n            fontOptions.fauxItalic = true;\r\n            return family;\r\n          }\r\n        }\r\n        if (bold && !italic) {\r\n          if (doc._registeredFonts.hasOwnProperty(family + '-Bold')) {\r\n            return family + '-Bold';\r\n          } else if (doc._registeredFonts.hasOwnProperty(family)) {\r\n            fontOptions.fauxBold = true;\r\n            return family;\r\n          }\r\n        }\r\n        if (!bold && italic) {\r\n          if (doc._registeredFonts.hasOwnProperty(family + '-Italic')) {\r\n            return family + '-Italic';\r\n          } else if (doc._registeredFonts.hasOwnProperty(family)) {\r\n            fontOptions.fauxItalic = true;\r\n            return family;\r\n          }\r\n        }\r\n        if (!bold && !italic) {\r\n          if (doc._registeredFonts.hasOwnProperty(family)) {\r\n            return family;\r\n          }\r\n        }\r\n        // Use standard fonts as fallback\r\n        if (family.match(/(?:^|,)\\s*serif\\s*$/)) {\r\n          if (bold && italic) {return 'Times-BoldItalic';}\r\n          if (bold && !italic) {return 'Times-Bold';}\r\n          if (!bold && italic) {return 'Times-Italic';}\r\n          if (!bold && !italic) {return 'Times-Roman';}\r\n        } else if (family.match(/(?:^|,)\\s*monospace\\s*$/)) {\r\n          if (bold && italic) {return 'Courier-BoldOblique';}\r\n          if (bold && !italic) {return 'Courier-Bold';}\r\n          if (!bold && italic) {return 'Courier-Oblique';}\r\n          if (!bold && !italic) {return 'Courier';}\r\n        } else if (family.match(/(?:^|,)\\s*sans-serif\\s*$/) || true) {\r\n          if (bold && italic) {return 'Helvetica-BoldOblique';}\r\n          if (bold && !italic) {return 'Helvetica-Bold';}\r\n          if (!bold && italic) {return 'Helvetica-Oblique';}\r\n          if (!bold && !italic) {return 'Helvetica';}\r\n        }\r\n      };\r\n    }\r\n    if (typeof imageCallback !== 'function') {\r\n      imageCallback = function(link) {\r\n        return link.replace(/\\s+/g, '');\r\n      };\r\n    }\r\n    if (typeof colorCallback !== 'function') {\r\n      colorCallback = null;\r\n    } else {\r\n      for (let color in DefaultColors) {\r\n        let newColor = colorCallback(DefaultColors[color]);\r\n        DefaultColors[color][0] = newColor[0];\r\n        DefaultColors[color][1] = newColor[1];\r\n      }\r\n    }\r\n    if (typeof documentCallback !== 'function') {\r\n      documentCallback = null;\r\n    }\r\n\r\n    if (typeof svg === 'string') {svg = parseXml(svg);}\r\n    if (svg) {\r\n      let styles = svg.getElementsByTagName('style');\r\n      for (let i = 0; i < styles.length; i++) {\r\n        styleRules = styleRules.concat(parseStyleSheet(styles[i].textContent));\r\n      }\r\n      let elem = createSVGElement(svg, null);\r\n      if (typeof elem.drawInDocument === 'function') {\r\n        if (options.useCSS && !useCSS) {\r\n          warningCallback('SVGtoPDF: useCSS option can only be used for SVG *elements* in compatible browsers');\r\n        }\r\n        let savedFillColor = doc._fillColor;\r\n        doc.save().translate(x || 0, y || 0).scale(pxToPt);\r\n        elem.drawInDocument();\r\n        for (let i = 0; i < links.length; i++) {\r\n          doc.page.annotations.push(links[i]);\r\n        }\r\n        doc.restore();\r\n        doc._fillColor = savedFillColor;\r\n      } else {\r\n        warningCallback('SVGtoPDF: this element can\\'t be rendered directly: ' + svg.nodeName);\r\n      }\r\n    } else {\r\n      warningCallback('SVGtoPDF: the input does not look like a valid SVG');\r\n    }\r\n\r\n};\r\n\r\nif ( true && module && typeof module.exports !== 'undefined') {\r\n  module.exports = SVGtoPDF;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvM3JkLXBhcnR5L3N2Zy10by1wZGZraXQvc291cmNlLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQix1QkFBdUI7QUFDdkI7QUFDQSw2QkFBNkIsa0NBQWtDO0FBQy9ELDZCQUE2Qiw0Q0FBNEMsK0RBQStEO0FBQ3hJLDZCQUE2Qiw0Q0FBNEM7QUFDekUsNkJBQTZCLCtCQUErQjtBQUM1RCw2QkFBNkIsNkNBQTZDO0FBQzFFLDZCQUE2QiwwQkFBMEI7QUFDdkQsNkJBQTZCLDBCQUEwQjtBQUN2RCw2QkFBNkIsMkJBQTJCO0FBQ3hELDZCQUE2Qiw0Q0FBNEMsMENBQTBDO0FBQ25ILDZCQUE2Qiw0Q0FBNEMsMENBQTBDO0FBQ25ILDZCQUE2QiwwQkFBMEI7QUFDdkQsNkJBQTZCLDJCQUEyQjtBQUN4RCw2QkFBNkIsMEJBQTBCO0FBQ3ZELDZCQUE2QiwwQkFBMEI7QUFDdkQsNkJBQTZCLDBDQUEwQyxtREFBbUQ7QUFDMUgsNkJBQTZCLHlDQUF5QyxtREFBbUQ7QUFDekgsNkJBQTZCLHFDQUFxQyw4RkFBOEY7QUFDaEssNkJBQTZCLHFDQUFxQztBQUNsRSw2QkFBNkIsMkNBQTJDLCtNQUErTTtBQUN2Uiw2QkFBNkIsMkNBQTJDLDBEQUEwRDtBQUNsSSw2QkFBNkIsMENBQTBDLGlEQUFpRDtBQUN4SCw2QkFBNkIsd0NBQXdDLDBCQUEwQjtBQUMvRiw2QkFBNkIsNkNBQTZDLHdUQUF3VDtBQUNsWSw2QkFBNkIsNkNBQTZDLHdUQUF3VDtBQUNsWSw2QkFBNkIsNkNBQTZDLHFEQUFxRDtBQUMvSCw2QkFBNkIsb0NBQW9DLFVBQVU7QUFDM0UsNkJBQTZCLG9DQUFvQyxVQUFVO0FBQzNFLDZCQUE2QiwwQ0FBMEMsOEZBQThGO0FBQ3JLLDZCQUE2QixnRUFBZ0UsaUlBQWlJO0FBQzlOLDZCQUE2QiwrQkFBK0I7QUFDNUQsNkJBQTZCLCtCQUErQjtBQUM1RCw2QkFBNkIsK0JBQStCO0FBQzVELDZCQUE2QiwyQkFBMkI7QUFDeEQsNkJBQTZCLDRDQUE0QztBQUN6RSw2QkFBNkIsNENBQTRDLG9EQUFvRDtBQUM3SCw2QkFBNkIsZ0NBQWdDO0FBQzdELDZCQUE2QixnQ0FBZ0M7QUFDN0QsNkJBQTZCLDRDQUE0QztBQUN6RTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQXNEO0FBQ3RFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3QjtBQUN2RCxpQkFBaUIsY0FBYyxpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsK0NBQStDO0FBQy9DLGtEQUFrRDtBQUNsRCxxREFBcUQ7QUFDckQsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZSwrQ0FBK0MsYUFBYTtBQUMzRztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLGlDQUFpQztBQUNqQyw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMscUNBQXFDO0FBQ3JDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9EQUFvRDtBQUM5RDtBQUNBLFVBQVUsbURBQW1EO0FBQzdEO0FBQ0EsVUFBVSw0REFBNEQ7QUFDdEU7QUFDQSxVQUFVLHFFQUFxRTtBQUMvRTtBQUNBLFVBQVUsa0RBQWtEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUUsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QixzQ0FBc0M7QUFDdEMsY0FBYztBQUNkLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IscUNBQXFDLDZCQUE2Qiw2QkFBNkI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHFDQUFxQyw2QkFBNkI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDhDQUE4QyxzQ0FBc0M7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1Q0FBdUMsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFO0FBQzNFO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0QkFBNEI7QUFDNUMsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEMscUNBQXFDO0FBQ3JDLG1DQUFtQztBQUNuQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxFQUFFLFNBQVMsS0FBSyxFQUFFLE1BQU07QUFDbkU7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHNCQUFzQiwwQkFBMEI7QUFDaEQsaURBQWlEO0FBQ2pEO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQywwQ0FBMEM7QUFDMUM7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25ELGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxzRkFBc0Y7QUFDdEYsaUZBQWlGO0FBQ2pGLGtFQUFrRTtBQUNsRSxnRUFBZ0U7QUFDaEUsMkRBQTJEO0FBQzNELGtGQUFrRjtBQUNsRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyx3Q0FBd0M7QUFDeEMsdUNBQXVDO0FBQ3ZDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWEsYUFBYTtBQUNwRCwwQkFBMEIsYUFBYSxhQUFhO0FBQ3BEO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsMkNBQTJDO0FBQzNDLDRDQUE0QztBQUM1Qyx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osb0dBQW9HO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOEJBQThCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtCQUErQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELDZEQUE2RDtBQUM3RCxpSEFBaUg7QUFDakgsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQSwwQkFBMEIsaUNBQWlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsOEJBQThCLGlCQUFpQjtBQUMvQyxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixpQkFBaUI7QUFDM0MsVUFBVTtBQUNWLDBCQUEwQix5RUFBeUU7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUMsc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDJDQUEyQztBQUMzQyx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQ0FBa0MsbUJBQW1CO0FBQ3JELHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLG9DQUFvQyxzQkFBc0IsTUFBTTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EseURBQXlELGtDQUFrQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxQkFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQjtBQUNyRDtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsb0NBQW9DO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9DQUFvQztBQUN0RjtBQUNBLHlDQUF5QyxnQkFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyRkFBMkY7QUFDdkgsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELDZCQUE2QixtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esd0RBQXdEO0FBQ3hELHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsb0JBQW9CLGVBQWU7QUFDakYsOENBQThDLG9CQUFvQixlQUFlO0FBQ2pGLCtDQUErQyxvQkFBb0I7QUFDbkUsK0NBQStDLG9CQUFvQjtBQUNuRSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsaUNBQWlDO0FBQ2pDLFVBQVU7QUFDViwrQkFBK0I7QUFDL0IsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxpQ0FBaUM7QUFDakMsVUFBVTtBQUNWLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUE2QjtBQUNqQztBQUNBIiwic291cmNlcyI6WyIvaG9tZS9nYXNjYXQvcHJpc21hcXVhbnQvcHJpc21hLXF1YW50dW0vbm9kZV9tb2R1bGVzL3BkZm1ha2Uvc3JjLzNyZC1wYXJ0eS9zdmctdG8tcGRma2l0L3NvdXJjZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU1ZHdG9QREYgPSBmdW5jdGlvbihkb2MsIHN2ZywgeCwgeSwgb3B0aW9ucykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgY29uc3QgTmFtZWRDb2xvcnMgPSB7YWxpY2VibHVlOiBbMjQwLDI0OCwyNTVdLCBhbnRpcXVld2hpdGU6IFsyNTAsMjM1LDIxNV0sIGFxdWE6IFswLDI1NSwyNTVdLCBhcXVhbWFyaW5lOiBbMTI3LDI1NSwyMTJdLCBhenVyZTogWzI0MCwyNTUsMjU1XSwgYmVpZ2U6IFsyNDUsMjQ1LDIyMF0sIGJpc3F1ZTogWzI1NSwyMjgsMTk2XSwgYmxhY2s6IFswLDAsMF0sIGJsYW5jaGVkYWxtb25kOiBbMjU1LDIzNSwyMDVdLCBibHVlOiBbMCwwLDI1NV0sIGJsdWV2aW9sZXQ6IFsxMzgsNDMsMjI2XSwgYnJvd246IFsxNjUsNDIsNDJdLCBidXJseXdvb2Q6IFsyMjIsMTg0LDEzNV0sIGNhZGV0Ymx1ZTogWzk1LDE1OCwxNjBdLCBjaGFydHJldXNlOiBbMTI3LDI1NSwwXSxcclxuICAgICAgY2hvY29sYXRlOiBbMjEwLDEwNSwzMF0sIGNvcmFsOiBbMjU1LDEyNyw4MF0sIGNvcm5mbG93ZXJibHVlOiBbMTAwLDE0OSwyMzddLCBjb3Juc2lsazogWzI1NSwyNDgsMjIwXSwgY3JpbXNvbjogWzIyMCwyMCw2MF0sIGN5YW46IFswLDI1NSwyNTVdLCBkYXJrYmx1ZTogWzAsMCwxMzldLCBkYXJrY3lhbjogWzAsMTM5LDEzOV0sIGRhcmtnb2xkZW5yb2Q6IFsxODQsMTM0LDExXSwgZGFya2dyYXk6IFsxNjksMTY5LDE2OV0sIGRhcmtncmV5OiBbMTY5LDE2OSwxNjldLCBkYXJrZ3JlZW46IFswLDEwMCwwXSwgZGFya2toYWtpOiBbMTg5LDE4MywxMDddLCBkYXJrbWFnZW50YTogWzEzOSwwLDEzOV0sIGRhcmtvbGl2ZWdyZWVuOiBbODUsMTA3LDQ3XSxcclxuICAgICAgZGFya29yYW5nZTogWzI1NSwxNDAsMF0sIGRhcmtvcmNoaWQ6IFsxNTMsNTAsMjA0XSwgZGFya3JlZDogWzEzOSwwLDBdLCBkYXJrc2FsbW9uOiBbMjMzLDE1MCwxMjJdLCBkYXJrc2VhZ3JlZW46IFsxNDMsMTg4LDE0M10sIGRhcmtzbGF0ZWJsdWU6IFs3Miw2MSwxMzldLCBkYXJrc2xhdGVncmF5OiBbNDcsNzksNzldLCBkYXJrc2xhdGVncmV5OiBbNDcsNzksNzldLCBkYXJrdHVycXVvaXNlOiBbMCwyMDYsMjA5XSwgZGFya3Zpb2xldDogWzE0OCwwLDIxMV0sIGRlZXBwaW5rOiBbMjU1LDIwLDE0N10sIGRlZXBza3libHVlOiBbMCwxOTEsMjU1XSwgZGltZ3JheTogWzEwNSwxMDUsMTA1XSwgZGltZ3JleTogWzEwNSwxMDUsMTA1XSxcclxuICAgICAgZG9kZ2VyYmx1ZTogWzMwLDE0NCwyNTVdLCBmaXJlYnJpY2s6IFsxNzgsMzQsMzRdLCBmbG9yYWx3aGl0ZTogWzI1NSwyNTAsMjQwXSwgZm9yZXN0Z3JlZW46IFszNCwxMzksMzRdLCBmdWNoc2lhOiBbMjU1LDAsMjU1XSwgZ2FpbnNib3JvOiBbMjIwLDIyMCwyMjBdLCBnaG9zdHdoaXRlOiBbMjQ4LDI0OCwyNTVdLCBnb2xkOiBbMjU1LDIxNSwwXSwgZ29sZGVucm9kOiBbMjE4LDE2NSwzMl0sIGdyYXk6IFsxMjgsMTI4LDEyOF0sIGdyZXk6IFsxMjgsMTI4LDEyOF0sIGdyZWVuOiBbMCwxMjgsMF0sIGdyZWVueWVsbG93OiBbMTczLDI1NSw0N10sIGhvbmV5ZGV3OiBbMjQwLDI1NSwyNDBdLCBob3RwaW5rOiBbMjU1LDEwNSwxODBdLFxyXG4gICAgICBpbmRpYW5yZWQ6IFsyMDUsOTIsOTJdLCBpbmRpZ286IFs3NSwwLDEzMF0sIGl2b3J5OiBbMjU1LDI1NSwyNDBdLCBraGFraTogWzI0MCwyMzAsMTQwXSwgbGF2ZW5kZXI6IFsyMzAsMjMwLDI1MF0sIGxhdmVuZGVyYmx1c2g6IFsyNTUsMjQwLDI0NV0sIGxhd25ncmVlbjogWzEyNCwyNTIsMF0sIGxlbW9uY2hpZmZvbjogWzI1NSwyNTAsMjA1XSwgbGlnaHRibHVlOiBbMTczLDIxNiwyMzBdLCBsaWdodGNvcmFsOiBbMjQwLDEyOCwxMjhdLCBsaWdodGN5YW46IFsyMjQsMjU1LDI1NV0sIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbMjUwLDI1MCwyMTBdLCBsaWdodGdyYXk6IFsyMTEsMjExLDIxMV0sIGxpZ2h0Z3JleTogWzIxMSwyMTEsMjExXSxcclxuICAgICAgbGlnaHRncmVlbjogWzE0NCwyMzgsMTQ0XSwgbGlnaHRwaW5rOiBbMjU1LDE4MiwxOTNdLCBsaWdodHNhbG1vbjogWzI1NSwxNjAsMTIyXSwgbGlnaHRzZWFncmVlbjogWzMyLDE3OCwxNzBdLCBsaWdodHNreWJsdWU6IFsxMzUsMjA2LDI1MF0sIGxpZ2h0c2xhdGVncmF5OiBbMTE5LDEzNiwxNTNdLCBsaWdodHNsYXRlZ3JleTogWzExOSwxMzYsMTUzXSwgbGlnaHRzdGVlbGJsdWU6IFsxNzYsMTk2LDIyMl0sIGxpZ2h0eWVsbG93OiBbMjU1LDI1NSwyMjRdLCBsaW1lOiBbMCwyNTUsMF0sIGxpbWVncmVlbjogWzUwLDIwNSw1MF0sIGxpbmVuOiBbMjUwLDI0MCwyMzBdLCBtYWdlbnRhOiBbMjU1LDAsMjU1XSwgbWFyb29uOiBbMTI4LDAsMF0sXHJcbiAgICAgIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsMjA1LDE3MF0sIG1lZGl1bWJsdWU6IFswLDAsMjA1XSwgbWVkaXVtb3JjaGlkOiBbMTg2LDg1LDIxMV0sIG1lZGl1bXB1cnBsZTogWzE0NywxMTIsMjE5XSwgbWVkaXVtc2VhZ3JlZW46IFs2MCwxNzksMTEzXSwgbWVkaXVtc2xhdGVibHVlOiBbMTIzLDEwNCwyMzhdLCBtZWRpdW1zcHJpbmdncmVlbjogWzAsMjUwLDE1NF0sIG1lZGl1bXR1cnF1b2lzZTogWzcyLDIwOSwyMDRdLCBtZWRpdW12aW9sZXRyZWQ6IFsxOTksMjEsMTMzXSwgbWlkbmlnaHRibHVlOiBbMjUsMjUsMTEyXSwgbWludGNyZWFtOiBbMjQ1LDI1NSwyNTBdLCBtaXN0eXJvc2U6IFsyNTUsMjI4LDIyNV0sIG1vY2Nhc2luOiBbMjU1LDIyOCwxODFdLFxyXG4gICAgICBuYXZham93aGl0ZTogWzI1NSwyMjIsMTczXSwgbmF2eTogWzAsMCwxMjhdLCBvbGRsYWNlOiBbMjUzLDI0NSwyMzBdLCBvbGl2ZTogWzEyOCwxMjgsMF0sIG9saXZlZHJhYjogWzEwNywxNDIsMzVdLCBvcmFuZ2U6IFsyNTUsMTY1LDBdLCBvcmFuZ2VyZWQ6IFsyNTUsNjksMF0sIG9yY2hpZDogWzIxOCwxMTIsMjE0XSwgcGFsZWdvbGRlbnJvZDogWzIzOCwyMzIsMTcwXSwgcGFsZWdyZWVuOiBbMTUyLDI1MSwxNTJdLCBwYWxldHVycXVvaXNlOiBbMTc1LDIzOCwyMzhdLCBwYWxldmlvbGV0cmVkOiBbMjE5LDExMiwxNDddLCBwYXBheWF3aGlwOiBbMjU1LDIzOSwyMTNdLCBwZWFjaHB1ZmY6IFsyNTUsMjE4LDE4NV0sIHBlcnU6IFsyMDUsMTMzLDYzXSxcclxuICAgICAgcGluazogWzI1NSwxOTIsMjAzXSwgcGx1bTogWzIyMSwxNjAsMjIxXSwgcG93ZGVyYmx1ZTogWzE3NiwyMjQsMjMwXSwgcHVycGxlOiBbMTI4LDAsMTI4XSwgcmViZWNjYXB1cnBsZTogWzEwMiw1MSwxNTNdLCByZWQ6IFsyNTUsMCwwXSwgcm9zeWJyb3duOiBbMTg4LDE0MywxNDNdLCByb3lhbGJsdWU6IFs2NSwxMDUsMjI1XSwgc2FkZGxlYnJvd246IFsxMzksNjksMTldLCBzYWxtb246IFsyNTAsMTI4LDExNF0sIHNhbmR5YnJvd246IFsyNDQsMTY0LDk2XSwgc2VhZ3JlZW46IFs0NiwxMzksODddLCBzZWFzaGVsbDogWzI1NSwyNDUsMjM4XSwgc2llbm5hOiBbMTYwLDgyLDQ1XSwgc2lsdmVyOiBbMTkyLDE5MiwxOTJdLCBza3libHVlOiBbMTM1LDIwNiwyMzVdLFxyXG4gICAgICBzbGF0ZWJsdWU6IFsxMDYsOTAsMjA1XSwgc2xhdGVncmF5OiBbMTEyLDEyOCwxNDRdLCBzbGF0ZWdyZXk6IFsxMTIsMTI4LDE0NF0sIHNub3c6IFsyNTUsMjUwLDI1MF0sIHNwcmluZ2dyZWVuOiBbMCwyNTUsMTI3XSwgc3RlZWxibHVlOiBbNzAsMTMwLDE4MF0sIHRhbjogWzIxMCwxODAsMTQwXSwgdGVhbDogWzAsMTI4LDEyOF0sIHRoaXN0bGU6IFsyMTYsMTkxLDIxNl0sIHRvbWF0bzogWzI1NSw5OSw3MV0sIHR1cnF1b2lzZTogWzY0LDIyNCwyMDhdLCB2aW9sZXQ6IFsyMzgsMTMwLDIzOF0sIHdoZWF0OiBbMjQ1LDIyMiwxNzldLCB3aGl0ZTogWzI1NSwyNTUsMjU1XSwgd2hpdGVzbW9rZTogWzI0NSwyNDUsMjQ1XSwgeWVsbG93OiBbMjU1LDI1NSwwXX07XHJcbiAgICBjb25zdCBEZWZhdWx0Q29sb3JzID0ge2JsYWNrOiBbTmFtZWRDb2xvcnMuYmxhY2ssIDFdLCB3aGl0ZTogW05hbWVkQ29sb3JzLndoaXRlLCAxXSwgdHJhbnNwYXJlbnQ6IFtOYW1lZENvbG9ycy5ibGFjaywgMF19O1xyXG4gICAgY29uc3QgRW50aXRpZXMgPSB7cXVvdDogMzQsIGFtcDogMzgsIGx0OiA2MCwgZ3Q6IDYyLCBhcG9zOiAzOSwgT0VsaWc6IDMzOCwgb2VsaWc6IDMzOSwgU2Nhcm9uOiAzNTIsIHNjYXJvbjogMzUzLCBZdW1sOiAzNzYsIGNpcmM6IDcxMCwgdGlsZGU6IDczMiwgZW5zcDogODE5NCwgZW1zcDogODE5NSwgdGhpbnNwOiA4MjAxLCB6d25qOiA4MjA0LCB6d2o6IDgyMDUsIGxybTogODIwNiwgcmxtOiA4MjA3LCBuZGFzaDogODIxMSwgbWRhc2g6IDgyMTIsIGxzcXVvOiA4MjE2LCByc3F1bzogODIxNywgc2JxdW86IDgyMTgsIGxkcXVvOiA4MjIwLCByZHF1bzogODIyMSwgYmRxdW86IDgyMjIsIGRhZ2dlcjogODIyNCwgRGFnZ2VyOiA4MjI1LCBwZXJtaWw6IDgyNDAsIGxzYXF1bzogODI0OSxcclxuICAgICAgcnNhcXVvOiA4MjUwLCBldXJvOiA4MzY0LCBuYnNwOiAxNjAsIGlleGNsOiAxNjEsIGNlbnQ6IDE2MiwgcG91bmQ6IDE2MywgY3VycmVuOiAxNjQsIHllbjogMTY1LCBicnZiYXI6IDE2Niwgc2VjdDogMTY3LCB1bWw6IDE2OCwgY29weTogMTY5LCBvcmRmOiAxNzAsIGxhcXVvOiAxNzEsIG5vdDogMTcyLCBzaHk6IDE3MywgcmVnOiAxNzQsIG1hY3I6IDE3NSwgZGVnOiAxNzYsIHBsdXNtbjogMTc3LCBzdXAyOiAxNzgsIHN1cDM6IDE3OSwgYWN1dGU6IDE4MCwgbWljcm86IDE4MSwgcGFyYTogMTgyLCBtaWRkb3Q6IDE4MywgY2VkaWw6IDE4NCwgc3VwMTogMTg1LCBvcmRtOiAxODYsIHJhcXVvOiAxODcsIGZyYWMxNDogMTg4LCBmcmFjMTI6IDE4OSwgZnJhYzM0OiAxOTAsXHJcbiAgICAgIGlxdWVzdDogMTkxLCBBZ3JhdmU6IDE5MiwgQWFjdXRlOiAxOTMsIEFjaXJjOiAxOTQsIEF0aWxkZTogMTk1LCBBdW1sOiAxOTYsIEFyaW5nOiAxOTcsIEFFbGlnOiAxOTgsIENjZWRpbDogMTk5LCBFZ3JhdmU6IDIwMCwgRWFjdXRlOiAyMDEsIEVjaXJjOiAyMDIsIEV1bWw6IDIwMywgSWdyYXZlOiAyMDQsIElhY3V0ZTogMjA1LCBJY2lyYzogMjA2LCBJdW1sOiAyMDcsIEVUSDogMjA4LCBOdGlsZGU6IDIwOSwgT2dyYXZlOiAyMTAsIE9hY3V0ZTogMjExLCBPY2lyYzogMjEyLCBPdGlsZGU6IDIxMywgT3VtbDogMjE0LCB0aW1lczogMjE1LCBPc2xhc2g6IDIxNiwgVWdyYXZlOiAyMTcsIFVhY3V0ZTogMjE4LCBVY2lyYzogMjE5LCBVdW1sOiAyMjAsIFlhY3V0ZTogMjIxLFxyXG4gICAgICBUSE9STjogMjIyLCBzemxpZzogMjIzLCBhZ3JhdmU6IDIyNCwgYWFjdXRlOiAyMjUsIGFjaXJjOiAyMjYsIGF0aWxkZTogMjI3LCBhdW1sOiAyMjgsIGFyaW5nOiAyMjksIGFlbGlnOiAyMzAsIGNjZWRpbDogMjMxLCBlZ3JhdmU6IDIzMiwgZWFjdXRlOiAyMzMsIGVjaXJjOiAyMzQsIGV1bWw6IDIzNSwgaWdyYXZlOiAyMzYsIGlhY3V0ZTogMjM3LCBpY2lyYzogMjM4LCBpdW1sOiAyMzksIGV0aDogMjQwLCBudGlsZGU6IDI0MSwgb2dyYXZlOiAyNDIsIG9hY3V0ZTogMjQzLCBvY2lyYzogMjQ0LCBvdGlsZGU6IDI0NSwgb3VtbDogMjQ2LCBkaXZpZGU6IDI0Nywgb3NsYXNoOiAyNDgsIHVncmF2ZTogMjQ5LCB1YWN1dGU6IDI1MCwgdWNpcmM6IDI1MSwgdXVtbDogMjUyLFxyXG4gICAgICB5YWN1dGU6IDI1MywgdGhvcm46IDI1NCwgeXVtbDogMjU1LCBmbm9mOiA0MDIsIEFscGhhOiA5MTMsIEJldGE6IDkxNCwgR2FtbWE6IDkxNSwgRGVsdGE6IDkxNiwgRXBzaWxvbjogOTE3LCBaZXRhOiA5MTgsIEV0YTogOTE5LCBUaGV0YTogOTIwLCBJb3RhOiA5MjEsIEthcHBhOiA5MjIsIExhbWJkYTogOTIzLCBNdTogOTI0LCBOdTogOTI1LCBYaTogOTI2LCBPbWljcm9uOiA5MjcsIFBpOiA5MjgsIFJobzogOTI5LCBTaWdtYTogOTMxLCBUYXU6IDkzMiwgVXBzaWxvbjogOTMzLCBQaGk6IDkzNCwgQ2hpOiA5MzUsIFBzaTogOTM2LCBPbWVnYTogOTM3LCBhbHBoYTogOTQ1LCBiZXRhOiA5NDYsIGdhbW1hOiA5NDcsIGRlbHRhOiA5NDgsIGVwc2lsb246IDk0OSxcclxuICAgICAgemV0YTogOTUwLCBldGE6IDk1MSwgdGhldGE6IDk1MiwgaW90YTogOTUzLCBrYXBwYTogOTU0LCBsYW1iZGE6IDk1NSwgbXU6IDk1NiwgbnU6IDk1NywgeGk6IDk1OCwgb21pY3JvbjogOTU5LCBwaTogOTYwLCByaG86IDk2MSwgc2lnbWFmOiA5NjIsIHNpZ21hOiA5NjMsIHRhdTogOTY0LCB1cHNpbG9uOiA5NjUsIHBoaTogOTY2LCBjaGk6IDk2NywgcHNpOiA5NjgsIG9tZWdhOiA5NjksIHRoZXRhc3ltOiA5NzcsIHVwc2loOiA5NzgsIHBpdjogOTgyLCBidWxsOiA4MjI2LCBoZWxsaXA6IDgyMzAsIHByaW1lOiA4MjQyLCBQcmltZTogODI0Mywgb2xpbmU6IDgyNTQsIGZyYXNsOiA4MjYwLCB3ZWllcnA6IDg0NzIsIGltYWdlOiA4NDY1LCByZWFsOiA4NDc2LFxyXG4gICAgICB0cmFkZTogODQ4MiwgYWxlZnN5bTogODUwMSwgbGFycjogODU5MiwgdWFycjogODU5MywgcmFycjogODU5NCwgZGFycjogODU5NSwgaGFycjogODU5NiwgY3JhcnI6IDg2MjksIGxBcnI6IDg2NTYsIHVBcnI6IDg2NTcsIHJBcnI6IDg2NTgsIGRBcnI6IDg2NTksIGhBcnI6IDg2NjAsIGZvcmFsbDogODcwNCwgcGFydDogODcwNiwgZXhpc3Q6IDg3MDcsIGVtcHR5OiA4NzA5LCBuYWJsYTogODcxMSwgaXNpbjogODcxMiwgbm90aW46IDg3MTMsIG5pOiA4NzE1LCBwcm9kOiA4NzE5LCBzdW06IDg3MjEsIG1pbnVzOiA4NzIyLCBsb3dhc3Q6IDg3MjcsIHJhZGljOiA4NzMwLCBwcm9wOiA4NzMzLCBpbmZpbjogODczNCwgYW5nOiA4NzM2LCBhbmQ6IDg3NDMsIG9yOiA4NzQ0LFxyXG4gICAgICBjYXA6IDg3NDUsIGN1cDogODc0NiwgaW50OiA4NzQ3LCB0aGVyZTQ6IDg3NTYsIHNpbTogODc2NCwgY29uZzogODc3MywgYXN5bXA6IDg3NzYsIG5lOiA4ODAwLCBlcXVpdjogODgwMSwgbGU6IDg4MDQsIGdlOiA4ODA1LCBzdWI6IDg4MzQsIHN1cDogODgzNSwgbnN1YjogODgzNiwgc3ViZTogODgzOCwgc3VwZTogODgzOSwgb3BsdXM6IDg4NTMsIG90aW1lczogODg1NSwgcGVycDogODg2OSwgc2RvdDogODkwMSwgbGNlaWw6IDg5NjgsIHJjZWlsOiA4OTY5LCBsZmxvb3I6IDg5NzAsIHJmbG9vcjogODk3MSwgbGFuZzogOTAwMSwgcmFuZzogOTAwMiwgbG96OiA5Njc0LCBzcGFkZXM6IDk4MjQsIGNsdWJzOiA5ODI3LCBoZWFydHM6IDk4MjksIGRpYW1zOiA5ODMwfTtcclxuICAgIGNvbnN0IFBhdGhBcmd1bWVudHMgPSB7QTogNywgYTogNywgQzogNiwgYzogNiwgSDogMSwgaDogMSwgTDogMiwgbDogMiwgTTogMiwgbTogMiwgUTogNCwgcTogNCwgUzogNCwgczogNCwgVDogMiwgdDogMiwgVjogMSwgdjogMSwgWjogMCwgejogMH07XHJcbiAgICBjb25zdCBQYXRoRmxhZ3MgPSB7QTM6IHRydWUsIEE0OiB0cnVlLCBhMzogdHJ1ZSwgYTQ6IHRydWV9O1xyXG4gICAgY29uc3QgUHJvcGVydGllcyA9IHtcclxuICAgICAgJ2NvbG9yJzogICAgICAgICAgICAgIHtpbmhlcml0OiB0cnVlLCBpbml0aWFsOiB1bmRlZmluZWR9LFxyXG4gICAgICAndmlzaWJpbGl0eSc6ICAgICAgICAge2luaGVyaXQ6IHRydWUsIGluaXRpYWw6ICd2aXNpYmxlJywgdmFsdWVzOiB7J2hpZGRlbic6ICdoaWRkZW4nLCAnY29sbGFwc2UnOiAnaGlkZGVuJywgJ3Zpc2libGUnOid2aXNpYmxlJ319LFxyXG4gICAgICAnZmlsbCc6ICAgICAgICAgICAgICAge2luaGVyaXQ6IHRydWUsIGluaXRpYWw6IERlZmF1bHRDb2xvcnMuYmxhY2t9LFxyXG4gICAgICAnc3Ryb2tlJzogICAgICAgICAgICAge2luaGVyaXQ6IHRydWUsIGluaXRpYWw6ICdub25lJ30sXHJcbiAgICAgICdzdG9wLWNvbG9yJzogICAgICAgICB7aW5oZXJpdDogZmFsc2UsIGluaXRpYWw6IERlZmF1bHRDb2xvcnMuYmxhY2t9LFxyXG4gICAgICAnZmlsbC1vcGFjaXR5JzogICAgICAge2luaGVyaXQ6IHRydWUsIGluaXRpYWw6IDF9LFxyXG4gICAgICAnc3Ryb2tlLW9wYWNpdHknOiAgICAge2luaGVyaXQ6IHRydWUsIGluaXRpYWw6IDF9LFxyXG4gICAgICAnc3RvcC1vcGFjaXR5JzogICAgICAge2luaGVyaXQ6IGZhbHNlLCBpbml0aWFsOiAxfSxcclxuICAgICAgJ2ZpbGwtcnVsZSc6ICAgICAgICAgIHtpbmhlcml0OiB0cnVlLCBpbml0aWFsOiAnbm9uemVybycsIHZhbHVlczogeydub256ZXJvJzonbm9uemVybycsICdldmVub2RkJzonZXZlbm9kZCd9fSxcclxuICAgICAgJ2NsaXAtcnVsZSc6ICAgICAgICAgIHtpbmhlcml0OiB0cnVlLCBpbml0aWFsOiAnbm9uemVybycsIHZhbHVlczogeydub256ZXJvJzonbm9uemVybycsICdldmVub2RkJzonZXZlbm9kZCd9fSxcclxuICAgICAgJ3N0cm9rZS13aWR0aCc6ICAgICAgIHtpbmhlcml0OiB0cnVlLCBpbml0aWFsOiAxfSxcclxuICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknOiAgIHtpbmhlcml0OiB0cnVlLCBpbml0aWFsOiBbXX0sXHJcbiAgICAgICdzdHJva2UtZGFzaG9mZnNldCc6ICB7aW5oZXJpdDogdHJ1ZSwgaW5pdGlhbDogMH0sXHJcbiAgICAgICdzdHJva2UtbWl0ZXJsaW1pdCc6ICB7aW5oZXJpdDogdHJ1ZSwgaW5pdGlhbDogNH0sXHJcbiAgICAgICdzdHJva2UtbGluZWpvaW4nOiAgICB7aW5oZXJpdDogdHJ1ZSwgaW5pdGlhbDogJ21pdGVyJywgdmFsdWVzOiB7J21pdGVyJzonbWl0ZXInLCAncm91bmQnOidyb3VuZCcsICdiZXZlbCc6J2JldmVsJ319LFxyXG4gICAgICAnc3Ryb2tlLWxpbmVjYXAnOiAgICAge2luaGVyaXQ6IHRydWUsIGluaXRpYWw6ICdidXR0JywgdmFsdWVzOiB7J2J1dHQnOididXR0JywgJ3JvdW5kJzoncm91bmQnLCAnc3F1YXJlJzonc3F1YXJlJ319LFxyXG4gICAgICAnZm9udC1zaXplJzogICAgICAgICAge2luaGVyaXQ6IHRydWUsIGluaXRpYWw6IDE2LCB2YWx1ZXM6IHsneHgtc21hbGwnOjksICd4LXNtYWxsJzoxMCwgJ3NtYWxsJzoxMywgJ21lZGl1bSc6MTYsICdsYXJnZSc6MTgsICd4LWxhcmdlJzoyNCwgJ3h4LWxhcmdlJzozMn19LFxyXG4gICAgICAnZm9udC1mYW1pbHknOiAgICAgICAge2luaGVyaXQ6IHRydWUsIGluaXRpYWw6ICdzYW5zLXNlcmlmJ30sXHJcbiAgICAgICdmb250LXdlaWdodCc6ICAgICAgICB7aW5oZXJpdDogdHJ1ZSwgaW5pdGlhbDogJ25vcm1hbCcsIHZhbHVlczogeyc2MDAnOidib2xkJywgJzcwMCc6J2JvbGQnLCAnODAwJzonYm9sZCcsICc5MDAnOidib2xkJywgJ2JvbGQnOidib2xkJywgJ2JvbGRlcic6J2JvbGQnLCAnNTAwJzonbm9ybWFsJywgJzQwMCc6J25vcm1hbCcsICczMDAnOidub3JtYWwnLCAnMjAwJzonbm9ybWFsJywgJzEwMCc6J25vcm1hbCcsICdub3JtYWwnOidub3JtYWwnLCAnbGlnaHRlcic6J25vcm1hbCd9fSxcclxuICAgICAgJ2ZvbnQtc3R5bGUnOiAgICAgICAgIHtpbmhlcml0OiB0cnVlLCBpbml0aWFsOiAnbm9ybWFsJywgdmFsdWVzOiB7J2l0YWxpYyc6J2l0YWxpYycsICdvYmxpcXVlJzonaXRhbGljJywgJ25vcm1hbCc6J25vcm1hbCd9fSxcclxuICAgICAgJ3RleHQtYW5jaG9yJzogICAgICAgIHtpbmhlcml0OiB0cnVlLCBpbml0aWFsOiAnc3RhcnQnLCB2YWx1ZXM6IHsnc3RhcnQnOidzdGFydCcsICdtaWRkbGUnOidtaWRkbGUnLCAnZW5kJzonZW5kJ319LFxyXG4gICAgICAnZGlyZWN0aW9uJzogICAgICAgICAge2luaGVyaXQ6IHRydWUsIGluaXRpYWw6ICdsdHInLCB2YWx1ZXM6IHsnbHRyJzonbHRyJywgJ3J0bCc6J3J0bCd9fSxcclxuICAgICAgJ2RvbWluYW50LWJhc2VsaW5lJzogIHtpbmhlcml0OiB0cnVlLCBpbml0aWFsOiAnYmFzZWxpbmUnLCB2YWx1ZXM6IHsnYXV0byc6J2Jhc2VsaW5lJywgJ2Jhc2VsaW5lJzonYmFzZWxpbmUnLCAnYmVmb3JlLWVkZ2UnOidiZWZvcmUtZWRnZScsICd0ZXh0LWJlZm9yZS1lZGdlJzonYmVmb3JlLWVkZ2UnLCAnbWlkZGxlJzonbWlkZGxlJywgJ2NlbnRyYWwnOidjZW50cmFsJywgJ2FmdGVyLWVkZ2UnOidhZnRlci1lZGdlJywgJ3RleHQtYWZ0ZXItZWRnZSc6J2FmdGVyLWVkZ2UnLCAnaWRlb2dyYXBoaWMnOidpZGVvZ3JhcGhpYycsICdhbHBoYWJldGljJzonYWxwaGFiZXRpYycsICdoYW5naW5nJzonaGFuZ2luZycsICdtYXRoZW1hdGljYWwnOidtYXRoZW1hdGljYWwnfX0sXHJcbiAgICAgICdhbGlnbm1lbnQtYmFzZWxpbmUnOiB7aW5oZXJpdDogZmFsc2UsIGluaXRpYWw6IHVuZGVmaW5lZCwgdmFsdWVzOiB7J2F1dG8nOidiYXNlbGluZScsICdiYXNlbGluZSc6J2Jhc2VsaW5lJywgJ2JlZm9yZS1lZGdlJzonYmVmb3JlLWVkZ2UnLCAndGV4dC1iZWZvcmUtZWRnZSc6J2JlZm9yZS1lZGdlJywgJ21pZGRsZSc6J21pZGRsZScsICdjZW50cmFsJzonY2VudHJhbCcsICdhZnRlci1lZGdlJzonYWZ0ZXItZWRnZScsICd0ZXh0LWFmdGVyLWVkZ2UnOidhZnRlci1lZGdlJywgJ2lkZW9ncmFwaGljJzonaWRlb2dyYXBoaWMnLCAnYWxwaGFiZXRpYyc6J2FscGhhYmV0aWMnLCAnaGFuZ2luZyc6J2hhbmdpbmcnLCAnbWF0aGVtYXRpY2FsJzonbWF0aGVtYXRpY2FsJ319LFxyXG4gICAgICAnYmFzZWxpbmUtc2hpZnQnOiAgICAge2luaGVyaXQ6IHRydWUsIGluaXRpYWw6ICdiYXNlbGluZScsIHZhbHVlczogeydiYXNlbGluZSc6J2Jhc2VsaW5lJywgJ3N1Yic6J3N1YicsICdzdXBlcic6J3N1cGVyJ319LFxyXG4gICAgICAnd29yZC1zcGFjaW5nJzogICAgICAge2luaGVyaXQ6IHRydWUsIGluaXRpYWw6IDAsIHZhbHVlczoge25vcm1hbDowfX0sXHJcbiAgICAgICdsZXR0ZXItc3BhY2luZyc6ICAgICB7aW5oZXJpdDogdHJ1ZSwgaW5pdGlhbDogMCwgdmFsdWVzOiB7bm9ybWFsOjB9fSxcclxuICAgICAgJ3RleHQtZGVjb3JhdGlvbic6ICAgIHtpbmhlcml0OiBmYWxzZSwgaW5pdGlhbDogJ25vbmUnLCB2YWx1ZXM6IHsnbm9uZSc6J25vbmUnLCAndW5kZXJsaW5lJzondW5kZXJsaW5lJywgJ292ZXJsaW5lJzonb3ZlcmxpbmUnLCAnbGluZS10aHJvdWdoJzonbGluZS10aHJvdWdoJ319LFxyXG4gICAgICAneG1sOnNwYWNlJzogICAgICAgICAge2luaGVyaXQ6IHRydWUsIGluaXRpYWw6ICdkZWZhdWx0JywgY3NzOiAnd2hpdGUtc3BhY2UnLCB2YWx1ZXM6IHsncHJlc2VydmUnOidwcmVzZXJ2ZScsICdkZWZhdWx0JzonZGVmYXVsdCcsICdwcmUnOidwcmVzZXJ2ZScsICdwcmUtbGluZSc6J3ByZXNlcnZlJywgJ3ByZS13cmFwJzoncHJlc2VydmUnLCAnbm93cmFwJzogJ2RlZmF1bHQnfX0sXHJcbiAgICAgICdtYXJrZXItc3RhcnQnOiAgICAgICB7aW5oZXJpdDogdHJ1ZSwgaW5pdGlhbDogJ25vbmUnfSxcclxuICAgICAgJ21hcmtlci1taWQnOiAgICAgICAgIHtpbmhlcml0OiB0cnVlLCBpbml0aWFsOiAnbm9uZSd9LFxyXG4gICAgICAnbWFya2VyLWVuZCc6ICAgICAgICAge2luaGVyaXQ6IHRydWUsIGluaXRpYWw6ICdub25lJ30sXHJcbiAgICAgICdvcGFjaXR5JzogICAgICAgICAgICB7aW5oZXJpdDogZmFsc2UsIGluaXRpYWw6IDF9LFxyXG4gICAgICAndHJhbnNmb3JtJzogICAgICAgICAge2luaGVyaXQ6IGZhbHNlLCBpbml0aWFsOiBbMSwgMCwgMCwgMSwgMCwgMF19LFxyXG4gICAgICAnZGlzcGxheSc6ICAgICAgICAgICAge2luaGVyaXQ6IGZhbHNlLCBpbml0aWFsOiAnaW5saW5lJywgdmFsdWVzOiB7J25vbmUnOidub25lJywgJ2lubGluZSc6J2lubGluZScsICdibG9jayc6J2lubGluZSd9fSxcclxuICAgICAgJ2NsaXAtcGF0aCc6ICAgICAgICAgIHtpbmhlcml0OiBmYWxzZSwgaW5pdGlhbDogJ25vbmUnfSxcclxuICAgICAgJ21hc2snOiAgICAgICAgICAgICAgIHtpbmhlcml0OiBmYWxzZSwgaW5pdGlhbDogJ25vbmUnfSxcclxuICAgICAgJ292ZXJmbG93JzogICAgICAgICAgIHtpbmhlcml0OiBmYWxzZSwgaW5pdGlhbDogJ2hpZGRlbicsIHZhbHVlczogeydoaWRkZW4nOidoaWRkZW4nLCAnc2Nyb2xsJzonaGlkZGVuJywgJ3Zpc2libGUnOid2aXNpYmxlJ319XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGRvY0JlZ2luR3JvdXAoYmJveCkge1xyXG4gICAgICBsZXQgZ3JvdXAgPSBuZXcgKGZ1bmN0aW9uIFBERkdyb3VwKCkge30pKCk7XHJcbiAgICAgIGdyb3VwLm5hbWUgPSAnRycgKyAoZG9jLl9ncm91cENvdW50ID0gKGRvYy5fZ3JvdXBDb3VudCB8fCAwKSArIDEpO1xyXG4gICAgICBncm91cC5yZXNvdXJjZXMgPSBkb2MucmVmKCk7XHJcbiAgICAgIGdyb3VwLnhvYmogPSBkb2MucmVmKHtcclxuICAgICAgICBUeXBlOiAnWE9iamVjdCcsXHJcbiAgICAgICAgU3VidHlwZTogJ0Zvcm0nLFxyXG4gICAgICAgIEZvcm1UeXBlOiAxLFxyXG4gICAgICAgIEJCb3g6IGJib3gsXHJcbiAgICAgICAgR3JvdXA6IHtTOiAnVHJhbnNwYXJlbmN5JywgQ1M6ICdEZXZpY2VSR0InLCBJOiB0cnVlLCBLOiBmYWxzZX0sXHJcbiAgICAgICAgUmVzb3VyY2VzOiBncm91cC5yZXNvdXJjZXNcclxuICAgICAgfSk7XHJcbiAgICAgIGdyb3VwLnhvYmoud3JpdGUoJycpO1xyXG4gICAgICBncm91cC5zYXZlZE1hdHJpeCA9IGRvYy5fY3RtO1xyXG4gICAgICBncm91cC5zYXZlZFBhZ2UgPSBkb2MucGFnZTtcclxuICAgICAgZ3JvdXBTdGFjay5wdXNoKGdyb3VwKTtcclxuICAgICAgZG9jLl9jdG0gPSBbMSwgMCwgMCwgMSwgMCwgMF07XHJcbiAgICAgIGRvYy5wYWdlID0ge1xyXG4gICAgICAgIHdpZHRoOiBkb2MucGFnZS53aWR0aCwgaGVpZ2h0OiBkb2MucGFnZS5oZWlnaHQsXHJcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uKGRhdGEpIHtncm91cC54b2JqLndyaXRlKGRhdGEpO30sXHJcbiAgICAgICAgZm9udHM6IHt9LCB4b2JqZWN0czoge30sIGV4dF9nc3RhdGVzOiB7fSwgcGF0dGVybnM6IHt9XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBncm91cDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRvY0VuZEdyb3VwKGdyb3VwKSB7XHJcbiAgICAgIGlmIChncm91cCAhPT0gZ3JvdXBTdGFjay5wb3AoKSkge3Rocm93KCdHcm91cCBub3QgbWF0Y2hpbmcnKTt9XHJcbiAgICAgIGlmIChPYmplY3Qua2V5cyhkb2MucGFnZS5mb250cykubGVuZ3RoKSB7Z3JvdXAucmVzb3VyY2VzLmRhdGEuRm9udCA9IGRvYy5wYWdlLmZvbnRzO31cclxuICAgICAgaWYgKE9iamVjdC5rZXlzKGRvYy5wYWdlLnhvYmplY3RzKS5sZW5ndGgpIHtncm91cC5yZXNvdXJjZXMuZGF0YS5YT2JqZWN0ID0gZG9jLnBhZ2UueG9iamVjdHM7fVxyXG4gICAgICBpZiAoT2JqZWN0LmtleXMoZG9jLnBhZ2UuZXh0X2dzdGF0ZXMpLmxlbmd0aCkge2dyb3VwLnJlc291cmNlcy5kYXRhLkV4dEdTdGF0ZSA9IGRvYy5wYWdlLmV4dF9nc3RhdGVzO31cclxuICAgICAgaWYgKE9iamVjdC5rZXlzKGRvYy5wYWdlLnBhdHRlcm5zKS5sZW5ndGgpIHtncm91cC5yZXNvdXJjZXMuZGF0YS5QYXR0ZXJuID0gZG9jLnBhZ2UucGF0dGVybnM7fVxyXG4gICAgICBncm91cC5yZXNvdXJjZXMuZW5kKCk7XHJcbiAgICAgIGdyb3VwLnhvYmouZW5kKCk7XHJcbiAgICAgIGRvYy5fY3RtID0gZ3JvdXAuc2F2ZWRNYXRyaXg7XHJcbiAgICAgIGRvYy5wYWdlID0gZ3JvdXAuc2F2ZWRQYWdlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZG9jSW5zZXJ0R3JvdXAoZ3JvdXApIHtcclxuICAgICAgZG9jLnBhZ2UueG9iamVjdHNbZ3JvdXAubmFtZV0gPSBncm91cC54b2JqO1xyXG4gICAgICBkb2MuYWRkQ29udGVudCgnLycgKyBncm91cC5uYW1lICsgJyBEbycpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZG9jQXBwbHlNYXNrKGdyb3VwLCBjbGlwKSB7XHJcbiAgICAgIGxldCBuYW1lID0gJ00nICsgKGRvYy5fbWFza0NvdW50ID0gKGRvYy5fbWFza0NvdW50IHx8IDApICsgMSk7XHJcbiAgICAgIGxldCBnc3RhdGUgPSBkb2MucmVmKHtcclxuICAgICAgICBUeXBlOiAnRXh0R1N0YXRlJywgQ0E6IDEsIGNhOiAxLCBCTTogJ05vcm1hbCcsXHJcbiAgICAgICAgU01hc2s6IHtTOiAnTHVtaW5vc2l0eScsIEc6IGdyb3VwLnhvYmosIEJDOiAoY2xpcCA/IFswLCAwLCAwXSA6IFsxLCAxLCAxXSl9XHJcbiAgICAgIH0pO1xyXG4gICAgICBnc3RhdGUuZW5kKCk7XHJcbiAgICAgIGRvYy5wYWdlLmV4dF9nc3RhdGVzW25hbWVdID0gZ3N0YXRlO1xyXG4gICAgICBkb2MuYWRkQ29udGVudCgnLycgKyBuYW1lICsgJyBncycpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZG9jQ3JlYXRlUGF0dGVybihncm91cCwgZHgsIGR5LCBtYXRyaXgpIHtcclxuICAgICAgbGV0IHBhdHRlcm4gPSBuZXcgKGZ1bmN0aW9uIFBERlBhdHRlcm4oKSB7fSkoKTtcclxuICAgICAgcGF0dGVybi5ncm91cCA9IGdyb3VwO1xyXG4gICAgICBwYXR0ZXJuLmR4ID0gZHg7XHJcbiAgICAgIHBhdHRlcm4uZHkgPSBkeTtcclxuICAgICAgcGF0dGVybi5tYXRyaXggPSBtYXRyaXggfHwgWzEsIDAsIDAsIDEsIDAsIDBdO1xyXG4gICAgICByZXR1cm4gcGF0dGVybjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRvY1VzZVBhdHRlcm4ocGF0dGVybiwgc3Ryb2tlKSB7XHJcbiAgICAgIGxldCBuYW1lID0gJ1AnICsgKGRvYy5fcGF0dGVybkNvdW50ID0gKGRvYy5fcGF0dGVybkNvdW50IHx8IDApICsgMSk7XHJcbiAgICAgIGxldCByZWYgPSBkb2MucmVmKHtcclxuICAgICAgICBUeXBlOiAnUGF0dGVybicsIFBhdHRlcm5UeXBlOiAxLCBQYWludFR5cGU6IDEsIFRpbGluZ1R5cGU6IDIsXHJcbiAgICAgICAgQkJveDogWzAsIDAsIHBhdHRlcm4uZHgsIHBhdHRlcm4uZHldLCBYU3RlcDogcGF0dGVybi5keCwgWVN0ZXA6IHBhdHRlcm4uZHksXHJcbiAgICAgICAgTWF0cml4OiBtdWx0aXBseU1hdHJpeChkb2MuX2N0bSwgcGF0dGVybi5tYXRyaXgpLFxyXG4gICAgICAgIFJlc291cmNlczoge1xyXG4gICAgICAgICAgUHJvY1NldDogWydQREYnLCAnVGV4dCcsICdJbWFnZUInLCAnSW1hZ2VDJywgJ0ltYWdlSSddLFxyXG4gICAgICAgICAgWE9iamVjdDogKGZ1bmN0aW9uKCkge2xldCB0ZW1wID0ge307IHRlbXBbcGF0dGVybi5ncm91cC5uYW1lXSA9IHBhdHRlcm4uZ3JvdXAueG9iajsgcmV0dXJuIHRlbXA7fSkoKVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJlZi53cml0ZSgnLycgKyBwYXR0ZXJuLmdyb3VwLm5hbWUgKyAnIERvJyk7XHJcbiAgICAgIHJlZi5lbmQoKTtcclxuICAgICAgZG9jLnBhZ2UucGF0dGVybnNbbmFtZV0gPSByZWY7XHJcbiAgICAgIGlmIChzdHJva2UpIHtcclxuICAgICAgICBkb2MuYWRkQ29udGVudCgnL1BhdHRlcm4gQ1MnKTtcclxuICAgICAgICBkb2MuYWRkQ29udGVudCgnLycgKyBuYW1lICsgJyBTQ04nKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkb2MuYWRkQ29udGVudCgnL1BhdHRlcm4gY3MnKTtcclxuICAgICAgICBkb2MuYWRkQ29udGVudCgnLycgKyBuYW1lICsgJyBzY24nKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZG9jQmVnaW5UZXh0KGZvbnQsIHNpemUpIHtcclxuICAgICAgaWYgKCFkb2MucGFnZS5mb250c1tmb250LmlkXSkge2RvYy5wYWdlLmZvbnRzW2ZvbnQuaWRdID0gZm9udC5yZWYoKTt9XHJcbiAgICAgIGRvYy5hZGRDb250ZW50KCdCVCcpLmFkZENvbnRlbnQoJy8nICsgZm9udC5pZCArICcgJyArIHNpemUgKyAnIFRmJyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkb2NTZXRUZXh0TWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpIHtcclxuICAgICAgZG9jLmFkZENvbnRlbnQodmFsaWRhdGVOdW1iZXIoYSkgKyAnICcgKyB2YWxpZGF0ZU51bWJlcihiKSArICcgJyArIHZhbGlkYXRlTnVtYmVyKC1jKSArICcgJyAgKyB2YWxpZGF0ZU51bWJlcigtZCkgKyAnICcgKyB2YWxpZGF0ZU51bWJlcihlKSArICcgJyArIHZhbGlkYXRlTnVtYmVyKGYpICsgJyBUbScpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZG9jU2V0VGV4dE1vZGUoZmlsbCwgc3Ryb2tlKSB7XHJcbiAgICAgIGxldCBtb2RlID0gZmlsbCAmJiBzdHJva2UgPyAyIDogc3Ryb2tlID8gMSA6IGZpbGwgPyAwIDogMztcclxuICAgICAgZG9jLmFkZENvbnRlbnQobW9kZSArICcgVHInKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRvY1dyaXRlR2x5cGgoZ2x5cGgpIHtcclxuICAgICAgZG9jLmFkZENvbnRlbnQoJzwnICsgZ2x5cGggKyAnPiBUaicpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZG9jRW5kVGV4dCgpIHtcclxuICAgICAgZG9jLmFkZENvbnRlbnQoJ0VUJyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkb2NGaWxsQ29sb3IoY29sb3IpIHtcclxuICAgICAgaWYgKGNvbG9yWzBdLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdQREZQYXR0ZXJuJykge1xyXG4gICAgICAgIGRvYy5maWxsT3BhY2l0eShjb2xvclsxXSk7XHJcbiAgICAgICAgZG9jVXNlUGF0dGVybihjb2xvclswXSwgZmFsc2UpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGRvYy5maWxsQ29sb3IoY29sb3JbMF0sIGNvbG9yWzFdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZG9jU3Ryb2tlQ29sb3IoY29sb3IpIHtcclxuICAgICAgaWYgKGNvbG9yWzBdLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdQREZQYXR0ZXJuJykge1xyXG4gICAgICAgIGRvYy5zdHJva2VPcGFjaXR5KGNvbG9yWzFdKTtcclxuICAgICAgICBkb2NVc2VQYXR0ZXJuKGNvbG9yWzBdLCB0cnVlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkb2Muc3Ryb2tlQ29sb3IoY29sb3JbMF0sIGNvbG9yWzFdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZG9jSW5zZXJ0TGluayh4LCB5LCB3LCBoLCB1cmwpIHtcclxuICAgICAgbGV0IHJlZiA9IGRvYy5yZWYoe1xyXG4gICAgICAgIFR5cGU6ICdBbm5vdCcsXHJcbiAgICAgICAgU3VidHlwZTogJ0xpbmsnLFxyXG4gICAgICAgIFJlY3Q6IFt4LCB5LCB3LCBoXSxcclxuICAgICAgICBCb3JkZXI6IFswLCAwLCAwXSxcclxuICAgICAgICBBOiB7XHJcbiAgICAgICAgICBTOiAnVVJJJyxcclxuICAgICAgICAgIFVSSTogbmV3IFN0cmluZyh1cmwpXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmVmLmVuZCgpO1xyXG4gICAgICBsaW5rcy5wdXNoKHJlZik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwYXJzZVhtbCh4bWwpIHtcclxuICAgICAgbGV0IFN2Z05vZGUgPSBmdW5jdGlvbih0YWcsIHR5cGUsIHZhbHVlLCBlcnJvcikge1xyXG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICB0aGlzLm5vZGVOYW1lID0gdGFnO1xyXG4gICAgICAgIHRoaXMubm9kZVZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5ub2RlVHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICB0aGlzLmNoaWxkTm9kZXMgPSBbXTtcclxuICAgICAgICB0aGlzLnBhcmVudE5vZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaWQgPSAnJztcclxuICAgICAgICB0aGlzLnRleHRDb250ZW50ID0gJyc7XHJcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QgPSBbXTtcclxuICAgICAgfTtcclxuICAgICAgU3ZnTm9kZS5wcm90b3R5cGUuZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24oYXR0cikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0gIT0gbnVsbCA/IHRoaXMuYXR0cmlidXRlc1thdHRyXSA6IG51bGw7XHJcbiAgICAgIH07XHJcbiAgICAgIFN2Z05vZGUucHJvdG90eXBlLmdldEVsZW1lbnRCeUlkID0gZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcclxuICAgICAgICAoZnVuY3Rpb24gcmVjdXJzaXZlKG5vZGUpIHtcclxuICAgICAgICAgIGlmIChyZXN1bHQpIHtyZXR1cm47fVxyXG4gICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuaWQgPT09IGlkKSB7cmVzdWx0ID0gbm9kZTt9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgcmVjdXJzaXZlKG5vZGUuY2hpbGROb2Rlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KSh0aGlzKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9O1xyXG4gICAgICBTdmdOb2RlLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGZ1bmN0aW9uKHRhZykge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcclxuICAgICAgICAoZnVuY3Rpb24gcmVjdXJzaXZlKG5vZGUpIHtcclxuICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09PSB0YWcpIHtyZXN1bHQucHVzaChub2RlKTt9XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgcmVjdXJzaXZlKG5vZGUuY2hpbGROb2Rlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KSh0aGlzKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9O1xyXG4gICAgICBsZXQgcGFyc2VyID0gbmV3IFN0cmluZ1BhcnNlcih4bWwudHJpbSgpKSwgcmVzdWx0LCBjaGlsZCwgZXJyb3IgPSBmYWxzZTsgXHJcbiAgICAgIGxldCByZWN1cnNpdmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBsZXQgdGVtcCwgY2hpbGQ7XHJcbiAgICAgICAgaWYgKHRlbXAgPSBwYXJzZXIubWF0Y2goL148KFtcXHc6Li1dKylcXHMqLywgdHJ1ZSkpIHsgLy8gT3BlbmluZyB0YWdcclxuICAgICAgICAgIGxldCBub2RlID0gbmV3IFN2Z05vZGUodGVtcFsxXSwgMSwgbnVsbCwgZXJyb3IpO1xyXG4gICAgICAgICAgd2hpbGUgKHRlbXAgPSBwYXJzZXIubWF0Y2goL14oW1xcdzouLV0rKSg/Olxccyo9XFxzKlwiKFteXCJdKilcInxcXHMqPVxccyonKFteJ10qKScpP1xccyovLCB0cnVlKSkgeyAvLyBBdHRyaWJ1dGVcclxuICAgICAgICAgICAgbGV0IGF0dHIgPSB0ZW1wWzFdLCB2YWx1ZSA9IGRlY29kZUVudGl0aWVzKHRlbXBbMl0gfHwgdGVtcFszXSB8fCAnJyk7XHJcbiAgICAgICAgICAgIGlmICghbm9kZS5hdHRyaWJ1dGVzW2F0dHJdKSB7XHJcbiAgICAgICAgICAgICAgbm9kZS5hdHRyaWJ1dGVzW2F0dHJdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgaWYgKGF0dHIgPT09ICdpZCcpIHtub2RlLmlkID0gdmFsdWU7fVxyXG4gICAgICAgICAgICAgIGlmIChhdHRyID09PSAnY2xhc3MnKSB7bm9kZS5jbGFzc0xpc3QgPSB2YWx1ZS5zcGxpdCgnICcpO31cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB3YXJuaW5nQ2FsbGJhY2soJ3BhcnNlWG1sOiBkdXBsaWNhdGUgYXR0cmlidXRlIFwiJyArIGF0dHIgKyAnXCInKTtcclxuICAgICAgICAgICAgICBlcnJvciA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChwYXJzZXIubWF0Y2goL14+LykpIHsgLy8gRW5kIG9mIG9wZW5pbmcgdGFnXHJcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZCA9IHJlY3Vyc2l2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgbm9kZS5jaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAgIGNoaWxkLnBhcmVudE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgKz0gKGNoaWxkLm5vZGVUeXBlID09PSAzIHx8IGNoaWxkLm5vZGVUeXBlID09PSA0ID8gY2hpbGQubm9kZVZhbHVlIDogY2hpbGQudGV4dENvbnRlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0ZW1wID0gcGFyc2VyLm1hdGNoKC9ePFxcLyhbXFx3Oi4tXSspXFxzKj4vLCB0cnVlKSkgeyAvLyBDbG9zaW5nIHRhZ1xyXG4gICAgICAgICAgICAgIGlmICh0ZW1wWzFdID09PSBub2RlLm5vZGVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2FybmluZ0NhbGxiYWNrKCdwYXJzZVhtbDogdGFnIG5vdCBtYXRjaGluZywgb3BlbmluZyBcIicgKyBub2RlLm5vZGVOYW1lICsgJ1wiICYgY2xvc2luZyBcIicgKyB0ZW1wWzFdICsgJ1wiJyk7XHJcbiAgICAgICAgICAgICAgICBlcnJvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgd2FybmluZ0NhbGxiYWNrKCdwYXJzZVhtbDogdGFnIG5vdCBtYXRjaGluZywgb3BlbmluZyBcIicgKyBub2RlLm5vZGVOYW1lICsgJ1wiICYgbm90IGNsb3NpbmcnKTtcclxuICAgICAgICAgICAgICBlcnJvciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VyLm1hdGNoKC9eXFwvPi8pKSB7IC8vIFNlbGYtY2xvc2luZyB0YWdcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB3YXJuaW5nQ2FsbGJhY2soJ3BhcnNlWG1sOiB0YWcgY291bGQgbm90IGJlIHBhcnNlZCBcIicgKyBub2RlLm5vZGVOYW1lICsgJ1wiJyk7XHJcbiAgICAgICAgICAgIGVycm9yID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHRlbXAgPSBwYXJzZXIubWF0Y2goL148IS0tW1xcc1xcU10qPy0tPi8pKSB7IC8vIENvbW1lbnRcclxuICAgICAgICAgIHJldHVybiBuZXcgU3ZnTm9kZShudWxsLCA4LCB0ZW1wLCBlcnJvcik7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0ZW1wID0gcGFyc2VyLm1hdGNoKC9ePFxcP1tcXHNcXFNdKj9cXD8+LykpIHsgLy8gUHJvY2Vzc2luZyBpbnN0cnVjdGlvbnNcclxuICAgICAgICAgIHJldHVybiBuZXcgU3ZnTm9kZShudWxsLCA3LCB0ZW1wLCBlcnJvcik7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0ZW1wID0gcGFyc2VyLm1hdGNoKC9ePCFET0NUWVBFXFxzKihbXFxzXFxTXSo/KT4vKSkgeyAvLyBEb2N0eXBlXHJcbiAgICAgICAgICByZXR1cm4gbmV3IFN2Z05vZGUobnVsbCwgMTAsIHRlbXAsIGVycm9yKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRlbXAgPSBwYXJzZXIubWF0Y2goL148IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXFxdXFxdPi8sIHRydWUpKSB7IC8vIENkYXRhIG5vZGVcclxuICAgICAgICAgIHJldHVybiBuZXcgU3ZnTm9kZSgnI2NkYXRhLXNlY3Rpb24nLCA0LCB0ZW1wWzFdLCBlcnJvcik7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0ZW1wID0gcGFyc2VyLm1hdGNoKC9eKFtePF0rKS8sIHRydWUpKSB7IC8vIFRleHQgbm9kZVxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBTdmdOb2RlKCcjdGV4dCcsIDMsIGRlY29kZUVudGl0aWVzKHRlbXBbMV0pLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICB3aGlsZSAoY2hpbGQgPSByZWN1cnNpdmUoKSkge1xyXG4gICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSAmJiAhcmVzdWx0KSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBjaGlsZDtcclxuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxIHx8IChjaGlsZC5ub2RlVHlwZSA9PT0gMyAmJiBjaGlsZC5ub2RlVmFsdWUudHJpbSgpICE9PSAnJykpIHtcclxuICAgICAgICAgIHdhcm5pbmdDYWxsYmFjaygncGFyc2VYbWw6IGRhdGEgYWZ0ZXIgZG9jdW1lbnQgZW5kIGhhcyBiZWVuIGRpc2NhcmRlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAocGFyc2VyLm1hdGNoQWxsKCkpIHtcclxuICAgICAgICB3YXJuaW5nQ2FsbGJhY2soJ3BhcnNlWG1sOiBwYXJzaW5nIGVycm9yJyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBkZWNvZGVFbnRpdGllcyhzdHIpIHtcclxuICAgICAgcmV0dXJuKHN0ci5yZXBsYWNlKC8mKD86IyhbMC05XSspfCNbeFhdKFswLTlBLUZhLWZdKyl8KFswLTlBLVphLXpdKykpOy9nLCBmdW5jdGlvbihtdCwgbTAsIG0xLCBtMikge1xyXG4gICAgICAgIGlmIChtMCkge3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG0wLCAxMCkpO31cclxuICAgICAgICBlbHNlIGlmIChtMSkge3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG0xLCAxNikpO31cclxuICAgICAgICBlbHNlIGlmIChtMiAmJiBFbnRpdGllc1ttMl0pIHtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShFbnRpdGllc1ttMl0pO31cclxuICAgICAgICBlbHNlIHtyZXR1cm4gbXQ7fVxyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwYXJzZUNvbG9yKHJhdykge1xyXG4gICAgICBsZXQgdGVtcCwgcmVzdWx0O1xyXG4gICAgICByYXcgPSAocmF3IHx8ICcnKS50cmltKCk7XHJcbiAgICAgIGlmICh0ZW1wID0gTmFtZWRDb2xvcnNbcmF3XSkge1xyXG4gICAgICAgIHJlc3VsdCA9IFt0ZW1wLnNsaWNlKCksIDFdO1xyXG4gICAgICB9IGVsc2UgaWYgKHRlbXAgPSByYXcubWF0Y2goL15yZ2JhXFwoXFxzKihbMC05XSspXFxzKixcXHMqKFswLTldKylcXHMqLFxccyooWzAtOV0rKVxccyosXFxzKihbMC05Ll0rKVxccypcXCkkL2kpKSB7XHJcbiAgICAgICAgdGVtcFsxXSA9IHBhcnNlSW50KHRlbXBbMV0pOyB0ZW1wWzJdID0gcGFyc2VJbnQodGVtcFsyXSk7IHRlbXBbM10gPSBwYXJzZUludCh0ZW1wWzNdKTsgdGVtcFs0XSA9IHBhcnNlRmxvYXQodGVtcFs0XSk7XHJcbiAgICAgICAgaWYgKHRlbXBbMV0gPCAyNTYgJiYgdGVtcFsyXSA8IDI1NiAmJiB0ZW1wWzNdIDwgMjU2ICYmIHRlbXBbNF0gPD0gMSkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gW3RlbXAuc2xpY2UoMSwgNCksIHRlbXBbNF1dO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0ZW1wID0gcmF3Lm1hdGNoKC9ecmdiXFwoXFxzKihbMC05XSspXFxzKixcXHMqKFswLTldKylcXHMqLFxccyooWzAtOV0rKVxccypcXCkkL2kpKSB7XHJcbiAgICAgICAgdGVtcFsxXSA9IHBhcnNlSW50KHRlbXBbMV0pOyB0ZW1wWzJdID0gcGFyc2VJbnQodGVtcFsyXSk7IHRlbXBbM10gPSBwYXJzZUludCh0ZW1wWzNdKTtcclxuICAgICAgICBpZiAodGVtcFsxXSA8IDI1NiAmJiB0ZW1wWzJdIDwgMjU2ICYmIHRlbXBbM10gPCAyNTYpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IFt0ZW1wLnNsaWNlKDEsIDQpLCAxXTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodGVtcCA9IHJhdy5tYXRjaCgvXnJnYlxcKFxccyooWzAtOS5dKyklXFxzKixcXHMqKFswLTkuXSspJVxccyosXFxzKihbMC05Ll0rKSVcXHMqXFwpJC9pKSkge1xyXG4gICAgICAgIHRlbXBbMV0gPSAyLjU1ICogcGFyc2VGbG9hdCh0ZW1wWzFdKTsgdGVtcFsyXSA9IDIuNTUgKiBwYXJzZUZsb2F0KHRlbXBbMl0pOyB0ZW1wWzNdID0gMi41NSAqIHBhcnNlRmxvYXQodGVtcFszXSk7XHJcbiAgICAgICAgaWYgKHRlbXBbMV0gPCAyNTYgJiYgdGVtcFsyXSA8IDI1NiAmJiB0ZW1wWzNdIDwgMjU2KSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBbdGVtcC5zbGljZSgxLCA0KSwgMV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHRlbXAgPSByYXcubWF0Y2goL14jKFswLTlhLWZdezJ9KShbMC05YS1mXXsyfSkoWzAtOWEtZl17Mn0pJC9pKSkge1xyXG4gICAgICAgIHJlc3VsdCA9IFtbcGFyc2VJbnQodGVtcFsxXSwgMTYpLCBwYXJzZUludCh0ZW1wWzJdLCAxNiksIHBhcnNlSW50KHRlbXBbM10sIDE2KV0sIDFdO1xyXG4gICAgICB9IGVsc2UgaWYgKHRlbXAgPSByYXcubWF0Y2goL14jKFswLTlhLWZdKShbMC05YS1mXSkoWzAtOWEtZl0pJC9pKSkge1xyXG4gICAgICAgIHJlc3VsdCA9IFtbMHgxMSAqIHBhcnNlSW50KHRlbXBbMV0sIDE2KSwgMHgxMSAqIHBhcnNlSW50KHRlbXBbMl0sIDE2KSwgMHgxMSAqIHBhcnNlSW50KHRlbXBbM10sIDE2KV0sIDFdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjb2xvckNhbGxiYWNrID8gY29sb3JDYWxsYmFjayhyZXN1bHQsIHJhdykgOiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBvcGFjaXR5VG9Db2xvcihjb2xvciwgb3BhY2l0eSwgaXNNYXNrKSB7XHJcbiAgICAgIGxldCBuZXdDb2xvciA9IGNvbG9yWzBdLnNsaWNlKCksXHJcbiAgICAgICAgICBuZXdPcGFjaXR5ID0gY29sb3JbMV0gKiBvcGFjaXR5O1xyXG4gICAgICBpZiAoaXNNYXNrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xvci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbmV3Q29sb3JbaV0gKj0gbmV3T3BhY2l0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtuZXdDb2xvciwgMV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFtuZXdDb2xvciwgbmV3T3BhY2l0eV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG11bHRpcGx5TWF0cml4KCkge1xyXG4gICAgICBmdW5jdGlvbiBtdWx0aXBseShhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIFsgYVswXSpiWzBdK2FbMl0qYlsxXSwgYVsxXSpiWzBdK2FbM10qYlsxXSwgYVswXSpiWzJdK2FbMl0qYlszXSxcclxuICAgICAgICAgICAgICAgICBhWzFdKmJbMl0rYVszXSpiWzNdLCBhWzBdKmJbNF0rYVsyXSpiWzVdK2FbNF0sIGFbMV0qYls0XSthWzNdKmJbNV0rYVs1XSBdO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCByZXN1bHQgPSBhcmd1bWVudHNbMF07XHJcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gbXVsdGlwbHkocmVzdWx0LCBhcmd1bWVudHNbaV0pO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludChwLCBtKSB7XHJcbiAgICAgIHJldHVybiBbbVswXSAqIHBbMF0gKyBtWzJdICogcFsxXSArIG1bNF0sIG1bMV0gKiBwWzBdICsgbVszXSAqIHBbMV0gKyBtWzVdXTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldEdsb2JhbE1hdHJpeCgpIHtcclxuICAgICAgbGV0IGN0bSA9IGRvYy5fY3RtO1xyXG4gICAgICBmb3IgKGxldCBpID0gZ3JvdXBTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGN0bSA9IG11bHRpcGx5TWF0cml4KGdyb3VwU3RhY2tbaV0uc2F2ZWRNYXRyaXgsIGN0bSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGN0bTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFBhZ2VCQm94KCkge1xyXG4gICAgICByZXR1cm4gbmV3IFN2Z1NoYXBlKCkuTSgwLCAwKS5MKGRvYy5wYWdlLndpZHRoLCAwKS5MKGRvYy5wYWdlLndpZHRoLCBkb2MucGFnZS5oZWlnaHQpLkwoMCwgZG9jLnBhZ2UuaGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNmb3JtKGludmVyc2VNYXRyaXgoZ2V0R2xvYmFsTWF0cml4KCkpKS5nZXRCb3VuZGluZ0JveCgpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW52ZXJzZU1hdHJpeChtKSB7XHJcbiAgICAgIGxldCBkdCA9IG1bMF0gKiBtWzNdIC0gbVsxXSAqIG1bMl07XHJcbiAgICAgIHJldHVybiBbbVszXSAvIGR0LCAtbVsxXSAvIGR0LCAtbVsyXSAvIGR0LCBtWzBdIC8gZHQsIChtWzJdKm1bNV0gLSBtWzNdKm1bNF0pIC8gZHQsIChtWzFdKm1bNF0gLSBtWzBdKm1bNV0pIC8gZHRdO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVNYXRyaXgobSkge1xyXG4gICAgICBsZXQgbTAgPSB2YWxpZGF0ZU51bWJlcihtWzBdKSwgbTEgPSB2YWxpZGF0ZU51bWJlcihtWzFdKSwgbTIgPSB2YWxpZGF0ZU51bWJlcihtWzJdKSxcclxuICAgICAgICAgIG0zID0gdmFsaWRhdGVOdW1iZXIobVszXSksIG00ID0gdmFsaWRhdGVOdW1iZXIobVs0XSksIG01ID0gdmFsaWRhdGVOdW1iZXIobVs1XSk7XHJcbiAgICAgIGlmIChpc05vdEVxdWFsKG0wICogbTMgLSBtMSAqIG0yLCAwKSkge1xyXG4gICAgICAgIHJldHVybiBbbTAsIG0xLCBtMiwgbTMsIG00LCBtNV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNvbHZlRXF1YXRpb24oY3VydmUpIHtcclxuICAgICAgbGV0IGEgPSBjdXJ2ZVsyXSB8fCAwLCBiID0gY3VydmVbMV0gfHwgMCwgYyA9IGN1cnZlWzBdIHx8IDA7XHJcbiAgICAgIGlmIChpc0VxdWFsKGEsIDApICYmIGlzRXF1YWwoYiwgMCkpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH0gZWxzZSBpZiAoaXNFcXVhbChhLCAwKSkge1xyXG4gICAgICAgIHJldHVybiBbKC1jKSAvIGJdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldCBkID0gYiAqIGIgLSA0ICogYSAqIGM7XHJcbiAgICAgICAgaWYgKGlzTm90RXF1YWwoZCwgMCkgJiYgZCA+IDApIHtcclxuICAgICAgICAgIHJldHVybiBbKC1iICsgTWF0aC5zcXJ0KGQpKSAvICgyICogYSksICgtYiAtIE1hdGguc3FydChkKSkgLyAoMiAqIGEpXTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzRXF1YWwoZCwgMCkpIHtcclxuICAgICAgICAgIHJldHVybiBbKC1iKSAvICgyICogYSldO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRDdXJ2ZVZhbHVlKHQsIGN1cnZlKSB7XHJcbiAgICAgIHJldHVybiAoY3VydmVbMF0gfHwgMCkgKyAoY3VydmVbMV0gfHwgMCkgKiB0ICsgKGN1cnZlWzJdIHx8IDApICogdCAqIHQgKyAoY3VydmVbM10gfHwgMCkgKiB0ICogdCAqIHQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0VxdWFsKG51bWJlciwgcmVmKSB7XHJcbiAgICAgIHJldHVybiBNYXRoLmFicyhudW1iZXIgLSByZWYpIDwgMWUtMTA7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc05vdEVxdWFsKG51bWJlciwgcmVmKSB7XHJcbiAgICAgIHJldHVybiBNYXRoLmFicyhudW1iZXIgLSByZWYpID49IDFlLTEwO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIobikge1xyXG4gICAgICByZXR1cm4gbiA+IC0xZTIxICYmIG4gPCAxZTIxID8gTWF0aC5yb3VuZChuICogMWU2KSAvIDFlNiA6IDA7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2KSB7XHJcbiAgICAgIHJldHVybiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgdiAhPT0gbnVsbCAmJiB0eXBlb2Ygdi5sZW5ndGggPT09ICdudW1iZXInO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFyc2VUcmFuZm9ybSh2KSB7XHJcbiAgICAgIGxldCBwYXJzZXIgPSBuZXcgU3RyaW5nUGFyc2VyKCh2IHx8ICcnKS50cmltKCkpLCByZXN1bHQgPSBbMSwgMCwgMCwgMSwgMCwgMF0sIHRlbXA7XHJcbiAgICAgIHdoaWxlICh0ZW1wID0gcGFyc2VyLm1hdGNoKC9eKFtBLVphLXpdKylcXHMqWyhdKFteKF0rKVspXS8sIHRydWUpKSB7XHJcbiAgICAgICAgbGV0IGZ1bmMgPSB0ZW1wWzFdLCBudW1zID0gW10sIHBhcnNlcjIgPSBuZXcgU3RyaW5nUGFyc2VyKHRlbXBbMl0udHJpbSgpKSwgdGVtcDI7XHJcbiAgICAgICAgd2hpbGUgKHRlbXAyID0gcGFyc2VyMi5tYXRjaE51bWJlcigpKSB7XHJcbiAgICAgICAgICBudW1zLnB1c2goTnVtYmVyKHRlbXAyKSk7XHJcbiAgICAgICAgICBwYXJzZXIyLm1hdGNoU2VwYXJhdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmdW5jID09PSAnbWF0cml4JyAmJiBudW1zLmxlbmd0aCA9PT0gNikge1xyXG4gICAgICAgICAgcmVzdWx0ID0gbXVsdGlwbHlNYXRyaXgocmVzdWx0LCBbbnVtc1swXSwgbnVtc1sxXSwgbnVtc1syXSwgbnVtc1szXSwgbnVtc1s0XSwgbnVtc1s1XV0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZnVuYyA9PT0gJ3RyYW5zbGF0ZScgJiYgbnVtcy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IG11bHRpcGx5TWF0cml4KHJlc3VsdCwgWzEsIDAsIDAsIDEsIG51bXNbMF0sIG51bXNbMV1dKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGZ1bmMgPT09ICd0cmFuc2xhdGUnICYmIG51bXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBtdWx0aXBseU1hdHJpeChyZXN1bHQsIFsxLCAwLCAwLCAxLCBudW1zWzBdLCAwXSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChmdW5jID09PSAnc2NhbGUnICYmIG51bXMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBtdWx0aXBseU1hdHJpeChyZXN1bHQsIFtudW1zWzBdLCAwLCAwLCBudW1zWzFdLCAwLCAwXSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChmdW5jID09PSAnc2NhbGUnICYmIG51bXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICByZXN1bHQgPSBtdWx0aXBseU1hdHJpeChyZXN1bHQsIFtudW1zWzBdLCAwLCAwLCBudW1zWzBdLCAwLCAwXSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChmdW5jID09PSAncm90YXRlJyAmJiBudW1zLmxlbmd0aCA9PT0gMykge1xyXG4gICAgICAgICAgbGV0IGEgPSBudW1zWzBdICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgICAgIHJlc3VsdCA9IG11bHRpcGx5TWF0cml4KHJlc3VsdCwgWzEsIDAsIDAsIDEsIG51bXNbMV0sIG51bXNbMl1dLCBbTWF0aC5jb3MoYSksIE1hdGguc2luKGEpLCAtTWF0aC5zaW4oYSksIE1hdGguY29zKGEpLCAwLCAwXSwgWzEsIDAsIDAsIDEsIC1udW1zWzFdLCAtbnVtc1syXV0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZnVuYyA9PT0gJ3JvdGF0ZScgJiYgbnVtcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgIGxldCBhID0gbnVtc1swXSAqIE1hdGguUEkgLyAxODA7XHJcbiAgICAgICAgICByZXN1bHQgPSBtdWx0aXBseU1hdHJpeChyZXN1bHQsIFtNYXRoLmNvcyhhKSwgTWF0aC5zaW4oYSksIC1NYXRoLnNpbihhKSwgTWF0aC5jb3MoYSksIDAsIDBdKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGZ1bmMgPT09ICdza2V3WCcgJiYgbnVtcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgIGxldCBhID0gbnVtc1swXSAqIE1hdGguUEkgLyAxODA7XHJcbiAgICAgICAgICByZXN1bHQgPSBtdWx0aXBseU1hdHJpeChyZXN1bHQsIFsxLCAwLCBNYXRoLnRhbihhKSwgMSwgMCwgMF0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZnVuYyA9PT0gJ3NrZXdZJyAmJiBudW1zLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgbGV0IGEgPSBudW1zWzBdICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgICAgIHJlc3VsdCA9IG11bHRpcGx5TWF0cml4KHJlc3VsdCwgWzEsIE1hdGgudGFuKGEpLCAwLCAxLCAwLCAwXSk7XHJcbiAgICAgICAgfSBlbHNlIHtyZXR1cm47fVxyXG4gICAgICAgIHBhcnNlci5tYXRjaFNlcGFyYXRvcigpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChwYXJzZXIubWF0Y2hBbGwoKSkge3JldHVybjt9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwYXJzZUFzcGVjdFJhdGlvKGFzcGVjdFJhdGlvLCBhdmFpbFdpZHRoLCBhdmFpbEhlaWdodCwgZWxlbVdpZHRoLCBlbGVtSGVpZ2h0LCBpbml0QWxpZ24pIHtcclxuICAgICAgbGV0IHRlbXAgPSAoYXNwZWN0UmF0aW8gfHwgJycpLnRyaW0oKS5tYXRjaCgvXihub25lKSR8XngoTWlufE1pZHxNYXgpWShNaW58TWlkfE1heCkoPzpcXHMrKG1lZXR8c2xpY2UpKT8kLykgfHwgW10sXHJcbiAgICAgICAgICByYXRpb1R5cGUgPSB0ZW1wWzFdIHx8IHRlbXBbNF0gfHwgJ21lZXQnLFxyXG4gICAgICAgICAgeEFsaWduID0gdGVtcFsyXSB8fCAnTWlkJyxcclxuICAgICAgICAgIHlBbGlnbiA9IHRlbXBbM10gfHwgJ01pZCcsXHJcbiAgICAgICAgICBzY2FsZVggPSBhdmFpbFdpZHRoIC8gZWxlbVdpZHRoLFxyXG4gICAgICAgICAgc2NhbGVZID0gYXZhaWxIZWlnaHQgLyBlbGVtSGVpZ2h0LFxyXG4gICAgICAgICAgZHggPSB7J01pbic6MCwgJ01pZCc6MC41LCAnTWF4JzoxfVt4QWxpZ25dIC0gKGluaXRBbGlnbiB8fCAwKSxcclxuICAgICAgICAgIGR5ID0geydNaW4nOjAsICdNaWQnOjAuNSwgJ01heCc6MX1beUFsaWduXSAtIChpbml0QWxpZ24gfHwgMCk7XHJcbiAgICAgIGlmIChyYXRpb1R5cGUgPT09ICdzbGljZScpIHtcclxuICAgICAgICBzY2FsZVkgPSBzY2FsZVggPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSk7XHJcbiAgICAgIH0gZWxzZSBpZiAocmF0aW9UeXBlID09PSAnbWVldCcpIHtcclxuICAgICAgICBzY2FsZVkgPSBzY2FsZVggPSBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIFtzY2FsZVgsIDAsIDAsIHNjYWxlWSwgZHggKiAoYXZhaWxXaWR0aCAtIGVsZW1XaWR0aCAqIHNjYWxlWCksIGR5ICogKGF2YWlsSGVpZ2h0IC0gZWxlbUhlaWdodCAqIHNjYWxlWSldO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFyc2VTdHlsZUF0dHIodikge1xyXG4gICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgdiA9ICh2IHx8ICcnKS50cmltKCkuc3BsaXQoLzsvKTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IGtleSA9ICh2W2ldLnNwbGl0KCc6JylbMF0gfHwgJycpLnRyaW0oKSxcclxuICAgICAgICAgICAgdmFsdWUgPSAodltpXS5zcGxpdCgnOicpWzFdIHx8ICcnKS50cmltKCk7XHJcbiAgICAgICAgaWYgKGtleSkge1xyXG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlc3VsdFsnbWFya2VyJ10pIHtcclxuICAgICAgICBpZiAoIXJlc3VsdFsnbWFya2VyLXN0YXJ0J10pIHtyZXN1bHRbJ21hcmtlci1zdGFydCddID0gcmVzdWx0WydtYXJrZXInXTt9XHJcbiAgICAgICAgaWYgKCFyZXN1bHRbJ21hcmtlci1taWQnXSkge3Jlc3VsdFsnbWFya2VyLW1pZCddID0gcmVzdWx0WydtYXJrZXInXTt9XHJcbiAgICAgICAgaWYgKCFyZXN1bHRbJ21hcmtlci1lbmQnXSkge3Jlc3VsdFsnbWFya2VyLWVuZCddID0gcmVzdWx0WydtYXJrZXInXTt9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHJlc3VsdFsnZm9udCddKSB7XHJcbiAgICAgICAgbGV0IGZvbnRGYW1pbHkgPSBudWxsLCBmb250U2l6ZSA9IG51bGwsIGZvbnRTdHlsZSA9IFwibm9ybWFsXCIsIGZvbnRXZWlnaHQgPSBcIm5vcm1hbFwiLCBmb250VmFyaWFudCA9IFwibm9ybWFsXCI7XHJcbiAgICAgICAgbGV0IHBhcnRzID0gcmVzdWx0Wydmb250J10uc3BsaXQoL1xccysvKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKHBhcnRzW2ldKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJub3JtYWxcIjpcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIml0YWxpY1wiOiBjYXNlIFwib2JsaXF1ZVwiOlxyXG4gICAgICAgICAgICAgIGZvbnRTdHlsZSA9IHBhcnRzW2ldO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwic21hbGwtY2Fwc1wiOlxyXG4gICAgICAgICAgICAgIGZvbnRWYXJpYW50ID0gcGFydHNbaV07XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJib2xkXCI6IGNhc2UgXCJib2xkZXJcIjogY2FzZSBcImxpZ2h0ZXJcIjogY2FzZSBcIjEwMFwiOiBjYXNlIFwiMjAwXCI6IGNhc2UgXCIzMDBcIjpcclxuICAgICAgICAgICAgY2FzZSBcIjQwMFwiOiBjYXNlIFwiNTAwXCI6IGNhc2UgXCI2MDBcIjogY2FzZSBcIjcwMFwiOiBjYXNlIFwiODAwXCI6IGNhc2UgXCI5MDBcIjpcclxuICAgICAgICAgICAgICBmb250V2VpZ2h0ID0gcGFydHNbaV07XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgaWYgKCFmb250U2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgZm9udFNpemUgPSBwYXJ0c1tpXS5zcGxpdCgnLycpWzBdO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZvbnRGYW1pbHkpIHtcclxuICAgICAgICAgICAgICAgICAgZm9udEZhbWlseSA9IHBhcnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgZm9udEZhbWlseSArPSAnICcgKyBwYXJ0c1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcmVzdWx0Wydmb250LXN0eWxlJ10pIHtyZXN1bHRbJ2ZvbnQtc3R5bGUnXSA9IGZvbnRTdHlsZTt9XHJcbiAgICAgICAgaWYgKCFyZXN1bHRbJ2ZvbnQtdmFyaWFudCddKSB7cmVzdWx0Wydmb250LXZhcmlhbnQnXSA9IGZvbnRWYXJpYW50O31cclxuICAgICAgICBpZiAoIXJlc3VsdFsnZm9udC13ZWlnaHQnXSkge3Jlc3VsdFsnZm9udC13ZWlnaHQnXSA9IGZvbnRXZWlnaHQ7fVxyXG4gICAgICAgIGlmICghcmVzdWx0Wydmb250LXNpemUnXSkge3Jlc3VsdFsnZm9udC1zaXplJ10gPSBmb250U2l6ZTt9XHJcbiAgICAgICAgaWYgKCFyZXN1bHRbJ2ZvbnQtZmFtaWx5J10pIHtyZXN1bHRbJ2ZvbnQtZmFtaWx5J10gPSBmb250RmFtaWx5O31cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFyc2VTZWxlY3Rvcih2KSB7XHJcbiAgICAgIGxldCBwYXJ0cyA9IHYuc3BsaXQoLyg/PVsuI10pL2cpLCBpZHMgPSBbXSwgY2xhc3NlcyA9IFtdLCB0YWdzID0gW10sIHRlbXA7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAodGVtcCA9IHBhcnRzW2ldLm1hdGNoKC9eWyNdKFtfQS1aYS16MC05LV0rKSQvKSkge1xyXG4gICAgICAgICAgaWRzLnB1c2godGVtcFsxXSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0ZW1wID0gcGFydHNbaV0ubWF0Y2goL15bLl0oW19BLVphLXowLTktXSspJC8pKSB7XHJcbiAgICAgICAgICBjbGFzc2VzLnB1c2godGVtcFsxXSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0ZW1wID0gcGFydHNbaV0ubWF0Y2goL14oW19BLVphLXowLTktXSspJC8pKSB7XHJcbiAgICAgICAgICB0YWdzLnB1c2godGVtcFsxXSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwYXJ0c1tpXSAhPT0gJyonKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdGFnczogdGFncywgaWRzOiBpZHMsIGNsYXNzZXM6IGNsYXNzZXMsXHJcbiAgICAgICAgc3BlY2lmaWNpdHk6IGlkcy5sZW5ndGggKiAxMDAwMCArIGNsYXNzZXMubGVuZ3RoICogMTAwICsgdGFncy5sZW5ndGhcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBhcnNlU3R5bGVTaGVldCh2KSB7XHJcbiAgICAgIGxldCBwYXJzZXIgPSBuZXcgU3RyaW5nUGFyc2VyKHYudHJpbSgpKSwgcnVsZXMgPSBbXSwgcnVsZTtcclxuICAgICAgd2hpbGUgKHJ1bGUgPSBwYXJzZXIubWF0Y2goL15cXHMqKFteXFx7XFx9XSo/KVxccypcXHsoW15cXHtcXH1dKj8pXFx9LywgdHJ1ZSkpIHtcclxuICAgICAgICBsZXQgc2VsZWN0b3JzID0gcnVsZVsxXS5zcGxpdCgvXFxzKixcXHMqL2cpLFxyXG4gICAgICAgICAgICBjc3MgPSBwYXJzZVN0eWxlQXR0cihydWxlWzJdKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbGV0IHNlbGVjdG9yID0gcGFyc2VTZWxlY3RvcihzZWxlY3RvcnNbaV0pO1xyXG4gICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJ1bGVzLnB1c2goe3NlbGVjdG9yOiBzZWxlY3RvciwgY3NzOmNzc30pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcnVsZXM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBtYXRjaGVzU2VsZWN0b3IoZWxlbSwgc2VsZWN0b3IpIHtcclxuICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgIT09IDEpIHtyZXR1cm4gZmFsc2U7fVxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdG9yLnRhZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoc2VsZWN0b3IudGFnc1tpXSAhPT0gZWxlbS5ub2RlTmFtZSkge3JldHVybiBmYWxzZTt9XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Rvci5pZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoc2VsZWN0b3IuaWRzW2ldICE9PSBlbGVtLmlkKSB7cmV0dXJuIGZhbHNlO31cclxuICAgICAgfVxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdG9yLmNsYXNzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoZWxlbS5jbGFzc0xpc3QuaW5kZXhPZihzZWxlY3Rvci5jbGFzc2VzW2ldKSA9PT0gLTEpIHtyZXR1cm4gZmFsc2U7fVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0U3R5bGUoZWxlbSkge1xyXG4gICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgbGV0IHNwZWNpZmljaXRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0eWxlUnVsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgcnVsZSA9IHN0eWxlUnVsZXNbaV07XHJcbiAgICAgICAgaWYgKG1hdGNoZXNTZWxlY3RvcihlbGVtLCBydWxlLnNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgZm9yIChsZXQga2V5IGluIHJ1bGUuY3NzKSB7XHJcbiAgICAgICAgICAgIGlmICghKHNwZWNpZmljaXRpZXNba2V5XSA+IHJ1bGUuc2VsZWN0b3Iuc3BlY2lmaWNpdHkpKSB7XHJcbiAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBydWxlLmNzc1trZXldO1xyXG4gICAgICAgICAgICAgIHNwZWNpZmljaXRpZXNba2V5XSA9IHJ1bGUuc2VsZWN0b3Iuc3BlY2lmaWNpdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbWJpbmVBcnJheXMoYXJyYXkxLCBhcnJheTIpIHtcclxuICAgICAgcmV0dXJuIGFycmF5MS5jb25jYXQoYXJyYXkyLnNsaWNlKGFycmF5MS5sZW5ndGgpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldEFzY2VudChmb250LCBzaXplKSB7XHJcbiAgICAgIHJldHVybiBNYXRoLm1heChmb250LmFzY2VuZGVyLCAoZm9udC5iYm94WzNdIHx8IGZvbnQuYmJveC5tYXhZKSAqIChmb250LnNjYWxlIHx8IDEpKSAqIHNpemUgLyAxMDAwO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2V0RGVzY2VudChmb250LCBzaXplKSB7XHJcbiAgICAgIHJldHVybiBNYXRoLm1pbihmb250LmRlc2NlbmRlciwgKGZvbnQuYmJveFsxXSB8fCBmb250LmJib3gubWluWSkgKiAoZm9udC5zY2FsZSB8fCAxKSkgKiBzaXplIC8gMTAwMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFhIZWlnaHQoZm9udCwgc2l6ZSkge1xyXG4gICAgICByZXR1cm4gKGZvbnQueEhlaWdodCB8fCAwLjUgKiAoZm9udC5hc2NlbmRlciAtIGZvbnQuZGVzY2VuZGVyKSkgKiBzaXplIC8gMTAwMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldEJhc2VsaW5lKGZvbnQsIHNpemUsIGJhc2VsaW5lLCBzaGlmdCkge1xyXG4gICAgICBsZXQgZHkxLCBkeTI7XHJcbiAgICAgIHN3aXRjaCAoYmFzZWxpbmUpIHtcclxuICAgICAgICBjYXNlICdtaWRkbGUnOiBkeTEgPSAwLjUgKiBnZXRYSGVpZ2h0KGZvbnQsIHNpemUpOyBicmVhaztcclxuICAgICAgICBjYXNlICdjZW50cmFsJzogZHkxID0gMC41ICogKGdldERlc2NlbnQoZm9udCwgc2l6ZSkgKyBnZXRBc2NlbnQoZm9udCwgc2l6ZSkpOyBicmVhaztcclxuICAgICAgICBjYXNlICdhZnRlci1lZGdlJzogY2FzZSAndGV4dC1hZnRlci1lZGdlJzogZHkxID0gZ2V0RGVzY2VudChmb250LCBzaXplKTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnYWxwaGFiZXRpYyc6IGNhc2UgJ2F1dG8nOiBjYXNlICdiYXNlbGluZSc6IGR5MSA9IDA7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ21hdGhlbWF0aWNhbCc6IGR5MSA9IDAuNSAqIGdldEFzY2VudChmb250LCBzaXplKTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnaGFuZ2luZyc6IGR5MSA9IDAuOCAqIGdldEFzY2VudChmb250LCBzaXplKTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnYmVmb3JlLWVkZ2UnOiBjYXNlICd0ZXh0LWJlZm9yZS1lZGdlJzogZHkxID0gZ2V0QXNjZW50KGZvbnQsIHNpemUpOyBicmVhaztcclxuICAgICAgICBkZWZhdWx0OiBkeTEgPSAwOyBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBzd2l0Y2ggKHNoaWZ0KSB7XHJcbiAgICAgICAgY2FzZSAnYmFzZWxpbmUnOiBkeTIgPSAwOyBicmVhaztcclxuICAgICAgICBjYXNlICdzdXBlcic6IGR5MiA9IDAuNiAqIHNpemU7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ3N1Yic6IGR5MiA9IC0wLjYgKiBzaXplOyBicmVhaztcclxuICAgICAgICBkZWZhdWx0OiBkeTIgPSBzaGlmdDsgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGR5MSAtIGR5MjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldFRleHRQb3MoZm9udCwgc2l6ZSwgdGV4dCkge1xyXG4gICAgICBsZXQgZW5jb2RlZCA9IGZvbnQuZW5jb2RlKCcnICsgdGV4dCksIGhleCA9IGVuY29kZWRbMF0sIHBvcyA9IGVuY29kZWRbMV0sIGRhdGEgPSBbXTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZXgubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgdW5pY29kZSA9IGZvbnQudW5pY29kZSA/IGZvbnQudW5pY29kZVtwYXJzZUludChoZXhbaV0sIDE2KV0gOiBbdGV4dC5jaGFyQ29kZUF0KGkpXTtcclxuICAgICAgICBkYXRhLnB1c2goe1xyXG4gICAgICAgICAgZ2x5cGg6IGhleFtpXSxcclxuICAgICAgICAgIHVuaWNvZGU6IHVuaWNvZGUsXHJcbiAgICAgICAgICB3aWR0aDogcG9zW2ldLmFkdmFuY2VXaWR0aCAqIHNpemUgLyAxMDAwLFxyXG4gICAgICAgICAgeE9mZnNldDogcG9zW2ldLnhPZmZzZXQgKiBzaXplIC8gMTAwMCxcclxuICAgICAgICAgIHlPZmZzZXQ6IHBvc1tpXS55T2Zmc2V0ICogc2l6ZSAvIDEwMDAsXHJcbiAgICAgICAgICB4QWR2YW5jZTogcG9zW2ldLnhBZHZhbmNlICogc2l6ZSAvIDEwMDAsXHJcbiAgICAgICAgICB5QWR2YW5jZTogcG9zW2ldLnlBZHZhbmNlICogc2l6ZSAvIDEwMDBcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNWR0VsZW1lbnQob2JqLCBpbmhlcml0cykge1xyXG4gICAgICBzd2l0Y2ggKG9iai5ub2RlTmFtZSkge1xyXG4gICAgICAgIGNhc2UgJ3VzZSc6IHJldHVybiBuZXcgU3ZnRWxlbVVzZShvYmosIGluaGVyaXRzKTtcclxuICAgICAgICBjYXNlICdzeW1ib2wnOiByZXR1cm4gbmV3IFN2Z0VsZW1TeW1ib2wob2JqLCBpbmhlcml0cyk7XHJcbiAgICAgICAgY2FzZSAnZyc6IHJldHVybiBuZXcgU3ZnRWxlbUdyb3VwKG9iaiwgaW5oZXJpdHMpO1xyXG4gICAgICAgIGNhc2UgJ2EnOiByZXR1cm4gbmV3IFN2Z0VsZW1MaW5rKG9iaiwgaW5oZXJpdHMpO1xyXG4gICAgICAgIGNhc2UgJ3N2Zyc6IHJldHVybiBuZXcgU3ZnRWxlbVN2ZyhvYmosIGluaGVyaXRzKTtcclxuICAgICAgICBjYXNlICdpbWFnZSc6IHJldHVybiBuZXcgU1ZHRWxlbUltYWdlKG9iaiwgaW5oZXJpdHMpO1xyXG4gICAgICAgIGNhc2UgJ3JlY3QnOiByZXR1cm4gbmV3IFN2Z0VsZW1SZWN0KG9iaiwgaW5oZXJpdHMpO1xyXG4gICAgICAgIGNhc2UgJ2NpcmNsZSc6IHJldHVybiBuZXcgU3ZnRWxlbUNpcmNsZShvYmosIGluaGVyaXRzKTtcclxuICAgICAgICBjYXNlICdlbGxpcHNlJzogcmV0dXJuIG5ldyBTdmdFbGVtRWxsaXBzZShvYmosIGluaGVyaXRzKTtcclxuICAgICAgICBjYXNlICdsaW5lJzogcmV0dXJuIG5ldyBTdmdFbGVtTGluZShvYmosIGluaGVyaXRzKTtcclxuICAgICAgICBjYXNlICdwb2x5bGluZSc6IHJldHVybiBuZXcgU3ZnRWxlbVBvbHlsaW5lKG9iaiwgaW5oZXJpdHMpO1xyXG4gICAgICAgIGNhc2UgJ3BvbHlnb24nOiByZXR1cm4gbmV3IFN2Z0VsZW1Qb2x5Z29uKG9iaiwgaW5oZXJpdHMpO1xyXG4gICAgICAgIGNhc2UgJ3BhdGgnOiByZXR1cm4gbmV3IFN2Z0VsZW1QYXRoKG9iaiwgaW5oZXJpdHMpO1xyXG4gICAgICAgIGNhc2UgJ3RleHQnOiByZXR1cm4gbmV3IFN2Z0VsZW1UZXh0KG9iaiwgaW5oZXJpdHMpO1xyXG4gICAgICAgIGNhc2UgJ3RzcGFuJzogcmV0dXJuIG5ldyBTdmdFbGVtVHNwYW4ob2JqLCBpbmhlcml0cyk7XHJcbiAgICAgICAgY2FzZSAndGV4dFBhdGgnOiByZXR1cm4gbmV3IFN2Z0VsZW1UZXh0UGF0aChvYmosIGluaGVyaXRzKTtcclxuICAgICAgICBjYXNlICcjdGV4dCc6IGNhc2UgJyNjZGF0YS1zZWN0aW9uJzogcmV0dXJuIG5ldyBTdmdFbGVtVGV4dE5vZGUob2JqLCBpbmhlcml0cyk7XHJcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuIG5ldyBTdmdFbGVtKG9iaiwgaW5oZXJpdHMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIFN0cmluZ1BhcnNlciA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICB0aGlzLm1hdGNoID0gZnVuY3Rpb24oZXhwLCBhbGwpIHtcclxuICAgICAgICBsZXQgdGVtcCA9IHN0ci5tYXRjaChleHApO1xyXG4gICAgICAgIGlmICghdGVtcCB8fCB0ZW1wLmluZGV4ICE9PSAwKSB7cmV0dXJuO31cclxuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKHRlbXBbMF0ubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gKGFsbCA/IHRlbXAgOiB0ZW1wWzBdKTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5tYXRjaFNlcGFyYXRvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoKC9eKD86XFxzKixcXHMqfFxccyp8KS8pO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLm1hdGNoU3BhY2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCgvXig/OlxccyopLyk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMubWF0Y2hMZW5ndGhVbml0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goL14oPzpweHxwdHxjbXxtbXxpbnxwY3xlbXxleHwlfCkvKTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5tYXRjaE51bWJlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoKC9eKD86Wy0rXT8oPzpbMC05XStbLl1bMC05XSt8WzAtOV0rWy5dfFsuXVswLTldK3xbMC05XSspKD86W2VFXVstK10/WzAtOV0rKT8pLyk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMubWF0Y2hBbGwgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCgvXltcXHNcXFNdKy8pO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgQmV6aWVyU2VnbWVudCA9IGZ1bmN0aW9uKHAxeCwgcDF5LCBjMXgsIGMxeSwgYzJ4LCBjMnksIHAyeCwgcDJ5KSB7XHJcbiAgICAgIGxldCBkaXZpc2lvbnMgPSA2ICogcHJlY2lzaW9uO1xyXG4gICAgICBsZXQgZXF1YXRpb25YID0gW3AxeCwgLTMgKiBwMXggKyAzICogYzF4LCAzICogcDF4IC0gNiAqIGMxeCArIDMgKiBjMngsIC1wMXggKyAzICogYzF4IC0gMyAqIGMyeCArIHAyeF07XHJcbiAgICAgIGxldCBlcXVhdGlvblkgPSBbcDF5LCAtMyAqIHAxeSArIDMgKiBjMXksIDMgKiBwMXkgLSA2ICogYzF5ICsgMyAqIGMyeSwgLXAxeSArIDMgKiBjMXkgLSAzICogYzJ5ICsgcDJ5XTtcclxuICAgICAgbGV0IGRlcml2YXRpdmVYID0gWy0zICogcDF4ICsgMyAqIGMxeCwgNiAqIHAxeCAtIDEyICogYzF4ICsgNiAqIGMyeCwgLTMgKiBwMXggKyA5ICogYzF4IC0gOSAqIGMyeCArIDMgKiBwMnhdO1xyXG4gICAgICBsZXQgZGVyaXZhdGl2ZVkgPSBbLTMgKiBwMXkgKyAzICogYzF5LCA2ICogcDF5IC0gMTIgKiBjMXkgKyA2ICogYzJ5LCAtMyAqIHAxeSArIDkgKiBjMXkgLSA5ICogYzJ5ICsgMyAqIHAyeV07XHJcbiAgICAgIGxldCBsZW5ndGhNYXAgPSBbMF07XHJcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGRpdmlzaW9uczsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHQgPSAoaSAtIDAuNSkgLyBkaXZpc2lvbnM7XHJcbiAgICAgICAgbGV0IGR4ID0gZ2V0Q3VydmVWYWx1ZSh0LCBkZXJpdmF0aXZlWCkgLyBkaXZpc2lvbnMsXHJcbiAgICAgICAgICAgIGR5ID0gZ2V0Q3VydmVWYWx1ZSh0LCBkZXJpdmF0aXZlWSkgLyBkaXZpc2lvbnMsXHJcbiAgICAgICAgICAgIGwgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG4gICAgICAgIGxlbmd0aE1hcFtpXSA9IGxlbmd0aE1hcFtpIC0gMV0gKyBsO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMudG90YWxMZW5ndGggPSBsZW5ndGhNYXBbZGl2aXNpb25zXTtcclxuICAgICAgdGhpcy5zdGFydFBvaW50ID0gW3AxeCwgcDF5LCBpc0VxdWFsKHAxeCwgYzF4KSAmJiBpc0VxdWFsKHAxeSwgYzF5KSA/IE1hdGguYXRhbjIoYzJ5IC0gYzF5LCBjMnggLSBjMXgpIDogTWF0aC5hdGFuMihjMXkgLSBwMXksIGMxeCAtIHAxeCldO1xyXG4gICAgICB0aGlzLmVuZFBvaW50ID0gW3AyeCwgcDJ5LCBpc0VxdWFsKGMyeCwgcDJ4KSAmJiBpc0VxdWFsKGMyeSwgcDJ5KSA/IE1hdGguYXRhbjIoYzJ5IC0gYzF5LCBjMnggLSBjMXgpIDogTWF0aC5hdGFuMihwMnkgLSBjMnksIHAyeCAtIGMyeCldO1xyXG4gICAgICB0aGlzLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgbGV0IHRlbXA7XHJcbiAgICAgICAgbGV0IG1pblggPSBnZXRDdXJ2ZVZhbHVlKDAsIGVxdWF0aW9uWCksIG1pblkgPSBnZXRDdXJ2ZVZhbHVlKDAsIGVxdWF0aW9uWSksXHJcbiAgICAgICAgICAgIG1heFggPSBnZXRDdXJ2ZVZhbHVlKDEsIGVxdWF0aW9uWCksIG1heFkgPSBnZXRDdXJ2ZVZhbHVlKDEsIGVxdWF0aW9uWSk7XHJcbiAgICAgICAgaWYgKG1pblggPiBtYXhYKSB7dGVtcCA9IG1heFg7IG1heFggPSBtaW5YOyBtaW5YID0gdGVtcDt9XHJcbiAgICAgICAgaWYgKG1pblkgPiBtYXhZKSB7dGVtcCA9IG1heFk7IG1heFkgPSBtaW5ZOyBtaW5ZID0gdGVtcDt9XHJcbiAgICAgICAgbGV0IHJvb3RzWCA9IHNvbHZlRXF1YXRpb24oZGVyaXZhdGl2ZVgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm9vdHNYLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAocm9vdHNYW2ldID49IDAgJiYgcm9vdHNYW2ldIDw9IDEpIHtcclxuICAgICAgICAgICAgbGV0IHggPSBnZXRDdXJ2ZVZhbHVlKHJvb3RzWFtpXSwgZXF1YXRpb25YKTtcclxuICAgICAgICAgICAgaWYgKHggPCBtaW5YKSB7bWluWCA9IHg7fVxyXG4gICAgICAgICAgICBpZiAoeCA+IG1heFgpIHttYXhYID0geDt9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByb290c1kgPSBzb2x2ZUVxdWF0aW9uKGRlcml2YXRpdmVZKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvb3RzWS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKHJvb3RzWVtpXSA+PSAwICYmIHJvb3RzWVtpXSA8PSAxKSB7XHJcbiAgICAgICAgICAgIGxldCB5ID0gZ2V0Q3VydmVWYWx1ZShyb290c1lbaV0sIGVxdWF0aW9uWSk7XHJcbiAgICAgICAgICAgIGlmICh5IDwgbWluWSkge21pblkgPSB5O31cclxuICAgICAgICAgICAgaWYgKHkgPiBtYXhZKSB7bWF4WSA9IHk7fVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW21pblgsIG1pblksIG1heFgsIG1heFldO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmdldFBvaW50QXRMZW5ndGggPSBmdW5jdGlvbihsKSB7XHJcbiAgICAgICAgaWYgKGlzRXF1YWwobCwgMCkpIHtyZXR1cm4gdGhpcy5zdGFydFBvaW50O31cclxuICAgICAgICBpZiAoaXNFcXVhbChsLCB0aGlzLnRvdGFsTGVuZ3RoKSkge3JldHVybiB0aGlzLmVuZFBvaW50O31cclxuICAgICAgICBpZiAobCA8IDAgfHwgbCA+IHRoaXMudG90YWxMZW5ndGgpIHtyZXR1cm47fVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGRpdmlzaW9uczsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgbDEgPSBsZW5ndGhNYXBbaS0xXSwgbDIgPSBsZW5ndGhNYXBbaV07XHJcbiAgICAgICAgICBpZiAobDEgPD0gbCAmJiBsIDw9IGwyKSB7XHJcbiAgICAgICAgICAgIGxldCB0ID0gKGkgLSAobDIgLSBsKSAvIChsMiAtIGwxKSkgLyBkaXZpc2lvbnMsXHJcbiAgICAgICAgICAgICAgICB4ID0gZ2V0Q3VydmVWYWx1ZSh0LCBlcXVhdGlvblgpLCB5ID0gZ2V0Q3VydmVWYWx1ZSh0LCBlcXVhdGlvblkpLFxyXG4gICAgICAgICAgICAgICAgZHggPSBnZXRDdXJ2ZVZhbHVlKHQsIGRlcml2YXRpdmVYKSwgZHkgPSBnZXRDdXJ2ZVZhbHVlKHQsIGRlcml2YXRpdmVZKTtcclxuICAgICAgICAgICAgcmV0dXJuIFt4LCB5LCBNYXRoLmF0YW4yKGR5LCBkeCldO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIExpbmVTZWdtZW50ID0gZnVuY3Rpb24ocDF4LCBwMXksIHAyeCwgcDJ5KSB7XHJcbiAgICAgIHRoaXMudG90YWxMZW5ndGggPSBNYXRoLnNxcnQoKHAyeCAtIHAxeCkgKiAocDJ4IC0gcDF4KSArIChwMnkgLSBwMXkpICogKHAyeSAtIHAxeSkpO1xyXG4gICAgICB0aGlzLnN0YXJ0UG9pbnQgPSBbcDF4LCBwMXksIE1hdGguYXRhbjIocDJ5IC0gcDF5LCBwMnggLSBwMXgpXTtcclxuICAgICAgdGhpcy5lbmRQb2ludCA9IFtwMngsIHAyeSwgTWF0aC5hdGFuMihwMnkgLSBwMXksIHAyeCAtIHAxeCldO1xyXG4gICAgICB0aGlzLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtNYXRoLm1pbih0aGlzLnN0YXJ0UG9pbnRbMF0sIHRoaXMuZW5kUG9pbnRbMF0pLCBNYXRoLm1pbih0aGlzLnN0YXJ0UG9pbnRbMV0sIHRoaXMuZW5kUG9pbnRbMV0pLFxyXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgodGhpcy5zdGFydFBvaW50WzBdLCB0aGlzLmVuZFBvaW50WzBdKSwgTWF0aC5tYXgodGhpcy5zdGFydFBvaW50WzFdLCB0aGlzLmVuZFBvaW50WzFdKV07XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZ2V0UG9pbnRBdExlbmd0aCA9IGZ1bmN0aW9uKGwpIHtcclxuICAgICAgICBpZiAobCA+PSAwICYmIGwgPD0gdGhpcy50b3RhbExlbmd0aCkge1xyXG4gICAgICAgICAgbGV0IHIgPSBsIC8gdGhpcy50b3RhbExlbmd0aCB8fCAwLFxyXG4gICAgICAgICAgICAgIHggPSB0aGlzLnN0YXJ0UG9pbnRbMF0gKyByICogKHRoaXMuZW5kUG9pbnRbMF0gLSB0aGlzLnN0YXJ0UG9pbnRbMF0pLFxyXG4gICAgICAgICAgICAgIHkgPSB0aGlzLnN0YXJ0UG9pbnRbMV0gKyByICogKHRoaXMuZW5kUG9pbnRbMV0gLSB0aGlzLnN0YXJ0UG9pbnRbMV0pO1xyXG4gICAgICAgICAgcmV0dXJuIFt4LCB5LCB0aGlzLnN0YXJ0UG9pbnRbMl1dO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIFN2Z1NoYXBlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMucGF0aENvbW1hbmRzID0gW107XHJcbiAgICAgIHRoaXMucGF0aFNlZ21lbnRzID0gW107XHJcbiAgICAgIHRoaXMuc3RhcnRQb2ludCA9IG51bGw7XHJcbiAgICAgIHRoaXMuZW5kUG9pbnQgPSBudWxsO1xyXG4gICAgICB0aGlzLnRvdGFsTGVuZ3RoID0gMDtcclxuICAgICAgbGV0IHN0YXJ0WCA9IDAsIHN0YXJ0WSA9IDAsIGN1cnJYID0gMCwgY3VyclkgPSAwLCBsYXN0Q29tLCBsYXN0Q3RybFgsIGxhc3RDdHJsWTtcclxuICAgICAgdGhpcy5tb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICAgIHN0YXJ0WCA9IGN1cnJYID0geDsgc3RhcnRZID0gY3VyclkgPSB5O1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmxpbmUgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgICAgbGV0IHNlZ21lbnQgPSBuZXcgTGluZVNlZ21lbnQoY3VyclgsIGN1cnJZLCB4LCB5KTtcclxuICAgICAgICBjdXJyWCA9IHg7IGN1cnJZID0geTtcclxuICAgICAgICByZXR1cm4gc2VnbWVudDtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5jdXJ2ZSA9IGZ1bmN0aW9uKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSkge1xyXG4gICAgICAgIGxldCBzZWdtZW50ID0gbmV3IEJlemllclNlZ21lbnQoY3VyclgsIGN1cnJZLCBjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xyXG4gICAgICAgIGN1cnJYID0geDsgY3VyclkgPSB5O1xyXG4gICAgICAgIHJldHVybiBzZWdtZW50O1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmNsb3NlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgbGV0IHNlZ21lbnQgPSBuZXcgTGluZVNlZ21lbnQoY3VyclgsIGN1cnJZLCBzdGFydFgsIHN0YXJ0WSk7XHJcbiAgICAgICAgY3VyclggPSBzdGFydFg7IGN1cnJZID0gc3RhcnRZO1xyXG4gICAgICAgIHJldHVybiBzZWdtZW50O1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmFkZENvbW1hbmQgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5wYXRoQ29tbWFuZHMucHVzaChkYXRhKTtcclxuICAgICAgICBsZXQgc2VnbWVudCA9IHRoaXNbZGF0YVswXV0uYXBwbHkodGhpcywgZGF0YS5zbGljZSgzKSk7XHJcbiAgICAgICAgaWYgKHNlZ21lbnQpIHtcclxuICAgICAgICAgIHNlZ21lbnQuaGFzU3RhcnQgPSBkYXRhWzFdO1xyXG4gICAgICAgICAgc2VnbWVudC5oYXNFbmQgPSBkYXRhWzJdO1xyXG4gICAgICAgICAgdGhpcy5zdGFydFBvaW50ID0gdGhpcy5zdGFydFBvaW50IHx8IHNlZ21lbnQuc3RhcnRQb2ludDtcclxuICAgICAgICAgIHRoaXMuZW5kUG9pbnQgPSBzZWdtZW50LmVuZFBvaW50O1xyXG4gICAgICAgICAgdGhpcy5wYXRoU2VnbWVudHMucHVzaChzZWdtZW50KTtcclxuICAgICAgICAgIHRoaXMudG90YWxMZW5ndGggKz0gc2VnbWVudC50b3RhbExlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuTSA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoWydtb3ZlJywgdHJ1ZSwgdHJ1ZSwgeCwgeV0pO1xyXG4gICAgICAgIGxhc3RDb20gPSAnTSc7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMubSA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5NKGN1cnJYICsgeCwgY3VyclkgKyB5KTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5aID0gdGhpcy56ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKFsnY2xvc2UnLCB0cnVlLCB0cnVlXSk7XHJcbiAgICAgICAgbGFzdENvbSA9ICdaJztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5MID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZChbJ2xpbmUnLCB0cnVlLCB0cnVlLCB4LCB5XSk7XHJcbiAgICAgICAgbGFzdENvbSA9ICdMJztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5sID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLkwoY3VyclggKyB4LCBjdXJyWSArIHkpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLkggPSBmdW5jdGlvbih4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuTCh4LCBjdXJyWSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuaCA9IGZ1bmN0aW9uKHgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5MKGN1cnJYICsgeCwgY3VyclkpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLlYgPSBmdW5jdGlvbih5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuTChjdXJyWCwgeSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMudiA9IGZ1bmN0aW9uKHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5MKGN1cnJYLCBjdXJyWSArIHkpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLkMgPSBmdW5jdGlvbihjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpIHtcclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoWydjdXJ2ZScsIHRydWUsIHRydWUsIGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeV0pO1xyXG4gICAgICAgIGxhc3RDb20gPSAnQyc7IGxhc3RDdHJsWCA9IGMyeDsgbGFzdEN0cmxZID0gYzJ5O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmMgPSBmdW5jdGlvbihjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5DKGN1cnJYICsgYzF4LCBjdXJyWSArIGMxeSwgY3VyclggKyBjMngsIGN1cnJZICsgYzJ5LCBjdXJyWCArIHgsIGN1cnJZICsgeSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuUyA9IGZ1bmN0aW9uKGMxeCwgYzF5LCB4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuQyhjdXJyWCArIChsYXN0Q29tID09PSAnQycgPyBjdXJyWCAtIGxhc3RDdHJsWCA6IDApLCBjdXJyWSArIChsYXN0Q29tID09PSAnQycgPyBjdXJyWSAtIGxhc3RDdHJsWSA6IDApLCBjMXgsIGMxeSwgeCwgeSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMucyA9IGZ1bmN0aW9uKGMxeCwgYzF5LCB4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuQyhjdXJyWCArIChsYXN0Q29tID09PSAnQycgPyBjdXJyWCAtIGxhc3RDdHJsWCA6IDApLCBjdXJyWSArIChsYXN0Q29tID09PSAnQycgPyBjdXJyWSAtIGxhc3RDdHJsWSA6IDApLCBjdXJyWCArIGMxeCwgY3VyclkgKyBjMXksIGN1cnJYICsgeCwgY3VyclkgKyB5KTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5RID0gZnVuY3Rpb24oY3gsIGN5LCB4LCB5KSB7XHJcbiAgICAgICAgbGV0IGMxeCA9IGN1cnJYICsgMiAvIDMgKiAoY3ggLSBjdXJyWCksIGMxeSA9IGN1cnJZICsgMiAvIDMgKiAoY3kgLSBjdXJyWSksXHJcbiAgICAgICAgICAgIGMyeCA9IHggKyAyIC8gMyAqIChjeCAtIHgpLCBjMnkgPSB5ICsgMiAvIDMgKiAoY3kgLSB5KTtcclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoWydjdXJ2ZScsIHRydWUsIHRydWUsIGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeV0pO1xyXG4gICAgICAgIGxhc3RDb20gPSAnUSc7IGxhc3RDdHJsWCA9IGN4OyBsYXN0Q3RybFkgPSBjeTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5xID0gZnVuY3Rpb24oYzF4LCBjMXksIHgsIHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5RKGN1cnJYICsgYzF4LCBjdXJyWSArIGMxeSwgY3VyclggKyB4LCBjdXJyWSArIHkpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLlQgPSBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuUShjdXJyWCArIChsYXN0Q29tID09PSAnUScgPyBjdXJyWCAtIGxhc3RDdHJsWCA6IDApLCBjdXJyWSArIChsYXN0Q29tID09PSAnUScgPyBjdXJyWSAtIGxhc3RDdHJsWSA6IDApLCB4LCB5KTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy50ID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLlEoY3VyclggKyAobGFzdENvbSA9PT0gJ1EnID8gY3VyclggLSBsYXN0Q3RybFggOiAwKSwgY3VyclkgKyAobGFzdENvbSA9PT0gJ1EnID8gY3VyclkgLSBsYXN0Q3RybFkgOiAwKSwgY3VyclggKyB4LCBjdXJyWSArIHkpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLkEgPSBmdW5jdGlvbihyeCwgcnksIGZpLCBmYSwgZnMsIHgsIHkpIHtcclxuICAgICAgICBpZiAoaXNFcXVhbChyeCwgMCkgfHwgaXNFcXVhbChyeSwgMCkpIHtcclxuICAgICAgICAgIHRoaXMuYWRkQ29tbWFuZChbJ2xpbmUnLCB0cnVlLCB0cnVlLCB4LCB5XSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZpID0gZmkgKiAoTWF0aC5QSSAvIDE4MCk7XHJcbiAgICAgICAgICByeCA9IE1hdGguYWJzKHJ4KTtcclxuICAgICAgICAgIHJ5ID0gTWF0aC5hYnMocnkpO1xyXG4gICAgICAgICAgZmEgPSAxICogISFmYTtcclxuICAgICAgICAgIGZzID0gMSAqICEhZnM7XHJcbiAgICAgICAgICBsZXQgeDEgPSBNYXRoLmNvcyhmaSkgKiAoY3VyclggLSB4KSAvIDIgKyBNYXRoLnNpbihmaSkgKiAoY3VyclkgLSB5KSAvIDIsXHJcbiAgICAgICAgICAgICAgeTEgPSBNYXRoLmNvcyhmaSkgKiAoY3VyclkgLSB5KSAvIDIgLSBNYXRoLnNpbihmaSkgKiAoY3VyclggLSB4KSAvIDIsXHJcbiAgICAgICAgICAgICAgbGFtYmRhID0gKHgxICogeDEpIC8gKHJ4ICogcngpICsgKHkxICogeTEpIC8gKHJ5ICogcnkpO1xyXG4gICAgICAgICAgaWYgKGxhbWJkYSA+IDEpIHtcclxuICAgICAgICAgICAgcnggKj0gTWF0aC5zcXJ0KGxhbWJkYSk7XHJcbiAgICAgICAgICAgIHJ5ICo9IE1hdGguc3FydChsYW1iZGEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGV0IHIgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgcnggKiByeCAqIHJ5ICogcnkgLSByeCAqIHJ4ICogeTEgKiB5MSAtIHJ5ICogcnkgKiB4MSAqIHgxKSAvIChyeCAqIHJ4ICogeTEgKiB5MSArIHJ5ICogcnkgKiB4MSAqIHgxKSksXHJcbiAgICAgICAgICAgICAgeDIgPSAoZmEgPT09IGZzID8gLTEgOiAxKSAqIHIgKiByeCAqIHkxIC8gcnksXHJcbiAgICAgICAgICAgICAgeTIgPSAoZmEgPT09IGZzID8gMSA6IC0xKSAqIHIgKiByeSAqIHgxIC8gcng7XHJcbiAgICAgICAgICBsZXQgY3ggPSBNYXRoLmNvcyhmaSkgKiB4MiAtIE1hdGguc2luKGZpKSAqIHkyICsgKGN1cnJYICsgeCkgLyAyLFxyXG4gICAgICAgICAgICAgIGN5ID0gTWF0aC5zaW4oZmkpICogeDIgKyBNYXRoLmNvcyhmaSkgKiB5MiArIChjdXJyWSArIHkpIC8gMixcclxuICAgICAgICAgICAgICB0aDEgPSBNYXRoLmF0YW4yKCh5MSAtIHkyKSAvIHJ5LCAoeDEgLSB4MikgLyByeCksXHJcbiAgICAgICAgICAgICAgdGgyID0gTWF0aC5hdGFuMigoLXkxIC0geTIpIC8gcnksICgteDEgLSB4MikgLyByeCk7XHJcbiAgICAgICAgICBpZiAoZnMgPT09IDAgJiYgdGgyIC0gdGgxID4gMCkge1xyXG4gICAgICAgICAgICB0aDIgLT0gMiAqIE1hdGguUEk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGZzID09PSAxICYmIHRoMiAtIHRoMSA8IDApIHtcclxuICAgICAgICAgICAgdGgyICs9IDIgKiBNYXRoLlBJO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGV0IHNlZ21zID0gTWF0aC5jZWlsKE1hdGguYWJzKHRoMiAtIHRoMSkgLyAoTWF0aC5QSSAvIHByZWNpc2lvbikpO1xyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB0aDMgPSB0aDEgKyBpICogKHRoMiAtIHRoMSkgLyBzZWdtcyxcclxuICAgICAgICAgICAgICAgIHRoNCA9IHRoMSArIChpICsgMSkgKiAodGgyIC0gdGgxKSAvIHNlZ21zLFxyXG4gICAgICAgICAgICAgICAgdCA9IDQvMyAqIE1hdGgudGFuKCh0aDQgLSB0aDMpIC8gNCk7XHJcbiAgICAgICAgICAgIGxldCBjMXggPSBjeCArIE1hdGguY29zKGZpKSAqIHJ4ICogKE1hdGguY29zKHRoMykgLSB0ICogTWF0aC5zaW4odGgzKSkgLSBNYXRoLnNpbihmaSkgKiByeSAqIChNYXRoLnNpbih0aDMpICsgdCAqIE1hdGguY29zKHRoMykpLFxyXG4gICAgICAgICAgICAgICAgYzF5ID0gY3kgKyBNYXRoLnNpbihmaSkgKiByeCAqIChNYXRoLmNvcyh0aDMpIC0gdCAqIE1hdGguc2luKHRoMykpICsgTWF0aC5jb3MoZmkpICogcnkgKiAoTWF0aC5zaW4odGgzKSArIHQgKiBNYXRoLmNvcyh0aDMpKSxcclxuICAgICAgICAgICAgICAgIGMyeCA9IGN4ICsgTWF0aC5jb3MoZmkpICogcnggKiAoTWF0aC5jb3ModGg0KSArIHQgKiBNYXRoLnNpbih0aDQpKSAtIE1hdGguc2luKGZpKSAqIHJ5ICogKE1hdGguc2luKHRoNCkgLSB0ICogTWF0aC5jb3ModGg0KSksXHJcbiAgICAgICAgICAgICAgICBjMnkgPSBjeSArIE1hdGguc2luKGZpKSAqIHJ4ICogKE1hdGguY29zKHRoNCkgKyB0ICogTWF0aC5zaW4odGg0KSkgKyBNYXRoLmNvcyhmaSkgKiByeSAqIChNYXRoLnNpbih0aDQpIC0gdCAqIE1hdGguY29zKHRoNCkpLFxyXG4gICAgICAgICAgICAgICAgZW5kWCA9IGN4ICsgTWF0aC5jb3MoZmkpICogcnggKiBNYXRoLmNvcyh0aDQpIC0gTWF0aC5zaW4oZmkpICogcnkgKiBNYXRoLnNpbih0aDQpLFxyXG4gICAgICAgICAgICAgICAgZW5kWSA9IGN5ICsgTWF0aC5zaW4oZmkpICogcnggKiBNYXRoLmNvcyh0aDQpICsgTWF0aC5jb3MoZmkpICogcnkgKiBNYXRoLnNpbih0aDQpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZENvbW1hbmQoWydjdXJ2ZScsIChpID09PSAwKSwgKGkgPT09IHNlZ21zIC0gMSksIGMxeCwgYzF5LCBjMngsIGMyeSwgZW5kWCwgZW5kWV0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0Q29tID0gJ0EnO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmEgPSBmdW5jdGlvbihyeCwgcnksIGZpLCBmYSwgZnMsIHgsIHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5BKHJ4LCByeSwgZmksIGZhLCBmcywgY3VyclggKyB4LCBjdXJyWSArIHkpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLnBhdGggPSBmdW5jdGlvbihkKSB7XHJcbiAgICAgICAgbGV0IGNvbW1hbmQsIHZhbHVlLCB0ZW1wLFxyXG4gICAgICAgICAgICBwYXJzZXIgPSBuZXcgU3RyaW5nUGFyc2VyKChkIHx8ICcnKS50cmltKCkpO1xyXG4gICAgICAgIHdoaWxlIChjb21tYW5kID0gcGFyc2VyLm1hdGNoKC9eW2FzdHZ6cW1obGNBU1RWWlFNSExDXS8pKSB7XHJcbiAgICAgICAgICBwYXJzZXIubWF0Y2hTZXBhcmF0b3IoKTtcclxuICAgICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcclxuICAgICAgICAgIHdoaWxlICh2YWx1ZSA9IChQYXRoRmxhZ3NbY29tbWFuZCArIHZhbHVlcy5sZW5ndGhdID8gcGFyc2VyLm1hdGNoKC9eWzAxXS8pIDogcGFyc2VyLm1hdGNoTnVtYmVyKCkpKSB7XHJcbiAgICAgICAgICAgIHBhcnNlci5tYXRjaFNlcGFyYXRvcigpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gUGF0aEFyZ3VtZW50c1tjb21tYW5kXSkge1xyXG4gICAgICAgICAgICAgIHRoaXNbY29tbWFuZF0uYXBwbHkodGhpcywgdmFsdWVzKTtcclxuICAgICAgICAgICAgICB2YWx1ZXMgPSBbXTtcclxuICAgICAgICAgICAgICBpZiAoY29tbWFuZCA9PT0gJ00nKSB7Y29tbWFuZCA9ICdMJzt9XHJcbiAgICAgICAgICAgICAgZWxzZSBpZiAoY29tbWFuZCA9PT0gJ20nKSB7Y29tbWFuZCA9ICdsJzt9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsdWVzLnB1c2goTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gUGF0aEFyZ3VtZW50c1tjb21tYW5kXSkge1xyXG4gICAgICAgICAgICB0aGlzW2NvbW1hbmRdLmFwcGx5KHRoaXMsIHZhbHVlcyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB3YXJuaW5nQ2FsbGJhY2soJ1N2Z1BhdGg6IGNvbW1hbmQgJyArIGNvbW1hbmQgKyAnIHdpdGggJyArIHZhbHVlcy5sZW5ndGggKyAnIG51bWJlcnMnKTsgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGVtcCA9IHBhcnNlci5tYXRjaEFsbCgpKSB7XHJcbiAgICAgICAgICB3YXJuaW5nQ2FsbGJhY2soJ1N2Z1BhdGg6IHVuZXhwZWN0ZWQgc3RyaW5nICcgKyB0ZW1wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBsZXQgYmJveCA9IFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcclxuICAgICAgICBmdW5jdGlvbiBhZGRCb3VuZHMoYmJveDEpIHtcclxuICAgICAgICAgIGlmIChiYm94MVswXSA8IGJib3hbMF0pIHtiYm94WzBdID0gYmJveDFbMF07fVxyXG4gICAgICAgICAgaWYgKGJib3gxWzJdID4gYmJveFsyXSkge2Jib3hbMl0gPSBiYm94MVsyXTt9XHJcbiAgICAgICAgICBpZiAoYmJveDFbMV0gPCBiYm94WzFdKSB7YmJveFsxXSA9IGJib3gxWzFdO31cclxuICAgICAgICAgIGlmIChiYm94MVszXSA+IGJib3hbM10pIHtiYm94WzNdID0gYmJveDFbM107fVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aFNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBhZGRCb3VuZHModGhpcy5wYXRoU2VnbWVudHNbaV0uZ2V0Qm91bmRpbmdCb3goKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiYm94WzBdID09PSBJbmZpbml0eSkge2Jib3hbMF0gPSAwO31cclxuICAgICAgICBpZiAoYmJveFsxXSA9PT0gSW5maW5pdHkpIHtiYm94WzFdID0gMDt9XHJcbiAgICAgICAgaWYgKGJib3hbMl0gPT09IC1JbmZpbml0eSkge2Jib3hbMl0gPSAwO31cclxuICAgICAgICBpZiAoYmJveFszXSA9PT0gLUluZmluaXR5KSB7YmJveFszXSA9IDA7fVxyXG4gICAgICAgIHJldHVybiBiYm94O1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmdldFBvaW50QXRMZW5ndGggPSBmdW5jdGlvbihsKSB7XHJcbiAgICAgICAgaWYgKGwgPj0gMCAmJiBsIDw9IHRoaXMudG90YWxMZW5ndGgpIHtcclxuICAgICAgICAgIGxldCB0ZW1wO1xyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhdGhTZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGVtcCA9IHRoaXMucGF0aFNlZ21lbnRzW2ldLmdldFBvaW50QXRMZW5ndGgobCkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gdGVtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsIC09IHRoaXMucGF0aFNlZ21lbnRzW2ldLnRvdGFsTGVuZ3RoO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5kUG9pbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKG0pIHtcclxuICAgICAgICB0aGlzLnBhdGhTZWdtZW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3RhcnRQb2ludCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbmRQb2ludCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50b3RhbExlbmd0aCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhdGhDb21tYW5kcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbGV0IGRhdGEgPSB0aGlzLnBhdGhDb21tYW5kcy5zaGlmdCgpO1xyXG4gICAgICAgICAgZm9yIChsZXQgaiA9IDM7IGogPCBkYXRhLmxlbmd0aDsgais9Mikge1xyXG4gICAgICAgICAgICBsZXQgcCA9IHRyYW5zZm9ybVBvaW50KFtkYXRhW2pdLCBkYXRhW2ogKyAxXV0sIG0pXHJcbiAgICAgICAgICAgIGRhdGFbal0gPSBwWzBdO1xyXG4gICAgICAgICAgICBkYXRhW2ogKyAxXSA9IHBbMV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLmFkZENvbW1hbmQoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzOyAgICAgICAgXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMubWVyZ2VTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZS5wYXRoQ29tbWFuZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHRoaXMuYWRkQ29tbWFuZChzaGFwZS5wYXRoQ29tbWFuZHNbaV0uc2xpY2UoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTdmdTaGFwZSgpLm1lcmdlU2hhcGUodGhpcyk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuaW5zZXJ0SW5Eb2N1bWVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXRoQ29tbWFuZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGxldCBjb21tYW5kID0gdGhpcy5wYXRoQ29tbWFuZHNbaV1bMF0sIHZhbHVlcyA9IHRoaXMucGF0aENvbW1hbmRzW2ldLnNsaWNlKDMpO1xyXG4gICAgICAgICAgc3dpdGNoKGNvbW1hbmQpIHtcclxuICAgICAgICAgICAgY2FzZSAnbW92ZSc6ICBkb2MubW92ZVRvKHZhbHVlc1swXSwgdmFsdWVzWzFdKTsgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdsaW5lJzogIGRvYy5saW5lVG8odmFsdWVzWzBdLCB2YWx1ZXNbMV0pOyAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2N1cnZlJzogIGRvYy5iZXppZXJDdXJ2ZVRvKHZhbHVlc1swXSwgdmFsdWVzWzFdLCB2YWx1ZXNbMl0sIHZhbHVlc1szXSwgdmFsdWVzWzRdLCB2YWx1ZXNbNV0pOyAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2Nsb3NlJzogIGRvYy5jbG9zZVBhdGgoKTsgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgdGhpcy5nZXRTdWJQYXRocyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGxldCBzdWJQYXRocyA9IFtdLCBzaGFwZSA9IG5ldyBTdmdTaGFwZSgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXRoQ29tbWFuZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGxldCBkYXRhID0gdGhpcy5wYXRoQ29tbWFuZHNbaV0sIGNvbW1hbmQgPSB0aGlzLnBhdGhDb21tYW5kc1tpXVswXTtcclxuICAgICAgICAgIGlmIChjb21tYW5kID09PSAnbW92ZScgJiYgaSAhPT0gMCkge1xyXG4gICAgICAgICAgICBzdWJQYXRocy5wdXNoKHNoYXBlKTtcclxuICAgICAgICAgICAgc2hhcGUgPSBuZXcgU3ZnU2hhcGUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHNoYXBlLmFkZENvbW1hbmQoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1YlBhdGhzLnB1c2goc2hhcGUpO1xyXG4gICAgICAgIHJldHVybiBzdWJQYXRocztcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5nZXRNYXJrZXJzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgbGV0IG1hcmtlcnMgPSBbXSwgc3ViUGF0aHMgPSB0aGlzLmdldFN1YlBhdGhzKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJQYXRocy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbGV0IHN1YlBhdGggPSBzdWJQYXRoc1tpXSwgc3ViUGF0aE1hcmtlcnMgPSBbXTtcclxuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3ViUGF0aC5wYXRoU2VnbWVudHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgbGV0IHNlZ21lbnQgPSBzdWJQYXRoLnBhdGhTZWdtZW50c1tqXTtcclxuICAgICAgICAgICAgaWYgKGlzTm90RXF1YWwoc2VnbWVudC50b3RhbExlbmd0aCwgMCkgfHwgaiA9PT0gMCB8fCBqID09PSBzdWJQYXRoLnBhdGhTZWdtZW50cy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHNlZ21lbnQuaGFzU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdGFydE1hcmtlciA9IHNlZ21lbnQuZ2V0UG9pbnRBdExlbmd0aCgwKSwgcHJldkVuZE1hcmtlciA9IHN1YlBhdGhNYXJrZXJzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZFbmRNYXJrZXIpIHtzdGFydE1hcmtlclsyXSA9IDAuNSAqIChwcmV2RW5kTWFya2VyWzJdICsgc3RhcnRNYXJrZXJbMl0pO31cclxuICAgICAgICAgICAgICAgIHN1YlBhdGhNYXJrZXJzLnB1c2goc3RhcnRNYXJrZXIpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBpZiAoc2VnbWVudC5oYXNFbmQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBlbmRNYXJrZXIgPSBzZWdtZW50LmdldFBvaW50QXRMZW5ndGgoc2VnbWVudC50b3RhbExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBzdWJQYXRoTWFya2Vycy5wdXNoKGVuZE1hcmtlcik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBtYXJrZXJzID0gbWFya2Vycy5jb25jYXQoc3ViUGF0aE1hcmtlcnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWFya2VycztcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIFN2Z0VsZW0gPSBmdW5jdGlvbihvYmosIGluaGVyaXRzKSB7XHJcbiAgICAgIGxldCBzdHlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgbGV0IGNoaWxkcmVuQ2FjaGUgPSBudWxsO1xyXG4gICAgICB0aGlzLm5hbWUgPSBvYmoubm9kZU5hbWU7XHJcbiAgICAgIHRoaXMuaXNPdXRlckVsZW1lbnQgPSBvYmogPT09IHN2ZyB8fCAhb2JqLnBhcmVudE5vZGU7XHJcbiAgICAgIHRoaXMuaW5oZXJpdHMgPSBpbmhlcml0cyB8fCAoIXRoaXMuaXNPdXRlckVsZW1lbnQgPyBjcmVhdGVTVkdFbGVtZW50KG9iai5wYXJlbnROb2RlLCBudWxsKSA6IG51bGwpO1xyXG4gICAgICB0aGlzLnN0YWNrID0gKHRoaXMuaW5oZXJpdHMgPyB0aGlzLmluaGVyaXRzLnN0YWNrLmNvbmNhdChvYmopIDogW29ial0pO1xyXG4gICAgICB0aGlzLnN0eWxlID0gcGFyc2VTdHlsZUF0dHIodHlwZW9mIG9iai5nZXRBdHRyaWJ1dGUgPT09ICdmdW5jdGlvbicgJiYgb2JqLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSk7XHJcbiAgICAgIHRoaXMuY3NzID0gdXNlQ1NTID8gZ2V0Q29tcHV0ZWRTdHlsZShvYmopIDogZ2V0U3R5bGUob2JqKTtcclxuICAgICAgdGhpcy5hbGxvd2VkQ2hpbGRyZW4gPSBbXTtcclxuICAgICAgdGhpcy5hdHRyID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmouZ2V0QXR0cmlidXRlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICByZXR1cm4gb2JqLmdldEF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgdGhpcy5yZXNvbHZlVXJsID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBsZXQgdGVtcCA9ICh2YWx1ZSB8fCAnJykubWF0Y2goL15cXHMqKD86dXJsXFwoXCIoLiopIyguKilcIlxcKXx1cmxcXCgnKC4qKSMoLiopJ1xcKXx1cmxcXCgoLiopIyguKilcXCl8KC4qKSMoLiopKVxccyokLykgfHwgW107XHJcbiAgICAgICAgbGV0IGZpbGUgPSB0ZW1wWzFdIHx8IHRlbXBbM10gfHwgdGVtcFs1XSB8fCB0ZW1wWzddLFxyXG4gICAgICAgICAgICBpZCA9IHRlbXBbMl0gfHwgdGVtcFs0XSB8fCB0ZW1wWzZdIHx8IHRlbXBbOF07XHJcbiAgICAgICAgaWYgKGlkKSB7XHJcbiAgICAgICAgICBpZiAoIWZpbGUpIHtcclxuICAgICAgICAgICAgbGV0IHN2Z09iaiA9IHN2Zy5nZXRFbGVtZW50QnlJZChpZCk7XHJcbiAgICAgICAgICAgIGlmIChzdmdPYmopIHtcclxuICAgICAgICAgICAgICBpZiAodGhpcy5zdGFjay5pbmRleE9mKHN2Z09iaikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ZnT2JqO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuaW5nQ2FsbGJhY2soJ1NWR3RvUERGOiBsb29wIG9mIGNpcmN1bGFyIHJlZmVyZW5jZXMgZm9yIGlkIFwiJyArIGlkICsgJ1wiJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoZG9jdW1lbnRDYWxsYmFjaykge1xyXG4gICAgICAgICAgICBsZXQgc3ZncyA9IGRvY3VtZW50Q2FjaGVbZmlsZV07XHJcbiAgICAgICAgICAgIGlmICghc3Zncykge1xyXG4gICAgICAgICAgICAgIHN2Z3MgPSBkb2N1bWVudENhbGxiYWNrKGZpbGUpO1xyXG4gICAgICAgICAgICAgIGlmICghaXNBcnJheUxpa2Uoc3ZncykpIHtzdmdzID0gW3N2Z3NdO31cclxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN2Z3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3Znc1tpXSA9PT0gJ3N0cmluZycpIHtzdmdzW2ldID0gcGFyc2VYbWwoc3Znc1tpXSk7fVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBkb2N1bWVudENhY2hlW2ZpbGVdID0gc3ZncztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN2Z3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBsZXQgc3ZnT2JqID0gc3Znc1tpXS5nZXRFbGVtZW50QnlJZChpZCk7XHJcbiAgICAgICAgICAgICAgaWYgKHN2Z09iaikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2suaW5kZXhPZihzdmdPYmopID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gc3ZnT2JqO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgd2FybmluZ0NhbGxiYWNrKCdTVkd0b1BERjogbG9vcCBvZiBjaXJjdWxhciByZWZlcmVuY2VzIGZvciBpZCBcIicgKyBmaWxlICsgJyMnICsgaWQgKyAnXCInKTtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgdGhpcy5jb21wdXRlVW5pdHMgPSBmdW5jdGlvbih2YWx1ZSwgdW5pdCwgcGVyY2VudCwgaXNGb250U2l6ZSkge1xyXG4gICAgICAgIGlmICh1bml0ID09PSAnJScpIHtcclxuICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIChpc0ZvbnRTaXplIHx8IHBlcmNlbnQgIT0gbnVsbCA/IHBlcmNlbnQgOiB0aGlzLmdldFZpZXdwb3J0KCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gJ2V4JyB8fCB1bml0ID09PSAnZW0nKSB7XHJcbiAgICAgICAgICByZXR1cm4gdmFsdWUgKiB7J2VtJzoxLCAnZXgnOjAuNX1bdW5pdF0gKiAoaXNGb250U2l6ZSA/IHBlcmNlbnQgOiB0aGlzLmdldCgnZm9udC1zaXplJykpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gdmFsdWUgKiB7Jyc6MSwgJ3B4JzoxLCAncHQnOjk2LzcyLCAnY20nOjk2LzIuNTQsICdtbSc6OTYvMjUuNCwgJ2luJzo5NiwgJ3BjJzo5Ni82fVt1bml0XTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuY29tcHV0ZUxlbmd0aCA9IGZ1bmN0aW9uKHZhbHVlLCBwZXJjZW50LCBpbml0aWFsLCBpc0ZvbnRTaXplKSB7XHJcbiAgICAgICAgbGV0IHBhcnNlciA9IG5ldyBTdHJpbmdQYXJzZXIoKHZhbHVlIHx8ICcnKS50cmltKCkpLCB0ZW1wMSwgdGVtcDI7XHJcbiAgICAgICAgaWYgKHR5cGVvZiAodGVtcDEgPSBwYXJzZXIubWF0Y2hOdW1iZXIoKSkgPT09ICdzdHJpbmcnICYmIHR5cGVvZiAodGVtcDIgPSBwYXJzZXIubWF0Y2hMZW5ndGhVbml0KCkpID09PSAnc3RyaW5nJyAmJiAhcGFyc2VyLm1hdGNoQWxsKCkpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVVbml0cyh0ZW1wMSwgdGVtcDIsIHBlcmNlbnQsIGlzRm9udFNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5pdGlhbDtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5jb21wdXRlTGVuZ3RoTGlzdCA9IGZ1bmN0aW9uKHZhbHVlLCBwZXJjZW50LCBzdHJpY3QpIHtcclxuICAgICAgICBsZXQgcGFyc2VyID0gbmV3IFN0cmluZ1BhcnNlcigodmFsdWUgfHwgJycpLnRyaW0oKSksIHJlc3VsdCA9IFtdLCB0ZW1wMSwgdGVtcDI7XHJcbiAgICAgICAgd2hpbGUgKHR5cGVvZiAodGVtcDEgPSBwYXJzZXIubWF0Y2hOdW1iZXIoKSkgPT09ICdzdHJpbmcnICYmIHR5cGVvZiAodGVtcDIgPSBwYXJzZXIubWF0Y2hMZW5ndGhVbml0KCkpID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jb21wdXRlVW5pdHModGVtcDEsIHRlbXAyLCBwZXJjZW50KSk7XHJcbiAgICAgICAgICBwYXJzZXIubWF0Y2hTZXBhcmF0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0cmljdCAmJiBwYXJzZXIubWF0Y2hBbGwoKSkge3JldHVybjt9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbihrZXksIHBlcmNlbnQsIGluaXRpYWwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlTGVuZ3RoKHRoaXMuYXR0cihrZXkpLCBwZXJjZW50LCBpbml0aWFsKTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5nZXRMZW5ndGhMaXN0ID0gZnVuY3Rpb24oa2V5LCBwZXJjZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUxlbmd0aExpc3QodGhpcy5hdHRyKGtleSksIHBlcmNlbnQpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmdldFVybCA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVVcmwodGhpcy5hdHRyKGtleSkpXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZ2V0TnVtYmVyTGlzdCA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgIGxldCBwYXJzZXIgPSBuZXcgU3RyaW5nUGFyc2VyKCh0aGlzLmF0dHIoa2V5KSB8fCAnJykudHJpbSgpKSwgcmVzdWx0ID0gW10sIHRlbXA7XHJcbiAgICAgICAgd2hpbGUgKHRlbXAgPSBwYXJzZXIubWF0Y2hOdW1iZXIoKSkge1xyXG4gICAgICAgICAgcmVzdWx0LnB1c2goTnVtYmVyKHRlbXApKTtcclxuICAgICAgICAgIHBhcnNlci5tYXRjaFNlcGFyYXRvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQuZXJyb3IgPSBwYXJzZXIubWF0Y2hBbGwoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZ2V0Vmlld2JveCA9IGZ1bmN0aW9uKGtleSwgaW5pdGlhbCkge1xyXG4gICAgICAgIGxldCB2aWV3Qm94ID0gdGhpcy5nZXROdW1iZXJMaXN0KGtleSk7XHJcbiAgICAgICAgaWYgKHZpZXdCb3gubGVuZ3RoID09PSA0ICYmIHZpZXdCb3hbMl0gPj0gMCAmJiB2aWV3Qm94WzNdID49IDApIHtyZXR1cm4gdmlld0JveDt9XHJcbiAgICAgICAgcmV0dXJuIGluaXRpYWw7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZ2V0UGVyY2VudCA9IGZ1bmN0aW9uKGtleSwgaW5pdGlhbCkge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuYXR0cihrZXkpO1xyXG4gICAgICAgIGxldCBwYXJzZXIgPSBuZXcgU3RyaW5nUGFyc2VyKCh2YWx1ZSB8fCAnJykudHJpbSgpKSwgdGVtcDEsIHRlbXAyO1xyXG4gICAgICAgIGxldCBudW1iZXIgPSBwYXJzZXIubWF0Y2hOdW1iZXIoKTtcclxuICAgICAgICBpZiAoIW51bWJlcikge3JldHVybiBpbml0aWFsO31cclxuICAgICAgICBpZiAocGFyc2VyLm1hdGNoKCclJykpIHtudW1iZXIgKj0gMC4wMTt9XHJcbiAgICAgICAgaWYgKHBhcnNlci5tYXRjaEFsbCgpKSB7cmV0dXJuIGluaXRpYWw7fVxyXG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBudW1iZXIpKTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5jaG9vc2VWYWx1ZSA9IGZ1bmN0aW9uKGFyZ3MpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSAhPSBudWxsICYmIGFyZ3VtZW50c1tpXSA9PT0gYXJndW1lbnRzW2ldKSB7cmV0dXJuIGFyZ3VtZW50c1tpXTt9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmdldCA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICAgIGlmIChzdHlsZUNhY2hlW2tleV0gIT09IHVuZGVmaW5lZCkge3JldHVybiBzdHlsZUNhY2hlW2tleV07fVxyXG4gICAgICAgIGxldCBrZXlJbmZvID0gUHJvcGVydGllc1trZXldIHx8IHt9LCB2YWx1ZSwgcmVzdWx0O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKGkpIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgIGlmIChrZXkgIT09ICd0cmFuc2Zvcm0nKSB7IC8vIHRoZSBDU1MgdHJhbnNmb3JtIGJlaGF2ZXMgc3RyYW5nZWx5XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuY3NzW2tleUluZm8uY3NzIHx8IGtleV07XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnN0eWxlW2tleV07XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuYXR0cihrZXkpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnaW5oZXJpdCcpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gKHRoaXMuaW5oZXJpdHMgPyB0aGlzLmluaGVyaXRzLmdldChrZXkpIDoga2V5SW5mby5pbml0aWFsKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7cmV0dXJuIHN0eWxlQ2FjaGVba2V5XSA9IHJlc3VsdDt9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoa2V5SW5mby52YWx1ZXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBrZXlJbmZvLnZhbHVlc1t2YWx1ZV07XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge3JldHVybiBzdHlsZUNhY2hlW2tleV0gPSByZXN1bHQ7fVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgbGV0IHBhcnNlZDtcclxuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICAgICAgICBjYXNlICdmb250LXNpemUnOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jb21wdXRlTGVuZ3RoKHZhbHVlLCB0aGlzLmluaGVyaXRzID8gdGhpcy5pbmhlcml0cy5nZXQoa2V5KSA6IGtleUluZm8uaW5pdGlhbCwgdW5kZWZpbmVkLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgJ2Jhc2VsaW5lLXNoaWZ0JzpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY29tcHV0ZUxlbmd0aCh2YWx1ZSwgdGhpcy5nZXQoJ2ZvbnQtc2l6ZScpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgJ2ZvbnQtZmFtaWx5JzpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlIHx8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgJ29wYWNpdHknOiBjYXNlICdzdHJva2Utb3BhY2l0eSc6IGNhc2UgJ2ZpbGwtb3BhY2l0eSc6IGNhc2UgJ3N0b3Atb3BhY2l0eSc6XHJcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBwYXJzZUZsb2F0KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VkKSkge1xyXG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwYXJzZWQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgJ3RyYW5zZm9ybSc6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZVRyYW5mb3JtKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgJ3N0cm9rZS1kYXNoYXJyYXknOlxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlZCA9IHRoaXMuY29tcHV0ZUxlbmd0aExpc3QodmFsdWUsIHRoaXMuZ2V0Vmlld3BvcnQoKSwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgbGV0IHN1bSA9IDAsIGVycm9yID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGFyc2VkLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZFtqXSA8IDApIHtlcnJvciA9IHRydWU7fVxyXG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBwYXJzZWRbal07XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQubGVuZ3RoICUgMiA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gcGFyc2VkLmNvbmNhdChwYXJzZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAoc3VtID09PSAwID8gW10gOiBwYXJzZWQpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlICdjb2xvcic6XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09ICdub25lJyB8fCB2YWx1ZSA9PT0gJ3RyYW5zcGFyZW50Jykge1xyXG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZUNvbG9yKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgJ2ZpbGwnOiBjYXNlICdzdHJva2UnOlxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnbm9uZScgfHwgdmFsdWUgPT09ICd0cmFuc3BhcmVudCcpIHtcclxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJ2N1cnJlbnRDb2xvcicpIHtcclxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5nZXQoJ2NvbG9yJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlZCA9IHBhcnNlQ29sb3IodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlZCA9ICh2YWx1ZSB8fCAnJykuc3BsaXQoJyAnKSkge1xyXG4gICAgICAgICAgICAgICAgICBsZXQgb2JqZWN0ID0gdGhpcy5yZXNvbHZlVXJsKHBhcnNlZFswXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFja0NvbG9yID0gcGFyc2VDb2xvcihwYXJzZWRbMV0pO1xyXG4gICAgICAgICAgICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxsYmFja0NvbG9yO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdC5ub2RlTmFtZSA9PT0gJ2xpbmVhckdyYWRpZW50JyB8fCBvYmplY3Qubm9kZU5hbWUgPT09ICdyYWRpYWxHcmFkaWVudCcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgU3ZnRWxlbUdyYWRpZW50KG9iamVjdCwgbnVsbCwgZmFsbGJhY2tDb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0Lm5vZGVOYW1lID09PSAncGF0dGVybicpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgU3ZnRWxlbVBhdHRlcm4ob2JqZWN0LCBudWxsLCBmYWxsYmFja0NvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxsYmFja0NvbG9yO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlICdzdG9wLWNvbG9yJzpcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJ25vbmUnIHx8IHZhbHVlID09PSAndHJhbnNwYXJlbnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICdub25lJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICdjdXJyZW50Q29sb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZ2V0KCdjb2xvcicpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VDb2xvcih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlICdtYXJrZXItc3RhcnQnOiBjYXNlICdtYXJrZXItbWlkJzogY2FzZSAnbWFya2VyLWVuZCc6IGNhc2UgJ2NsaXAtcGF0aCc6IGNhc2UgJ21hc2snOlxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXNvbHZlVXJsKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgJ3N0cm9rZS13aWR0aCc6XHJcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSB0aGlzLmNvbXB1dGVMZW5ndGgodmFsdWUsIHRoaXMuZ2V0Vmlld3BvcnQoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkICE9IG51bGwgJiYgcGFyc2VkID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgY2FzZSAnc3Ryb2tlLW1pdGVybGltaXQnOlxyXG4gICAgICAgICAgICAgICAgcGFyc2VkID0gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkICE9IG51bGwgJiYgcGFyc2VkID49IDEpIHtcclxuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFyc2VkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgY2FzZSAnd29yZC1zcGFjaW5nJzogY2FzZSAnbGV0dGVyLXNwYWNpbmcnOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jb21wdXRlTGVuZ3RoKHZhbHVlLCB0aGlzLmdldFZpZXdwb3J0KCkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgY2FzZSAnc3Ryb2tlLWRhc2hvZmZzZXQnOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jb21wdXRlTGVuZ3RoKHZhbHVlLCB0aGlzLmdldFZpZXdwb3J0KCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPCAwKSB7IC8vIGZpeCBmb3IgY3JidWcuY29tLzY2MDg1MFxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXNoYXJyYXkgPSB0aGlzLmdldCgnc3Ryb2tlLWRhc2hhcnJheScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGFzaGFycmF5Lmxlbmd0aDsgaisrKSB7cmVzdWx0ICs9IGRhc2hhcnJheVtqXTt9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge3JldHVybiBzdHlsZUNhY2hlW2tleV0gPSByZXN1bHQ7fVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3R5bGVDYWNoZVtrZXldID0gKGtleUluZm8uaW5oZXJpdCAmJiB0aGlzLmluaGVyaXRzID8gdGhpcy5pbmhlcml0cy5nZXQoa2V5KSA6IGtleUluZm8uaW5pdGlhbCk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoY2hpbGRyZW5DYWNoZSAhPSBudWxsKSB7cmV0dXJuIGNoaWxkcmVuQ2FjaGU7fVxyXG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGxldCBjaGlsZCA9IG9iai5jaGlsZE5vZGVzW2ldO1xyXG4gICAgICAgICAgaWYgKCFjaGlsZC5lcnJvciAmJiB0aGlzLmFsbG93ZWRDaGlsZHJlbi5pbmRleE9mKGNoaWxkLm5vZGVOYW1lKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjcmVhdGVTVkdFbGVtZW50KGNoaWxkLCB0aGlzKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjaGlsZHJlbkNhY2hlID0gY2hpbGRyZW47XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZ2V0UGFyZW50VldpZHRoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmluaGVyaXRzID8gdGhpcy5pbmhlcml0cy5nZXRWV2lkdGgoKTogdmlld3BvcnRXaWR0aCk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZ2V0UGFyZW50VkhlaWdodCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5pbmhlcml0cyA/IHRoaXMuaW5oZXJpdHMuZ2V0VkhlaWdodCgpIDogdmlld3BvcnRIZWlnaHQpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmdldFBhcmVudFZpZXdwb3J0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgwLjUgKiB0aGlzLmdldFBhcmVudFZXaWR0aCgpICogdGhpcy5nZXRQYXJlbnRWV2lkdGgoKSArIDAuNSAqIHRoaXMuZ2V0UGFyZW50VkhlaWdodCgpICogdGhpcy5nZXRQYXJlbnRWSGVpZ2h0KCkpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmdldFZXaWR0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhcmVudFZXaWR0aCgpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmdldFZIZWlnaHQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJlbnRWSGVpZ2h0KCk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZ2V0Vmlld3BvcnQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDAuNSAqIHRoaXMuZ2V0VldpZHRoKCkgKiB0aGlzLmdldFZXaWR0aCgpICsgMC41ICogdGhpcy5nZXRWSGVpZ2h0KCkgKiB0aGlzLmdldFZIZWlnaHQoKSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBsZXQgc2hhcGUgPSB0aGlzLmdldEJvdW5kaW5nU2hhcGUoKTtcclxuICAgICAgICByZXR1cm4gc2hhcGUuZ2V0Qm91bmRpbmdCb3goKTtcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIFN2Z0VsZW1TdHlsYWJsZSA9IGZ1bmN0aW9uKG9iaiwgaW5oZXJpdHMpIHtcclxuICAgICAgU3ZnRWxlbS5jYWxsKHRoaXMsIG9iaiwgaW5oZXJpdHMpO1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGRvYy50cmFuc2Zvcm0uYXBwbHkoZG9jLCB0aGlzLmdldFRyYW5zZm9ybWF0aW9uKCkpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmNsaXAgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5nZXQoJ2NsaXAtcGF0aCcpICE9PSAnbm9uZScpIHtcclxuICAgICAgICAgIGxldCBjbGlwUGF0aCA9IG5ldyBTdmdFbGVtQ2xpcFBhdGgodGhpcy5nZXQoJ2NsaXAtcGF0aCcpLCBudWxsKTtcclxuICAgICAgICAgIGNsaXBQYXRoLnVzZU1hc2sodGhpcy5nZXRCb3VuZGluZ0JveCgpKTtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgdGhpcy5tYXNrID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0KCdtYXNrJykgIT09ICdub25lJykge1xyXG4gICAgICAgICAgbGV0IG1hc2sgPSBuZXcgU3ZnRWxlbU1hc2sodGhpcy5nZXQoJ21hc2snKSwgbnVsbCk7XHJcbiAgICAgICAgICBtYXNrLnVzZU1hc2sodGhpcy5nZXRCb3VuZGluZ0JveCgpKTtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgdGhpcy5nZXRGaWxsID0gZnVuY3Rpb24oaXNDbGlwLCBpc01hc2spIHtcclxuICAgICAgICBsZXQgb3BhY2l0eSA9IHRoaXMuZ2V0KCdvcGFjaXR5JyksXHJcbiAgICAgICAgICAgIGZpbGwgPSB0aGlzLmdldCgnZmlsbCcpLFxyXG4gICAgICAgICAgICBmaWxsT3BhY2l0eSA9IHRoaXMuZ2V0KCdmaWxsLW9wYWNpdHknKTtcclxuICAgICAgICBpZiAoaXNDbGlwKSB7cmV0dXJuIERlZmF1bHRDb2xvcnMud2hpdGU7fVxyXG4gICAgICAgIGlmIChmaWxsICE9PSAnbm9uZScgJiYgb3BhY2l0eSAmJiBmaWxsT3BhY2l0eSkge1xyXG4gICAgICAgICAgaWYgKGZpbGwgaW5zdGFuY2VvZiBTdmdFbGVtR3JhZGllbnQgfHwgZmlsbCBpbnN0YW5jZW9mIFN2Z0VsZW1QYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWxsLmdldFBhaW50KHRoaXMuZ2V0Qm91bmRpbmdCb3goKSwgZmlsbE9wYWNpdHkgKiBvcGFjaXR5LCBpc0NsaXAsIGlzTWFzayk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gb3BhY2l0eVRvQ29sb3IoZmlsbCwgZmlsbE9wYWNpdHkgKiBvcGFjaXR5LCBpc01hc2spO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgdGhpcy5nZXRTdHJva2UgPSBmdW5jdGlvbihpc0NsaXAsIGlzTWFzaykge1xyXG4gICAgICAgIGxldCBvcGFjaXR5ID0gdGhpcy5nZXQoJ29wYWNpdHknKSxcclxuICAgICAgICAgICAgc3Ryb2tlID0gdGhpcy5nZXQoJ3N0cm9rZScpLFxyXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5ID0gdGhpcy5nZXQoJ3N0cm9rZS1vcGFjaXR5Jyk7XHJcbiAgICAgICAgaWYgKGlzQ2xpcCB8fCBpc0VxdWFsKHRoaXMuZ2V0KCdzdHJva2Utd2lkdGgnKSwgMCkpIHtyZXR1cm47fVxyXG4gICAgICAgIGlmIChzdHJva2UgIT09ICdub25lJyAmJiBvcGFjaXR5ICYmIHN0cm9rZU9wYWNpdHkpIHtcclxuICAgICAgICAgIGlmIChzdHJva2UgaW5zdGFuY2VvZiBTdmdFbGVtR3JhZGllbnQgfHwgc3Ryb2tlIGluc3RhbmNlb2YgU3ZnRWxlbVBhdHRlcm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cm9rZS5nZXRQYWludCh0aGlzLmdldEJvdW5kaW5nQm94KCksIHN0cm9rZU9wYWNpdHkgKiBvcGFjaXR5LCBpc0NsaXAsIGlzTWFzayk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gb3BhY2l0eVRvQ29sb3Ioc3Ryb2tlLCBzdHJva2VPcGFjaXR5ICogb3BhY2l0eSwgaXNNYXNrKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBTdmdFbGVtSGFzQ2hpbGRyZW4gPSBmdW5jdGlvbihvYmosIGluaGVyaXRzKSB7XHJcbiAgICAgIFN2Z0VsZW1TdHlsYWJsZS5jYWxsKHRoaXMsIG9iaiwgaW5oZXJpdHMpO1xyXG4gICAgICB0aGlzLmFsbG93ZWRDaGlsZHJlbiA9IFsndXNlJywgJ2cnLCAnYScsICdzdmcnLCAnaW1hZ2UnLCAncmVjdCcsICdjaXJjbGUnLCAnZWxsaXBzZScsICdsaW5lJywgJ3BvbHlsaW5lJywgJ3BvbHlnb24nLCAncGF0aCcsICd0ZXh0J107XHJcbiAgICAgIHRoaXMuZ2V0Qm91bmRpbmdTaGFwZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGxldCBzaGFwZSA9IG5ldyBTdmdTaGFwZSgpLFxyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoY2hpbGRyZW5baV0uZ2V0KCdkaXNwbGF5JykgIT09ICdub25lJykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkcmVuW2ldLmdldEJvdW5kaW5nU2hhcGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICBsZXQgY2hpbGRTaGFwZSA9IGNoaWxkcmVuW2ldLmdldEJvdW5kaW5nU2hhcGUoKS5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW5baV0uZ2V0VHJhbnNmb3JtYXRpb24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkU2hhcGUudHJhbnNmb3JtKGNoaWxkcmVuW2ldLmdldFRyYW5zZm9ybWF0aW9uKCkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBzaGFwZS5tZXJnZVNoYXBlKGNoaWxkU2hhcGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaGFwZTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5kcmF3Q2hpbGRyZW4gPSBmdW5jdGlvbihpc0NsaXAsIGlzTWFzaykge1xyXG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoY2hpbGRyZW5baV0uZ2V0KCdkaXNwbGF5JykgIT09ICdub25lJykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoaWxkcmVuW2ldLmRyYXdJbkRvY3VtZW50ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgY2hpbGRyZW5baV0uZHJhd0luRG9jdW1lbnQoaXNDbGlwLCBpc01hc2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgU3ZnRWxlbUNvbnRhaW5lciA9IGZ1bmN0aW9uKG9iaiwgaW5oZXJpdHMpIHtcclxuICAgICAgU3ZnRWxlbUhhc0NoaWxkcmVuLmNhbGwodGhpcywgb2JqLCBpbmhlcml0cyk7XHJcbiAgICAgIHRoaXMuZHJhd0NvbnRlbnQgPSBmdW5jdGlvbihpc0NsaXAsIGlzTWFzaykge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtKCk7XHJcbiAgICAgICAgbGV0IGNsaXBwZWQgPSB0aGlzLmNsaXAoKSxcclxuICAgICAgICAgICAgbWFza2VkID0gdGhpcy5tYXNrKCksXHJcbiAgICAgICAgICAgIGdyb3VwO1xyXG4gICAgICAgIGlmICgodGhpcy5nZXQoJ29wYWNpdHknKSA8IDEgfHwgY2xpcHBlZCB8fCBtYXNrZWQpICYmICFpc0NsaXApIHtcclxuICAgICAgICAgIGdyb3VwID0gZG9jQmVnaW5Hcm91cChnZXRQYWdlQkJveCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kcmF3Q2hpbGRyZW4oaXNDbGlwLCBpc01hc2spO1xyXG4gICAgICAgIGlmIChncm91cCkge1xyXG4gICAgICAgICAgZG9jRW5kR3JvdXAoZ3JvdXApO1xyXG4gICAgICAgICAgZG9jLmZpbGxPcGFjaXR5KHRoaXMuZ2V0KCdvcGFjaXR5JykpO1xyXG4gICAgICAgICAgZG9jSW5zZXJ0R3JvdXAoZ3JvdXApO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIFN2Z0VsZW1Vc2UgPSBmdW5jdGlvbihvYmosIGluaGVyaXRzKSB7XHJcbiAgICAgIFN2Z0VsZW1Db250YWluZXIuY2FsbCh0aGlzLCBvYmosIGluaGVyaXRzKTtcclxuICAgICAgbGV0IHggPSB0aGlzLmdldExlbmd0aCgneCcsIHRoaXMuZ2V0VldpZHRoKCksIDApLFxyXG4gICAgICAgICAgeSA9IHRoaXMuZ2V0TGVuZ3RoKCd5JywgdGhpcy5nZXRWSGVpZ2h0KCksIDApLFxyXG4gICAgICAgICAgY2hpbGQgPSB0aGlzLmdldFVybCgnaHJlZicpIHx8IHRoaXMuZ2V0VXJsKCd4bGluazpocmVmJyk7XHJcbiAgICAgIGlmIChjaGlsZCkge2NoaWxkID0gY3JlYXRlU1ZHRWxlbWVudChjaGlsZCwgdGhpcyk7fVxyXG4gICAgICB0aGlzLmdldENoaWxkcmVuICA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBjaGlsZCA/IFtjaGlsZF0gOiBbXTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5kcmF3SW5Eb2N1bWVudCA9IGZ1bmN0aW9uKGlzQ2xpcCwgaXNNYXNrKSB7XHJcbiAgICAgICAgZG9jLnNhdmUoKTtcclxuICAgICAgICB0aGlzLmRyYXdDb250ZW50KGlzQ2xpcCwgaXNNYXNrKTtcclxuICAgICAgICBkb2MucmVzdG9yZSgpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmdldFRyYW5zZm9ybWF0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG11bHRpcGx5TWF0cml4KHRoaXMuZ2V0KCd0cmFuc2Zvcm0nKSwgWzEsIDAsIDAsIDEsIHgsIHldKTtcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIFN2Z0VsZW1TeW1ib2wgPSBmdW5jdGlvbihvYmosIGluaGVyaXRzKSB7XHJcbiAgICAgIFN2Z0VsZW1Db250YWluZXIuY2FsbCh0aGlzLCBvYmosIGluaGVyaXRzKTtcclxuICAgICAgbGV0IHdpZHRoID0gdGhpcy5nZXRMZW5ndGgoJ3dpZHRoJywgdGhpcy5nZXRQYXJlbnRWV2lkdGgoKSwgdGhpcy5nZXRQYXJlbnRWV2lkdGgoKSksXHJcbiAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldExlbmd0aCgnaGVpZ2h0JywgdGhpcy5nZXRQYXJlbnRWSGVpZ2h0KCksIHRoaXMuZ2V0UGFyZW50VkhlaWdodCgpKTtcclxuICAgICAgaWYgKGluaGVyaXRzIGluc3RhbmNlb2YgU3ZnRWxlbVVzZSkge1xyXG4gICAgICAgIHdpZHRoID0gaW5oZXJpdHMuZ2V0TGVuZ3RoKCd3aWR0aCcsIGluaGVyaXRzLmdldFBhcmVudFZXaWR0aCgpLCB3aWR0aCk7XHJcbiAgICAgICAgaGVpZ2h0ID0gaW5oZXJpdHMuZ2V0TGVuZ3RoKCdoZWlnaHQnLCBpbmhlcml0cy5nZXRQYXJlbnRWSGVpZ2h0KCksIGhlaWdodCk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGFzcGVjdFJhdGlvID0gKHRoaXMuYXR0cigncHJlc2VydmVBc3BlY3RSYXRpbycpIHx8ICcnKS50cmltKCksXHJcbiAgICAgICAgICB2aWV3Qm94ID0gdGhpcy5nZXRWaWV3Ym94KCd2aWV3Qm94JywgWzAsIDAsIHdpZHRoLCBoZWlnaHRdKTtcclxuICAgICAgdGhpcy5nZXRWV2lkdGggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdmlld0JveFsyXTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5nZXRWSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdCb3hbM107XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZHJhd0luRG9jdW1lbnQgPSBmdW5jdGlvbihpc0NsaXAsIGlzTWFzaykge1xyXG4gICAgICAgIGRvYy5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5kcmF3Q29udGVudChpc0NsaXAsIGlzTWFzayk7XHJcbiAgICAgICAgZG9jLnJlc3RvcmUoKTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5nZXRUcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBtdWx0aXBseU1hdHJpeChwYXJzZUFzcGVjdFJhdGlvKGFzcGVjdFJhdGlvLCB3aWR0aCwgaGVpZ2h0LCB2aWV3Qm94WzJdLCB2aWV3Qm94WzNdKSwgWzEsIDAsIDAsIDEsIC12aWV3Qm94WzBdLCAtdmlld0JveFsxXV0pO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgU3ZnRWxlbUdyb3VwID0gZnVuY3Rpb24ob2JqLCBpbmhlcml0cykge1xyXG4gICAgICBTdmdFbGVtQ29udGFpbmVyLmNhbGwodGhpcywgb2JqLCBpbmhlcml0cyk7XHJcbiAgICAgIHRoaXMuZHJhd0luRG9jdW1lbnQgPSBmdW5jdGlvbihpc0NsaXAsIGlzTWFzaykge1xyXG4gICAgICAgIGRvYy5zYXZlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubGluayAmJiAhaXNDbGlwICYmICFpc01hc2spIHt0aGlzLmFkZExpbmsoKTt9XHJcbiAgICAgICAgdGhpcy5kcmF3Q29udGVudChpc0NsaXAsIGlzTWFzayk7XHJcbiAgICAgICAgZG9jLnJlc3RvcmUoKTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5nZXRUcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldCgndHJhbnNmb3JtJyk7XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBTdmdFbGVtTGluayA9IGZ1bmN0aW9uKG9iaiwgaW5oZXJpdHMpIHtcclxuICAgICAgaWYgKGluaGVyaXRzICYmIGluaGVyaXRzLmlzVGV4dCkge1xyXG4gICAgICAgIFN2Z0VsZW1Uc3Bhbi5jYWxsKHRoaXMsIG9iaiwgaW5oZXJpdHMpO1xyXG4gICAgICAgIHRoaXMuYWxsb3dlZENoaWxkcmVuID0gWyd0ZXh0UGF0aCcsICd0c3BhbicsICcjdGV4dCcsICcjY2RhdGEtc2VjdGlvbicsICdhJ107XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgU3ZnRWxlbUdyb3VwLmNhbGwodGhpcywgb2JqLCBpbmhlcml0cyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5saW5rID0gdGhpcy5hdHRyKCdocmVmJykgfHwgdGhpcy5hdHRyKCd4bGluazpocmVmJyk7XHJcbiAgICAgIHRoaXMuYWRkTGluayA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxpbmsubWF0Y2goL14oPzpbYS16XVthLXowLTkrLi1dKjp8XFwvXFwvKT8vaSkgJiYgdGhpcy5nZXRDaGlsZHJlbigpLmxlbmd0aCkge1xyXG4gICAgICAgICAgbGV0IGJib3ggPSB0aGlzLmdldEJvdW5kaW5nU2hhcGUoKS50cmFuc2Zvcm0oZ2V0R2xvYmFsTWF0cml4KCkpLmdldEJvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgICBkb2NJbnNlcnRMaW5rKGJib3hbMF0sIGJib3hbMV0sIGJib3hbMl0sIGJib3hbM10sIHRoaXMubGluayk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBTdmdFbGVtU3ZnID0gZnVuY3Rpb24ob2JqLCBpbmhlcml0cykge1xyXG4gICAgICBTdmdFbGVtQ29udGFpbmVyLmNhbGwodGhpcywgb2JqLCBpbmhlcml0cyk7XHJcbiAgICAgIGxldCB3aWR0aCA9IHRoaXMuZ2V0TGVuZ3RoKCd3aWR0aCcsIHRoaXMuZ2V0UGFyZW50VldpZHRoKCksIHRoaXMuZ2V0UGFyZW50VldpZHRoKCkpLFxyXG4gICAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRMZW5ndGgoJ2hlaWdodCcsIHRoaXMuZ2V0UGFyZW50VkhlaWdodCgpLCB0aGlzLmdldFBhcmVudFZIZWlnaHQoKSksXHJcbiAgICAgICAgICB4ID0gdGhpcy5nZXRMZW5ndGgoJ3gnLCB0aGlzLmdldFBhcmVudFZXaWR0aCgpLCAwKSxcclxuICAgICAgICAgIHkgPSB0aGlzLmdldExlbmd0aCgneScsIHRoaXMuZ2V0UGFyZW50VkhlaWdodCgpLCAwKTtcclxuICAgICAgaWYgKGluaGVyaXRzIGluc3RhbmNlb2YgU3ZnRWxlbVVzZSkge1xyXG4gICAgICAgIHdpZHRoID0gaW5oZXJpdHMuZ2V0TGVuZ3RoKCd3aWR0aCcsIGluaGVyaXRzLmdldFBhcmVudFZXaWR0aCgpLCB3aWR0aCk7XHJcbiAgICAgICAgaGVpZ2h0ID0gaW5oZXJpdHMuZ2V0TGVuZ3RoKCdoZWlnaHQnLCBpbmhlcml0cy5nZXRQYXJlbnRWSGVpZ2h0KCksIGhlaWdodCk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IGFzcGVjdFJhdGlvID0gdGhpcy5hdHRyKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyksXHJcbiAgICAgICAgICB2aWV3Qm94ID0gdGhpcy5nZXRWaWV3Ym94KCd2aWV3Qm94JywgWzAsIDAsIHdpZHRoLCBoZWlnaHRdKTtcclxuICAgICAgaWYgKHRoaXMuaXNPdXRlckVsZW1lbnQgJiYgcHJlc2VydmVBc3BlY3RSYXRpbykge1xyXG4gICAgICAgIHggPSB5ID0gMDtcclxuICAgICAgICB3aWR0aCA9IHZpZXdwb3J0V2lkdGg7XHJcbiAgICAgICAgaGVpZ2h0ID0gdmlld3BvcnRIZWlnaHQ7XHJcbiAgICAgICAgYXNwZWN0UmF0aW8gPSBwcmVzZXJ2ZUFzcGVjdFJhdGlvO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuZ2V0VldpZHRoID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdCb3hbMl07XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZ2V0VkhlaWdodCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB2aWV3Qm94WzNdO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmRyYXdJbkRvY3VtZW50ID0gZnVuY3Rpb24oaXNDbGlwLCBpc01hc2spIHtcclxuICAgICAgICBkb2Muc2F2ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmdldCgnb3ZlcmZsb3cnKSA9PT0gJ2hpZGRlbicpIHtcclxuICAgICAgICAgIG5ldyBTdmdTaGFwZSgpLk0oeCwgeSkuTCh4ICsgd2lkdGgsIHkpLkwoeCArIHdpZHRoLCB5ICsgaGVpZ2h0KS5MKHgsIHkgKyBoZWlnaHQpLlooKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudHJhbnNmb3JtKHRoaXMuZ2V0KCd0cmFuc2Zvcm0nKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmluc2VydEluRG9jdW1lbnQoKTtcclxuICAgICAgICAgIGRvYy5jbGlwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZHJhd0NvbnRlbnQoaXNDbGlwLCBpc01hc2spO1xyXG4gICAgICAgIGRvYy5yZXN0b3JlKCk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZ2V0VHJhbnNmb3JtYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gbXVsdGlwbHlNYXRyaXgoXHJcbiAgICAgICAgICB0aGlzLmdldCgndHJhbnNmb3JtJyksXHJcbiAgICAgICAgICBbMSwgMCwgMCwgMSwgeCwgeV0sXHJcbiAgICAgICAgICBwYXJzZUFzcGVjdFJhdGlvKGFzcGVjdFJhdGlvLCB3aWR0aCwgaGVpZ2h0LCB2aWV3Qm94WzJdLCB2aWV3Qm94WzNdKSxcclxuICAgICAgICAgIFsxLCAwLCAwLCAxLCAtdmlld0JveFswXSwgLXZpZXdCb3hbMV1dXHJcbiAgICAgICAgKTtcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIFNWR0VsZW1JbWFnZSA9IGZ1bmN0aW9uKG9iaiwgaW5oZXJpdHMpIHtcclxuICAgICAgU3ZnRWxlbVN0eWxhYmxlLmNhbGwodGhpcywgb2JqLCBpbmhlcml0cyk7XHJcbiAgICAgIGxldCBsaW5rID0gaW1hZ2VDYWxsYmFjayh0aGlzLmF0dHIoJ2hyZWYnKSB8fCB0aGlzLmF0dHIoJ3hsaW5rOmhyZWYnKSB8fCAnJyksXHJcbiAgICAgICAgICB4ID0gdGhpcy5nZXRMZW5ndGgoJ3gnLCB0aGlzLmdldFZXaWR0aCgpLCAwKSxcclxuICAgICAgICAgIHkgPSB0aGlzLmdldExlbmd0aCgneScsIHRoaXMuZ2V0VkhlaWdodCgpLCAwKSxcclxuICAgICAgICAgIHdpZHRoID0gdGhpcy5nZXRMZW5ndGgoJ3dpZHRoJywgdGhpcy5nZXRWV2lkdGgoKSwgJ2F1dG8nKSxcclxuICAgICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0TGVuZ3RoKCdoZWlnaHQnLCB0aGlzLmdldFZIZWlnaHQoKSwgJ2F1dG8nKSxcclxuICAgICAgICAgIGltYWdlO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGltYWdlID0gZG9jLm9wZW5JbWFnZShsaW5rKTtcclxuICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgd2FybmluZ0NhbGxiYWNrKCdTVkdFbGVtSW1hZ2U6IGZhaWxlZCB0byBvcGVuIGltYWdlIFwiJyArIGxpbmsgKyAnXCIgaW4gUERGS2l0Jyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGltYWdlKSB7XHJcbiAgICAgICAgaWYgKHdpZHRoID09PSAnYXV0bycgJiYgaGVpZ2h0ICE9PSAnYXV0bycpIHtcclxuICAgICAgICAgIHdpZHRoID0gaGVpZ2h0ICogaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHQ7XHJcbiAgICAgICAgfSBlbHNlIGlmIChoZWlnaHQgPT09ICdhdXRvJyAmJiB3aWR0aCAhPT0gJ2F1dG8nKSB7XHJcbiAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAqIGltYWdlLmhlaWdodCAvIGltYWdlLndpZHRoO1xyXG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGggPT09ICdhdXRvJyAmJiBoZWlnaHQgPT09ICdhdXRvJykge1xyXG4gICAgICAgICAgd2lkdGggPSBpbWFnZS53aWR0aDtcclxuICAgICAgICAgIGhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHdpZHRoID09PSAnYXV0bycgfHwgd2lkdGggPCAwKSB7d2lkdGggPSAwO31cclxuICAgICAgaWYgKGhlaWdodCA9PT0gJ2F1dG8nIHx8IGhlaWdodCA8IDApIHtoZWlnaHQgPSAwO31cclxuICAgICAgdGhpcy5nZXRUcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldCgndHJhbnNmb3JtJyk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZ2V0Qm91bmRpbmdTaGFwZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU3ZnU2hhcGUoKS5NKHgsIHkpLkwoeCArIHdpZHRoLCB5KS5NKHggKyB3aWR0aCwgeSArIGhlaWdodCkuTCh4LCB5ICsgaGVpZ2h0KTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5kcmF3SW5Eb2N1bWVudCA9IGZ1bmN0aW9uKGlzQ2xpcCwgaXNNYXNrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0KCd2aXNpYmlsaXR5JykgPT09ICdoaWRkZW4nIHx8ICFpbWFnZSkge3JldHVybjt9XHJcbiAgICAgICAgZG9jLnNhdmUoKTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmdldCgnb3ZlcmZsb3cnKSA9PT0gJ2hpZGRlbicpIHtcclxuICAgICAgICAgIGRvYy5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpLmNsaXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jbGlwKCk7XHJcbiAgICAgICAgdGhpcy5tYXNrKCk7XHJcbiAgICAgICAgZG9jLnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgICAgICBkb2MudHJhbnNmb3JtLmFwcGx5KGRvYywgcGFyc2VBc3BlY3RSYXRpbyh0aGlzLmF0dHIoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKSwgd2lkdGgsIGhlaWdodCwgaW1hZ2UgPyBpbWFnZS53aWR0aCA6IHdpZHRoLCBpbWFnZSA/IGltYWdlLmhlaWdodCA6IGhlaWdodCkpO1xyXG4gICAgICAgIGlmICghaXNDbGlwKSB7XHJcbiAgICAgICAgICBkb2MuZmlsbE9wYWNpdHkodGhpcy5nZXQoJ29wYWNpdHknKSk7XHJcbiAgICAgICAgICBkb2MuaW1hZ2UoaW1hZ2UsIDAsIDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkb2MucmVjdCgwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcclxuICAgICAgICAgIGRvY0ZpbGxDb2xvcihEZWZhdWx0Q29sb3JzLndoaXRlKS5maWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvYy5yZXN0b3JlKCk7XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBTdmdFbGVtUGF0dGVybiA9IGZ1bmN0aW9uKG9iaiwgaW5oZXJpdHMsIGZhbGxiYWNrKSB7XHJcbiAgICAgIFN2Z0VsZW1IYXNDaGlsZHJlbi5jYWxsKHRoaXMsIG9iaiwgaW5oZXJpdHMpO1xyXG4gICAgICB0aGlzLnJlZiA9IChmdW5jdGlvbigpIHtcclxuICAgICAgICBsZXQgcmVmID0gdGhpcy5nZXRVcmwoJ2hyZWYnKSB8fCB0aGlzLmdldFVybCgneGxpbms6aHJlZicpO1xyXG4gICAgICAgIGlmIChyZWYgJiYgcmVmLm5vZGVOYW1lID09PSBvYmoubm9kZU5hbWUpIHtcclxuICAgICAgICAgIHJldHVybiBuZXcgU3ZnRWxlbVBhdHRlcm4ocmVmLCBpbmhlcml0cywgZmFsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgfSkuY2FsbCh0aGlzKTtcclxuICAgICAgbGV0IF9hdHRyID0gdGhpcy5hdHRyO1xyXG4gICAgICB0aGlzLmF0dHIgPSBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICBsZXQgYXR0ciA9IF9hdHRyLmNhbGwodGhpcywga2V5KTtcclxuICAgICAgICBpZiAoYXR0ciAhPSBudWxsIHx8IGtleSA9PT0gJ2hyZWYnIHx8IGtleSA9PT0gJ3hsaW5rOmhyZWYnKSB7cmV0dXJuIGF0dHI7fVxyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZiA/IHRoaXMucmVmLmF0dHIoa2V5KSA6IG51bGw7XHJcbiAgICAgIH07XHJcbiAgICAgIGxldCBfZ2V0Q2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuO1xyXG4gICAgICB0aGlzLmdldENoaWxkcmVuID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gX2dldENoaWxkcmVuLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtyZXR1cm4gY2hpbGRyZW47fVxyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZiA/IHRoaXMucmVmLmdldENoaWxkcmVuKCkgOiBbXTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5nZXRQYWludCA9IGZ1bmN0aW9uKGJCb3gsIGdPcGFjaXR5LCBpc0NsaXAsIGlzTWFzaykge1xyXG4gICAgICAgIGxldCBiQm94VW5pdHNQYXR0ZXJuID0gKHRoaXMuYXR0cigncGF0dGVyblVuaXRzJykgIT09ICd1c2VyU3BhY2VPblVzZScpLFxyXG4gICAgICAgICAgICBiQm94VW5pdHNDb250ZW50ID0gKHRoaXMuYXR0cigncGF0dGVybkNvbnRlbnRVbml0cycpID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnKSxcclxuICAgICAgICAgICAgeCA9IHRoaXMuZ2V0TGVuZ3RoKCd4JywgKGJCb3hVbml0c1BhdHRlcm4gPyAxIDogdGhpcy5nZXRQYXJlbnRWV2lkdGgoKSksIDApLFxyXG4gICAgICAgICAgICB5ID0gdGhpcy5nZXRMZW5ndGgoJ3knLCAoYkJveFVuaXRzUGF0dGVybiA/IDEgOiB0aGlzLmdldFBhcmVudFZIZWlnaHQoKSksIDApLFxyXG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuZ2V0TGVuZ3RoKCd3aWR0aCcsIChiQm94VW5pdHNQYXR0ZXJuID8gMSA6IHRoaXMuZ2V0UGFyZW50VldpZHRoKCkpLCAwKSxcclxuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRMZW5ndGgoJ2hlaWdodCcsIChiQm94VW5pdHNQYXR0ZXJuID8gMSA6IHRoaXMuZ2V0UGFyZW50VkhlaWdodCgpKSwgMCk7XHJcbiAgICAgICAgaWYgKGJCb3hVbml0c0NvbnRlbnQgJiYgIWJCb3hVbml0c1BhdHRlcm4pIHsgLy8gVXNlIHRoZSBzYW1lIHVuaXRzIGZvciBwYXR0ZXJuICYgcGF0dGVybiBjb250ZW50XHJcbiAgICAgICAgICB4ID0gKHggLSBiQm94WzBdKSAvIChiQm94WzJdIC0gYkJveFswXSkgfHwgMDtcclxuICAgICAgICAgIHkgPSAoeSAtIGJCb3hbMV0pIC8gKGJCb3hbM10gLSBiQm94WzFdKSB8fCAwO1xyXG4gICAgICAgICAgd2lkdGggPSB3aWR0aCAvIChiQm94WzJdIC0gYkJveFswXSkgfHwgMDtcclxuICAgICAgICAgIGhlaWdodCA9IGhlaWdodCAvIChiQm94WzNdIC0gYkJveFsxXSkgfHwgMDtcclxuICAgICAgICB9IGVsc2UgaWYgKCFiQm94VW5pdHNDb250ZW50ICYmIGJCb3hVbml0c1BhdHRlcm4pIHtcclxuICAgICAgICAgIHggPSBiQm94WzBdICsgeCAqIChiQm94WzJdIC0gYkJveFswXSk7XHJcbiAgICAgICAgICB5ID0gYkJveFsxXSArIHkgKiAoYkJveFszXSAtIGJCb3hbMV0pO1xyXG4gICAgICAgICAgd2lkdGggPSB3aWR0aCAqIChiQm94WzJdIC0gYkJveFswXSk7XHJcbiAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgKiAoYkJveFszXSAtIGJCb3hbMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdmlld0JveCA9IHRoaXMuZ2V0Vmlld2JveCgndmlld0JveCcsIFswLCAwLCB3aWR0aCwgaGVpZ2h0XSksXHJcbiAgICAgICAgICAgIGFzcGVjdFJhdGlvID0gKHRoaXMuYXR0cigncHJlc2VydmVBc3BlY3RSYXRpbycpIHx8ICcnKS50cmltKCksXHJcbiAgICAgICAgICAgIGFzcGVjdFJhdGlvTWF0cml4ID0gbXVsdGlwbHlNYXRyaXgoXHJcbiAgICAgICAgICAgICAgcGFyc2VBc3BlY3RSYXRpbyhhc3BlY3RSYXRpbywgd2lkdGgsIGhlaWdodCwgdmlld0JveFsyXSwgdmlld0JveFszXSwgMCksXHJcbiAgICAgICAgICAgICAgWzEsIDAsIDAsIDEsIC12aWV3Qm94WzBdLCAtdmlld0JveFsxXV1cclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgbWF0cml4ID0gcGFyc2VUcmFuZm9ybSh0aGlzLmF0dHIoJ3BhdHRlcm5UcmFuc2Zvcm0nKSk7XHJcbiAgICAgICAgaWYgKGJCb3hVbml0c0NvbnRlbnQpIHtcclxuICAgICAgICAgIG1hdHJpeCA9IG11bHRpcGx5TWF0cml4KFtiQm94WzJdIC0gYkJveFswXSwgMCwgMCwgYkJveFszXSAtIGJCb3hbMV0sIGJCb3hbMF0sIGJCb3hbMV1dLCBtYXRyaXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXRyaXggPSBtdWx0aXBseU1hdHJpeChtYXRyaXgsIFsxLCAwLCAwLCAxLCB4LCB5XSk7XHJcbiAgICAgICAgaWYgKChtYXRyaXggPSB2YWxpZGF0ZU1hdHJpeChtYXRyaXgpKSAmJiAoYXNwZWN0UmF0aW9NYXRyaXggPSB2YWxpZGF0ZU1hdHJpeChhc3BlY3RSYXRpb01hdHJpeCkpICYmICh3aWR0aCA9IHZhbGlkYXRlTnVtYmVyKHdpZHRoKSkgJiYgKGhlaWdodCA9IHZhbGlkYXRlTnVtYmVyKGhlaWdodCkpKSB7XHJcbiAgICAgICAgICBsZXQgZ3JvdXAgPSBkb2NCZWdpbkdyb3VwKFswLCAwLCB3aWR0aCwgaGVpZ2h0XSk7XHJcbiAgICAgICAgICBkb2MudHJhbnNmb3JtLmFwcGx5KGRvYywgYXNwZWN0UmF0aW9NYXRyaXgpO1xyXG4gICAgICAgICAgdGhpcy5kcmF3Q2hpbGRyZW4oaXNDbGlwLCBpc01hc2spO1xyXG4gICAgICAgICAgZG9jRW5kR3JvdXAoZ3JvdXApO1xyXG4gICAgICAgICAgcmV0dXJuIFtkb2NDcmVhdGVQYXR0ZXJuKGdyb3VwLCB3aWR0aCwgaGVpZ2h0LCBtYXRyaXgpLCBnT3BhY2l0eV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBmYWxsYmFjayA/IFtmYWxsYmFja1swXSwgZmFsbGJhY2tbMV0gKiBnT3BhY2l0eV0gOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmdldFZXaWR0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGxldCBiQm94VW5pdHNQYXR0ZXJuID0gKHRoaXMuYXR0cigncGF0dGVyblVuaXRzJykgIT09ICd1c2VyU3BhY2VPblVzZScpLFxyXG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuZ2V0TGVuZ3RoKCd3aWR0aCcsIChiQm94VW5pdHNQYXR0ZXJuID8gMSA6IHRoaXMuZ2V0UGFyZW50VldpZHRoKCkpLCAwKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRWaWV3Ym94KCd2aWV3Qm94JywgWzAsIDAsIHdpZHRoLCAwXSlbMl07XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZ2V0VkhlaWdodCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGxldCBiQm94VW5pdHNQYXR0ZXJuID0gKHRoaXMuYXR0cigncGF0dGVyblVuaXRzJykgIT09ICd1c2VyU3BhY2VPblVzZScpLFxyXG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldExlbmd0aCgnaGVpZ2h0JywgKGJCb3hVbml0c1BhdHRlcm4gPyAxIDogdGhpcy5nZXRQYXJlbnRWSGVpZ2h0KCkpLCAwKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRWaWV3Ym94KCd2aWV3Qm94JywgWzAsIDAsIDAsIGhlaWdodF0pWzNdO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgU3ZnRWxlbUdyYWRpZW50ID0gZnVuY3Rpb24ob2JqLCBpbmhlcml0cywgZmFsbGJhY2spIHtcclxuICAgICAgU3ZnRWxlbS5jYWxsKHRoaXMsIG9iaiwgaW5oZXJpdHMpO1xyXG4gICAgICB0aGlzLmFsbG93ZWRDaGlsZHJlbiA9IFsnc3RvcCddO1xyXG4gICAgICB0aGlzLnJlZiA9IChmdW5jdGlvbigpIHtcclxuICAgICAgICBsZXQgcmVmID0gdGhpcy5nZXRVcmwoJ2hyZWYnKSB8fCB0aGlzLmdldFVybCgneGxpbms6aHJlZicpO1xyXG4gICAgICAgIGlmIChyZWYgJiYgcmVmLm5vZGVOYW1lID09PSBvYmoubm9kZU5hbWUpIHtcclxuICAgICAgICAgIHJldHVybiBuZXcgU3ZnRWxlbUdyYWRpZW50KHJlZiwgaW5oZXJpdHMsIGZhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pLmNhbGwodGhpcyk7XHJcbiAgICAgIGxldCBfYXR0ciA9IHRoaXMuYXR0cjtcclxuICAgICAgdGhpcy5hdHRyID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgbGV0IGF0dHIgPSBfYXR0ci5jYWxsKHRoaXMsIGtleSk7XHJcbiAgICAgICAgaWYgKGF0dHIgIT0gbnVsbCB8fCBrZXkgPT09ICdocmVmJyB8fCBrZXkgPT09ICd4bGluazpocmVmJykge3JldHVybiBhdHRyO31cclxuICAgICAgICByZXR1cm4gdGhpcy5yZWYgPyB0aGlzLnJlZi5hdHRyKGtleSkgOiBudWxsO1xyXG4gICAgICB9O1xyXG4gICAgICBsZXQgX2dldENoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbjtcclxuICAgICAgdGhpcy5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGxldCBjaGlsZHJlbiA9IF9nZXRDaGlsZHJlbi5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7cmV0dXJuIGNoaWxkcmVuO31cclxuICAgICAgICByZXR1cm4gdGhpcy5yZWYgPyB0aGlzLnJlZi5nZXRDaGlsZHJlbigpIDogW107XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZ2V0UGFpbnQgPSBmdW5jdGlvbihiQm94LCBnT3BhY2l0eSwgaXNDbGlwLCBpc01hc2spIHtcclxuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge3JldHVybjt9XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5bMF0sXHJcbiAgICAgICAgICAgICAgc3RvcENvbG9yID0gY2hpbGQuZ2V0KCdzdG9wLWNvbG9yJyk7XHJcbiAgICAgICAgICBpZiAoc3RvcENvbG9yID09PSAnbm9uZScpIHtyZXR1cm47fVxyXG4gICAgICAgICAgcmV0dXJuIG9wYWNpdHlUb0NvbG9yKHN0b3BDb2xvciwgY2hpbGQuZ2V0KCdzdG9wLW9wYWNpdHknKSAqIGdPcGFjaXR5LCBpc01hc2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYkJveFVuaXRzID0gKHRoaXMuYXR0cignZ3JhZGllbnRVbml0cycpICE9PSAndXNlclNwYWNlT25Vc2UnKSxcclxuICAgICAgICAgICAgbWF0cml4ID0gcGFyc2VUcmFuZm9ybSh0aGlzLmF0dHIoJ2dyYWRpZW50VHJhbnNmb3JtJykpLFxyXG4gICAgICAgICAgICBzcHJlYWQgPSB0aGlzLmF0dHIoJ3NwcmVhZE1ldGhvZCcpLFxyXG4gICAgICAgICAgICBncmFkLFxyXG4gICAgICAgICAgICB4MSwgeDIsIHkxLCB5MiwgcjIsXHJcbiAgICAgICAgICAgIG5BZnRlciA9IDAsXHJcbiAgICAgICAgICAgIG5CZWZvcmUgPSAwLFxyXG4gICAgICAgICAgICBuVG90YWwgPSAxO1xyXG4gICAgICAgIGlmIChiQm94VW5pdHMpIHtcclxuICAgICAgICAgIG1hdHJpeCA9IG11bHRpcGx5TWF0cml4KFtiQm94WzJdIC0gYkJveFswXSwgMCwgMCwgYkJveFszXSAtIGJCb3hbMV0sIGJCb3hbMF0sIGJCb3hbMV1dLCBtYXRyaXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF0cml4ID0gdmFsaWRhdGVNYXRyaXgobWF0cml4KSkge1xyXG4gICAgICAgICAgaWYgKHRoaXMubmFtZSA9PT0gJ2xpbmVhckdyYWRpZW50Jykge1xyXG4gICAgICAgICAgICB4MSA9IHRoaXMuZ2V0TGVuZ3RoKCd4MScsIChiQm94VW5pdHMgPyAxIDogdGhpcy5nZXRWV2lkdGgoKSksIDApO1xyXG4gICAgICAgICAgICB4MiA9IHRoaXMuZ2V0TGVuZ3RoKCd4MicsIChiQm94VW5pdHMgPyAxIDogdGhpcy5nZXRWV2lkdGgoKSksIChiQm94VW5pdHMgPyAxIDogdGhpcy5nZXRWV2lkdGgoKSkpO1xyXG4gICAgICAgICAgICB5MSA9IHRoaXMuZ2V0TGVuZ3RoKCd5MScsIChiQm94VW5pdHMgPyAxIDogdGhpcy5nZXRWSGVpZ2h0KCkpLCAwKTtcclxuICAgICAgICAgICAgeTIgPSB0aGlzLmdldExlbmd0aCgneTInLCAoYkJveFVuaXRzID8gMSA6IHRoaXMuZ2V0VkhlaWdodCgpKSwgMCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4MiA9IHRoaXMuZ2V0TGVuZ3RoKCdjeCcsIChiQm94VW5pdHMgPyAxIDogdGhpcy5nZXRWV2lkdGgoKSksIChiQm94VW5pdHMgPyAwLjUgOiAwLjUgKiB0aGlzLmdldFZXaWR0aCgpKSk7XHJcbiAgICAgICAgICAgIHkyID0gdGhpcy5nZXRMZW5ndGgoJ2N5JywgKGJCb3hVbml0cyA/IDEgOiB0aGlzLmdldFZIZWlnaHQoKSksIChiQm94VW5pdHMgPyAwLjUgOiAwLjUgKiB0aGlzLmdldFZIZWlnaHQoKSkpO1xyXG4gICAgICAgICAgICByMiA9IHRoaXMuZ2V0TGVuZ3RoKCdyJywgKGJCb3hVbml0cyA/IDEgOiB0aGlzLmdldFZpZXdwb3J0KCkpLCAoYkJveFVuaXRzID8gMC41IDogMC41ICogdGhpcy5nZXRWaWV3cG9ydCgpKSk7XHJcbiAgICAgICAgICAgIHgxID0gdGhpcy5nZXRMZW5ndGgoJ2Z4JywgKGJCb3hVbml0cyA/IDEgOiB0aGlzLmdldFZXaWR0aCgpKSwgeDIpO1xyXG4gICAgICAgICAgICB5MSA9IHRoaXMuZ2V0TGVuZ3RoKCdmeScsIChiQm94VW5pdHMgPyAxIDogdGhpcy5nZXRWSGVpZ2h0KCkpLCB5Mik7XHJcbiAgICAgICAgICAgIGlmIChyMiA8IDApIHtcclxuICAgICAgICAgICAgICB3YXJuaW5nQ2FsbGJhY2soJ1N2Z0VsZW1HcmFkaWVudDogbmVnYXRpdmUgciB2YWx1ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBkID0gTWF0aC5zcXJ0KE1hdGgucG93KHgyIC0geDEsIDIpICsgTWF0aC5wb3coeTIgLSB5MSwgMikpLFxyXG4gICAgICAgICAgICAgICAgbXVsdGlwbGllciA9IDE7XHJcbiAgICAgICAgICAgIGlmIChkID4gcjIpIHsgLy8gYWNjb3JkaW5nIHRvIHNwZWNpZmljYXRpb25cclxuICAgICAgICAgICAgICBtdWx0aXBsaWVyID0gcjIgLyBkO1xyXG4gICAgICAgICAgICAgIHgxID0geDIgKyAoeDEgLSB4MikgKiBtdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICAgIHkxID0geTIgKyAoeTEgLSB5MikgKiBtdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHIyID0gTWF0aC5tYXgocjIsIGQgKiBtdWx0aXBsaWVyICogKDEgKyAxZS02KSk7IC8vIGZpeCBmb3IgZWRnZS1jYXNlIGdyYWRpZW50cyBzZWUgaXNzdWUgIzg0XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoc3ByZWFkID09PSAncmVmbGVjdCcgfHwgc3ByZWFkID09PSAncmVwZWF0Jykge1xyXG4gICAgICAgICAgICBsZXQgaW52ID0gaW52ZXJzZU1hdHJpeChtYXRyaXgpLFxyXG4gICAgICAgICAgICAgICAgY29ybmVyMSA9IHRyYW5zZm9ybVBvaW50KFtiQm94WzBdLCBiQm94WzFdXSwgaW52KSxcclxuICAgICAgICAgICAgICAgIGNvcm5lcjIgPSB0cmFuc2Zvcm1Qb2ludChbYkJveFsyXSwgYkJveFsxXV0sIGludiksXHJcbiAgICAgICAgICAgICAgICBjb3JuZXIzID0gdHJhbnNmb3JtUG9pbnQoW2JCb3hbMl0sIGJCb3hbM11dLCBpbnYpLFxyXG4gICAgICAgICAgICAgICAgY29ybmVyNCA9IHRyYW5zZm9ybVBvaW50KFtiQm94WzBdLCBiQm94WzNdXSwgaW52KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubmFtZSA9PT0gJ2xpbmVhckdyYWRpZW50JykgeyAvLyBTZWUgZmlsZSAnZ3JhZGllbnQtcmVwZWF0LW1hdGhzLnBuZydcclxuICAgICAgICAgICAgICBuQWZ0ZXIgID0gTWF0aC5tYXgoKGNvcm5lcjFbMF0gLSB4MikgKiAoeDIgLSB4MSkgKyAoY29ybmVyMVsxXSAtIHkyKSAqICh5MiAtIHkxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvcm5lcjJbMF0gLSB4MikgKiAoeDIgLSB4MSkgKyAoY29ybmVyMlsxXSAtIHkyKSAqICh5MiAtIHkxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvcm5lcjNbMF0gLSB4MikgKiAoeDIgLSB4MSkgKyAoY29ybmVyM1sxXSAtIHkyKSAqICh5MiAtIHkxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvcm5lcjRbMF0gLSB4MikgKiAoeDIgLSB4MSkgKyAoY29ybmVyNFsxXSAtIHkyKSAqICh5MiAtIHkxKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvIChNYXRoLnBvdyh4MiAtIHgxLCAyKSArIE1hdGgucG93KHkyIC0geTEsIDIpKTtcclxuICAgICAgICAgICAgICBuQmVmb3JlID0gTWF0aC5tYXgoKGNvcm5lcjFbMF0gLSB4MSkgKiAoeDEgLSB4MikgKyAoY29ybmVyMVsxXSAtIHkxKSAqICh5MSAtIHkyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvcm5lcjJbMF0gLSB4MSkgKiAoeDEgLSB4MikgKyAoY29ybmVyMlsxXSAtIHkxKSAqICh5MSAtIHkyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvcm5lcjNbMF0gLSB4MSkgKiAoeDEgLSB4MikgKyAoY29ybmVyM1sxXSAtIHkxKSAqICh5MSAtIHkyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvcm5lcjRbMF0gLSB4MSkgKiAoeDEgLSB4MikgKyAoY29ybmVyNFsxXSAtIHkxKSAqICh5MSAtIHkyKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvIChNYXRoLnBvdyh4MiAtIHgxLCAyKSArIE1hdGgucG93KHkyIC0geTEsIDIpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBuQWZ0ZXIgID0gTWF0aC5zcXJ0KE1hdGgubWF4KE1hdGgucG93KGNvcm5lcjFbMF0gLSB4MiwgMikgKyBNYXRoLnBvdyhjb3JuZXIxWzFdIC0geTIsIDIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3coY29ybmVyMlswXSAtIHgyLCAyKSArIE1hdGgucG93KGNvcm5lcjJbMV0gLSB5MiwgMiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyhjb3JuZXIzWzBdIC0geDIsIDIpICsgTWF0aC5wb3coY29ybmVyM1sxXSAtIHkyLCAyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucG93KGNvcm5lcjRbMF0gLSB4MiwgMikgKyBNYXRoLnBvdyhjb3JuZXI0WzFdIC0geTIsIDIpKSkgLyByMiAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbkFmdGVyID0gTWF0aC5jZWlsKG5BZnRlciArIDAuNSk7IC8vIEFkZCBhIGxpdHRsZSBtb3JlIGJlY2F1c2UgdGhlIHN0cm9rZSBjYW4gZXh0ZW5kIG91dHNpZGUgb2YgdGhlIGJvdW5kaW5nIGJveFxyXG4gICAgICAgICAgICBuQmVmb3JlID0gTWF0aC5jZWlsKG5CZWZvcmUgKyAwLjUpO1xyXG4gICAgICAgICAgICBuVG90YWwgPSBuQmVmb3JlICsgMSArIG5BZnRlcjsgLy8gSG93IG1hbnkgdGltZXMgdGhlIGdyYWRpZW50IG5lZWRzIHRvIGJlIHJlcGVhdGVkIHRvIGZpbGwgdGhlIG9iamVjdCBib3VuZGluZyBib3hcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT09ICdsaW5lYXJHcmFkaWVudCcpIHtcclxuICAgICAgICAgICAgZ3JhZCA9IGRvYy5saW5lYXJHcmFkaWVudCh4MSAtIG5CZWZvcmUgKiAoeDIgLSB4MSksIHkxIC0gbkJlZm9yZSAqICh5MiAtIHkxKSwgeDIgKyBuQWZ0ZXIgKiAoeDIgLSB4MSksIHkyICsgbkFmdGVyICogKHkyIC0geTEpKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGdyYWQgPSBkb2MucmFkaWFsR3JhZGllbnQoeDEsIHkxLCAwLCB4MiwgeTIsIHIyICsgbkFmdGVyICogcjIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBuVG90YWw7IG4rKykge1xyXG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMCxcclxuICAgICAgICAgICAgICAgIGluT3JkZXIgPSAoc3ByZWFkICE9PSAncmVmbGVjdCcgfHwgKG4gLSBuQmVmb3JlKSAlIDIgPT09IDApO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5baW5PcmRlciA/IGkgOiBjaGlsZHJlbi5sZW5ndGggLSAxIC0gaV0sXHJcbiAgICAgICAgICAgICAgICAgIHN0b3BDb2xvciA9IGNoaWxkLmdldCgnc3RvcC1jb2xvcicpO1xyXG4gICAgICAgICAgICAgIGlmIChzdG9wQ29sb3IgPT09ICdub25lJykge3N0b3BDb2xvciA9IERlZmF1bHRDb2xvcnMudHJhbnNwYXJlbnQ7fVxyXG4gICAgICAgICAgICAgIHN0b3BDb2xvciA9IG9wYWNpdHlUb0NvbG9yKHN0b3BDb2xvciwgY2hpbGQuZ2V0KCdzdG9wLW9wYWNpdHknKSAqIGdPcGFjaXR5LCBpc01hc2spO1xyXG4gICAgICAgICAgICAgIG9mZnNldCA9IE1hdGgubWF4KG9mZnNldCwgaW5PcmRlciA/IGNoaWxkLmdldFBlcmNlbnQoJ29mZnNldCcsIDApIDogMSAtIGNoaWxkLmdldFBlcmNlbnQoJ29mZnNldCcsIDApKTtcclxuICAgICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiBzdG9wQ29sb3JbMF0ubGVuZ3RoID09PSA0KSB7Z3JhZC5fY29sb3JTcGFjZSA9ICdEZXZpY2VDTVlLJzt9IC8vIEZpeCB1bnRpbCBQUiAjNzYzIGlzIG1lcmdlZCBpbnRvIFBERktpdFxyXG4gICAgICAgICAgICAgIGlmIChpID09PSAwICYmIG9mZnNldCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGdyYWQuc3RvcCgobiArIDApIC8gblRvdGFsLCBzdG9wQ29sb3JbMF0sIHN0b3BDb2xvclsxXSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGdyYWQuc3RvcCgobiArIG9mZnNldCkgLyAobkFmdGVyICsgbkJlZm9yZSArIDEpLCBzdG9wQ29sb3JbMF0sIHN0b3BDb2xvclsxXSk7XHJcbiAgICAgICAgICAgICAgaWYgKGkgPT09IGNoaWxkcmVuLmxlbmd0aCAtIDEgJiYgb2Zmc2V0IDwgMSkge1xyXG4gICAgICAgICAgICAgICAgZ3JhZC5zdG9wKChuICsgMSkgLyBuVG90YWwsIHN0b3BDb2xvclswXSwgc3RvcENvbG9yWzFdKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGdyYWQuc2V0VHJhbnNmb3JtLmFwcGx5KGdyYWQsIG1hdHJpeCk7XHJcbiAgICAgICAgICByZXR1cm4gW2dyYWQsIDFdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsbGJhY2sgPyBbZmFsbGJhY2tbMF0sIGZhbGxiYWNrWzFdICogZ09wYWNpdHldIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgU3ZnRWxlbUJhc2ljU2hhcGUgPSBmdW5jdGlvbihvYmosIGluaGVyaXRzKSB7XHJcbiAgICAgIFN2Z0VsZW1TdHlsYWJsZS5jYWxsKHRoaXMsIG9iaiwgaW5oZXJpdHMpO1xyXG4gICAgICB0aGlzLmRhc2hTY2FsZSA9IDE7XHJcbiAgICAgIHRoaXMuZ2V0Qm91bmRpbmdTaGFwZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNoYXBlO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmdldFRyYW5zZm9ybWF0aW9uID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KCd0cmFuc2Zvcm0nKTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5kcmF3SW5Eb2N1bWVudCA9IGZ1bmN0aW9uKGlzQ2xpcCwgaXNNYXNrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0KCd2aXNpYmlsaXR5JykgPT09ICdoaWRkZW4nIHx8ICF0aGlzLnNoYXBlKSB7cmV0dXJuO31cclxuICAgICAgICBkb2Muc2F2ZSgpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtKCk7XHJcbiAgICAgICAgdGhpcy5jbGlwKCk7XHJcbiAgICAgICAgaWYgKCFpc0NsaXApIHtcclxuICAgICAgICAgIGxldCBtYXNrZWQgPSB0aGlzLm1hc2soKSxcclxuICAgICAgICAgICAgICBncm91cDtcclxuICAgICAgICAgIGlmIChtYXNrZWQpIHtcclxuICAgICAgICAgICAgZ3JvdXAgPSBkb2NCZWdpbkdyb3VwKGdldFBhZ2VCQm94KCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGV0IHN1YlBhdGhzID0gdGhpcy5zaGFwZS5nZXRTdWJQYXRocygpLFxyXG4gICAgICAgICAgICAgIGZpbGwgPSB0aGlzLmdldEZpbGwoaXNDbGlwLCBpc01hc2spLFxyXG4gICAgICAgICAgICAgIHN0cm9rZSA9IHRoaXMuZ2V0U3Ryb2tlKGlzQ2xpcCwgaXNNYXNrKSxcclxuICAgICAgICAgICAgICBsaW5lV2lkdGggPSB0aGlzLmdldCgnc3Ryb2tlLXdpZHRoJyksXHJcbiAgICAgICAgICAgICAgbGluZUNhcCA9IHRoaXMuZ2V0KCdzdHJva2UtbGluZWNhcCcpO1xyXG4gICAgICAgICAgaWYgKGZpbGwgfHwgc3Ryb2tlKSB7XHJcbiAgICAgICAgICAgIGlmIChmaWxsKSB7XHJcbiAgICAgICAgICAgICAgZG9jRmlsbENvbG9yKGZpbGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdHJva2UpIHtcclxuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN1YlBhdGhzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFcXVhbChzdWJQYXRoc1tqXS50b3RhbExlbmd0aCwgMCkpIHtcclxuICAgICAgICAgICAgICAgICAgaWYgKChsaW5lQ2FwID09PSAnc3F1YXJlJyB8fCBsaW5lQ2FwID09PSAncm91bmQnKSAmJiBsaW5lV2lkdGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YlBhdGhzW2pdLnN0YXJ0UG9pbnQgJiYgc3ViUGF0aHNbal0uc3RhcnRQb2ludC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgeCA9IHN1YlBhdGhzW2pdLnN0YXJ0UG9pbnRbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHN1YlBhdGhzW2pdLnN0YXJ0UG9pbnRbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICBkb2NGaWxsQ29sb3Ioc3Ryb2tlKTtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lQ2FwID09PSAnc3F1YXJlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2MucmVjdCh4IC0gMC41ICogbGluZVdpZHRoLCB5IC0gMC41ICogbGluZVdpZHRoLCBsaW5lV2lkdGgsIGxpbmVXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmVDYXAgPT09ICdyb3VuZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jLmNpcmNsZSh4LCB5LCAwLjUgKiBsaW5lV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgZG9jLmZpbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgbGV0IGRhc2hBcnJheSA9IHRoaXMuZ2V0KCdzdHJva2UtZGFzaGFycmF5JyksXHJcbiAgICAgICAgICAgICAgICAgIGRhc2hPZmZzZXQgPSB0aGlzLmdldCgnc3Ryb2tlLWRhc2hvZmZzZXQnKTtcclxuICAgICAgICAgICAgICBpZiAoaXNOb3RFcXVhbCh0aGlzLmRhc2hTY2FsZSwgMSkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGFzaEFycmF5Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgIGRhc2hBcnJheVtqXSAqPSB0aGlzLmRhc2hTY2FsZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRhc2hPZmZzZXQgKj0gdGhpcy5kYXNoU2NhbGU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGRvY1N0cm9rZUNvbG9yKHN0cm9rZSk7XHJcbiAgICAgICAgICAgICAgZG9jLmxpbmVXaWR0aChsaW5lV2lkdGgpXHJcbiAgICAgICAgICAgICAgICAgLm1pdGVyTGltaXQodGhpcy5nZXQoJ3N0cm9rZS1taXRlcmxpbWl0JykpXHJcbiAgICAgICAgICAgICAgICAgLmxpbmVKb2luKHRoaXMuZ2V0KCdzdHJva2UtbGluZWpvaW4nKSlcclxuICAgICAgICAgICAgICAgICAubGluZUNhcChsaW5lQ2FwKVxyXG4gICAgICAgICAgICAgICAgIC5kYXNoKGRhc2hBcnJheSwge3BoYXNlOiBkYXNoT2Zmc2V0fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdWJQYXRocy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgIGlmIChzdWJQYXRoc1tqXS50b3RhbExlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHN1YlBhdGhzW2pdLmluc2VydEluRG9jdW1lbnQoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZpbGwgJiYgc3Ryb2tlKSB7XHJcbiAgICAgICAgICAgICAgZG9jLmZpbGxBbmRTdHJva2UodGhpcy5nZXQoJ2ZpbGwtcnVsZScpKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChmaWxsKSB7XHJcbiAgICAgICAgICAgICAgZG9jLmZpbGwodGhpcy5nZXQoJ2ZpbGwtcnVsZScpKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJva2UpIHtcclxuICAgICAgICAgICAgICBkb2Muc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxldCBtYXJrZXJTdGFydCA9IHRoaXMuZ2V0KCdtYXJrZXItc3RhcnQnKSxcclxuICAgICAgICAgICAgICBtYXJrZXJNaWQgPSB0aGlzLmdldCgnbWFya2VyLW1pZCcpLFxyXG4gICAgICAgICAgICAgIG1hcmtlckVuZCA9IHRoaXMuZ2V0KCdtYXJrZXItZW5kJyk7XHJcbiAgICAgICAgICBpZiAobWFya2VyU3RhcnQgIT09ICdub25lJyB8fCBtYXJrZXJNaWQgIT09ICdub25lJyB8fCBtYXJrZXJFbmQgIT09ICdub25lJykge1xyXG4gICAgICAgICAgICBsZXQgbWFya2Vyc1BvcyA9IHRoaXMuc2hhcGUuZ2V0TWFya2VycygpO1xyXG4gICAgICAgICAgICBpZiAobWFya2VyU3RhcnQgIT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgIGxldCBtYXJrZXIgPSBuZXcgU3ZnRWxlbU1hcmtlcihtYXJrZXJTdGFydCwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgbWFya2VyLmRyYXdNYXJrZXIoZmFsc2UsIGlzTWFzaywgbWFya2Vyc1Bvc1swXSwgbGluZVdpZHRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWFya2VyTWlkICE9PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG1hcmtlcnNQb3MubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWFya2VyID0gbmV3IFN2Z0VsZW1NYXJrZXIobWFya2VyTWlkLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIG1hcmtlci5kcmF3TWFya2VyKGZhbHNlLCBpc01hc2ssIG1hcmtlcnNQb3NbaV0sIGxpbmVXaWR0aCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXJrZXJFbmQgIT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgIGxldCBtYXJrZXIgPSBuZXcgU3ZnRWxlbU1hcmtlcihtYXJrZXJFbmQsIG51bGwpO1xyXG4gICAgICAgICAgICAgIG1hcmtlci5kcmF3TWFya2VyKGZhbHNlLCBpc01hc2ssIG1hcmtlcnNQb3NbbWFya2Vyc1Bvcy5sZW5ndGggLSAxXSwgbGluZVdpZHRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGRvY0VuZEdyb3VwKGdyb3VwKTtcclxuICAgICAgICAgICAgZG9jSW5zZXJ0R3JvdXAoZ3JvdXApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnNoYXBlLmluc2VydEluRG9jdW1lbnQoKTtcclxuICAgICAgICAgIGRvY0ZpbGxDb2xvcihEZWZhdWx0Q29sb3JzLndoaXRlKTtcclxuICAgICAgICAgIGRvYy5maWxsKHRoaXMuZ2V0KCdjbGlwLXJ1bGUnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvYy5yZXN0b3JlKCk7XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBTdmdFbGVtUmVjdCA9IGZ1bmN0aW9uKG9iaiwgaW5oZXJpdHMpIHtcclxuICAgICAgU3ZnRWxlbUJhc2ljU2hhcGUuY2FsbCh0aGlzLCBvYmosIGluaGVyaXRzKTtcclxuICAgICAgbGV0IHggPSB0aGlzLmdldExlbmd0aCgneCcsIHRoaXMuZ2V0VldpZHRoKCksIDApLFxyXG4gICAgICAgICAgeSA9IHRoaXMuZ2V0TGVuZ3RoKCd5JywgdGhpcy5nZXRWSGVpZ2h0KCksIDApLFxyXG4gICAgICAgICAgdyA9IHRoaXMuZ2V0TGVuZ3RoKCd3aWR0aCcsIHRoaXMuZ2V0VldpZHRoKCksIDApLFxyXG4gICAgICAgICAgaCA9IHRoaXMuZ2V0TGVuZ3RoKCdoZWlnaHQnLCB0aGlzLmdldFZIZWlnaHQoKSwgMCksXHJcbiAgICAgICAgICByeCA9IHRoaXMuZ2V0TGVuZ3RoKCdyeCcsIHRoaXMuZ2V0VldpZHRoKCkpLFxyXG4gICAgICAgICAgcnkgPSB0aGlzLmdldExlbmd0aCgncnknLCB0aGlzLmdldFZIZWlnaHQoKSk7XHJcbiAgICAgIGlmIChyeCA9PT0gdW5kZWZpbmVkICYmIHJ5ID09PSB1bmRlZmluZWQpIHtyeCA9IHJ5ID0gMDt9XHJcbiAgICAgIGVsc2UgaWYgKHJ4ID09PSB1bmRlZmluZWQgJiYgcnkgIT09IHVuZGVmaW5lZCkge3J4ID0gcnk7fVxyXG4gICAgICBlbHNlIGlmIChyeCAhPT0gdW5kZWZpbmVkICYmIHJ5ID09PSB1bmRlZmluZWQpIHtyeSA9IHJ4O31cclxuICAgICAgaWYgKHcgPiAwICYmIGggPiAwKSB7XHJcbiAgICAgICAgaWYgKHJ4ICYmIHJ5KSB7XHJcbiAgICAgICAgICByeCA9IE1hdGgubWluKHJ4LCAwLjUgKiB3KTtcclxuICAgICAgICAgIHJ5ID0gTWF0aC5taW4ocnksIDAuNSAqIGgpO1xyXG4gICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBTdmdTaGFwZSgpLk0oeCArIHJ4LCB5KS5MKHggKyB3IC0gcngsIHkpLkEocngsIHJ5LCAwLCAwLCAxLCB4ICsgdywgeSArIHJ5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLkwoeCArIHcsIHkgKyBoIC0gcnkpLkEocngsIHJ5LCAwLCAwLCAxLCB4ICsgdyAtIHJ4LCB5ICsgaCkuTCh4ICsgcngsIHkgKyBoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLkEocngsIHJ5LCAwLCAwLCAxLCB4LCB5ICsgaCAtIHJ5KS5MKHgsIHkgKyByeSkuQShyeCwgcnksIDAsIDAsIDEsIHggKyByeCwgeSkuWigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFN2Z1NoYXBlKCkuTSh4LCB5KS5MKHggKyB3LCB5KS5MKHggKyB3LCB5ICsgaCkuTCh4LCB5ICsgaCkuWigpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFN2Z1NoYXBlKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIFN2Z0VsZW1DaXJjbGUgPSBmdW5jdGlvbihvYmosIGluaGVyaXRzKSB7XHJcbiAgICAgIFN2Z0VsZW1CYXNpY1NoYXBlLmNhbGwodGhpcywgb2JqLCBpbmhlcml0cyk7XHJcbiAgICAgIGxldCBjeCA9IHRoaXMuZ2V0TGVuZ3RoKCdjeCcsIHRoaXMuZ2V0VldpZHRoKCksIDApLFxyXG4gICAgICAgICAgY3kgPSB0aGlzLmdldExlbmd0aCgnY3knLCB0aGlzLmdldFZIZWlnaHQoKSwgMCksXHJcbiAgICAgICAgICByID0gdGhpcy5nZXRMZW5ndGgoJ3InLCB0aGlzLmdldFZpZXdwb3J0KCksIDApO1xyXG4gICAgICBpZiAociA+IDApIHtcclxuICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFN2Z1NoYXBlKCkuTShjeCArIHIsIGN5KS5BKHIsIHIsIDAsIDAsIDEsIGN4IC0gciwgY3kpLkEociwgciwgMCwgMCwgMSwgY3ggKyByLCBjeSkuWigpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgU3ZnU2hhcGUoKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgU3ZnRWxlbUVsbGlwc2UgPSBmdW5jdGlvbihvYmosIGluaGVyaXRzKSB7XHJcbiAgICAgIFN2Z0VsZW1CYXNpY1NoYXBlLmNhbGwodGhpcywgb2JqLCBpbmhlcml0cyk7XHJcbiAgICAgIGxldCBjeCA9IHRoaXMuZ2V0TGVuZ3RoKCdjeCcsIHRoaXMuZ2V0VldpZHRoKCksIDApLFxyXG4gICAgICAgICAgY3kgPSB0aGlzLmdldExlbmd0aCgnY3knLCB0aGlzLmdldFZIZWlnaHQoKSwgMCksXHJcbiAgICAgICAgICByeCA9IHRoaXMuZ2V0TGVuZ3RoKCdyeCcsIHRoaXMuZ2V0VldpZHRoKCksIDApLFxyXG4gICAgICAgICAgcnkgPSB0aGlzLmdldExlbmd0aCgncnknLCB0aGlzLmdldFZIZWlnaHQoKSwgMCk7XHJcbiAgICAgIGlmIChyeCA+IDAgJiYgcnkgPiAwKSB7XHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBTdmdTaGFwZSgpLk0oY3ggKyByeCwgY3kpLkEocngsIHJ5LCAwLCAwLCAxLCBjeCAtIHJ4LCBjeSkuQShyeCwgcnksIDAsIDAsIDEsIGN4ICsgcngsIGN5KS5aKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBTdmdTaGFwZSgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBTdmdFbGVtTGluZSA9IGZ1bmN0aW9uKG9iaiwgaW5oZXJpdHMpIHtcclxuICAgICAgU3ZnRWxlbUJhc2ljU2hhcGUuY2FsbCh0aGlzLCBvYmosIGluaGVyaXRzKTtcclxuICAgICAgbGV0IHgxID0gdGhpcy5nZXRMZW5ndGgoJ3gxJywgdGhpcy5nZXRWV2lkdGgoKSwgMCksXHJcbiAgICAgICAgICB5MSA9IHRoaXMuZ2V0TGVuZ3RoKCd5MScsIHRoaXMuZ2V0VkhlaWdodCgpLCAwKSxcclxuICAgICAgICAgIHgyID0gdGhpcy5nZXRMZW5ndGgoJ3gyJywgdGhpcy5nZXRWV2lkdGgoKSwgMCksXHJcbiAgICAgICAgICB5MiA9IHRoaXMuZ2V0TGVuZ3RoKCd5MicsIHRoaXMuZ2V0VkhlaWdodCgpLCAwKTtcclxuICAgICAgdGhpcy5zaGFwZSA9IG5ldyBTdmdTaGFwZSgpLk0oeDEsIHkxKS5MKHgyLCB5Mik7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBTdmdFbGVtUG9seWxpbmUgPSBmdW5jdGlvbihvYmosIGluaGVyaXRzKSB7XHJcbiAgICAgIFN2Z0VsZW1CYXNpY1NoYXBlLmNhbGwodGhpcywgb2JqLCBpbmhlcml0cyk7XHJcbiAgICAgIGxldCBwb2ludHMgPSB0aGlzLmdldE51bWJlckxpc3QoJ3BvaW50cycpO1xyXG4gICAgICB0aGlzLnNoYXBlID0gbmV3IFN2Z1NoYXBlKCk7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xyXG4gICAgICAgIGlmIChpID09PSAwKSB7XHJcbiAgICAgICAgICB0aGlzLnNoYXBlLk0ocG9pbnRzW2ldLCBwb2ludHNbaSsxXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuc2hhcGUuTChwb2ludHNbaV0sIHBvaW50c1tpKzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHBvaW50cy5lcnJvcikge3dhcm5pbmdDYWxsYmFjaygnU3ZnRWxlbVBvbHlnb246IHVuZXhwZWN0ZWQgc3RyaW5nICcgKyBwb2ludHMuZXJyb3IpO31cclxuICAgICAgaWYgKHBvaW50cy5sZW5ndGggJSAyID09PSAxKSB7d2FybmluZ0NhbGxiYWNrKCdTdmdFbGVtUG9seWxpbmU6IHVuZXZlbiBudW1iZXIgb2YgY29vcmRpbmF0ZXMnKTt9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBTdmdFbGVtUG9seWdvbiA9IGZ1bmN0aW9uKG9iaiwgaW5oZXJpdHMpIHtcclxuICAgICAgU3ZnRWxlbUJhc2ljU2hhcGUuY2FsbCh0aGlzLCBvYmosIGluaGVyaXRzKTtcclxuICAgICAgbGV0IHBvaW50cyA9IHRoaXMuZ2V0TnVtYmVyTGlzdCgncG9pbnRzJyk7XHJcbiAgICAgIHRoaXMuc2hhcGUgPSBuZXcgU3ZnU2hhcGUoKTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XHJcbiAgICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgIHRoaXMuc2hhcGUuTShwb2ludHNbaV0sIHBvaW50c1tpKzFdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5zaGFwZS5MKHBvaW50c1tpXSwgcG9pbnRzW2krMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNoYXBlLlooKTtcclxuICAgICAgaWYgKHBvaW50cy5lcnJvcikge3dhcm5pbmdDYWxsYmFjaygnU3ZnRWxlbVBvbHlnb246IHVuZXhwZWN0ZWQgc3RyaW5nICcgKyBwb2ludHMuZXJyb3IpO31cclxuICAgICAgaWYgKHBvaW50cy5sZW5ndGggJSAyID09PSAxKSB7d2FybmluZ0NhbGxiYWNrKCdTdmdFbGVtUG9seWdvbjogdW5ldmVuIG51bWJlciBvZiBjb29yZGluYXRlcycpO31cclxuICAgIH07XHJcblxyXG4gICAgdmFyIFN2Z0VsZW1QYXRoID0gZnVuY3Rpb24ob2JqLCBpbmhlcml0cykge1xyXG4gICAgICBTdmdFbGVtQmFzaWNTaGFwZS5jYWxsKHRoaXMsIG9iaiwgaW5oZXJpdHMpO1xyXG4gICAgICB0aGlzLnNoYXBlID0gbmV3IFN2Z1NoYXBlKCkucGF0aCh0aGlzLmF0dHIoJ2QnKSk7XHJcbiAgICAgIGxldCBwYXRoTGVuZ3RoID0gdGhpcy5nZXRMZW5ndGgoJ3BhdGhMZW5ndGgnLCB0aGlzLmdldFZpZXdwb3J0KCkpO1xyXG4gICAgICB0aGlzLnBhdGhMZW5ndGggPSBwYXRoTGVuZ3RoID4gMCA/IHBhdGhMZW5ndGggOiB1bmRlZmluZWQ7XHJcbiAgICAgIHRoaXMuZGFzaFNjYWxlID0gKHRoaXMucGF0aExlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhpcy5zaGFwZS50b3RhbExlbmd0aCAvIHRoaXMucGF0aExlbmd0aCA6IDEpO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgU3ZnRWxlbU1hcmtlciA9IGZ1bmN0aW9uKG9iaiwgaW5oZXJpdHMpIHtcclxuICAgICAgU3ZnRWxlbUhhc0NoaWxkcmVuLmNhbGwodGhpcywgb2JqLCBpbmhlcml0cyk7XHJcbiAgICAgIGxldCB3aWR0aCA9IHRoaXMuZ2V0TGVuZ3RoKCdtYXJrZXJXaWR0aCcsIHRoaXMuZ2V0UGFyZW50VldpZHRoKCksIDMpLFxyXG4gICAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRMZW5ndGgoJ21hcmtlckhlaWdodCcsIHRoaXMuZ2V0UGFyZW50VkhlaWdodCgpLCAzKSxcclxuICAgICAgICAgIHZpZXdCb3ggPSB0aGlzLmdldFZpZXdib3goJ3ZpZXdCb3gnLCBbMCwgMCwgd2lkdGgsIGhlaWdodF0pO1xyXG4gICAgICB0aGlzLmdldFZXaWR0aCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB2aWV3Qm94WzJdO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmdldFZIZWlnaHQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdmlld0JveFszXTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5kcmF3TWFya2VyID0gZnVuY3Rpb24oaXNDbGlwLCBpc01hc2ssIHBvc0FycmF5LCBzdHJva2VXaWR0aCkge1xyXG4gICAgICAgIGRvYy5zYXZlKCk7XHJcbiAgICAgICAgbGV0IG9yaWVudCA9IHRoaXMuYXR0cignb3JpZW50JyksXHJcbiAgICAgICAgICAgIHVuaXRzID0gdGhpcy5hdHRyKCdtYXJrZXJVbml0cycpLFxyXG4gICAgICAgICAgICByb3RhdGUgPSAob3JpZW50ID09PSAnYXV0bycgPyBwb3NBcnJheVsyXSA6IChwYXJzZUZsb2F0KG9yaWVudCkgfHwgMCkgKiBNYXRoLlBJIC8gMTgwKSxcclxuICAgICAgICAgICAgc2NhbGUgPSAodW5pdHMgPT09ICd1c2VyU3BhY2VPblVzZScgPyAxIDogc3Ryb2tlV2lkdGgpO1xyXG4gICAgICAgIGRvYy50cmFuc2Zvcm0oTWF0aC5jb3Mocm90YXRlKSAqIHNjYWxlLCBNYXRoLnNpbihyb3RhdGUpICogc2NhbGUsIC1NYXRoLnNpbihyb3RhdGUpICogc2NhbGUsIE1hdGguY29zKHJvdGF0ZSkgKiBzY2FsZSwgcG9zQXJyYXlbMF0sIHBvc0FycmF5WzFdKTtcclxuICAgICAgICBsZXQgcmVmWCA9IHRoaXMuZ2V0TGVuZ3RoKCdyZWZYJywgdGhpcy5nZXRWV2lkdGgoKSwgMCksXHJcbiAgICAgICAgICAgIHJlZlkgPSB0aGlzLmdldExlbmd0aCgncmVmWScsIHRoaXMuZ2V0VkhlaWdodCgpLCAwKSxcclxuICAgICAgICAgICAgYXNwZWN0UmF0aW9NYXRyaXggPSBwYXJzZUFzcGVjdFJhdGlvKHRoaXMuYXR0cigncHJlc2VydmVBc3BlY3RSYXRpbycpLCB3aWR0aCwgaGVpZ2h0LCB2aWV3Qm94WzJdLCB2aWV3Qm94WzNdLCAwLjUpO1xyXG4gICAgICAgIGlmICh0aGlzLmdldCgnb3ZlcmZsb3cnKSA9PT0gJ2hpZGRlbicpIHtcclxuICAgICAgICAgIGRvYy5yZWN0KGFzcGVjdFJhdGlvTWF0cml4WzBdICogKHZpZXdCb3hbMF0gKyB2aWV3Qm94WzJdIC8gMiAtIHJlZlgpIC0gd2lkdGggLyAyLCBhc3BlY3RSYXRpb01hdHJpeFszXSAqICh2aWV3Qm94WzFdICsgdmlld0JveFszXSAvIDIgLSByZWZZKSAtIGhlaWdodCAvIDIsIHdpZHRoLCBoZWlnaHQpLmNsaXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jLnRyYW5zZm9ybS5hcHBseShkb2MsIGFzcGVjdFJhdGlvTWF0cml4KTtcclxuICAgICAgICBkb2MudHJhbnNsYXRlKC1yZWZYLCAtcmVmWSk7XHJcbiAgICAgICAgbGV0IGdyb3VwO1xyXG4gICAgICAgIGlmICh0aGlzLmdldCgnb3BhY2l0eScpIDwgMSAmJiAhaXNDbGlwKSB7XHJcbiAgICAgICAgICBncm91cCA9IGRvY0JlZ2luR3JvdXAoZ2V0UGFnZUJCb3goKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZHJhd0NoaWxkcmVuKGlzQ2xpcCwgaXNNYXNrKTtcclxuICAgICAgICBpZiAoZ3JvdXApIHtcclxuICAgICAgICAgIGRvY0VuZEdyb3VwKGdyb3VwKTtcclxuICAgICAgICAgIGRvYy5maWxsT3BhY2l0eSh0aGlzLmdldCgnb3BhY2l0eScpKTtcclxuICAgICAgICAgIGRvY0luc2VydEdyb3VwKGdyb3VwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jLnJlc3RvcmUoKTtcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIFN2Z0VsZW1DbGlwUGF0aCA9IGZ1bmN0aW9uKG9iaiwgaW5oZXJpdHMpIHtcclxuICAgICAgU3ZnRWxlbUhhc0NoaWxkcmVuLmNhbGwodGhpcywgb2JqLCBpbmhlcml0cyk7XHJcbiAgICAgIHRoaXMudXNlTWFzayA9IGZ1bmN0aW9uKGJCb3gpIHtcclxuICAgICAgICBsZXQgZ3JvdXAgPSBkb2NCZWdpbkdyb3VwKGdldFBhZ2VCQm94KCkpO1xyXG4gICAgICAgIGRvYy5zYXZlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuYXR0cignY2xpcFBhdGhVbml0cycpID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnKSB7XHJcbiAgICAgICAgICBkb2MudHJhbnNmb3JtKGJCb3hbMl0gLSBiQm94WzBdLCAwLCAwLCBiQm94WzNdIC0gYkJveFsxXSwgYkJveFswXSwgYkJveFsxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2xpcCgpO1xyXG4gICAgICAgIHRoaXMuZHJhd0NoaWxkcmVuKHRydWUsIGZhbHNlKTtcclxuICAgICAgICBkb2MucmVzdG9yZSgpO1xyXG4gICAgICAgIGRvY0VuZEdyb3VwKGdyb3VwKTtcclxuICAgICAgICBkb2NBcHBseU1hc2soZ3JvdXAsIHRydWUpO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgU3ZnRWxlbU1hc2sgPSBmdW5jdGlvbihvYmosIGluaGVyaXRzKSB7XHJcbiAgICAgIFN2Z0VsZW1IYXNDaGlsZHJlbi5jYWxsKHRoaXMsIG9iaiwgaW5oZXJpdHMpO1xyXG4gICAgICB0aGlzLnVzZU1hc2sgPSBmdW5jdGlvbihiQm94KSB7XHJcbiAgICAgICAgbGV0IGdyb3VwID0gZG9jQmVnaW5Hcm91cChnZXRQYWdlQkJveCgpKTtcclxuICAgICAgICBkb2Muc2F2ZSgpO1xyXG4gICAgICAgIGxldCB4LCB5LCB3LCBoO1xyXG4gICAgICAgIGlmICh0aGlzLmF0dHIoJ21hc2tVbml0cycpID09PSAndXNlclNwYWNlT25Vc2UnKSB7XHJcbiAgICAgICAgICB4ID0gdGhpcy5nZXRMZW5ndGgoJ3gnLCB0aGlzLmdldFZXaWR0aCgpLCAtMC4xICogKGJCb3hbMl0gLSBiQm94WzBdKSArIGJCb3hbMF0pO1xyXG4gICAgICAgICAgeSA9IHRoaXMuZ2V0TGVuZ3RoKCd5JywgdGhpcy5nZXRWSGVpZ2h0KCksIC0wLjEgKiAoYkJveFszXSAtIGJCb3hbMV0pICsgYkJveFsxXSk7XHJcbiAgICAgICAgICB3ID0gdGhpcy5nZXRMZW5ndGgoJ3dpZHRoJywgdGhpcy5nZXRWV2lkdGgoKSwgMS4yICogKGJCb3hbMl0gLSBiQm94WzBdKSk7XHJcbiAgICAgICAgICBoID0gdGhpcy5nZXRMZW5ndGgoJ2hlaWdodCcsIHRoaXMuZ2V0VkhlaWdodCgpLCAxLjIgKiAoYkJveFszXSAtIGJCb3hbMV0pKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeCA9IHRoaXMuZ2V0TGVuZ3RoKCd4JywgdGhpcy5nZXRWV2lkdGgoKSwgLTAuMSkgKiAoYkJveFsyXSAtIGJCb3hbMF0pICsgYkJveFswXTtcclxuICAgICAgICAgIHkgPSB0aGlzLmdldExlbmd0aCgneScsIHRoaXMuZ2V0VkhlaWdodCgpLCAtMC4xKSAqIChiQm94WzNdIC0gYkJveFsxXSkgKyBiQm94WzFdO1xyXG4gICAgICAgICAgdyA9IHRoaXMuZ2V0TGVuZ3RoKCd3aWR0aCcsIHRoaXMuZ2V0VldpZHRoKCksIDEuMikgKiAoYkJveFsyXSAtIGJCb3hbMF0pO1xyXG4gICAgICAgICAgaCA9IHRoaXMuZ2V0TGVuZ3RoKCdoZWlnaHQnLCB0aGlzLmdldFZIZWlnaHQoKSwgMS4yKSAqIChiQm94WzNdIC0gYkJveFsxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvYy5yZWN0KHgsIHksIHcsIGgpLmNsaXAoKTtcclxuICAgICAgICBpZiAodGhpcy5hdHRyKCdtYXNrQ29udGVudFVuaXRzJykgPT09ICdvYmplY3RCb3VuZGluZ0JveCcpIHtcclxuICAgICAgICAgIGRvYy50cmFuc2Zvcm0oYkJveFsyXSAtIGJCb3hbMF0sIDAsIDAsIGJCb3hbM10gLSBiQm94WzFdLCBiQm94WzBdLCBiQm94WzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jbGlwKCk7XHJcbiAgICAgICAgdGhpcy5kcmF3Q2hpbGRyZW4oZmFsc2UsIHRydWUpO1xyXG4gICAgICAgIGRvYy5yZXN0b3JlKCk7XHJcbiAgICAgICAgZG9jRW5kR3JvdXAoZ3JvdXApO1xyXG4gICAgICAgIGRvY0FwcGx5TWFzayhncm91cCwgdHJ1ZSk7XHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBTdmdFbGVtVGV4dENvbnRhaW5lciA9IGZ1bmN0aW9uKG9iaiwgaW5oZXJpdHMpIHtcclxuICAgICAgU3ZnRWxlbVN0eWxhYmxlLmNhbGwodGhpcywgb2JqLCBpbmhlcml0cyk7XHJcbiAgICAgIHRoaXMuYWxsb3dlZENoaWxkcmVuID0gWyd0c3BhbicsICcjdGV4dCcsICcjY2RhdGEtc2VjdGlvbicsICdhJ107XHJcbiAgICAgIHRoaXMuaXNUZXh0ID0gdHJ1ZTtcclxuICAgICAgdGhpcy5nZXRCb3VuZGluZ1NoYXBlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgbGV0IHNoYXBlID0gbmV3IFN2Z1NoYXBlKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wb3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGxldCBwb3MgPSB0aGlzLl9wb3NbaV07XHJcbiAgICAgICAgICBpZiAoIXBvcy5oaWRkZW4pIHtcclxuICAgICAgICAgICAgbGV0IGR4MCA9IHBvcy5hc2NlbnQgKiBNYXRoLnNpbihwb3Mucm90YXRlKSwgZHkwID0gLXBvcy5hc2NlbnQgKiBNYXRoLmNvcyhwb3Mucm90YXRlKSxcclxuICAgICAgICAgICAgICAgIGR4MSA9IHBvcy5kZXNjZW50ICogTWF0aC5zaW4ocG9zLnJvdGF0ZSksIGR5MSA9IC1wb3MuZGVzY2VudCAqIE1hdGguY29zKHBvcy5yb3RhdGUpLFxyXG4gICAgICAgICAgICAgICAgZHgyID0gcG9zLndpZHRoICogTWF0aC5jb3MocG9zLnJvdGF0ZSksIGR5MiA9IHBvcy53aWR0aCAqIE1hdGguc2luKHBvcy5yb3RhdGUpO1xyXG4gICAgICAgICAgICBzaGFwZS5NKHBvcy54ICsgZHgwLCBwb3MueSArIGR5MCkuTChwb3MueCArIGR4MCArIGR4MiwgcG9zLnkgKyBkeTAgKyBkeTIpXHJcbiAgICAgICAgICAgICAgICAgLk0ocG9zLnggKyBkeDEgKyBkeDIsIHBvcy55ICsgZHkxICsgZHkyKS5MKHBvcy54ICsgZHgxLCBwb3MueSArIGR5MSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaGFwZTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5kcmF3VGV4dEluRG9jdW1lbnQgPSBmdW5jdGlvbihpc0NsaXAsIGlzTWFzaykge1xyXG4gICAgICAgIGlmICh0aGlzLmxpbmsgJiYgIWlzQ2xpcCAmJiAhaXNNYXNrKSB7dGhpcy5hZGRMaW5rKCk7fVxyXG4gICAgICAgIGlmICh0aGlzLmdldCgndGV4dC1kZWNvcmF0aW9uJykgPT09ICd1bmRlcmxpbmUnKSB7XHJcbiAgICAgICAgICB0aGlzLmRlY29yYXRlKDAuMDUgKiB0aGlzLl9mb250LnNpemUsIC0wLjA3NSAqIHRoaXMuX2ZvbnQuc2l6ZSwgaXNDbGlwLCBpc01hc2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5nZXQoJ3RleHQtZGVjb3JhdGlvbicpID09PSAnb3ZlcmxpbmUnKSB7XHJcbiAgICAgICAgICB0aGlzLmRlY29yYXRlKDAuMDUgKiB0aGlzLl9mb250LnNpemUsIGdldEFzY2VudCh0aGlzLl9mb250LmZvbnQsIHRoaXMuX2ZvbnQuc2l6ZSkgKyAwLjA3NSAqIHRoaXMuX2ZvbnQuc2l6ZSwgaXNDbGlwLCBpc01hc2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZmlsbCA9IHRoaXMuZ2V0RmlsbChpc0NsaXAsIGlzTWFzayksXHJcbiAgICAgICAgICAgIHN0cm9rZSA9IHRoaXMuZ2V0U3Ryb2tlKGlzQ2xpcCwgaXNNYXNrKSxcclxuICAgICAgICAgICAgc3Ryb2tlV2lkdGggPSB0aGlzLmdldCgnc3Ryb2tlLXdpZHRoJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZvbnQuZmF1eEJvbGQpIHtcclxuICAgICAgICAgIGlmICghc3Ryb2tlKSB7XHJcbiAgICAgICAgICAgIHN0cm9rZSA9IGZpbGw7XHJcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoID0gdGhpcy5fZm9udC5zaXplICogMC4wMztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoICs9IHRoaXMuX2ZvbnQuc2l6ZSAqIDAuMDM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBsZXQgY2hpbGRFbGVtID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICBzd2l0Y2goY2hpbGRFbGVtLm5hbWUpIHtcclxuICAgICAgICAgICAgY2FzZSAndHNwYW4nOiBjYXNlICd0ZXh0UGF0aCc6IGNhc2UgJ2EnOlxyXG4gICAgICAgICAgICAgIGlmIChjaGlsZEVsZW0uZ2V0KCdkaXNwbGF5JykgIT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRFbGVtLmRyYXdUZXh0SW5Eb2N1bWVudChpc0NsaXAsIGlzTWFzayk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICcjdGV4dCc6IGNhc2UgJyNjZGF0YS1zZWN0aW9uJzpcclxuICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoJ3Zpc2liaWxpdHknKSA9PT0gJ2hpZGRlbicpIHtjb250aW51ZTt9XHJcbiAgICAgICAgICAgICAgaWYgKGZpbGwgfHwgc3Ryb2tlIHx8IGlzQ2xpcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpbGwpIHtcclxuICAgICAgICAgICAgICAgICAgZG9jRmlsbENvbG9yKGZpbGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHN0cm9rZSAmJiBzdHJva2VXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICBkb2NTdHJva2VDb2xvcihzdHJva2UpO1xyXG4gICAgICAgICAgICAgICAgICBkb2MubGluZVdpZHRoKHN0cm9rZVdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICAgICAubWl0ZXJMaW1pdCh0aGlzLmdldCgnc3Ryb2tlLW1pdGVybGltaXQnKSlcclxuICAgICAgICAgICAgICAgICAgICAgLmxpbmVKb2luKHRoaXMuZ2V0KCdzdHJva2UtbGluZWpvaW4nKSlcclxuICAgICAgICAgICAgICAgICAgICAgLmxpbmVDYXAodGhpcy5nZXQoJ3N0cm9rZS1saW5lY2FwJykpXHJcbiAgICAgICAgICAgICAgICAgICAgIC5kYXNoKHRoaXMuZ2V0KCdzdHJva2UtZGFzaGFycmF5JyksIHtwaGFzZTp0aGlzLmdldCgnc3Ryb2tlLWRhc2hvZmZzZXQnKX0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZG9jQmVnaW5UZXh0KHRoaXMuX2ZvbnQuZm9udCwgdGhpcy5fZm9udC5zaXplKTtcclxuICAgICAgICAgICAgICAgIGRvY1NldFRleHRNb2RlKCEhZmlsbCwgISFzdHJva2UpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIHBvcyA9IGNoaWxkRWxlbS5fcG9zOyBqIDwgcG9zLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgIGlmICghcG9zW2pdLmhpZGRlbiAmJiBpc05vdEVxdWFsKHBvc1tqXS53aWR0aCwgMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29zID0gTWF0aC5jb3MocG9zW2pdLnJvdGF0ZSksIHNpbiA9IE1hdGguc2luKHBvc1tqXS5yb3RhdGUpLCBza2V3ID0gKHRoaXMuX2ZvbnQuZmF1eEl0YWxpYyA/IC0wLjI1IDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jU2V0VGV4dE1hdHJpeChjb3MgKiBwb3Nbal0uc2NhbGUsIHNpbiAqIHBvc1tqXS5zY2FsZSwgY29zICogc2tldyAtIHNpbiwgc2luICogc2tldyArIGNvcywgcG9zW2pdLngsIHBvc1tqXS55KTtcclxuICAgICAgICAgICAgICAgICAgICBkb2NXcml0ZUdseXBoKHBvc1tqXS5nbHlwaCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRvY0VuZFRleHQoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmdldCgndGV4dC1kZWNvcmF0aW9uJykgPT09ICdsaW5lLXRocm91Z2gnKSB7XHJcbiAgICAgICAgICB0aGlzLmRlY29yYXRlKDAuMDUgKiB0aGlzLl9mb250LnNpemUsIDAuNSAqIChnZXRBc2NlbnQodGhpcy5fZm9udC5mb250LCB0aGlzLl9mb250LnNpemUpICsgZ2V0RGVzY2VudCh0aGlzLl9mb250LmZvbnQsIHRoaXMuX2ZvbnQuc2l6ZSkpLCBpc0NsaXAsIGlzTWFzayk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLmRlY29yYXRlID0gZnVuY3Rpb24obGluZVdpZHRoLCBsaW5lUG9zaXRpb24sIGlzQ2xpcCwgaXNNYXNrKSB7XHJcbiAgICAgICAgbGV0IGZpbGwgPSB0aGlzLmdldEZpbGwoaXNDbGlwLCBpc01hc2spLFxyXG4gICAgICAgICAgICBzdHJva2UgPSB0aGlzLmdldFN0cm9rZShpc0NsaXAsIGlzTWFzayk7XHJcbiAgICAgICAgaWYgKGZpbGwpIHtcclxuICAgICAgICAgIGRvY0ZpbGxDb2xvcihmaWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0cm9rZSkge1xyXG4gICAgICAgICAgZG9jU3Ryb2tlQ29sb3Ioc3Ryb2tlKTtcclxuICAgICAgICAgIGRvYy5saW5lV2lkdGgodGhpcy5nZXQoJ3N0cm9rZS13aWR0aCcpKVxyXG4gICAgICAgICAgICAgLm1pdGVyTGltaXQodGhpcy5nZXQoJ3N0cm9rZS1taXRlcmxpbWl0JykpXHJcbiAgICAgICAgICAgICAubGluZUpvaW4odGhpcy5nZXQoJ3N0cm9rZS1saW5lam9pbicpKVxyXG4gICAgICAgICAgICAgLmxpbmVDYXAodGhpcy5nZXQoJ3N0cm9rZS1saW5lY2FwJykpXHJcbiAgICAgICAgICAgICAuZGFzaCh0aGlzLmdldCgnc3Ryb2tlLWRhc2hhcnJheScpLCB7cGhhc2U6dGhpcy5nZXQoJ3N0cm9rZS1kYXNob2Zmc2V0Jyl9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIHBvcyA9IHRoaXMuX3BvczsgaiA8IHBvcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgaWYgKCFwb3Nbal0uaGlkZGVuICYmIGlzTm90RXF1YWwocG9zW2pdLndpZHRoLCAwKSkge1xyXG4gICAgICAgICAgICBsZXQgZHgwID0gKGxpbmVQb3NpdGlvbiArIGxpbmVXaWR0aCAvIDIpICogTWF0aC5zaW4ocG9zW2pdLnJvdGF0ZSksXHJcbiAgICAgICAgICAgICAgICBkeTAgPSAtKGxpbmVQb3NpdGlvbiArIGxpbmVXaWR0aCAvIDIpICogTWF0aC5jb3MocG9zW2pdLnJvdGF0ZSksXHJcbiAgICAgICAgICAgICAgICBkeDEgPSAobGluZVBvc2l0aW9uIC0gbGluZVdpZHRoIC8gMikgKiBNYXRoLnNpbihwb3Nbal0ucm90YXRlKSxcclxuICAgICAgICAgICAgICAgIGR5MSA9IC0obGluZVBvc2l0aW9uIC0gbGluZVdpZHRoIC8gMikgKiBNYXRoLmNvcyhwb3Nbal0ucm90YXRlKSxcclxuICAgICAgICAgICAgICAgIGR4MiA9IHBvc1tqXS53aWR0aCAqIE1hdGguY29zKHBvc1tqXS5yb3RhdGUpLFxyXG4gICAgICAgICAgICAgICAgZHkyID0gcG9zW2pdLndpZHRoICogTWF0aC5zaW4ocG9zW2pdLnJvdGF0ZSk7XHJcbiAgICAgICAgICAgIG5ldyBTdmdTaGFwZSgpLk0ocG9zW2pdLnggKyBkeDAsIHBvc1tqXS55ICsgZHkwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5MKHBvc1tqXS54ICsgZHgwICsgZHgyLCBwb3Nbal0ueSArIGR5MCArIGR5MilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAuTChwb3Nbal0ueCArIGR4MSArIGR4MiwgcG9zW2pdLnkgKyBkeTEgKyBkeTIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLkwocG9zW2pdLnggKyBkeDEsIHBvc1tqXS55ICsgZHkxKS5aKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0SW5Eb2N1bWVudCgpO1xyXG4gICAgICAgICAgICBpZiAoZmlsbCAmJiBzdHJva2UpIHtcclxuICAgICAgICAgICAgICBkb2MuZmlsbEFuZFN0cm9rZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGwpIHtcclxuICAgICAgICAgICAgICBkb2MuZmlsbCgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cm9rZSkge1xyXG4gICAgICAgICAgICAgIGRvYy5zdHJva2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIFN2Z0VsZW1UZXh0Tm9kZSA9IGZ1bmN0aW9uKG9iaiwgaW5oZXJpdHMpIHtcclxuICAgICAgdGhpcy5uYW1lID0gb2JqLm5vZGVOYW1lO1xyXG4gICAgICB0aGlzLnRleHRDb250ZW50ID0gb2JqLm5vZGVWYWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIFN2Z0VsZW1Uc3BhbiA9IGZ1bmN0aW9uKG9iaiwgaW5oZXJpdHMpIHtcclxuICAgICAgU3ZnRWxlbVRleHRDb250YWluZXIuY2FsbCh0aGlzLCBvYmosIGluaGVyaXRzKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIFN2Z0VsZW1UZXh0UGF0aCA9IGZ1bmN0aW9uKG9iaiwgaW5oZXJpdHMpIHtcclxuICAgICAgU3ZnRWxlbVRleHRDb250YWluZXIuY2FsbCh0aGlzLCBvYmosIGluaGVyaXRzKTtcclxuICAgICAgbGV0IHBhdGhPYmplY3QsIHBhdGhMZW5ndGgsIHRlbXA7XHJcbiAgICAgIGlmICgodGVtcCA9IHRoaXMuYXR0cigncGF0aCcpKSAmJiB0ZW1wLnRyaW0oKSAhPT0gJycpIHtcclxuICAgICAgICBsZXQgcGF0aExlbmd0aCA9IHRoaXMuZ2V0TGVuZ3RoKCdwYXRoTGVuZ3RoJywgdGhpcy5nZXRWaWV3cG9ydCgpKTtcclxuICAgICAgICB0aGlzLnBhdGhPYmplY3QgPSBuZXcgU3ZnU2hhcGUoKS5wYXRoKHRlbXApO1xyXG4gICAgICAgIHRoaXMucGF0aExlbmd0aCA9IHBhdGhMZW5ndGggPiAwID8gcGF0aExlbmd0aCA6IHRoaXMucGF0aE9iamVjdC50b3RhbExlbmd0aDtcclxuICAgICAgICB0aGlzLnBhdGhTY2FsZSA9IHRoaXMucGF0aE9iamVjdC50b3RhbExlbmd0aCAvIHRoaXMucGF0aExlbmd0aDtcclxuICAgICAgfSBlbHNlIGlmICgodGVtcCA9IHRoaXMuZ2V0VXJsKCdocmVmJykgfHwgdGhpcy5nZXRVcmwoJ3hsaW5rOmhyZWYnKSkgJiYgdGVtcC5ub2RlTmFtZSA9PT0gJ3BhdGgnKSB7XHJcbiAgICAgICAgbGV0IHBhdGhFbGVtID0gbmV3IFN2Z0VsZW1QYXRoKHRlbXAsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMucGF0aE9iamVjdCA9IHBhdGhFbGVtLnNoYXBlLmNsb25lKCkudHJhbnNmb3JtKHBhdGhFbGVtLmdldCgndHJhbnNmb3JtJykpO1xyXG4gICAgICAgIHRoaXMucGF0aExlbmd0aCA9IHRoaXMuY2hvb3NlVmFsdWUocGF0aEVsZW0ucGF0aExlbmd0aCwgdGhpcy5wYXRoT2JqZWN0LnRvdGFsTGVuZ3RoKTtcclxuICAgICAgICB0aGlzLnBhdGhTY2FsZSA9IHRoaXMucGF0aE9iamVjdC50b3RhbExlbmd0aCAvIHRoaXMucGF0aExlbmd0aDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgU3ZnRWxlbVRleHQgPSBmdW5jdGlvbihvYmosIGluaGVyaXRzKSB7XHJcbiAgICAgIFN2Z0VsZW1UZXh0Q29udGFpbmVyLmNhbGwodGhpcywgb2JqLCBpbmhlcml0cyk7XHJcbiAgICAgIHRoaXMuYWxsb3dlZENoaWxkcmVuID0gWyd0ZXh0UGF0aCcsICd0c3BhbicsICcjdGV4dCcsICcjY2RhdGEtc2VjdGlvbicsICdhJ107XHJcbiAgICAgIChmdW5jdGlvbiAodGV4dFBhcmVudEVsZW0pIHtcclxuICAgICAgICBsZXQgcHJvY2Vzc2VkVGV4dCA9ICcnLCByZW1haW5pbmdUZXh0ID0gb2JqLnRleHRDb250ZW50LCB0ZXh0UGF0aHMgPSBbXSwgY3VycmVudENodW5rID0gW10sIGN1cnJlbnRBbmNob3IsIGN1cnJlbnREaXJlY3Rpb24sIGN1cnJlbnRYID0gMCwgY3VycmVudFkgPSAwO1xyXG4gICAgICAgIGZ1bmN0aW9uIGRvQW5jaG9yaW5nKCkge1xyXG4gICAgICAgICAgaWYgKGN1cnJlbnRDaHVuay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbGV0IGxhc3QgPSBjdXJyZW50Q2h1bmtbY3VycmVudENodW5rLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBjdXJyZW50Q2h1bmtbMF1cclxuICAgICAgICAgICAgbGV0IHdpZHRoID0gbGFzdC54ICsgbGFzdC53aWR0aCAtIGZpcnN0Lng7XHJcbiAgICAgICAgICAgIGxldCBhbmNob3JkeCA9IHsnc3RhcnRsdHInOiAwLCAnbWlkZGxlbHRyJzogMC41LCAnZW5kbHRyJzogMSwgJ3N0YXJ0cnRsJzogMSwgJ21pZGRsZXJ0bCc6IDAuNSwgJ2VuZHJ0bCc6IDB9W2N1cnJlbnRBbmNob3IgKyBjdXJyZW50RGlyZWN0aW9uXSAqIHdpZHRoIHx8IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudENodW5rLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgY3VycmVudENodW5rW2ldLnggLT0gYW5jaG9yZHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGN1cnJlbnRDaHVuayA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBhZGp1c3RMZW5ndGgocG9zLCBsZW5ndGgsIHNwYWNpbmdBbmRHbHlwaHMpIHtcclxuICAgICAgICAgIGxldCBmaXJzdENoYXIgPSBwb3NbMF0sIGxhc3RDaGFyID0gcG9zW3Bvcy5sZW5ndGggLSAxXSxcclxuICAgICAgICAgICAgICBzdGFydFggPSBmaXJzdENoYXIueCwgZW5kWCA9IGxhc3RDaGFyLnggKyBsYXN0Q2hhci53aWR0aDtcclxuICAgICAgICAgIGlmIChzcGFjaW5nQW5kR2x5cGhzKSB7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0U2NhbGUgPSBsZW5ndGggLyAoZW5kWCAtIHN0YXJ0WCk7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0U2NhbGUgPiAwICYmIHRleHRTY2FsZSA8IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwb3MubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHBvc1tqXS54ID0gc3RhcnRYICsgdGV4dFNjYWxlICogKHBvc1tqXS54IC0gc3RhcnRYKTtcclxuICAgICAgICAgICAgICAgIHBvc1tqXS5zY2FsZSAqPSB0ZXh0U2NhbGU7XHJcbiAgICAgICAgICAgICAgICBwb3Nbal0ud2lkdGggKj0gdGV4dFNjYWxlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHBvcy5sZW5ndGggPj0gMikge1xyXG4gICAgICAgICAgICAgIGxldCBzcGFjZURpZmYgPSAobGVuZ3RoIC0gKGVuZFggLSBzdGFydFgpKSAvIChwb3MubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwb3MubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHBvc1tqXS54ICs9IGogKiBzcGFjZURpZmY7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjdXJyZW50WCArPSBsZW5ndGggLSAoZW5kWCAtIHN0YXJ0WCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZShjdXJyZW50RWxlbSwgcGFyZW50RWxlbSkge1xyXG4gICAgICAgICAgY3VycmVudEVsZW0uX3ggPSBjb21iaW5lQXJyYXlzKGN1cnJlbnRFbGVtLmdldExlbmd0aExpc3QoJ3gnLCBjdXJyZW50RWxlbS5nZXRWV2lkdGgoKSksIChwYXJlbnRFbGVtID8gcGFyZW50RWxlbS5feC5zbGljZShwYXJlbnRFbGVtLl9wb3MubGVuZ3RoKSA6IFtdKSk7XHJcbiAgICAgICAgICBjdXJyZW50RWxlbS5feSA9IGNvbWJpbmVBcnJheXMoY3VycmVudEVsZW0uZ2V0TGVuZ3RoTGlzdCgneScsIGN1cnJlbnRFbGVtLmdldFZIZWlnaHQoKSksIChwYXJlbnRFbGVtID8gcGFyZW50RWxlbS5feS5zbGljZShwYXJlbnRFbGVtLl9wb3MubGVuZ3RoKSA6IFtdKSk7XHJcbiAgICAgICAgICBjdXJyZW50RWxlbS5fZHggPSBjb21iaW5lQXJyYXlzKGN1cnJlbnRFbGVtLmdldExlbmd0aExpc3QoJ2R4JywgY3VycmVudEVsZW0uZ2V0VldpZHRoKCkpLCAocGFyZW50RWxlbSA/IHBhcmVudEVsZW0uX2R4LnNsaWNlKHBhcmVudEVsZW0uX3Bvcy5sZW5ndGgpIDogW10pKTtcclxuICAgICAgICAgIGN1cnJlbnRFbGVtLl9keSA9IGNvbWJpbmVBcnJheXMoY3VycmVudEVsZW0uZ2V0TGVuZ3RoTGlzdCgnZHknLCBjdXJyZW50RWxlbS5nZXRWSGVpZ2h0KCkpLCAocGFyZW50RWxlbSA/IHBhcmVudEVsZW0uX2R5LnNsaWNlKHBhcmVudEVsZW0uX3Bvcy5sZW5ndGgpIDogW10pKTtcclxuICAgICAgICAgIGN1cnJlbnRFbGVtLl9yb3QgPSBjb21iaW5lQXJyYXlzKGN1cnJlbnRFbGVtLmdldE51bWJlckxpc3QoJ3JvdGF0ZScpLCAocGFyZW50RWxlbSA/IHBhcmVudEVsZW0uX3JvdC5zbGljZShwYXJlbnRFbGVtLl9wb3MubGVuZ3RoKSA6IFtdKSk7XHJcbiAgICAgICAgICBjdXJyZW50RWxlbS5fZGVmUm90ID0gY3VycmVudEVsZW0uY2hvb3NlVmFsdWUoY3VycmVudEVsZW0uX3JvdFtjdXJyZW50RWxlbS5fcm90Lmxlbmd0aCAtIDFdLCBwYXJlbnRFbGVtICYmIHBhcmVudEVsZW0uX2RlZlJvdCwgMCk7XHJcbiAgICAgICAgICBpZiAoY3VycmVudEVsZW0ubmFtZSA9PT0gJ3RleHRQYXRoJykge2N1cnJlbnRFbGVtLl95ID0gW107fVxyXG4gICAgICAgICAgbGV0IGZvbnRPcHRpb25zID0ge2ZhdXhJdGFsaWM6IGZhbHNlLCBmYXV4Qm9sZDogZmFsc2V9LFxyXG4gICAgICAgICAgICAgIGZvbnROYW1lb3JMaW5rID0gZm9udENhbGxiYWNrKGN1cnJlbnRFbGVtLmdldCgnZm9udC1mYW1pbHknKSwgY3VycmVudEVsZW0uZ2V0KCdmb250LXdlaWdodCcpID09PSAnYm9sZCcsIGN1cnJlbnRFbGVtLmdldCgnZm9udC1zdHlsZScpID09PSAnaXRhbGljJywgZm9udE9wdGlvbnMpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZG9jLmZvbnQoZm9udE5hbWVvckxpbmspO1xyXG4gICAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmdDYWxsYmFjaygnU1ZHRWxlbVRleHQ6IGZhaWxlZCB0byBvcGVuIGZvbnQgXCInICsgZm9udE5hbWVvckxpbmsgKyAnXCIgaW4gUERGS2l0Jyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjdXJyZW50RWxlbS5fcG9zID0gW107XHJcbiAgICAgICAgICBjdXJyZW50RWxlbS5faW5kZXggPSAwO1xyXG4gICAgICAgICAgY3VycmVudEVsZW0uX2ZvbnQgPSB7Zm9udDogZG9jLl9mb250LCBzaXplOiBjdXJyZW50RWxlbS5nZXQoJ2ZvbnQtc2l6ZScpLCBmYXV4SXRhbGljOiBmb250T3B0aW9ucy5mYXV4SXRhbGljLCBmYXV4Qm9sZDogZm9udE9wdGlvbnMuZmF1eEJvbGR9O1xyXG4gICAgICAgICAgbGV0IHRleHRMZW5ndGggPSBjdXJyZW50RWxlbS5nZXRMZW5ndGgoJ3RleHRMZW5ndGgnLCBjdXJyZW50RWxlbS5nZXRWV2lkdGgoKSwgdW5kZWZpbmVkKSxcclxuICAgICAgICAgICAgICBzcGFjaW5nQW5kR2x5cGhzID0gY3VycmVudEVsZW0uYXR0cignbGVuZ3RoQWRqdXN0JykgPT09ICdzcGFjaW5nQW5kR2x5cGhzJyxcclxuICAgICAgICAgICAgICB3b3JkU3BhY2luZyA9IGN1cnJlbnRFbGVtLmdldCgnd29yZC1zcGFjaW5nJyksXHJcbiAgICAgICAgICAgICAgbGV0dGVyU3BhY2luZyA9IGN1cnJlbnRFbGVtLmdldCgnbGV0dGVyLXNwYWNpbmcnKSxcclxuICAgICAgICAgICAgICB0ZXh0QW5jaG9yID0gY3VycmVudEVsZW0uZ2V0KCd0ZXh0LWFuY2hvcicpLFxyXG4gICAgICAgICAgICAgIHRleHREaXJlY3Rpb24gPSBjdXJyZW50RWxlbS5nZXQoJ2RpcmVjdGlvbicpLFxyXG4gICAgICAgICAgICAgIGJhc2VsaW5lID0gZ2V0QmFzZWxpbmUoY3VycmVudEVsZW0uX2ZvbnQuZm9udCwgY3VycmVudEVsZW0uX2ZvbnQuc2l6ZSwgY3VycmVudEVsZW0uZ2V0KCdhbGlnbm1lbnQtYmFzZWxpbmUnKSB8fCBjdXJyZW50RWxlbS5nZXQoJ2RvbWluYW50LWJhc2VsaW5lJyksIGN1cnJlbnRFbGVtLmdldCgnYmFzZWxpbmUtc2hpZnQnKSk7XHJcbiAgICAgICAgICBpZiAoY3VycmVudEVsZW0ubmFtZSA9PT0gJ3RleHRQYXRoJykge1xyXG4gICAgICAgICAgICBkb0FuY2hvcmluZygpO1xyXG4gICAgICAgICAgICBjdXJyZW50WCA9IGN1cnJlbnRZID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxldCBjaGlsZHJlbiA9IGN1cnJlbnRFbGVtLmdldENoaWxkcmVuKCk7XHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjaGlsZEVsZW0gPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgc3dpdGNoKGNoaWxkRWxlbS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgY2FzZSAndHNwYW4nOiBjYXNlICd0ZXh0UGF0aCc6IGNhc2UgJ2EnOlxyXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlKGNoaWxkRWxlbSwgY3VycmVudEVsZW0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgY2FzZSAnI3RleHQnOiBjYXNlICcjY2RhdGEtc2VjdGlvbic6XHJcbiAgICAgICAgICAgICAgICBsZXQgcmF3VGV4dCA9IGNoaWxkRWxlbS50ZXh0Q29udGVudCwgcmVuZGVyZWRUZXh0ID0gcmF3VGV4dCwgd29yZHM7XHJcbiAgICAgICAgICAgICAgICBjaGlsZEVsZW0uX2ZvbnQgPSBjdXJyZW50RWxlbS5fZm9udDtcclxuICAgICAgICAgICAgICAgIGNoaWxkRWxlbS5fcG9zID0gW107XHJcbiAgICAgICAgICAgICAgICByZW1haW5pbmdUZXh0ID0gcmVtYWluaW5nVGV4dC5zdWJzdHJpbmcocmF3VGV4dC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFbGVtLmdldCgneG1sOnNwYWNlJykgPT09ICdwcmVzZXJ2ZScpIHtcclxuICAgICAgICAgICAgICAgICAgcmVuZGVyZWRUZXh0ID0gcmVuZGVyZWRUZXh0LnJlcGxhY2UoL1tcXHNdL2csICcgJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICByZW5kZXJlZFRleHQgPSByZW5kZXJlZFRleHQucmVwbGFjZSgvW1xcc10rL2csICcgJyk7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZWRUZXh0Lm1hdGNoKC9bXFxzXSR8XiQvKSkge3JlbmRlcmVkVGV4dCA9IHJlbmRlcmVkVGV4dC5yZXBsYWNlKC9eW1xcc10vLCAnJyk7fVxyXG4gICAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nVGV4dC5tYXRjaCgvXltcXHNdKiQvKSkge3JlbmRlcmVkVGV4dCA9IHJlbmRlcmVkVGV4dC5yZXBsYWNlKC9bXFxzXSQvLCAnJyk7fVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkVGV4dCArPSByYXdUZXh0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHdvcmRTcGFjaW5nID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgIHdvcmRzID0gW3JlbmRlcmVkVGV4dF07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICB3b3JkcyA9IHJlbmRlcmVkVGV4dC5zcGxpdCgvKFxccykvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHcgPSAwOyB3IDwgd29yZHMubGVuZ3RoOyB3KyspIHtcclxuICAgICAgICAgICAgICAgICAgbGV0IHBvcyA9IGdldFRleHRQb3MoY3VycmVudEVsZW0uX2ZvbnQuZm9udCwgY3VycmVudEVsZW0uX2ZvbnQuc2l6ZSwgd29yZHNbd10pO1xyXG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBvcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGN1cnJlbnRFbGVtLl9pbmRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeEF0dHIgPSBjdXJyZW50RWxlbS5feFtpbmRleF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlBdHRyID0gY3VycmVudEVsZW0uX3lbaW5kZXhdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkeEF0dHIgPSBjdXJyZW50RWxlbS5fZHhbaW5kZXhdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkeUF0dHIgPSBjdXJyZW50RWxlbS5fZHlbaW5kZXhdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RBdHRyID0gY3VycmVudEVsZW0uX3JvdFtpbmRleF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVvdXMgPSAhKHcgPT09IDAgJiYgaiA9PT0gMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhBdHRyICE9PSB1bmRlZmluZWQpIHtjb250aW51b3VzID0gZmFsc2U7IGRvQW5jaG9yaW5nKCk7IGN1cnJlbnRYID0geEF0dHI7fVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh5QXR0ciAhPT0gdW5kZWZpbmVkKSB7Y29udGludW91cyA9IGZhbHNlOyBkb0FuY2hvcmluZygpOyBjdXJyZW50WSA9IHlBdHRyO31cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZHhBdHRyICE9PSB1bmRlZmluZWQpIHtjb250aW51b3VzID0gZmFsc2U7IGN1cnJlbnRYICs9IGR4QXR0cjt9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR5QXR0ciAhPT0gdW5kZWZpbmVkKSB7Y29udGludW91cyA9IGZhbHNlOyBjdXJyZW50WSArPSBkeUF0dHI7fVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3RBdHRyICE9PSB1bmRlZmluZWQgfHwgY3VycmVudEVsZW0uX2RlZlJvdCAhPT0gMCkge2NvbnRpbnVvdXMgPSBmYWxzZTt9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgZ2x5cGg6IHBvc1tqXS5nbHlwaCxcclxuICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZTogKE1hdGguUEkgLyAxODApICogY3VycmVudEVsZW0uY2hvb3NlVmFsdWUocm90QXR0ciwgY3VycmVudEVsZW0uX2RlZlJvdCksXHJcbiAgICAgICAgICAgICAgICAgICAgICB4OiBjdXJyZW50WCArIHBvc1tqXS54T2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgeTogY3VycmVudFkgKyBiYXNlbGluZSArIHBvc1tqXS55T2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHBvc1tqXS53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgIGFzY2VudDogZ2V0QXNjZW50KGN1cnJlbnRFbGVtLl9mb250LmZvbnQsIGN1cnJlbnRFbGVtLl9mb250LnNpemUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZGVzY2VudDogZ2V0RGVzY2VudChjdXJyZW50RWxlbS5fZm9udC5mb250LCBjdXJyZW50RWxlbS5fZm9udC5zaXplKSxcclxuICAgICAgICAgICAgICAgICAgICAgIHNjYWxlOiAxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVvdXM6IGNvbnRpbnVvdXNcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaHVuay5wdXNoKHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZEVsZW0uX3Bvcy5wdXNoKHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWxlbS5fcG9zLnB1c2gocG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFbGVtLl9pbmRleCArPSBwb3Nbal0udW5pY29kZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaHVuay5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBbmNob3IgPSB0ZXh0QW5jaG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudERpcmVjdGlvbiA9IHRleHREaXJlY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRYICs9IHBvc1tqXS54QWR2YW5jZSArIGxldHRlclNwYWNpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFkgKz0gcG9zW2pdLnlBZHZhbmNlO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGlmICh3b3Jkc1t3XSA9PT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFggKz0gd29yZFNwYWNpbmc7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZW1haW5pbmdUZXh0ID0gcmVtYWluaW5nVGV4dC5zdWJzdHJpbmcoY2hpbGRFbGVtLnRleHRDb250ZW50Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0ZXh0TGVuZ3RoICYmIGN1cnJlbnRFbGVtLl9wb3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGFkanVzdExlbmd0aChjdXJyZW50RWxlbS5fcG9zLCB0ZXh0TGVuZ3RoLCBzcGFjaW5nQW5kR2x5cGhzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChjdXJyZW50RWxlbS5uYW1lID09PSAndGV4dFBhdGgnIHx8IGN1cnJlbnRFbGVtLm5hbWUgPT09ICd0ZXh0Jykge1xyXG4gICAgICAgICAgICBkb0FuY2hvcmluZygpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGN1cnJlbnRFbGVtLm5hbWUgPT09ICd0ZXh0UGF0aCcpIHtcclxuICAgICAgICAgICAgdGV4dFBhdGhzLnB1c2goY3VycmVudEVsZW0pO1xyXG4gICAgICAgICAgICBsZXQgcGF0aE9iamVjdCA9IGN1cnJlbnRFbGVtLnBhdGhPYmplY3Q7XHJcbiAgICAgICAgICAgIGlmIChwYXRoT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgY3VycmVudFggPSBwYXRoT2JqZWN0LmVuZFBvaW50WzBdOyBjdXJyZW50WSA9IHBhdGhPYmplY3QuZW5kUG9pbnRbMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChwYXJlbnRFbGVtKSB7XHJcbiAgICAgICAgICAgIHBhcmVudEVsZW0uX3BvcyA9IHBhcmVudEVsZW0uX3Bvcy5jb25jYXQoY3VycmVudEVsZW0uX3Bvcyk7XHJcbiAgICAgICAgICAgIHBhcmVudEVsZW0uX2luZGV4ICs9IGN1cnJlbnRFbGVtLl9pbmRleDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gdGV4dE9uUGF0aChjdXJyZW50RWxlbSkge1xyXG4gICAgICAgICAgbGV0IHBhdGhPYmplY3QgPSBjdXJyZW50RWxlbS5wYXRoT2JqZWN0LFxyXG4gICAgICAgICAgICAgIHBhdGhMZW5ndGggPSBjdXJyZW50RWxlbS5wYXRoTGVuZ3RoLFxyXG4gICAgICAgICAgICAgIHBhdGhTY2FsZSA9IGN1cnJlbnRFbGVtLnBhdGhTY2FsZTtcclxuICAgICAgICAgIGlmIChwYXRoT2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0T2Zmc2V0ID0gY3VycmVudEVsZW0uZ2V0TGVuZ3RoKCdzdGFydE9mZnNldCcsIHBhdGhMZW5ndGgsIDApO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGN1cnJlbnRFbGVtLl9wb3MubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICBsZXQgY2hhck1pZFggPSB0ZXh0T2Zmc2V0ICsgY3VycmVudEVsZW0uX3Bvc1tqXS54ICsgMC41ICogY3VycmVudEVsZW0uX3Bvc1tqXS53aWR0aDtcclxuICAgICAgICAgICAgICBpZiAoY2hhck1pZFggPiBwYXRoTGVuZ3RoIHx8IGNoYXJNaWRYIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEVsZW0uX3Bvc1tqXS5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRPblBhdGggPSBwYXRoT2JqZWN0LmdldFBvaW50QXRMZW5ndGgoY2hhck1pZFggKiBwYXRoU2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTm90RXF1YWwocGF0aFNjYWxlLCAxKSkge1xyXG4gICAgICAgICAgICAgICAgICBjdXJyZW50RWxlbS5fcG9zW2pdLnNjYWxlICo9IHBhdGhTY2FsZTtcclxuICAgICAgICAgICAgICAgICAgY3VycmVudEVsZW0uX3Bvc1tqXS53aWR0aCAqPSBwYXRoU2NhbGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RWxlbS5fcG9zW2pdLnggPSBwb2ludE9uUGF0aFswXSAtIDAuNSAqIGN1cnJlbnRFbGVtLl9wb3Nbal0ud2lkdGggKiBNYXRoLmNvcyhwb2ludE9uUGF0aFsyXSkgLSBjdXJyZW50RWxlbS5fcG9zW2pdLnkgKiBNYXRoLnNpbihwb2ludE9uUGF0aFsyXSk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RWxlbS5fcG9zW2pdLnkgPSBwb2ludE9uUGF0aFsxXSAtIDAuNSAqIGN1cnJlbnRFbGVtLl9wb3Nbal0ud2lkdGggKiBNYXRoLnNpbihwb2ludE9uUGF0aFsyXSkgKyBjdXJyZW50RWxlbS5fcG9zW2pdLnkgKiBNYXRoLmNvcyhwb2ludE9uUGF0aFsyXSk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RWxlbS5fcG9zW2pdLnJvdGF0ZSA9IHBvaW50T25QYXRoWzJdICsgY3VycmVudEVsZW0uX3Bvc1tqXS5yb3RhdGU7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RWxlbS5fcG9zW2pdLmNvbnRpbnVvdXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3VycmVudEVsZW0uX3Bvcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgIGN1cnJlbnRFbGVtLl9wb3Nbal0uaGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZWN1cnNpdmUodGV4dFBhcmVudEVsZW0sIG51bGwpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFBhdGhzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB0ZXh0T25QYXRoKHRleHRQYXRoc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KSh0aGlzKTtcclxuICAgICAgdGhpcy5nZXRUcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldCgndHJhbnNmb3JtJyk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuZHJhd0luRG9jdW1lbnQgPSBmdW5jdGlvbihpc0NsaXAsIGlzTWFzaykge1xyXG4gICAgICAgIGRvYy5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0oKTtcclxuICAgICAgICB0aGlzLmNsaXAoKTtcclxuICAgICAgICBsZXQgbWFza2VkID0gdGhpcy5tYXNrKCksIGdyb3VwO1xyXG4gICAgICAgIGlmIChtYXNrZWQpIHtcclxuICAgICAgICAgIGdyb3VwID0gZG9jQmVnaW5Hcm91cChnZXRQYWdlQkJveCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kcmF3VGV4dEluRG9jdW1lbnQoaXNDbGlwLCBpc01hc2spO1xyXG4gICAgICAgIGlmIChncm91cCkge1xyXG4gICAgICAgICAgZG9jRW5kR3JvdXAoZ3JvdXApO1xyXG4gICAgICAgICAgZG9jSW5zZXJ0R3JvdXAoZ3JvdXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkb2MucmVzdG9yZSgpO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIHZhciBweFRvUHQgPSBvcHRpb25zLmFzc3VtZVB0ID8gMSA6ICg3Mi85NiksIC8vIDFweCA9IDcyLzk2cHQsIGJ1dCBvbmx5IGlmIGFzc3VtZVB0IGlzIGZhbHNlXHJcbiAgICAgICAgdmlld3BvcnRXaWR0aCA9IChvcHRpb25zLndpZHRoIHx8IGRvYy5wYWdlLndpZHRoKSAvIHB4VG9QdCxcclxuICAgICAgICB2aWV3cG9ydEhlaWdodCA9IChvcHRpb25zLmhlaWdodCB8fCBkb2MucGFnZS5oZWlnaHQpIC8gcHhUb1B0LFxyXG4gICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBvcHRpb25zLnByZXNlcnZlQXNwZWN0UmF0aW8gfHwgbnVsbCwgLy8gZGVmYXVsdCB0byBudWxsIHNvIHRoYXQgdGhlIGF0dHIgY2FuIG92ZXJyaWRlIGlmIG5vdCBwYXNzZWRcclxuICAgICAgICB1c2VDU1MgPSBvcHRpb25zLnVzZUNTUyAmJiB0eXBlb2YgU1ZHRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgc3ZnIGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiB0eXBlb2YgZ2V0Q29tcHV0ZWRTdHlsZSA9PT0gJ2Z1bmN0aW9uJyxcclxuICAgICAgICB3YXJuaW5nQ2FsbGJhY2sgPSBvcHRpb25zLndhcm5pbmdDYWxsYmFjayxcclxuICAgICAgICBmb250Q2FsbGJhY2sgPSBvcHRpb25zLmZvbnRDYWxsYmFjayxcclxuICAgICAgICBpbWFnZUNhbGxiYWNrID0gb3B0aW9ucy5pbWFnZUNhbGxiYWNrLFxyXG4gICAgICAgIGNvbG9yQ2FsbGJhY2sgPSBvcHRpb25zLmNvbG9yQ2FsbGJhY2ssXHJcbiAgICAgICAgZG9jdW1lbnRDYWxsYmFjayA9IG9wdGlvbnMuZG9jdW1lbnRDYWxsYmFjayxcclxuICAgICAgICBwcmVjaXNpb24gPSBNYXRoLmNlaWwoTWF0aC5tYXgoMSwgb3B0aW9ucy5wcmVjaXNpb24pKSB8fCAzLFxyXG4gICAgICAgIGdyb3VwU3RhY2sgPSBbXSxcclxuICAgICAgICBkb2N1bWVudENhY2hlID0ge30sXHJcbiAgICAgICAgbGlua3MgPSBbXSxcclxuICAgICAgICBzdHlsZVJ1bGVzID0gW107XHJcblxyXG4gICAgaWYgKHR5cGVvZiB3YXJuaW5nQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgd2FybmluZ0NhbGxiYWNrID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gJ2Z1bmN0aW9uJykge2NvbnNvbGUud2FybihzdHIpO31cclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZm9udENhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGZvbnRDYWxsYmFjayA9IGZ1bmN0aW9uKGZhbWlseSwgYm9sZCwgaXRhbGljLCBmb250T3B0aW9ucykge1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBmb250IGlzIGFscmVhZHkgcmVnaXN0ZXJlZCBpbiB0aGUgZG9jdW1lbnRcclxuICAgICAgICBpZiAoYm9sZCAmJiBpdGFsaWMpIHtcclxuICAgICAgICAgIGlmIChkb2MuX3JlZ2lzdGVyZWRGb250cy5oYXNPd25Qcm9wZXJ0eShmYW1pbHkgKyAnLUJvbGRJdGFsaWMnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFtaWx5ICsgJy1Cb2xkSXRhbGljJztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoZG9jLl9yZWdpc3RlcmVkRm9udHMuaGFzT3duUHJvcGVydHkoZmFtaWx5ICsgJy1JdGFsaWMnKSkge1xyXG4gICAgICAgICAgICBmb250T3B0aW9ucy5mYXV4Qm9sZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBmYW1pbHkgKyAnLUl0YWxpYyc7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGRvYy5fcmVnaXN0ZXJlZEZvbnRzLmhhc093blByb3BlcnR5KGZhbWlseSArICctQm9sZCcpKSB7XHJcbiAgICAgICAgICAgIGZvbnRPcHRpb25zLmZhdXhJdGFsaWMgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFtaWx5ICsgJy1Cb2xkJztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoZG9jLl9yZWdpc3RlcmVkRm9udHMuaGFzT3duUHJvcGVydHkoZmFtaWx5KSkge1xyXG4gICAgICAgICAgICBmb250T3B0aW9ucy5mYXV4Qm9sZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvbnRPcHRpb25zLmZhdXhJdGFsaWMgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFtaWx5O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYm9sZCAmJiAhaXRhbGljKSB7XHJcbiAgICAgICAgICBpZiAoZG9jLl9yZWdpc3RlcmVkRm9udHMuaGFzT3duUHJvcGVydHkoZmFtaWx5ICsgJy1Cb2xkJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbWlseSArICctQm9sZCc7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGRvYy5fcmVnaXN0ZXJlZEZvbnRzLmhhc093blByb3BlcnR5KGZhbWlseSkpIHtcclxuICAgICAgICAgICAgZm9udE9wdGlvbnMuZmF1eEJvbGQgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFtaWx5O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWJvbGQgJiYgaXRhbGljKSB7XHJcbiAgICAgICAgICBpZiAoZG9jLl9yZWdpc3RlcmVkRm9udHMuaGFzT3duUHJvcGVydHkoZmFtaWx5ICsgJy1JdGFsaWMnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFtaWx5ICsgJy1JdGFsaWMnO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChkb2MuX3JlZ2lzdGVyZWRGb250cy5oYXNPd25Qcm9wZXJ0eShmYW1pbHkpKSB7XHJcbiAgICAgICAgICAgIGZvbnRPcHRpb25zLmZhdXhJdGFsaWMgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFtaWx5O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWJvbGQgJiYgIWl0YWxpYykge1xyXG4gICAgICAgICAgaWYgKGRvYy5fcmVnaXN0ZXJlZEZvbnRzLmhhc093blByb3BlcnR5KGZhbWlseSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbWlseTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXNlIHN0YW5kYXJkIGZvbnRzIGFzIGZhbGxiYWNrXHJcbiAgICAgICAgaWYgKGZhbWlseS5tYXRjaCgvKD86XnwsKVxccypzZXJpZlxccyokLykpIHtcclxuICAgICAgICAgIGlmIChib2xkICYmIGl0YWxpYykge3JldHVybiAnVGltZXMtQm9sZEl0YWxpYyc7fVxyXG4gICAgICAgICAgaWYgKGJvbGQgJiYgIWl0YWxpYykge3JldHVybiAnVGltZXMtQm9sZCc7fVxyXG4gICAgICAgICAgaWYgKCFib2xkICYmIGl0YWxpYykge3JldHVybiAnVGltZXMtSXRhbGljJzt9XHJcbiAgICAgICAgICBpZiAoIWJvbGQgJiYgIWl0YWxpYykge3JldHVybiAnVGltZXMtUm9tYW4nO31cclxuICAgICAgICB9IGVsc2UgaWYgKGZhbWlseS5tYXRjaCgvKD86XnwsKVxccyptb25vc3BhY2VcXHMqJC8pKSB7XHJcbiAgICAgICAgICBpZiAoYm9sZCAmJiBpdGFsaWMpIHtyZXR1cm4gJ0NvdXJpZXItQm9sZE9ibGlxdWUnO31cclxuICAgICAgICAgIGlmIChib2xkICYmICFpdGFsaWMpIHtyZXR1cm4gJ0NvdXJpZXItQm9sZCc7fVxyXG4gICAgICAgICAgaWYgKCFib2xkICYmIGl0YWxpYykge3JldHVybiAnQ291cmllci1PYmxpcXVlJzt9XHJcbiAgICAgICAgICBpZiAoIWJvbGQgJiYgIWl0YWxpYykge3JldHVybiAnQ291cmllcic7fVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZmFtaWx5Lm1hdGNoKC8oPzpefCwpXFxzKnNhbnMtc2VyaWZcXHMqJC8pIHx8IHRydWUpIHtcclxuICAgICAgICAgIGlmIChib2xkICYmIGl0YWxpYykge3JldHVybiAnSGVsdmV0aWNhLUJvbGRPYmxpcXVlJzt9XHJcbiAgICAgICAgICBpZiAoYm9sZCAmJiAhaXRhbGljKSB7cmV0dXJuICdIZWx2ZXRpY2EtQm9sZCc7fVxyXG4gICAgICAgICAgaWYgKCFib2xkICYmIGl0YWxpYykge3JldHVybiAnSGVsdmV0aWNhLU9ibGlxdWUnO31cclxuICAgICAgICAgIGlmICghYm9sZCAmJiAhaXRhbGljKSB7cmV0dXJuICdIZWx2ZXRpY2EnO31cclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGltYWdlQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgaW1hZ2VDYWxsYmFjayA9IGZ1bmN0aW9uKGxpbmspIHtcclxuICAgICAgICByZXR1cm4gbGluay5yZXBsYWNlKC9cXHMrL2csICcnKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY29sb3JDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBjb2xvckNhbGxiYWNrID0gbnVsbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvciAobGV0IGNvbG9yIGluIERlZmF1bHRDb2xvcnMpIHtcclxuICAgICAgICBsZXQgbmV3Q29sb3IgPSBjb2xvckNhbGxiYWNrKERlZmF1bHRDb2xvcnNbY29sb3JdKTtcclxuICAgICAgICBEZWZhdWx0Q29sb3JzW2NvbG9yXVswXSA9IG5ld0NvbG9yWzBdO1xyXG4gICAgICAgIERlZmF1bHRDb2xvcnNbY29sb3JdWzFdID0gbmV3Q29sb3JbMV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnRDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBkb2N1bWVudENhbGxiYWNrID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIHN2ZyA9PT0gJ3N0cmluZycpIHtzdmcgPSBwYXJzZVhtbChzdmcpO31cclxuICAgIGlmIChzdmcpIHtcclxuICAgICAgbGV0IHN0eWxlcyA9IHN2Zy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3R5bGUnKTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzdHlsZVJ1bGVzID0gc3R5bGVSdWxlcy5jb25jYXQocGFyc2VTdHlsZVNoZWV0KHN0eWxlc1tpXS50ZXh0Q29udGVudCkpO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBlbGVtID0gY3JlYXRlU1ZHRWxlbWVudChzdmcsIG51bGwpO1xyXG4gICAgICBpZiAodHlwZW9mIGVsZW0uZHJhd0luRG9jdW1lbnQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy51c2VDU1MgJiYgIXVzZUNTUykge1xyXG4gICAgICAgICAgd2FybmluZ0NhbGxiYWNrKCdTVkd0b1BERjogdXNlQ1NTIG9wdGlvbiBjYW4gb25seSBiZSB1c2VkIGZvciBTVkcgKmVsZW1lbnRzKiBpbiBjb21wYXRpYmxlIGJyb3dzZXJzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzYXZlZEZpbGxDb2xvciA9IGRvYy5fZmlsbENvbG9yO1xyXG4gICAgICAgIGRvYy5zYXZlKCkudHJhbnNsYXRlKHggfHwgMCwgeSB8fCAwKS5zY2FsZShweFRvUHQpO1xyXG4gICAgICAgIGVsZW0uZHJhd0luRG9jdW1lbnQoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBkb2MucGFnZS5hbm5vdGF0aW9ucy5wdXNoKGxpbmtzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jLnJlc3RvcmUoKTtcclxuICAgICAgICBkb2MuX2ZpbGxDb2xvciA9IHNhdmVkRmlsbENvbG9yO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdhcm5pbmdDYWxsYmFjaygnU1ZHdG9QREY6IHRoaXMgZWxlbWVudCBjYW5cXCd0IGJlIHJlbmRlcmVkIGRpcmVjdGx5OiAnICsgc3ZnLm5vZGVOYW1lKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd2FybmluZ0NhbGxiYWNrKCdTVkd0b1BERjogdGhlIGlucHV0IGRvZXMgbm90IGxvb2sgbGlrZSBhIHZhbGlkIFNWRycpO1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gU1ZHdG9QREY7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/3rd-party/svg-to-pdfkit/source.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/columnCalculator.js":
/*!******************************************************!*\
  !*** ./node_modules/pdfmake/src/columnCalculator.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar isString = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isString);\r\n\r\nfunction buildColumnWidths(columns, availableWidth, offsetTotal = 0, tableNode) {\r\n\tvar autoColumns = [],\r\n\t\tautoMin = 0, autoMax = 0,\r\n\t\tstarColumns = [],\r\n\t\tstarMaxMin = 0,\r\n\t\tstarMaxMax = 0,\r\n\t\tfixedColumns = [],\r\n\t\tinitial_availableWidth = availableWidth;\r\n\r\n\tcolumns.forEach(function (column) {\r\n\t\tif (isAutoColumn(column)) {\r\n\t\t\tautoColumns.push(column);\r\n\t\t\tautoMin += column._minWidth;\r\n\t\t\tautoMax += column._maxWidth;\r\n\t\t} else if (isStarColumn(column)) {\r\n\t\t\tstarColumns.push(column);\r\n\t\t\tstarMaxMin = Math.max(starMaxMin, column._minWidth);\r\n\t\t\tstarMaxMax = Math.max(starMaxMax, column._maxWidth);\r\n\t\t} else {\r\n\t\t\tfixedColumns.push(column);\r\n\t\t}\r\n\t});\r\n\r\n\tfixedColumns.forEach(function (col, colIndex) {\r\n\t\t// width specified as %\r\n\t\tif (isString(col.width) && /\\d+%/.test(col.width)) {\r\n\t\t\t// In tables we have to take into consideration the reserved width for paddings and borders\r\n\t\t\tvar reservedWidth = 0;\r\n\t\t\tif (tableNode) {\r\n\t\t\t\tvar paddingLeft = tableNode._layout.paddingLeft(colIndex, tableNode);\r\n\t\t\t\tvar paddingRight = tableNode._layout.paddingRight(colIndex, tableNode);\r\n\t\t\t\tvar borderLeft = tableNode._layout.vLineWidth(colIndex, tableNode);\r\n\t\t\t\tvar borderRight = tableNode._layout.vLineWidth(colIndex + 1, tableNode);\r\n\t\t\t\tif (colIndex === 0) {\r\n\t\t\t\t\t// first column assumes whole borderLeft and half of border right\r\n\t\t\t\t\treservedWidth = paddingLeft + paddingRight + borderLeft + (borderRight / 2);\r\n\r\n\t\t\t\t} else if (colIndex === fixedColumns.length - 1) {\r\n\t\t\t\t\t// last column assumes whole borderRight and half of border left\r\n\t\t\t\t\treservedWidth = paddingLeft + paddingRight + (borderLeft / 2) + borderRight;\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Columns in the middle assume half of each border\r\n\t\t\t\t\treservedWidth = paddingLeft + paddingRight + (borderLeft / 2) + (borderRight / 2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar totalAvailableWidth = initial_availableWidth + offsetTotal;\r\n\t\t\tcol.width = (parseFloat(col.width) * totalAvailableWidth / 100) - reservedWidth;\r\n\t\t}\r\n\t\tif (col.width < (col._minWidth) && col.elasticWidth) {\r\n\t\t\tcol._calcWidth = col._minWidth;\r\n\t\t} else {\r\n\t\t\tcol._calcWidth = col.width;\r\n\t\t}\r\n\r\n\t\tavailableWidth -= col._calcWidth;\r\n\t});\r\n\r\n\t// http://www.freesoft.org/CIE/RFC/1942/18.htm\r\n\t// http://www.w3.org/TR/CSS2/tables.html#width-layout\r\n\t// http://dev.w3.org/csswg/css3-tables-algorithms/Overview.src.htm\r\n\tvar minW = autoMin + starMaxMin * starColumns.length;\r\n\tvar maxW = autoMax + starMaxMax * starColumns.length;\r\n\tif (minW >= availableWidth) {\r\n\t\t// case 1 - there's no way to fit all columns within available width\r\n\t\t// that's actually pretty bad situation with PDF as we have no horizontal scroll\r\n\t\t// no easy workaround (unless we decide, in the future, to split single words)\r\n\t\t// currently we simply use minWidths for all columns\r\n\t\tautoColumns.forEach(function (col) {\r\n\t\t\tcol._calcWidth = col._minWidth;\r\n\t\t});\r\n\r\n\t\tstarColumns.forEach(function (col) {\r\n\t\t\tcol._calcWidth = starMaxMin; // starMaxMin already contains padding\r\n\t\t});\r\n\t} else {\r\n\t\tif (maxW < availableWidth) {\r\n\t\t\t// case 2 - we can fit rest of the table within available space\r\n\t\t\tautoColumns.forEach(function (col) {\r\n\t\t\t\tcol._calcWidth = col._maxWidth;\r\n\t\t\t\tavailableWidth -= col._calcWidth;\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\t// maxW is too large, but minW fits within available width\r\n\t\t\tvar W = availableWidth - minW;\r\n\t\t\tvar D = maxW - minW;\r\n\r\n\t\t\tautoColumns.forEach(function (col) {\r\n\t\t\t\tvar d = col._maxWidth - col._minWidth;\r\n\t\t\t\tcol._calcWidth = col._minWidth + d * W / D;\r\n\t\t\t\tavailableWidth -= col._calcWidth;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif (starColumns.length > 0) {\r\n\t\t\tvar starSize = availableWidth / starColumns.length;\r\n\r\n\t\t\tstarColumns.forEach(function (col) {\r\n\t\t\t\tcol._calcWidth = starSize;\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction isAutoColumn(column) {\r\n\treturn column.width === 'auto';\r\n}\r\n\r\nfunction isStarColumn(column) {\r\n\treturn column.width === null || column.width === undefined || column.width === '*' || column.width === 'star';\r\n}\r\n\r\n//TODO: refactor and reuse in measureTable\r\nfunction measureMinMax(columns) {\r\n\tvar result = { min: 0, max: 0 };\r\n\r\n\tvar maxStar = { min: 0, max: 0 };\r\n\tvar starCount = 0;\r\n\r\n\tfor (var i = 0, l = columns.length; i < l; i++) {\r\n\t\tvar c = columns[i];\r\n\r\n\t\tif (isStarColumn(c)) {\r\n\t\t\tmaxStar.min = Math.max(maxStar.min, c._minWidth);\r\n\t\t\tmaxStar.max = Math.max(maxStar.max, c._maxWidth);\r\n\t\t\tstarCount++;\r\n\t\t} else if (isAutoColumn(c)) {\r\n\t\t\tresult.min += c._minWidth;\r\n\t\t\tresult.max += c._maxWidth;\r\n\t\t} else {\r\n\t\t\tresult.min += ((c.width !== undefined && c.width) || c._minWidth);\r\n\t\t\tresult.max += ((c.width !== undefined && c.width) || c._maxWidth);\r\n\t\t}\r\n\t}\r\n\r\n\tif (starCount) {\r\n\t\tresult.min += starCount * maxStar.min;\r\n\t\tresult.max += starCount * maxStar.max;\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Calculates column widths\r\n * @private\r\n */\r\nmodule.exports = {\r\n\tbuildColumnWidths: buildColumnWidths,\r\n\tmeasureMinMax: measureMinMax,\r\n\tisAutoColumn: isAutoColumn,\r\n\tisStarColumn: isStarColumn\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvY29sdW1uQ2FsY3VsYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsZUFBZSw4RkFBNkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsR0FBRztBQUNILEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2dhc2NhdC9wcmlzbWFxdWFudC9wcmlzbWEtcXVhbnR1bS9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvY29sdW1uQ2FsY3VsYXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaXNTdHJpbmcgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc1N0cmluZztcclxuXHJcbmZ1bmN0aW9uIGJ1aWxkQ29sdW1uV2lkdGhzKGNvbHVtbnMsIGF2YWlsYWJsZVdpZHRoLCBvZmZzZXRUb3RhbCA9IDAsIHRhYmxlTm9kZSkge1xyXG5cdHZhciBhdXRvQ29sdW1ucyA9IFtdLFxyXG5cdFx0YXV0b01pbiA9IDAsIGF1dG9NYXggPSAwLFxyXG5cdFx0c3RhckNvbHVtbnMgPSBbXSxcclxuXHRcdHN0YXJNYXhNaW4gPSAwLFxyXG5cdFx0c3Rhck1heE1heCA9IDAsXHJcblx0XHRmaXhlZENvbHVtbnMgPSBbXSxcclxuXHRcdGluaXRpYWxfYXZhaWxhYmxlV2lkdGggPSBhdmFpbGFibGVXaWR0aDtcclxuXHJcblx0Y29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcclxuXHRcdGlmIChpc0F1dG9Db2x1bW4oY29sdW1uKSkge1xyXG5cdFx0XHRhdXRvQ29sdW1ucy5wdXNoKGNvbHVtbik7XHJcblx0XHRcdGF1dG9NaW4gKz0gY29sdW1uLl9taW5XaWR0aDtcclxuXHRcdFx0YXV0b01heCArPSBjb2x1bW4uX21heFdpZHRoO1xyXG5cdFx0fSBlbHNlIGlmIChpc1N0YXJDb2x1bW4oY29sdW1uKSkge1xyXG5cdFx0XHRzdGFyQ29sdW1ucy5wdXNoKGNvbHVtbik7XHJcblx0XHRcdHN0YXJNYXhNaW4gPSBNYXRoLm1heChzdGFyTWF4TWluLCBjb2x1bW4uX21pbldpZHRoKTtcclxuXHRcdFx0c3Rhck1heE1heCA9IE1hdGgubWF4KHN0YXJNYXhNYXgsIGNvbHVtbi5fbWF4V2lkdGgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Zml4ZWRDb2x1bW5zLnB1c2goY29sdW1uKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0Zml4ZWRDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbCwgY29sSW5kZXgpIHtcclxuXHRcdC8vIHdpZHRoIHNwZWNpZmllZCBhcyAlXHJcblx0XHRpZiAoaXNTdHJpbmcoY29sLndpZHRoKSAmJiAvXFxkKyUvLnRlc3QoY29sLndpZHRoKSkge1xyXG5cdFx0XHQvLyBJbiB0YWJsZXMgd2UgaGF2ZSB0byB0YWtlIGludG8gY29uc2lkZXJhdGlvbiB0aGUgcmVzZXJ2ZWQgd2lkdGggZm9yIHBhZGRpbmdzIGFuZCBib3JkZXJzXHJcblx0XHRcdHZhciByZXNlcnZlZFdpZHRoID0gMDtcclxuXHRcdFx0aWYgKHRhYmxlTm9kZSkge1xyXG5cdFx0XHRcdHZhciBwYWRkaW5nTGVmdCA9IHRhYmxlTm9kZS5fbGF5b3V0LnBhZGRpbmdMZWZ0KGNvbEluZGV4LCB0YWJsZU5vZGUpO1xyXG5cdFx0XHRcdHZhciBwYWRkaW5nUmlnaHQgPSB0YWJsZU5vZGUuX2xheW91dC5wYWRkaW5nUmlnaHQoY29sSW5kZXgsIHRhYmxlTm9kZSk7XHJcblx0XHRcdFx0dmFyIGJvcmRlckxlZnQgPSB0YWJsZU5vZGUuX2xheW91dC52TGluZVdpZHRoKGNvbEluZGV4LCB0YWJsZU5vZGUpO1xyXG5cdFx0XHRcdHZhciBib3JkZXJSaWdodCA9IHRhYmxlTm9kZS5fbGF5b3V0LnZMaW5lV2lkdGgoY29sSW5kZXggKyAxLCB0YWJsZU5vZGUpO1xyXG5cdFx0XHRcdGlmIChjb2xJbmRleCA9PT0gMCkge1xyXG5cdFx0XHRcdFx0Ly8gZmlyc3QgY29sdW1uIGFzc3VtZXMgd2hvbGUgYm9yZGVyTGVmdCBhbmQgaGFsZiBvZiBib3JkZXIgcmlnaHRcclxuXHRcdFx0XHRcdHJlc2VydmVkV2lkdGggPSBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodCArIGJvcmRlckxlZnQgKyAoYm9yZGVyUmlnaHQgLyAyKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmIChjb2xJbmRleCA9PT0gZml4ZWRDb2x1bW5zLmxlbmd0aCAtIDEpIHtcclxuXHRcdFx0XHRcdC8vIGxhc3QgY29sdW1uIGFzc3VtZXMgd2hvbGUgYm9yZGVyUmlnaHQgYW5kIGhhbGYgb2YgYm9yZGVyIGxlZnRcclxuXHRcdFx0XHRcdHJlc2VydmVkV2lkdGggPSBwYWRkaW5nTGVmdCArIHBhZGRpbmdSaWdodCArIChib3JkZXJMZWZ0IC8gMikgKyBib3JkZXJSaWdodDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIENvbHVtbnMgaW4gdGhlIG1pZGRsZSBhc3N1bWUgaGFsZiBvZiBlYWNoIGJvcmRlclxyXG5cdFx0XHRcdFx0cmVzZXJ2ZWRXaWR0aCA9IHBhZGRpbmdMZWZ0ICsgcGFkZGluZ1JpZ2h0ICsgKGJvcmRlckxlZnQgLyAyKSArIChib3JkZXJSaWdodCAvIDIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgdG90YWxBdmFpbGFibGVXaWR0aCA9IGluaXRpYWxfYXZhaWxhYmxlV2lkdGggKyBvZmZzZXRUb3RhbDtcclxuXHRcdFx0Y29sLndpZHRoID0gKHBhcnNlRmxvYXQoY29sLndpZHRoKSAqIHRvdGFsQXZhaWxhYmxlV2lkdGggLyAxMDApIC0gcmVzZXJ2ZWRXaWR0aDtcclxuXHRcdH1cclxuXHRcdGlmIChjb2wud2lkdGggPCAoY29sLl9taW5XaWR0aCkgJiYgY29sLmVsYXN0aWNXaWR0aCkge1xyXG5cdFx0XHRjb2wuX2NhbGNXaWR0aCA9IGNvbC5fbWluV2lkdGg7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb2wuX2NhbGNXaWR0aCA9IGNvbC53aWR0aDtcclxuXHRcdH1cclxuXHJcblx0XHRhdmFpbGFibGVXaWR0aCAtPSBjb2wuX2NhbGNXaWR0aDtcclxuXHR9KTtcclxuXHJcblx0Ly8gaHR0cDovL3d3dy5mcmVlc29mdC5vcmcvQ0lFL1JGQy8xOTQyLzE4Lmh0bVxyXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIvdGFibGVzLmh0bWwjd2lkdGgtbGF5b3V0XHJcblx0Ly8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzMy10YWJsZXMtYWxnb3JpdGhtcy9PdmVydmlldy5zcmMuaHRtXHJcblx0dmFyIG1pblcgPSBhdXRvTWluICsgc3Rhck1heE1pbiAqIHN0YXJDb2x1bW5zLmxlbmd0aDtcclxuXHR2YXIgbWF4VyA9IGF1dG9NYXggKyBzdGFyTWF4TWF4ICogc3RhckNvbHVtbnMubGVuZ3RoO1xyXG5cdGlmIChtaW5XID49IGF2YWlsYWJsZVdpZHRoKSB7XHJcblx0XHQvLyBjYXNlIDEgLSB0aGVyZSdzIG5vIHdheSB0byBmaXQgYWxsIGNvbHVtbnMgd2l0aGluIGF2YWlsYWJsZSB3aWR0aFxyXG5cdFx0Ly8gdGhhdCdzIGFjdHVhbGx5IHByZXR0eSBiYWQgc2l0dWF0aW9uIHdpdGggUERGIGFzIHdlIGhhdmUgbm8gaG9yaXpvbnRhbCBzY3JvbGxcclxuXHRcdC8vIG5vIGVhc3kgd29ya2Fyb3VuZCAodW5sZXNzIHdlIGRlY2lkZSwgaW4gdGhlIGZ1dHVyZSwgdG8gc3BsaXQgc2luZ2xlIHdvcmRzKVxyXG5cdFx0Ly8gY3VycmVudGx5IHdlIHNpbXBseSB1c2UgbWluV2lkdGhzIGZvciBhbGwgY29sdW1uc1xyXG5cdFx0YXV0b0NvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7XHJcblx0XHRcdGNvbC5fY2FsY1dpZHRoID0gY29sLl9taW5XaWR0aDtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHN0YXJDb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbCkge1xyXG5cdFx0XHRjb2wuX2NhbGNXaWR0aCA9IHN0YXJNYXhNaW47IC8vIHN0YXJNYXhNaW4gYWxyZWFkeSBjb250YWlucyBwYWRkaW5nXHJcblx0XHR9KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0aWYgKG1heFcgPCBhdmFpbGFibGVXaWR0aCkge1xyXG5cdFx0XHQvLyBjYXNlIDIgLSB3ZSBjYW4gZml0IHJlc3Qgb2YgdGhlIHRhYmxlIHdpdGhpbiBhdmFpbGFibGUgc3BhY2VcclxuXHRcdFx0YXV0b0NvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7XHJcblx0XHRcdFx0Y29sLl9jYWxjV2lkdGggPSBjb2wuX21heFdpZHRoO1xyXG5cdFx0XHRcdGF2YWlsYWJsZVdpZHRoIC09IGNvbC5fY2FsY1dpZHRoO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIG1heFcgaXMgdG9vIGxhcmdlLCBidXQgbWluVyBmaXRzIHdpdGhpbiBhdmFpbGFibGUgd2lkdGhcclxuXHRcdFx0dmFyIFcgPSBhdmFpbGFibGVXaWR0aCAtIG1pblc7XHJcblx0XHRcdHZhciBEID0gbWF4VyAtIG1pblc7XHJcblxyXG5cdFx0XHRhdXRvQ29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2wpIHtcclxuXHRcdFx0XHR2YXIgZCA9IGNvbC5fbWF4V2lkdGggLSBjb2wuX21pbldpZHRoO1xyXG5cdFx0XHRcdGNvbC5fY2FsY1dpZHRoID0gY29sLl9taW5XaWR0aCArIGQgKiBXIC8gRDtcclxuXHRcdFx0XHRhdmFpbGFibGVXaWR0aCAtPSBjb2wuX2NhbGNXaWR0aDtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN0YXJDb2x1bW5zLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0dmFyIHN0YXJTaXplID0gYXZhaWxhYmxlV2lkdGggLyBzdGFyQ29sdW1ucy5sZW5ndGg7XHJcblxyXG5cdFx0XHRzdGFyQ29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2wpIHtcclxuXHRcdFx0XHRjb2wuX2NhbGNXaWR0aCA9IHN0YXJTaXplO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzQXV0b0NvbHVtbihjb2x1bW4pIHtcclxuXHRyZXR1cm4gY29sdW1uLndpZHRoID09PSAnYXV0byc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzU3RhckNvbHVtbihjb2x1bW4pIHtcclxuXHRyZXR1cm4gY29sdW1uLndpZHRoID09PSBudWxsIHx8IGNvbHVtbi53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGNvbHVtbi53aWR0aCA9PT0gJyonIHx8IGNvbHVtbi53aWR0aCA9PT0gJ3N0YXInO1xyXG59XHJcblxyXG4vL1RPRE86IHJlZmFjdG9yIGFuZCByZXVzZSBpbiBtZWFzdXJlVGFibGVcclxuZnVuY3Rpb24gbWVhc3VyZU1pbk1heChjb2x1bW5zKSB7XHJcblx0dmFyIHJlc3VsdCA9IHsgbWluOiAwLCBtYXg6IDAgfTtcclxuXHJcblx0dmFyIG1heFN0YXIgPSB7IG1pbjogMCwgbWF4OiAwIH07XHJcblx0dmFyIHN0YXJDb3VudCA9IDA7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsID0gY29sdW1ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdHZhciBjID0gY29sdW1uc1tpXTtcclxuXHJcblx0XHRpZiAoaXNTdGFyQ29sdW1uKGMpKSB7XHJcblx0XHRcdG1heFN0YXIubWluID0gTWF0aC5tYXgobWF4U3Rhci5taW4sIGMuX21pbldpZHRoKTtcclxuXHRcdFx0bWF4U3Rhci5tYXggPSBNYXRoLm1heChtYXhTdGFyLm1heCwgYy5fbWF4V2lkdGgpO1xyXG5cdFx0XHRzdGFyQ291bnQrKztcclxuXHRcdH0gZWxzZSBpZiAoaXNBdXRvQ29sdW1uKGMpKSB7XHJcblx0XHRcdHJlc3VsdC5taW4gKz0gYy5fbWluV2lkdGg7XHJcblx0XHRcdHJlc3VsdC5tYXggKz0gYy5fbWF4V2lkdGg7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXN1bHQubWluICs9ICgoYy53aWR0aCAhPT0gdW5kZWZpbmVkICYmIGMud2lkdGgpIHx8IGMuX21pbldpZHRoKTtcclxuXHRcdFx0cmVzdWx0Lm1heCArPSAoKGMud2lkdGggIT09IHVuZGVmaW5lZCAmJiBjLndpZHRoKSB8fCBjLl9tYXhXaWR0aCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAoc3RhckNvdW50KSB7XHJcblx0XHRyZXN1bHQubWluICs9IHN0YXJDb3VudCAqIG1heFN0YXIubWluO1xyXG5cdFx0cmVzdWx0Lm1heCArPSBzdGFyQ291bnQgKiBtYXhTdGFyLm1heDtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGNvbHVtbiB3aWR0aHNcclxuICogQHByaXZhdGVcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdGJ1aWxkQ29sdW1uV2lkdGhzOiBidWlsZENvbHVtbldpZHRocyxcclxuXHRtZWFzdXJlTWluTWF4OiBtZWFzdXJlTWluTWF4LFxyXG5cdGlzQXV0b0NvbHVtbjogaXNBdXRvQ29sdW1uLFxyXG5cdGlzU3RhckNvbHVtbjogaXNTdGFyQ29sdW1uXHJcbn07XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/columnCalculator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/docMeasure.js":
/*!************************************************!*\
  !*** ./node_modules/pdfmake/src/docMeasure.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*eslint no-unused-vars: [\"error\", {\"args\": \"none\"}]*/\r\n\r\n\r\n\r\nvar TextTools = __webpack_require__(/*! ./textTools */ \"(rsc)/./node_modules/pdfmake/src/textTools.js\");\r\nvar StyleContextStack = __webpack_require__(/*! ./styleContextStack */ \"(rsc)/./node_modules/pdfmake/src/styleContextStack.js\");\r\nvar ColumnCalculator = __webpack_require__(/*! ./columnCalculator */ \"(rsc)/./node_modules/pdfmake/src/columnCalculator.js\");\r\nvar isString = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isString);\r\nvar isNumber = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isNumber);\r\nvar isObject = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isObject);\r\nvar isArray = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isArray);\r\nvar fontStringify = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").fontStringify);\r\nvar getNodeId = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").getNodeId);\r\nvar pack = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").pack);\r\nvar qrEncoder = __webpack_require__(/*! ./qrEnc.js */ \"(rsc)/./node_modules/pdfmake/src/qrEnc.js\");\r\n\r\n/**\r\n * @private\r\n */\r\nfunction DocMeasure(fontProvider, styleDictionary, defaultStyle, imageMeasure, svgMeasure, tableLayouts, images) {\r\n\tthis.textTools = new TextTools(fontProvider);\r\n\tthis.styleStack = new StyleContextStack(styleDictionary, defaultStyle);\r\n\tthis.imageMeasure = imageMeasure;\r\n\tthis.svgMeasure = svgMeasure;\r\n\tthis.tableLayouts = tableLayouts;\r\n\tthis.images = images;\r\n\tthis.autoImageIndex = 1;\r\n}\r\n\r\n/**\r\n * Measures all nodes and sets min/max-width properties required for the second\r\n * layout-pass.\r\n * @param  {Object} docStructure document-definition-object\r\n * @return {Object}              document-measurement-object\r\n */\r\nDocMeasure.prototype.measureDocument = function (docStructure) {\r\n\treturn this.measureNode(docStructure);\r\n};\r\n\r\nDocMeasure.prototype.measureNode = function (node) {\r\n\r\n\tvar self = this;\r\n\r\n\treturn this.styleStack.auto(node, function () {\r\n\t\t// TODO: refactor + rethink whether this is the proper way to handle margins\r\n\t\tnode._margin = getNodeMargin(node);\r\n\r\n\t\tif (node.columns) {\r\n\t\t\treturn extendMargins(self.measureColumns(node));\r\n\t\t} else if (node.stack) {\r\n\t\t\treturn extendMargins(self.measureVerticalContainer(node));\r\n\t\t} else if (node.ul) {\r\n\t\t\treturn extendMargins(self.measureUnorderedList(node));\r\n\t\t} else if (node.ol) {\r\n\t\t\treturn extendMargins(self.measureOrderedList(node));\r\n\t\t} else if (node.table) {\r\n\t\t\treturn extendMargins(self.measureTable(node));\r\n\t\t} else if (node.text !== undefined) {\r\n\t\t\treturn extendMargins(self.measureLeaf(node));\r\n\t\t} else if (node.toc) {\r\n\t\t\treturn extendMargins(self.measureToc(node));\r\n\t\t} else if (node.image) {\r\n\t\t\treturn extendMargins(self.measureImage(node));\r\n\t\t} else if (node.svg) {\r\n\t\t\treturn extendMargins(self.measureSVG(node));\r\n\t\t} else if (node.canvas) {\r\n\t\t\treturn extendMargins(self.measureCanvas(node));\r\n\t\t} else if (node.qr) {\r\n\t\t\treturn extendMargins(self.measureQr(node));\r\n\t\t} else {\r\n\t\t\tthrow 'Unrecognized document structure: ' + JSON.stringify(node, fontStringify);\r\n\t\t}\r\n\t});\r\n\r\n\tfunction extendMargins(node) {\r\n\t\tvar margin = node._margin;\r\n\r\n\t\tif (margin) {\r\n\t\t\tnode._minWidth += margin[0] + margin[2];\r\n\t\t\tnode._maxWidth += margin[0] + margin[2];\r\n\t\t}\r\n\r\n\t\treturn node;\r\n\t}\r\n\r\n\tfunction getNodeMargin() {\r\n\r\n\t\tfunction processSingleMargins(node, currentMargin) {\r\n\t\t\tif (node.marginLeft || node.marginTop || node.marginRight || node.marginBottom) {\r\n\t\t\t\treturn [\r\n\t\t\t\t\tnode.marginLeft || currentMargin[0] || 0,\r\n\t\t\t\t\tnode.marginTop || currentMargin[1] || 0,\r\n\t\t\t\t\tnode.marginRight || currentMargin[2] || 0,\r\n\t\t\t\t\tnode.marginBottom || currentMargin[3] || 0\r\n\t\t\t\t];\r\n\t\t\t}\r\n\t\t\treturn currentMargin;\r\n\t\t}\r\n\r\n\t\tfunction flattenStyleArray(styleArray) {\r\n\t\t\tvar flattenedStyles = {};\r\n\t\t\tfor (var i = styleArray.length - 1; i >= 0; i--) {\r\n\t\t\t\tvar styleName = styleArray[i];\r\n\t\t\t\tvar style = self.styleStack.styleDictionary[styleName];\r\n\t\t\t\tfor (var key in style) {\r\n\t\t\t\t\tif (style.hasOwnProperty(key)) {\r\n\t\t\t\t\t\tflattenedStyles[key] = style[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn flattenedStyles;\r\n\t\t}\r\n\r\n\t\tfunction convertMargin(margin) {\r\n\t\t\tif (isNumber(margin)) {\r\n\t\t\t\tmargin = [margin, margin, margin, margin];\r\n\t\t\t} else if (isArray(margin)) {\r\n\t\t\t\tif (margin.length === 2) {\r\n\t\t\t\t\tmargin = [margin[0], margin[1], margin[0], margin[1]];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn margin;\r\n\t\t}\r\n\r\n\t\tvar margin = [undefined, undefined, undefined, undefined];\r\n\r\n\t\tif (node.style) {\r\n\t\t\tvar styleArray = isArray(node.style) ? node.style : [node.style];\r\n\t\t\tvar flattenedStyleArray = flattenStyleArray(styleArray);\r\n\r\n\t\t\tif (flattenedStyleArray) {\r\n\t\t\t\tmargin = processSingleMargins(flattenedStyleArray, margin);\r\n\t\t\t}\r\n\r\n\t\t\tif (flattenedStyleArray.margin) {\r\n\t\t\t\tmargin = convertMargin(flattenedStyleArray.margin);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tmargin = processSingleMargins(node, margin);\r\n\r\n\t\tif (node.margin) {\r\n\t\t\tmargin = convertMargin(node.margin);\r\n\t\t}\r\n\r\n\t\tif (margin[0] === undefined && margin[1] === undefined && margin[2] === undefined && margin[3] === undefined) {\r\n\t\t\treturn null;\r\n\t\t} else {\r\n\t\t\treturn margin;\r\n\t\t}\r\n\t}\r\n};\r\n\r\nDocMeasure.prototype.convertIfBase64Image = function (node) {\r\n\tif (/^data:image\\/(jpeg|jpg|png);base64,/.test(node.image)) {\r\n\t\tvar label = '$$pdfmake$$' + this.autoImageIndex++;\r\n\t\tthis.images[label] = node.image;\r\n\t\tnode.image = label;\r\n\t}\r\n};\r\n\r\nDocMeasure.prototype.measureImageWithDimensions = function (node, dimensions) {\r\n\tif (node.fit) {\r\n\t\tvar factor = (dimensions.width / dimensions.height > node.fit[0] / node.fit[1]) ? node.fit[0] / dimensions.width : node.fit[1] / dimensions.height;\r\n\t\tnode._width = node._minWidth = node._maxWidth = dimensions.width * factor;\r\n\t\tnode._height = dimensions.height * factor;\r\n\t} else if (node.cover) {\r\n\t\tnode._width = node._minWidth = node._maxWidth = node.cover.width;\r\n\t\tnode._height = node._minHeight = node._maxHeight = node.cover.height;\r\n\t} else {\r\n\t\tnode._width = node._minWidth = node._maxWidth = node.width || dimensions.width;\r\n\t\tnode._height = node.height || (dimensions.height * node._width / dimensions.width);\r\n\r\n\t\tif (isNumber(node.maxWidth) && node.maxWidth < node._width) {\r\n\t\t\tnode._width = node._minWidth = node._maxWidth = node.maxWidth;\r\n\t\t\tnode._height = node._width * dimensions.height / dimensions.width;\r\n\t\t}\r\n\r\n\t\tif (isNumber(node.maxHeight) && node.maxHeight < node._height) {\r\n\t\t\tnode._height = node.maxHeight;\r\n\t\t\tnode._width = node._minWidth = node._maxWidth = node._height * dimensions.width / dimensions.height;\r\n\t\t}\r\n\r\n\t\tif (isNumber(node.minWidth) && node.minWidth > node._width) {\r\n\t\t\tnode._width = node._minWidth = node._maxWidth = node.minWidth;\r\n\t\t\tnode._height = node._width * dimensions.height / dimensions.width;\r\n\t\t}\r\n\r\n\t\tif (isNumber(node.minHeight) && node.minHeight > node._height) {\r\n\t\t\tnode._height = node.minHeight;\r\n\t\t\tnode._width = node._minWidth = node._maxWidth = node._height * dimensions.width / dimensions.height;\r\n\t\t}\r\n\t}\r\n\r\n\tnode._alignment = this.styleStack.getProperty('alignment');\r\n};\r\n\r\nDocMeasure.prototype.measureImage = function (node) {\r\n\tif (this.images) {\r\n\t\tthis.convertIfBase64Image(node);\r\n\t}\r\n\r\n\tvar dimensions = this.imageMeasure.measureImage(node.image);\r\n\r\n\tthis.measureImageWithDimensions(node, dimensions);\r\n\r\n\treturn node;\r\n};\r\n\r\nDocMeasure.prototype.measureSVG = function (node) {\r\n\r\n\tvar dimensions = this.svgMeasure.measureSVG(node.svg);\r\n\r\n\tthis.measureImageWithDimensions(node, dimensions);\r\n\r\n\tnode.font = this.styleStack.getProperty('font');\r\n\r\n\t// scale SVG based on final dimension\r\n\tnode.svg = this.svgMeasure.writeDimensions(node.svg, {\r\n\t\twidth: node._width,\r\n\t\theight: node._height\r\n\t});\r\n\r\n\treturn node;\r\n};\r\n\r\nDocMeasure.prototype.measureLeaf = function (node) {\r\n\r\n\tif (node._textRef && node._textRef._textNodeRef.text) {\r\n\t\tnode.text = node._textRef._textNodeRef.text;\r\n\t}\r\n\r\n\t// Make sure style properties of the node itself are considered when building inlines.\r\n\t// We could also just pass [node] to buildInlines, but that fails for bullet points.\r\n\tvar styleStack = this.styleStack.clone();\r\n\tstyleStack.push(node);\r\n\r\n\tvar data = this.textTools.buildInlines(node.text, styleStack);\r\n\r\n\tnode._inlines = data.items;\r\n\tnode._minWidth = data.minWidth;\r\n\tnode._maxWidth = data.maxWidth;\r\n\r\n\treturn node;\r\n};\r\n\r\nDocMeasure.prototype.measureToc = function (node) {\r\n\tif (node.toc.title) {\r\n\t\tnode.toc.title = this.measureNode(node.toc.title);\r\n\t}\r\n\r\n\tif (node.toc._items.length > 0) {\r\n\t\tvar body = [];\r\n\t\tvar textStyle = node.toc.textStyle || {};\r\n\t\tvar numberStyle = node.toc.numberStyle || textStyle;\r\n\t\tvar textMargin = node.toc.textMargin || [0, 0, 0, 0];\r\n\t\tfor (var i = 0, l = node.toc._items.length; i < l; i++) {\r\n\t\t\tvar item = node.toc._items[i];\r\n\t\t\tvar lineStyle = item._textNodeRef.tocStyle || textStyle;\r\n\t\t\tvar lineMargin = item._textNodeRef.tocMargin || textMargin;\r\n\t\t\tvar lineNumberStyle = item._textNodeRef.tocNumberStyle || numberStyle;\r\n\t\t\tvar destination = getNodeId(item._nodeRef);\r\n\t\t\tbody.push([\r\n\t\t\t\t{ text: item._textNodeRef.text, linkToDestination: destination, alignment: 'left', style: lineStyle, margin: lineMargin },\r\n\t\t\t\t{ text: '00000', linkToDestination: destination, alignment: 'right', _tocItemRef: item._nodeRef, style: lineNumberStyle, margin: [0, lineMargin[1], 0, lineMargin[3]] }\r\n\t\t\t]);\r\n\t\t}\r\n\r\n\r\n\t\tnode.toc._table = {\r\n\t\t\ttable: {\r\n\t\t\t\tdontBreakRows: true,\r\n\t\t\t\twidths: ['*', 'auto'],\r\n\t\t\t\tbody: body\r\n\t\t\t},\r\n\t\t\tlayout: 'noBorders'\r\n\t\t};\r\n\r\n\t\tnode.toc._table = this.measureNode(node.toc._table);\r\n\t}\r\n\r\n\treturn node;\r\n};\r\n\r\nDocMeasure.prototype.measureVerticalContainer = function (node) {\r\n\tvar items = node.stack;\r\n\r\n\tnode._minWidth = 0;\r\n\tnode._maxWidth = 0;\r\n\r\n\tfor (var i = 0, l = items.length; i < l; i++) {\r\n\t\titems[i] = this.measureNode(items[i]);\r\n\r\n\t\tnode._minWidth = Math.max(node._minWidth, items[i]._minWidth);\r\n\t\tnode._maxWidth = Math.max(node._maxWidth, items[i]._maxWidth);\r\n\t}\r\n\r\n\treturn node;\r\n};\r\n\r\nDocMeasure.prototype.gapSizeForList = function () {\r\n\treturn this.textTools.sizeOfString('9. ', this.styleStack);\r\n};\r\n\r\nDocMeasure.prototype.buildUnorderedMarker = function (styleStack, gapSize, type) {\r\n\tfunction buildDisc(gapSize, color) {\r\n\t\t// TODO: ascender-based calculations\r\n\t\tvar radius = gapSize.fontSize / 6;\r\n\t\treturn {\r\n\t\t\tcanvas: [{\r\n\t\t\t\tx: radius,\r\n\t\t\t\ty: (gapSize.height / gapSize.lineHeight) + gapSize.descender - gapSize.fontSize / 3,\r\n\t\t\t\tr1: radius,\r\n\t\t\t\tr2: radius,\r\n\t\t\t\ttype: 'ellipse',\r\n\t\t\t\tcolor: color\r\n\t\t\t}]\r\n\t\t};\r\n\t}\r\n\r\n\tfunction buildSquare(gapSize, color) {\r\n\t\t// TODO: ascender-based calculations\r\n\t\tvar size = gapSize.fontSize / 3;\r\n\t\treturn {\r\n\t\t\tcanvas: [{\r\n\t\t\t\tx: 0,\r\n\t\t\t\ty: (gapSize.height / gapSize.lineHeight) + gapSize.descender - (gapSize.fontSize / 3) - (size / 2),\r\n\t\t\t\th: size,\r\n\t\t\t\tw: size,\r\n\t\t\t\ttype: 'rect',\r\n\t\t\t\tcolor: color\r\n\t\t\t}]\r\n\t\t};\r\n\t}\r\n\r\n\tfunction buildCircle(gapSize, color) {\r\n\t\t// TODO: ascender-based calculations\r\n\t\tvar radius = gapSize.fontSize / 6;\r\n\t\treturn {\r\n\t\t\tcanvas: [{\r\n\t\t\t\tx: radius,\r\n\t\t\t\ty: (gapSize.height / gapSize.lineHeight) + gapSize.descender - gapSize.fontSize / 3,\r\n\t\t\t\tr1: radius,\r\n\t\t\t\tr2: radius,\r\n\t\t\t\ttype: 'ellipse',\r\n\t\t\t\tlineColor: color\r\n\t\t\t}]\r\n\t\t};\r\n\t}\r\n\r\n\tvar marker;\r\n\tvar color = styleStack.getProperty('markerColor') || styleStack.getProperty('color') || 'black';\r\n\r\n\tswitch (type) {\r\n\t\tcase 'circle':\r\n\t\t\tmarker = buildCircle(gapSize, color);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'square':\r\n\t\t\tmarker = buildSquare(gapSize, color);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'none':\r\n\t\t\tmarker = {};\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'disc':\r\n\t\tdefault:\r\n\t\t\tmarker = buildDisc(gapSize, color);\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\tmarker._minWidth = marker._maxWidth = gapSize.width;\r\n\tmarker._minHeight = marker._maxHeight = gapSize.height;\r\n\r\n\treturn marker;\r\n};\r\n\r\nDocMeasure.prototype.buildOrderedMarker = function (counter, styleStack, type, separator) {\r\n\tfunction prepareAlpha(counter) {\r\n\t\tfunction toAlpha(num) {\r\n\t\t\treturn (num >= 26 ? toAlpha((num / 26 >> 0) - 1) : '') + 'abcdefghijklmnopqrstuvwxyz'[num % 26 >> 0];\r\n\t\t}\r\n\r\n\t\tif (counter < 1) {\r\n\t\t\treturn counter.toString();\r\n\t\t}\r\n\r\n\t\treturn toAlpha(counter - 1);\r\n\t}\r\n\r\n\tfunction prepareRoman(counter) {\r\n\t\tif (counter < 1 || counter > 4999) {\r\n\t\t\treturn counter.toString();\r\n\t\t}\r\n\t\tvar num = counter;\r\n\t\tvar lookup = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 }, roman = '', i;\r\n\t\tfor (i in lookup) {\r\n\t\t\twhile (num >= lookup[i]) {\r\n\t\t\t\troman += i;\r\n\t\t\t\tnum -= lookup[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn roman;\r\n\t}\r\n\r\n\tfunction prepareDecimal(counter) {\r\n\t\treturn counter.toString();\r\n\t}\r\n\r\n\tvar counterText;\r\n\tswitch (type) {\r\n\t\tcase 'none':\r\n\t\t\tcounterText = null;\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'upper-alpha':\r\n\t\t\tcounterText = prepareAlpha(counter).toUpperCase();\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'lower-alpha':\r\n\t\t\tcounterText = prepareAlpha(counter);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'upper-roman':\r\n\t\t\tcounterText = prepareRoman(counter);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'lower-roman':\r\n\t\t\tcounterText = prepareRoman(counter).toLowerCase();\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'decimal':\r\n\t\tdefault:\r\n\t\t\tcounterText = prepareDecimal(counter);\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\tif (counterText === null) {\r\n\t\treturn {};\r\n\t}\r\n\r\n\tif (separator) {\r\n\t\tif (isArray(separator)) {\r\n\t\t\tif (separator[0]) {\r\n\t\t\t\tcounterText = separator[0] + counterText;\r\n\t\t\t}\r\n\r\n\t\t\tif (separator[1]) {\r\n\t\t\t\tcounterText += separator[1];\r\n\t\t\t}\r\n\t\t\tcounterText += ' ';\r\n\t\t} else {\r\n\t\t\tcounterText += separator + ' ';\r\n\t\t}\r\n\t}\r\n\r\n\tvar textArray = { text: counterText };\r\n\tvar markerColor = styleStack.getProperty('markerColor');\r\n\tif (markerColor) {\r\n\t\ttextArray.color = markerColor;\r\n\t}\r\n\r\n\treturn { _inlines: this.textTools.buildInlines(textArray, styleStack).items };\r\n};\r\n\r\nDocMeasure.prototype.measureUnorderedList = function (node) {\r\n\tvar style = this.styleStack.clone();\r\n\tvar items = node.ul;\r\n\tnode.type = node.type || 'disc';\r\n\tnode._gapSize = this.gapSizeForList();\r\n\tnode._minWidth = 0;\r\n\tnode._maxWidth = 0;\r\n\r\n\tfor (var i = 0, l = items.length; i < l; i++) {\r\n\t\tvar item = items[i] = this.measureNode(items[i]);\r\n\r\n\t\tif (!item.ol && !item.ul) {\r\n\t\t\titem.listMarker = this.buildUnorderedMarker(style, node._gapSize, item.listType || node.type);\r\n\t\t}\r\n\r\n\t\tnode._minWidth = Math.max(node._minWidth, items[i]._minWidth + node._gapSize.width);\r\n\t\tnode._maxWidth = Math.max(node._maxWidth, items[i]._maxWidth + node._gapSize.width);\r\n\t}\r\n\r\n\treturn node;\r\n};\r\n\r\nDocMeasure.prototype.measureOrderedList = function (node) {\r\n\tvar style = this.styleStack.clone();\r\n\tvar items = node.ol;\r\n\tnode.type = node.type || 'decimal';\r\n\tnode.separator = node.separator || '.';\r\n\tnode.reversed = node.reversed || false;\r\n\tif (!isNumber(node.start)) {\r\n\t\tnode.start = node.reversed ? items.length : 1;\r\n\t}\r\n\tnode._gapSize = this.gapSizeForList();\r\n\tnode._minWidth = 0;\r\n\tnode._maxWidth = 0;\r\n\r\n\tvar counter = node.start;\r\n\tfor (var i = 0, l = items.length; i < l; i++) {\r\n\t\tvar item = items[i] = this.measureNode(items[i]);\r\n\r\n\t\tif (!item.ol && !item.ul) {\r\n\t\t\tvar counterValue = isNumber(item.counter) ? item.counter : counter;\r\n\t\t\titem.listMarker = this.buildOrderedMarker(counterValue, style, item.listType || node.type, node.separator);\r\n\t\t\tif (item.listMarker._inlines) {\r\n\t\t\t\tnode._gapSize.width = Math.max(node._gapSize.width, item.listMarker._inlines[0].width);\r\n\t\t\t}\r\n\r\n\t\t\tif (node.reversed) {\r\n\t\t\t\tcounter--;\r\n\t\t\t} else {\r\n\t\t\t\tcounter++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tnode._minWidth = Math.max(node._minWidth, items[i]._minWidth);\r\n\t\tnode._maxWidth = Math.max(node._maxWidth, items[i]._maxWidth);\r\n\t}\r\n\r\n\tnode._minWidth += node._gapSize.width;\r\n\tnode._maxWidth += node._gapSize.width;\r\n\r\n\tfor (var i = 0, l = items.length; i < l; i++) {\r\n\t\tvar item = items[i];\r\n\t\tif (!item.ol && !item.ul) {\r\n\t\t\titem.listMarker._minWidth = item.listMarker._maxWidth = node._gapSize.width;\r\n\t\t}\r\n\t}\r\n\r\n\treturn node;\r\n};\r\n\r\nDocMeasure.prototype.measureColumns = function (node) {\r\n\tvar columns = node.columns;\r\n\tnode._gap = this.styleStack.getProperty('columnGap') || 0;\r\n\r\n\tfor (var i = 0, l = columns.length; i < l; i++) {\r\n\t\tcolumns[i] = this.measureNode(columns[i]);\r\n\t}\r\n\r\n\tvar measures = ColumnCalculator.measureMinMax(columns);\r\n\r\n\tvar numGaps = (columns.length > 0) ? (columns.length - 1) : 0;\r\n\tnode._minWidth = measures.min + node._gap * numGaps;\r\n\tnode._maxWidth = measures.max + node._gap * numGaps;\r\n\r\n\treturn node;\r\n};\r\n\r\nDocMeasure.prototype.measureTable = function (node) {\r\n\textendTableWidths(node);\r\n\tnode._layout = getLayout(this.tableLayouts);\r\n\tnode._offsets = getOffsets(node._layout);\r\n\r\n\tvar colSpans = [];\r\n\tvar col, row, cols, rows;\r\n\r\n\tfor (col = 0, cols = node.table.body[0].length; col < cols; col++) {\r\n\t\tvar c = node.table.widths[col];\r\n\t\tc._minWidth = 0;\r\n\t\tc._maxWidth = 0;\r\n\r\n\t\tfor (row = 0, rows = node.table.body.length; row < rows; row++) {\r\n\t\t\tvar rowData = node.table.body[row];\r\n\t\t\tvar data = rowData[col];\r\n\t\t\tif (data === undefined) {\r\n\t\t\t\tconsole.error('Malformed table row ', rowData, 'in node ', node);\r\n\t\t\t\tthrow 'Malformed table row, a cell is undefined.';\r\n\t\t\t}\r\n\t\t\tif (data === null) { // transform to object\r\n\t\t\t\tdata = '';\r\n\t\t\t}\r\n\r\n\t\t\tif (!data._span) {\r\n\t\t\t\tdata = rowData[col] = this.styleStack.auto(data, measureCb(this, data));\r\n\r\n\t\t\t\tif (data.colSpan && data.colSpan > 1) {\r\n\t\t\t\t\tmarkSpans(rowData, col, data.colSpan);\r\n\t\t\t\t\tcolSpans.push({ col: col, span: data.colSpan, minWidth: data._minWidth, maxWidth: data._maxWidth });\r\n\t\t\t\t} else {\r\n\t\t\t\t\tc._minWidth = Math.max(c._minWidth, data._minWidth);\r\n\t\t\t\t\tc._maxWidth = Math.max(c._maxWidth, data._maxWidth);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (data.rowSpan && data.rowSpan > 1) {\r\n\t\t\t\tmarkVSpans(node.table, row, col, data.rowSpan);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\textendWidthsForColSpans();\r\n\r\n\tvar measures = ColumnCalculator.measureMinMax(node.table.widths);\r\n\r\n\tnode._minWidth = measures.min + node._offsets.total;\r\n\tnode._maxWidth = measures.max + node._offsets.total;\r\n\r\n\treturn node;\r\n\r\n\tfunction measureCb(_this, data) {\r\n\t\treturn function () {\r\n\t\t\tif (isObject(data)) {\r\n\t\t\t\tdata.fillColor = _this.styleStack.getProperty('fillColor');\r\n\t\t\t\tdata.fillOpacity = _this.styleStack.getProperty('fillOpacity');\r\n\t\t\t}\r\n\t\t\treturn _this.measureNode(data);\r\n\t\t};\r\n\t}\r\n\r\n\tfunction getLayout(tableLayouts) {\r\n\t\tvar layout = node.layout;\r\n\r\n\t\tif (isString(layout)) {\r\n\t\t\tlayout = tableLayouts[layout];\r\n\t\t}\r\n\r\n\t\tvar defaultLayout = {\r\n\t\t\thLineWidth: function (i, node) {\r\n\t\t\t\treturn 1;\r\n\t\t\t},\r\n\t\t\tvLineWidth: function (i, node) {\r\n\t\t\t\treturn 1;\r\n\t\t\t},\r\n\t\t\thLineColor: function (i, node) {\r\n\t\t\t\treturn 'black';\r\n\t\t\t},\r\n\t\t\tvLineColor: function (i, node) {\r\n\t\t\t\treturn 'black';\r\n\t\t\t},\r\n\t\t\thLineStyle: function (i, node) {\r\n\t\t\t\treturn null;\r\n\t\t\t},\r\n\t\t\tvLineStyle: function (i, node) {\r\n\t\t\t\treturn null;\r\n\t\t\t},\r\n\t\t\tpaddingLeft: function (i, node) {\r\n\t\t\t\treturn 4;\r\n\t\t\t},\r\n\t\t\tpaddingRight: function (i, node) {\r\n\t\t\t\treturn 4;\r\n\t\t\t},\r\n\t\t\tpaddingTop: function (i, node) {\r\n\t\t\t\treturn 2;\r\n\t\t\t},\r\n\t\t\tpaddingBottom: function (i, node) {\r\n\t\t\t\treturn 2;\r\n\t\t\t},\r\n\t\t\tfillColor: function (i, node) {\r\n\t\t\t\treturn null;\r\n\t\t\t},\r\n\t\t\tfillOpacity: function (i, node) {\r\n\t\t\t\treturn 1;\r\n\t\t\t},\r\n\t\t\tdefaultBorder: true\r\n\t\t};\r\n\r\n\t\treturn pack(defaultLayout, layout);\r\n\t}\r\n\r\n\tfunction getOffsets(layout) {\r\n\t\tvar offsets = [];\r\n\t\tvar totalOffset = 0;\r\n\t\tvar prevRightPadding = 0;\r\n\r\n\t\tfor (var i = 0, l = node.table.widths.length; i < l; i++) {\r\n\t\t\tvar lOffset = prevRightPadding + layout.vLineWidth(i, node) + layout.paddingLeft(i, node);\r\n\t\t\toffsets.push(lOffset);\r\n\t\t\ttotalOffset += lOffset;\r\n\t\t\tprevRightPadding = layout.paddingRight(i, node);\r\n\t\t}\r\n\r\n\t\ttotalOffset += prevRightPadding + layout.vLineWidth(node.table.widths.length, node);\r\n\r\n\t\treturn {\r\n\t\t\ttotal: totalOffset,\r\n\t\t\toffsets: offsets\r\n\t\t};\r\n\t}\r\n\r\n\tfunction extendWidthsForColSpans() {\r\n\t\tvar q, j;\r\n\r\n\t\tfor (var i = 0, l = colSpans.length; i < l; i++) {\r\n\t\t\tvar span = colSpans[i];\r\n\r\n\t\t\tvar currentMinMax = getMinMax(span.col, span.span, node._offsets);\r\n\t\t\tvar minDifference = span.minWidth - currentMinMax.minWidth;\r\n\t\t\tvar maxDifference = span.maxWidth - currentMinMax.maxWidth;\r\n\r\n\t\t\tif (minDifference > 0) {\r\n\t\t\t\tq = minDifference / span.span;\r\n\r\n\t\t\t\tfor (j = 0; j < span.span; j++) {\r\n\t\t\t\t\tnode.table.widths[span.col + j]._minWidth += q;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (maxDifference > 0) {\r\n\t\t\t\tq = maxDifference / span.span;\r\n\r\n\t\t\t\tfor (j = 0; j < span.span; j++) {\r\n\t\t\t\t\tnode.table.widths[span.col + j]._maxWidth += q;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getMinMax(col, span, offsets) {\r\n\t\tvar result = { minWidth: 0, maxWidth: 0 };\r\n\r\n\t\tfor (var i = 0; i < span; i++) {\r\n\t\t\tresult.minWidth += node.table.widths[col + i]._minWidth + (i ? offsets.offsets[col + i] : 0);\r\n\t\t\tresult.maxWidth += node.table.widths[col + i]._maxWidth + (i ? offsets.offsets[col + i] : 0);\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tfunction markSpans(rowData, col, span) {\r\n\t\tfor (var i = 1; i < span; i++) {\r\n\t\t\trowData[col + i] = {\r\n\t\t\t\t_span: true,\r\n\t\t\t\t_minWidth: 0,\r\n\t\t\t\t_maxWidth: 0,\r\n\t\t\t\trowSpan: rowData[col].rowSpan\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\tfunction markVSpans(table, row, col, span) {\r\n\t\tfor (var i = 1; i < span; i++) {\r\n\t\t\ttable.body[row + i][col] = {\r\n\t\t\t\t_span: true,\r\n\t\t\t\t_minWidth: 0,\r\n\t\t\t\t_maxWidth: 0,\r\n\t\t\t\tfillColor: table.body[row][col].fillColor,\r\n\t\t\t\tfillOpacity: table.body[row][col].fillOpacity\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\tfunction extendTableWidths(node) {\r\n\t\tif (!node.table.widths) {\r\n\t\t\tnode.table.widths = 'auto';\r\n\t\t}\r\n\r\n\t\tif (isString(node.table.widths)) {\r\n\t\t\tnode.table.widths = [node.table.widths];\r\n\r\n\t\t\twhile (node.table.widths.length < node.table.body[0].length) {\r\n\t\t\t\tnode.table.widths.push(node.table.widths[node.table.widths.length - 1]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var i = 0, l = node.table.widths.length; i < l; i++) {\r\n\t\t\tvar w = node.table.widths[i];\r\n\t\t\tif (isNumber(w) || isString(w)) {\r\n\t\t\t\tnode.table.widths[i] = { width: w };\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\nDocMeasure.prototype.measureCanvas = function (node) {\r\n\tvar w = 0, h = 0;\r\n\r\n\tfor (var i = 0, l = node.canvas.length; i < l; i++) {\r\n\t\tvar vector = node.canvas[i];\r\n\r\n\t\tswitch (vector.type) {\r\n\t\t\tcase 'ellipse':\r\n\t\t\t\tw = Math.max(w, vector.x + vector.r1);\r\n\t\t\t\th = Math.max(h, vector.y + vector.r2);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'rect':\r\n\t\t\t\tw = Math.max(w, vector.x + vector.w);\r\n\t\t\t\th = Math.max(h, vector.y + vector.h);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'line':\r\n\t\t\t\tw = Math.max(w, vector.x1, vector.x2);\r\n\t\t\t\th = Math.max(h, vector.y1, vector.y2);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'polyline':\r\n\t\t\t\tfor (var i2 = 0, l2 = vector.points.length; i2 < l2; i2++) {\r\n\t\t\t\t\tw = Math.max(w, vector.points[i2].x);\r\n\t\t\t\t\th = Math.max(h, vector.points[i2].y);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tnode._minWidth = node._maxWidth = w;\r\n\tnode._minHeight = node._maxHeight = h;\r\n\tnode._alignment = this.styleStack.getProperty('alignment');\r\n\r\n\treturn node;\r\n};\r\n\r\nDocMeasure.prototype.measureQr = function (node) {\r\n\tnode = qrEncoder.measure(node);\r\n\tnode._alignment = this.styleStack.getProperty('alignment');\r\n\treturn node;\r\n};\r\n\r\nmodule.exports = DocMeasure;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvZG9jTWVhc3VyZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxvQ0FBb0MsZUFBZTtBQUNuRDtBQUNhO0FBQ2I7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBYTtBQUNyQyx3QkFBd0IsbUJBQU8sQ0FBQyxrRkFBcUI7QUFDckQsdUJBQXVCLG1CQUFPLENBQUMsZ0ZBQW9CO0FBQ25ELGVBQWUsOEZBQTZCO0FBQzVDLGVBQWUsOEZBQTZCO0FBQzVDLGVBQWUsOEZBQTZCO0FBQzVDLGNBQWMsNkZBQTRCO0FBQzFDLG9CQUFvQixtR0FBa0M7QUFDdEQsZ0JBQWdCLCtGQUE4QjtBQUM5QyxXQUFXLDBGQUF5QjtBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVIQUF1SDtBQUM3SCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtR0FBbUc7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0ZBQWtGO0FBQ3ZHLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9nYXNjYXQvcHJpc21hcXVhbnQvcHJpc21hLXF1YW50dW0vbm9kZV9tb2R1bGVzL3BkZm1ha2Uvc3JjL2RvY01lYXN1cmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyplc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgVGV4dFRvb2xzID0gcmVxdWlyZSgnLi90ZXh0VG9vbHMnKTtcclxudmFyIFN0eWxlQ29udGV4dFN0YWNrID0gcmVxdWlyZSgnLi9zdHlsZUNvbnRleHRTdGFjaycpO1xyXG52YXIgQ29sdW1uQ2FsY3VsYXRvciA9IHJlcXVpcmUoJy4vY29sdW1uQ2FsY3VsYXRvcicpO1xyXG52YXIgaXNTdHJpbmcgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc1N0cmluZztcclxudmFyIGlzTnVtYmVyID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuaXNOdW1iZXI7XHJcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaGVscGVycycpLmlzT2JqZWN0O1xyXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaGVscGVycycpLmlzQXJyYXk7XHJcbnZhciBmb250U3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuZm9udFN0cmluZ2lmeTtcclxudmFyIGdldE5vZGVJZCA9IHJlcXVpcmUoJy4vaGVscGVycycpLmdldE5vZGVJZDtcclxudmFyIHBhY2sgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5wYWNrO1xyXG52YXIgcXJFbmNvZGVyID0gcmVxdWlyZSgnLi9xckVuYy5qcycpO1xyXG5cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBEb2NNZWFzdXJlKGZvbnRQcm92aWRlciwgc3R5bGVEaWN0aW9uYXJ5LCBkZWZhdWx0U3R5bGUsIGltYWdlTWVhc3VyZSwgc3ZnTWVhc3VyZSwgdGFibGVMYXlvdXRzLCBpbWFnZXMpIHtcclxuXHR0aGlzLnRleHRUb29scyA9IG5ldyBUZXh0VG9vbHMoZm9udFByb3ZpZGVyKTtcclxuXHR0aGlzLnN0eWxlU3RhY2sgPSBuZXcgU3R5bGVDb250ZXh0U3RhY2soc3R5bGVEaWN0aW9uYXJ5LCBkZWZhdWx0U3R5bGUpO1xyXG5cdHRoaXMuaW1hZ2VNZWFzdXJlID0gaW1hZ2VNZWFzdXJlO1xyXG5cdHRoaXMuc3ZnTWVhc3VyZSA9IHN2Z01lYXN1cmU7XHJcblx0dGhpcy50YWJsZUxheW91dHMgPSB0YWJsZUxheW91dHM7XHJcblx0dGhpcy5pbWFnZXMgPSBpbWFnZXM7XHJcblx0dGhpcy5hdXRvSW1hZ2VJbmRleCA9IDE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZWFzdXJlcyBhbGwgbm9kZXMgYW5kIHNldHMgbWluL21heC13aWR0aCBwcm9wZXJ0aWVzIHJlcXVpcmVkIGZvciB0aGUgc2Vjb25kXHJcbiAqIGxheW91dC1wYXNzLlxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRvY1N0cnVjdHVyZSBkb2N1bWVudC1kZWZpbml0aW9uLW9iamVjdFxyXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICBkb2N1bWVudC1tZWFzdXJlbWVudC1vYmplY3RcclxuICovXHJcbkRvY01lYXN1cmUucHJvdG90eXBlLm1lYXN1cmVEb2N1bWVudCA9IGZ1bmN0aW9uIChkb2NTdHJ1Y3R1cmUpIHtcclxuXHRyZXR1cm4gdGhpcy5tZWFzdXJlTm9kZShkb2NTdHJ1Y3R1cmUpO1xyXG59O1xyXG5cclxuRG9jTWVhc3VyZS5wcm90b3R5cGUubWVhc3VyZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG5cclxuXHR2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG5cdHJldHVybiB0aGlzLnN0eWxlU3RhY2suYXV0byhub2RlLCBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBUT0RPOiByZWZhY3RvciArIHJldGhpbmsgd2hldGhlciB0aGlzIGlzIHRoZSBwcm9wZXIgd2F5IHRvIGhhbmRsZSBtYXJnaW5zXHJcblx0XHRub2RlLl9tYXJnaW4gPSBnZXROb2RlTWFyZ2luKG5vZGUpO1xyXG5cclxuXHRcdGlmIChub2RlLmNvbHVtbnMpIHtcclxuXHRcdFx0cmV0dXJuIGV4dGVuZE1hcmdpbnMoc2VsZi5tZWFzdXJlQ29sdW1ucyhub2RlKSk7XHJcblx0XHR9IGVsc2UgaWYgKG5vZGUuc3RhY2spIHtcclxuXHRcdFx0cmV0dXJuIGV4dGVuZE1hcmdpbnMoc2VsZi5tZWFzdXJlVmVydGljYWxDb250YWluZXIobm9kZSkpO1xyXG5cdFx0fSBlbHNlIGlmIChub2RlLnVsKSB7XHJcblx0XHRcdHJldHVybiBleHRlbmRNYXJnaW5zKHNlbGYubWVhc3VyZVVub3JkZXJlZExpc3Qobm9kZSkpO1xyXG5cdFx0fSBlbHNlIGlmIChub2RlLm9sKSB7XHJcblx0XHRcdHJldHVybiBleHRlbmRNYXJnaW5zKHNlbGYubWVhc3VyZU9yZGVyZWRMaXN0KG5vZGUpKTtcclxuXHRcdH0gZWxzZSBpZiAobm9kZS50YWJsZSkge1xyXG5cdFx0XHRyZXR1cm4gZXh0ZW5kTWFyZ2lucyhzZWxmLm1lYXN1cmVUYWJsZShub2RlKSk7XHJcblx0XHR9IGVsc2UgaWYgKG5vZGUudGV4dCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiBleHRlbmRNYXJnaW5zKHNlbGYubWVhc3VyZUxlYWYobm9kZSkpO1xyXG5cdFx0fSBlbHNlIGlmIChub2RlLnRvYykge1xyXG5cdFx0XHRyZXR1cm4gZXh0ZW5kTWFyZ2lucyhzZWxmLm1lYXN1cmVUb2Mobm9kZSkpO1xyXG5cdFx0fSBlbHNlIGlmIChub2RlLmltYWdlKSB7XHJcblx0XHRcdHJldHVybiBleHRlbmRNYXJnaW5zKHNlbGYubWVhc3VyZUltYWdlKG5vZGUpKTtcclxuXHRcdH0gZWxzZSBpZiAobm9kZS5zdmcpIHtcclxuXHRcdFx0cmV0dXJuIGV4dGVuZE1hcmdpbnMoc2VsZi5tZWFzdXJlU1ZHKG5vZGUpKTtcclxuXHRcdH0gZWxzZSBpZiAobm9kZS5jYW52YXMpIHtcclxuXHRcdFx0cmV0dXJuIGV4dGVuZE1hcmdpbnMoc2VsZi5tZWFzdXJlQ2FudmFzKG5vZGUpKTtcclxuXHRcdH0gZWxzZSBpZiAobm9kZS5xcikge1xyXG5cdFx0XHRyZXR1cm4gZXh0ZW5kTWFyZ2lucyhzZWxmLm1lYXN1cmVRcihub2RlKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aHJvdyAnVW5yZWNvZ25pemVkIGRvY3VtZW50IHN0cnVjdHVyZTogJyArIEpTT04uc3RyaW5naWZ5KG5vZGUsIGZvbnRTdHJpbmdpZnkpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRmdW5jdGlvbiBleHRlbmRNYXJnaW5zKG5vZGUpIHtcclxuXHRcdHZhciBtYXJnaW4gPSBub2RlLl9tYXJnaW47XHJcblxyXG5cdFx0aWYgKG1hcmdpbikge1xyXG5cdFx0XHRub2RlLl9taW5XaWR0aCArPSBtYXJnaW5bMF0gKyBtYXJnaW5bMl07XHJcblx0XHRcdG5vZGUuX21heFdpZHRoICs9IG1hcmdpblswXSArIG1hcmdpblsyXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbm9kZTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldE5vZGVNYXJnaW4oKSB7XHJcblxyXG5cdFx0ZnVuY3Rpb24gcHJvY2Vzc1NpbmdsZU1hcmdpbnMobm9kZSwgY3VycmVudE1hcmdpbikge1xyXG5cdFx0XHRpZiAobm9kZS5tYXJnaW5MZWZ0IHx8IG5vZGUubWFyZ2luVG9wIHx8IG5vZGUubWFyZ2luUmlnaHQgfHwgbm9kZS5tYXJnaW5Cb3R0b20pIHtcclxuXHRcdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdFx0bm9kZS5tYXJnaW5MZWZ0IHx8IGN1cnJlbnRNYXJnaW5bMF0gfHwgMCxcclxuXHRcdFx0XHRcdG5vZGUubWFyZ2luVG9wIHx8IGN1cnJlbnRNYXJnaW5bMV0gfHwgMCxcclxuXHRcdFx0XHRcdG5vZGUubWFyZ2luUmlnaHQgfHwgY3VycmVudE1hcmdpblsyXSB8fCAwLFxyXG5cdFx0XHRcdFx0bm9kZS5tYXJnaW5Cb3R0b20gfHwgY3VycmVudE1hcmdpblszXSB8fCAwXHJcblx0XHRcdFx0XTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gY3VycmVudE1hcmdpbjtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBmbGF0dGVuU3R5bGVBcnJheShzdHlsZUFycmF5KSB7XHJcblx0XHRcdHZhciBmbGF0dGVuZWRTdHlsZXMgPSB7fTtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IHN0eWxlQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHR2YXIgc3R5bGVOYW1lID0gc3R5bGVBcnJheVtpXTtcclxuXHRcdFx0XHR2YXIgc3R5bGUgPSBzZWxmLnN0eWxlU3RhY2suc3R5bGVEaWN0aW9uYXJ5W3N0eWxlTmFtZV07XHJcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHN0eWxlKSB7XHJcblx0XHRcdFx0XHRpZiAoc3R5bGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG5cdFx0XHRcdFx0XHRmbGF0dGVuZWRTdHlsZXNba2V5XSA9IHN0eWxlW2tleV07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBmbGF0dGVuZWRTdHlsZXM7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gY29udmVydE1hcmdpbihtYXJnaW4pIHtcclxuXHRcdFx0aWYgKGlzTnVtYmVyKG1hcmdpbikpIHtcclxuXHRcdFx0XHRtYXJnaW4gPSBbbWFyZ2luLCBtYXJnaW4sIG1hcmdpbiwgbWFyZ2luXTtcclxuXHRcdFx0fSBlbHNlIGlmIChpc0FycmF5KG1hcmdpbikpIHtcclxuXHRcdFx0XHRpZiAobWFyZ2luLmxlbmd0aCA9PT0gMikge1xyXG5cdFx0XHRcdFx0bWFyZ2luID0gW21hcmdpblswXSwgbWFyZ2luWzFdLCBtYXJnaW5bMF0sIG1hcmdpblsxXV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBtYXJnaW47XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1hcmdpbiA9IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWRdO1xyXG5cclxuXHRcdGlmIChub2RlLnN0eWxlKSB7XHJcblx0XHRcdHZhciBzdHlsZUFycmF5ID0gaXNBcnJheShub2RlLnN0eWxlKSA/IG5vZGUuc3R5bGUgOiBbbm9kZS5zdHlsZV07XHJcblx0XHRcdHZhciBmbGF0dGVuZWRTdHlsZUFycmF5ID0gZmxhdHRlblN0eWxlQXJyYXkoc3R5bGVBcnJheSk7XHJcblxyXG5cdFx0XHRpZiAoZmxhdHRlbmVkU3R5bGVBcnJheSkge1xyXG5cdFx0XHRcdG1hcmdpbiA9IHByb2Nlc3NTaW5nbGVNYXJnaW5zKGZsYXR0ZW5lZFN0eWxlQXJyYXksIG1hcmdpbik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChmbGF0dGVuZWRTdHlsZUFycmF5Lm1hcmdpbikge1xyXG5cdFx0XHRcdG1hcmdpbiA9IGNvbnZlcnRNYXJnaW4oZmxhdHRlbmVkU3R5bGVBcnJheS5tYXJnaW4pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bWFyZ2luID0gcHJvY2Vzc1NpbmdsZU1hcmdpbnMobm9kZSwgbWFyZ2luKTtcclxuXHJcblx0XHRpZiAobm9kZS5tYXJnaW4pIHtcclxuXHRcdFx0bWFyZ2luID0gY29udmVydE1hcmdpbihub2RlLm1hcmdpbik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1hcmdpblswXSA9PT0gdW5kZWZpbmVkICYmIG1hcmdpblsxXSA9PT0gdW5kZWZpbmVkICYmIG1hcmdpblsyXSA9PT0gdW5kZWZpbmVkICYmIG1hcmdpblszXSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG1hcmdpbjtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG5Eb2NNZWFzdXJlLnByb3RvdHlwZS5jb252ZXJ0SWZCYXNlNjRJbWFnZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblx0aWYgKC9eZGF0YTppbWFnZVxcLyhqcGVnfGpwZ3xwbmcpO2Jhc2U2NCwvLnRlc3Qobm9kZS5pbWFnZSkpIHtcclxuXHRcdHZhciBsYWJlbCA9ICckJHBkZm1ha2UkJCcgKyB0aGlzLmF1dG9JbWFnZUluZGV4Kys7XHJcblx0XHR0aGlzLmltYWdlc1tsYWJlbF0gPSBub2RlLmltYWdlO1xyXG5cdFx0bm9kZS5pbWFnZSA9IGxhYmVsO1xyXG5cdH1cclxufTtcclxuXHJcbkRvY01lYXN1cmUucHJvdG90eXBlLm1lYXN1cmVJbWFnZVdpdGhEaW1lbnNpb25zID0gZnVuY3Rpb24gKG5vZGUsIGRpbWVuc2lvbnMpIHtcclxuXHRpZiAobm9kZS5maXQpIHtcclxuXHRcdHZhciBmYWN0b3IgPSAoZGltZW5zaW9ucy53aWR0aCAvIGRpbWVuc2lvbnMuaGVpZ2h0ID4gbm9kZS5maXRbMF0gLyBub2RlLmZpdFsxXSkgPyBub2RlLmZpdFswXSAvIGRpbWVuc2lvbnMud2lkdGggOiBub2RlLmZpdFsxXSAvIGRpbWVuc2lvbnMuaGVpZ2h0O1xyXG5cdFx0bm9kZS5fd2lkdGggPSBub2RlLl9taW5XaWR0aCA9IG5vZGUuX21heFdpZHRoID0gZGltZW5zaW9ucy53aWR0aCAqIGZhY3RvcjtcclxuXHRcdG5vZGUuX2hlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0ICogZmFjdG9yO1xyXG5cdH0gZWxzZSBpZiAobm9kZS5jb3Zlcikge1xyXG5cdFx0bm9kZS5fd2lkdGggPSBub2RlLl9taW5XaWR0aCA9IG5vZGUuX21heFdpZHRoID0gbm9kZS5jb3Zlci53aWR0aDtcclxuXHRcdG5vZGUuX2hlaWdodCA9IG5vZGUuX21pbkhlaWdodCA9IG5vZGUuX21heEhlaWdodCA9IG5vZGUuY292ZXIuaGVpZ2h0O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRub2RlLl93aWR0aCA9IG5vZGUuX21pbldpZHRoID0gbm9kZS5fbWF4V2lkdGggPSBub2RlLndpZHRoIHx8IGRpbWVuc2lvbnMud2lkdGg7XHJcblx0XHRub2RlLl9oZWlnaHQgPSBub2RlLmhlaWdodCB8fCAoZGltZW5zaW9ucy5oZWlnaHQgKiBub2RlLl93aWR0aCAvIGRpbWVuc2lvbnMud2lkdGgpO1xyXG5cclxuXHRcdGlmIChpc051bWJlcihub2RlLm1heFdpZHRoKSAmJiBub2RlLm1heFdpZHRoIDwgbm9kZS5fd2lkdGgpIHtcclxuXHRcdFx0bm9kZS5fd2lkdGggPSBub2RlLl9taW5XaWR0aCA9IG5vZGUuX21heFdpZHRoID0gbm9kZS5tYXhXaWR0aDtcclxuXHRcdFx0bm9kZS5faGVpZ2h0ID0gbm9kZS5fd2lkdGggKiBkaW1lbnNpb25zLmhlaWdodCAvIGRpbWVuc2lvbnMud2lkdGg7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlzTnVtYmVyKG5vZGUubWF4SGVpZ2h0KSAmJiBub2RlLm1heEhlaWdodCA8IG5vZGUuX2hlaWdodCkge1xyXG5cdFx0XHRub2RlLl9oZWlnaHQgPSBub2RlLm1heEhlaWdodDtcclxuXHRcdFx0bm9kZS5fd2lkdGggPSBub2RlLl9taW5XaWR0aCA9IG5vZGUuX21heFdpZHRoID0gbm9kZS5faGVpZ2h0ICogZGltZW5zaW9ucy53aWR0aCAvIGRpbWVuc2lvbnMuaGVpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpc051bWJlcihub2RlLm1pbldpZHRoKSAmJiBub2RlLm1pbldpZHRoID4gbm9kZS5fd2lkdGgpIHtcclxuXHRcdFx0bm9kZS5fd2lkdGggPSBub2RlLl9taW5XaWR0aCA9IG5vZGUuX21heFdpZHRoID0gbm9kZS5taW5XaWR0aDtcclxuXHRcdFx0bm9kZS5faGVpZ2h0ID0gbm9kZS5fd2lkdGggKiBkaW1lbnNpb25zLmhlaWdodCAvIGRpbWVuc2lvbnMud2lkdGg7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlzTnVtYmVyKG5vZGUubWluSGVpZ2h0KSAmJiBub2RlLm1pbkhlaWdodCA+IG5vZGUuX2hlaWdodCkge1xyXG5cdFx0XHRub2RlLl9oZWlnaHQgPSBub2RlLm1pbkhlaWdodDtcclxuXHRcdFx0bm9kZS5fd2lkdGggPSBub2RlLl9taW5XaWR0aCA9IG5vZGUuX21heFdpZHRoID0gbm9kZS5faGVpZ2h0ICogZGltZW5zaW9ucy53aWR0aCAvIGRpbWVuc2lvbnMuaGVpZ2h0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0bm9kZS5fYWxpZ25tZW50ID0gdGhpcy5zdHlsZVN0YWNrLmdldFByb3BlcnR5KCdhbGlnbm1lbnQnKTtcclxufTtcclxuXHJcbkRvY01lYXN1cmUucHJvdG90eXBlLm1lYXN1cmVJbWFnZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblx0aWYgKHRoaXMuaW1hZ2VzKSB7XHJcblx0XHR0aGlzLmNvbnZlcnRJZkJhc2U2NEltYWdlKG5vZGUpO1xyXG5cdH1cclxuXHJcblx0dmFyIGRpbWVuc2lvbnMgPSB0aGlzLmltYWdlTWVhc3VyZS5tZWFzdXJlSW1hZ2Uobm9kZS5pbWFnZSk7XHJcblxyXG5cdHRoaXMubWVhc3VyZUltYWdlV2l0aERpbWVuc2lvbnMobm9kZSwgZGltZW5zaW9ucyk7XHJcblxyXG5cdHJldHVybiBub2RlO1xyXG59O1xyXG5cclxuRG9jTWVhc3VyZS5wcm90b3R5cGUubWVhc3VyZVNWRyA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblxyXG5cdHZhciBkaW1lbnNpb25zID0gdGhpcy5zdmdNZWFzdXJlLm1lYXN1cmVTVkcobm9kZS5zdmcpO1xyXG5cclxuXHR0aGlzLm1lYXN1cmVJbWFnZVdpdGhEaW1lbnNpb25zKG5vZGUsIGRpbWVuc2lvbnMpO1xyXG5cclxuXHRub2RlLmZvbnQgPSB0aGlzLnN0eWxlU3RhY2suZ2V0UHJvcGVydHkoJ2ZvbnQnKTtcclxuXHJcblx0Ly8gc2NhbGUgU1ZHIGJhc2VkIG9uIGZpbmFsIGRpbWVuc2lvblxyXG5cdG5vZGUuc3ZnID0gdGhpcy5zdmdNZWFzdXJlLndyaXRlRGltZW5zaW9ucyhub2RlLnN2Zywge1xyXG5cdFx0d2lkdGg6IG5vZGUuX3dpZHRoLFxyXG5cdFx0aGVpZ2h0OiBub2RlLl9oZWlnaHRcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIG5vZGU7XHJcbn07XHJcblxyXG5Eb2NNZWFzdXJlLnByb3RvdHlwZS5tZWFzdXJlTGVhZiA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblxyXG5cdGlmIChub2RlLl90ZXh0UmVmICYmIG5vZGUuX3RleHRSZWYuX3RleHROb2RlUmVmLnRleHQpIHtcclxuXHRcdG5vZGUudGV4dCA9IG5vZGUuX3RleHRSZWYuX3RleHROb2RlUmVmLnRleHQ7XHJcblx0fVxyXG5cclxuXHQvLyBNYWtlIHN1cmUgc3R5bGUgcHJvcGVydGllcyBvZiB0aGUgbm9kZSBpdHNlbGYgYXJlIGNvbnNpZGVyZWQgd2hlbiBidWlsZGluZyBpbmxpbmVzLlxyXG5cdC8vIFdlIGNvdWxkIGFsc28ganVzdCBwYXNzIFtub2RlXSB0byBidWlsZElubGluZXMsIGJ1dCB0aGF0IGZhaWxzIGZvciBidWxsZXQgcG9pbnRzLlxyXG5cdHZhciBzdHlsZVN0YWNrID0gdGhpcy5zdHlsZVN0YWNrLmNsb25lKCk7XHJcblx0c3R5bGVTdGFjay5wdXNoKG5vZGUpO1xyXG5cclxuXHR2YXIgZGF0YSA9IHRoaXMudGV4dFRvb2xzLmJ1aWxkSW5saW5lcyhub2RlLnRleHQsIHN0eWxlU3RhY2spO1xyXG5cclxuXHRub2RlLl9pbmxpbmVzID0gZGF0YS5pdGVtcztcclxuXHRub2RlLl9taW5XaWR0aCA9IGRhdGEubWluV2lkdGg7XHJcblx0bm9kZS5fbWF4V2lkdGggPSBkYXRhLm1heFdpZHRoO1xyXG5cclxuXHRyZXR1cm4gbm9kZTtcclxufTtcclxuXHJcbkRvY01lYXN1cmUucHJvdG90eXBlLm1lYXN1cmVUb2MgPSBmdW5jdGlvbiAobm9kZSkge1xyXG5cdGlmIChub2RlLnRvYy50aXRsZSkge1xyXG5cdFx0bm9kZS50b2MudGl0bGUgPSB0aGlzLm1lYXN1cmVOb2RlKG5vZGUudG9jLnRpdGxlKTtcclxuXHR9XHJcblxyXG5cdGlmIChub2RlLnRvYy5faXRlbXMubGVuZ3RoID4gMCkge1xyXG5cdFx0dmFyIGJvZHkgPSBbXTtcclxuXHRcdHZhciB0ZXh0U3R5bGUgPSBub2RlLnRvYy50ZXh0U3R5bGUgfHwge307XHJcblx0XHR2YXIgbnVtYmVyU3R5bGUgPSBub2RlLnRvYy5udW1iZXJTdHlsZSB8fCB0ZXh0U3R5bGU7XHJcblx0XHR2YXIgdGV4dE1hcmdpbiA9IG5vZGUudG9jLnRleHRNYXJnaW4gfHwgWzAsIDAsIDAsIDBdO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLnRvYy5faXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gbm9kZS50b2MuX2l0ZW1zW2ldO1xyXG5cdFx0XHR2YXIgbGluZVN0eWxlID0gaXRlbS5fdGV4dE5vZGVSZWYudG9jU3R5bGUgfHwgdGV4dFN0eWxlO1xyXG5cdFx0XHR2YXIgbGluZU1hcmdpbiA9IGl0ZW0uX3RleHROb2RlUmVmLnRvY01hcmdpbiB8fCB0ZXh0TWFyZ2luO1xyXG5cdFx0XHR2YXIgbGluZU51bWJlclN0eWxlID0gaXRlbS5fdGV4dE5vZGVSZWYudG9jTnVtYmVyU3R5bGUgfHwgbnVtYmVyU3R5bGU7XHJcblx0XHRcdHZhciBkZXN0aW5hdGlvbiA9IGdldE5vZGVJZChpdGVtLl9ub2RlUmVmKTtcclxuXHRcdFx0Ym9keS5wdXNoKFtcclxuXHRcdFx0XHR7IHRleHQ6IGl0ZW0uX3RleHROb2RlUmVmLnRleHQsIGxpbmtUb0Rlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbiwgYWxpZ25tZW50OiAnbGVmdCcsIHN0eWxlOiBsaW5lU3R5bGUsIG1hcmdpbjogbGluZU1hcmdpbiB9LFxyXG5cdFx0XHRcdHsgdGV4dDogJzAwMDAwJywgbGlua1RvRGVzdGluYXRpb246IGRlc3RpbmF0aW9uLCBhbGlnbm1lbnQ6ICdyaWdodCcsIF90b2NJdGVtUmVmOiBpdGVtLl9ub2RlUmVmLCBzdHlsZTogbGluZU51bWJlclN0eWxlLCBtYXJnaW46IFswLCBsaW5lTWFyZ2luWzFdLCAwLCBsaW5lTWFyZ2luWzNdXSB9XHJcblx0XHRcdF0pO1xyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRub2RlLnRvYy5fdGFibGUgPSB7XHJcblx0XHRcdHRhYmxlOiB7XHJcblx0XHRcdFx0ZG9udEJyZWFrUm93czogdHJ1ZSxcclxuXHRcdFx0XHR3aWR0aHM6IFsnKicsICdhdXRvJ10sXHJcblx0XHRcdFx0Ym9keTogYm9keVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRsYXlvdXQ6ICdub0JvcmRlcnMnXHJcblx0XHR9O1xyXG5cclxuXHRcdG5vZGUudG9jLl90YWJsZSA9IHRoaXMubWVhc3VyZU5vZGUobm9kZS50b2MuX3RhYmxlKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBub2RlO1xyXG59O1xyXG5cclxuRG9jTWVhc3VyZS5wcm90b3R5cGUubWVhc3VyZVZlcnRpY2FsQ29udGFpbmVyID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuXHR2YXIgaXRlbXMgPSBub2RlLnN0YWNrO1xyXG5cclxuXHRub2RlLl9taW5XaWR0aCA9IDA7XHJcblx0bm9kZS5fbWF4V2lkdGggPSAwO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0aXRlbXNbaV0gPSB0aGlzLm1lYXN1cmVOb2RlKGl0ZW1zW2ldKTtcclxuXHJcblx0XHRub2RlLl9taW5XaWR0aCA9IE1hdGgubWF4KG5vZGUuX21pbldpZHRoLCBpdGVtc1tpXS5fbWluV2lkdGgpO1xyXG5cdFx0bm9kZS5fbWF4V2lkdGggPSBNYXRoLm1heChub2RlLl9tYXhXaWR0aCwgaXRlbXNbaV0uX21heFdpZHRoKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBub2RlO1xyXG59O1xyXG5cclxuRG9jTWVhc3VyZS5wcm90b3R5cGUuZ2FwU2l6ZUZvckxpc3QgPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIHRoaXMudGV4dFRvb2xzLnNpemVPZlN0cmluZygnOS4gJywgdGhpcy5zdHlsZVN0YWNrKTtcclxufTtcclxuXHJcbkRvY01lYXN1cmUucHJvdG90eXBlLmJ1aWxkVW5vcmRlcmVkTWFya2VyID0gZnVuY3Rpb24gKHN0eWxlU3RhY2ssIGdhcFNpemUsIHR5cGUpIHtcclxuXHRmdW5jdGlvbiBidWlsZERpc2MoZ2FwU2l6ZSwgY29sb3IpIHtcclxuXHRcdC8vIFRPRE86IGFzY2VuZGVyLWJhc2VkIGNhbGN1bGF0aW9uc1xyXG5cdFx0dmFyIHJhZGl1cyA9IGdhcFNpemUuZm9udFNpemUgLyA2O1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Y2FudmFzOiBbe1xyXG5cdFx0XHRcdHg6IHJhZGl1cyxcclxuXHRcdFx0XHR5OiAoZ2FwU2l6ZS5oZWlnaHQgLyBnYXBTaXplLmxpbmVIZWlnaHQpICsgZ2FwU2l6ZS5kZXNjZW5kZXIgLSBnYXBTaXplLmZvbnRTaXplIC8gMyxcclxuXHRcdFx0XHRyMTogcmFkaXVzLFxyXG5cdFx0XHRcdHIyOiByYWRpdXMsXHJcblx0XHRcdFx0dHlwZTogJ2VsbGlwc2UnLFxyXG5cdFx0XHRcdGNvbG9yOiBjb2xvclxyXG5cdFx0XHR9XVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGJ1aWxkU3F1YXJlKGdhcFNpemUsIGNvbG9yKSB7XHJcblx0XHQvLyBUT0RPOiBhc2NlbmRlci1iYXNlZCBjYWxjdWxhdGlvbnNcclxuXHRcdHZhciBzaXplID0gZ2FwU2l6ZS5mb250U2l6ZSAvIDM7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRjYW52YXM6IFt7XHJcblx0XHRcdFx0eDogMCxcclxuXHRcdFx0XHR5OiAoZ2FwU2l6ZS5oZWlnaHQgLyBnYXBTaXplLmxpbmVIZWlnaHQpICsgZ2FwU2l6ZS5kZXNjZW5kZXIgLSAoZ2FwU2l6ZS5mb250U2l6ZSAvIDMpIC0gKHNpemUgLyAyKSxcclxuXHRcdFx0XHRoOiBzaXplLFxyXG5cdFx0XHRcdHc6IHNpemUsXHJcblx0XHRcdFx0dHlwZTogJ3JlY3QnLFxyXG5cdFx0XHRcdGNvbG9yOiBjb2xvclxyXG5cdFx0XHR9XVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGJ1aWxkQ2lyY2xlKGdhcFNpemUsIGNvbG9yKSB7XHJcblx0XHQvLyBUT0RPOiBhc2NlbmRlci1iYXNlZCBjYWxjdWxhdGlvbnNcclxuXHRcdHZhciByYWRpdXMgPSBnYXBTaXplLmZvbnRTaXplIC8gNjtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGNhbnZhczogW3tcclxuXHRcdFx0XHR4OiByYWRpdXMsXHJcblx0XHRcdFx0eTogKGdhcFNpemUuaGVpZ2h0IC8gZ2FwU2l6ZS5saW5lSGVpZ2h0KSArIGdhcFNpemUuZGVzY2VuZGVyIC0gZ2FwU2l6ZS5mb250U2l6ZSAvIDMsXHJcblx0XHRcdFx0cjE6IHJhZGl1cyxcclxuXHRcdFx0XHRyMjogcmFkaXVzLFxyXG5cdFx0XHRcdHR5cGU6ICdlbGxpcHNlJyxcclxuXHRcdFx0XHRsaW5lQ29sb3I6IGNvbG9yXHJcblx0XHRcdH1dXHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dmFyIG1hcmtlcjtcclxuXHR2YXIgY29sb3IgPSBzdHlsZVN0YWNrLmdldFByb3BlcnR5KCdtYXJrZXJDb2xvcicpIHx8IHN0eWxlU3RhY2suZ2V0UHJvcGVydHkoJ2NvbG9yJykgfHwgJ2JsYWNrJztcclxuXHJcblx0c3dpdGNoICh0eXBlKSB7XHJcblx0XHRjYXNlICdjaXJjbGUnOlxyXG5cdFx0XHRtYXJrZXIgPSBidWlsZENpcmNsZShnYXBTaXplLCBjb2xvcik7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgJ3NxdWFyZSc6XHJcblx0XHRcdG1hcmtlciA9IGJ1aWxkU3F1YXJlKGdhcFNpemUsIGNvbG9yKTtcclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSAnbm9uZSc6XHJcblx0XHRcdG1hcmtlciA9IHt9O1xyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlICdkaXNjJzpcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdG1hcmtlciA9IGJ1aWxkRGlzYyhnYXBTaXplLCBjb2xvcik7XHJcblx0XHRcdGJyZWFrO1xyXG5cdH1cclxuXHJcblx0bWFya2VyLl9taW5XaWR0aCA9IG1hcmtlci5fbWF4V2lkdGggPSBnYXBTaXplLndpZHRoO1xyXG5cdG1hcmtlci5fbWluSGVpZ2h0ID0gbWFya2VyLl9tYXhIZWlnaHQgPSBnYXBTaXplLmhlaWdodDtcclxuXHJcblx0cmV0dXJuIG1hcmtlcjtcclxufTtcclxuXHJcbkRvY01lYXN1cmUucHJvdG90eXBlLmJ1aWxkT3JkZXJlZE1hcmtlciA9IGZ1bmN0aW9uIChjb3VudGVyLCBzdHlsZVN0YWNrLCB0eXBlLCBzZXBhcmF0b3IpIHtcclxuXHRmdW5jdGlvbiBwcmVwYXJlQWxwaGEoY291bnRlcikge1xyXG5cdFx0ZnVuY3Rpb24gdG9BbHBoYShudW0pIHtcclxuXHRcdFx0cmV0dXJuIChudW0gPj0gMjYgPyB0b0FscGhhKChudW0gLyAyNiA+PiAwKSAtIDEpIDogJycpICsgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6J1tudW0gJSAyNiA+PiAwXTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY291bnRlciA8IDEpIHtcclxuXHRcdFx0cmV0dXJuIGNvdW50ZXIudG9TdHJpbmcoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdG9BbHBoYShjb3VudGVyIC0gMSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwcmVwYXJlUm9tYW4oY291bnRlcikge1xyXG5cdFx0aWYgKGNvdW50ZXIgPCAxIHx8IGNvdW50ZXIgPiA0OTk5KSB7XHJcblx0XHRcdHJldHVybiBjb3VudGVyLnRvU3RyaW5nKCk7XHJcblx0XHR9XHJcblx0XHR2YXIgbnVtID0gY291bnRlcjtcclxuXHRcdHZhciBsb29rdXAgPSB7IE06IDEwMDAsIENNOiA5MDAsIEQ6IDUwMCwgQ0Q6IDQwMCwgQzogMTAwLCBYQzogOTAsIEw6IDUwLCBYTDogNDAsIFg6IDEwLCBJWDogOSwgVjogNSwgSVY6IDQsIEk6IDEgfSwgcm9tYW4gPSAnJywgaTtcclxuXHRcdGZvciAoaSBpbiBsb29rdXApIHtcclxuXHRcdFx0d2hpbGUgKG51bSA+PSBsb29rdXBbaV0pIHtcclxuXHRcdFx0XHRyb21hbiArPSBpO1xyXG5cdFx0XHRcdG51bSAtPSBsb29rdXBbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByb21hbjtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByZXBhcmVEZWNpbWFsKGNvdW50ZXIpIHtcclxuXHRcdHJldHVybiBjb3VudGVyLnRvU3RyaW5nKCk7XHJcblx0fVxyXG5cclxuXHR2YXIgY291bnRlclRleHQ7XHJcblx0c3dpdGNoICh0eXBlKSB7XHJcblx0XHRjYXNlICdub25lJzpcclxuXHRcdFx0Y291bnRlclRleHQgPSBudWxsO1xyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlICd1cHBlci1hbHBoYSc6XHJcblx0XHRcdGNvdW50ZXJUZXh0ID0gcHJlcGFyZUFscGhhKGNvdW50ZXIpLnRvVXBwZXJDYXNlKCk7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgJ2xvd2VyLWFscGhhJzpcclxuXHRcdFx0Y291bnRlclRleHQgPSBwcmVwYXJlQWxwaGEoY291bnRlcik7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgJ3VwcGVyLXJvbWFuJzpcclxuXHRcdFx0Y291bnRlclRleHQgPSBwcmVwYXJlUm9tYW4oY291bnRlcik7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgJ2xvd2VyLXJvbWFuJzpcclxuXHRcdFx0Y291bnRlclRleHQgPSBwcmVwYXJlUm9tYW4oY291bnRlcikudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSAnZGVjaW1hbCc6XHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHRjb3VudGVyVGV4dCA9IHByZXBhcmVEZWNpbWFsKGNvdW50ZXIpO1xyXG5cdFx0XHRicmVhaztcclxuXHR9XHJcblxyXG5cdGlmIChjb3VudGVyVGV4dCA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIHt9O1xyXG5cdH1cclxuXHJcblx0aWYgKHNlcGFyYXRvcikge1xyXG5cdFx0aWYgKGlzQXJyYXkoc2VwYXJhdG9yKSkge1xyXG5cdFx0XHRpZiAoc2VwYXJhdG9yWzBdKSB7XHJcblx0XHRcdFx0Y291bnRlclRleHQgPSBzZXBhcmF0b3JbMF0gKyBjb3VudGVyVGV4dDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHNlcGFyYXRvclsxXSkge1xyXG5cdFx0XHRcdGNvdW50ZXJUZXh0ICs9IHNlcGFyYXRvclsxXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjb3VudGVyVGV4dCArPSAnICc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb3VudGVyVGV4dCArPSBzZXBhcmF0b3IgKyAnICc7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR2YXIgdGV4dEFycmF5ID0geyB0ZXh0OiBjb3VudGVyVGV4dCB9O1xyXG5cdHZhciBtYXJrZXJDb2xvciA9IHN0eWxlU3RhY2suZ2V0UHJvcGVydHkoJ21hcmtlckNvbG9yJyk7XHJcblx0aWYgKG1hcmtlckNvbG9yKSB7XHJcblx0XHR0ZXh0QXJyYXkuY29sb3IgPSBtYXJrZXJDb2xvcjtcclxuXHR9XHJcblxyXG5cdHJldHVybiB7IF9pbmxpbmVzOiB0aGlzLnRleHRUb29scy5idWlsZElubGluZXModGV4dEFycmF5LCBzdHlsZVN0YWNrKS5pdGVtcyB9O1xyXG59O1xyXG5cclxuRG9jTWVhc3VyZS5wcm90b3R5cGUubWVhc3VyZVVub3JkZXJlZExpc3QgPSBmdW5jdGlvbiAobm9kZSkge1xyXG5cdHZhciBzdHlsZSA9IHRoaXMuc3R5bGVTdGFjay5jbG9uZSgpO1xyXG5cdHZhciBpdGVtcyA9IG5vZGUudWw7XHJcblx0bm9kZS50eXBlID0gbm9kZS50eXBlIHx8ICdkaXNjJztcclxuXHRub2RlLl9nYXBTaXplID0gdGhpcy5nYXBTaXplRm9yTGlzdCgpO1xyXG5cdG5vZGUuX21pbldpZHRoID0gMDtcclxuXHRub2RlLl9tYXhXaWR0aCA9IDA7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldID0gdGhpcy5tZWFzdXJlTm9kZShpdGVtc1tpXSk7XHJcblxyXG5cdFx0aWYgKCFpdGVtLm9sICYmICFpdGVtLnVsKSB7XHJcblx0XHRcdGl0ZW0ubGlzdE1hcmtlciA9IHRoaXMuYnVpbGRVbm9yZGVyZWRNYXJrZXIoc3R5bGUsIG5vZGUuX2dhcFNpemUsIGl0ZW0ubGlzdFR5cGUgfHwgbm9kZS50eXBlKTtcclxuXHRcdH1cclxuXHJcblx0XHRub2RlLl9taW5XaWR0aCA9IE1hdGgubWF4KG5vZGUuX21pbldpZHRoLCBpdGVtc1tpXS5fbWluV2lkdGggKyBub2RlLl9nYXBTaXplLndpZHRoKTtcclxuXHRcdG5vZGUuX21heFdpZHRoID0gTWF0aC5tYXgobm9kZS5fbWF4V2lkdGgsIGl0ZW1zW2ldLl9tYXhXaWR0aCArIG5vZGUuX2dhcFNpemUud2lkdGgpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5vZGU7XHJcbn07XHJcblxyXG5Eb2NNZWFzdXJlLnByb3RvdHlwZS5tZWFzdXJlT3JkZXJlZExpc3QgPSBmdW5jdGlvbiAobm9kZSkge1xyXG5cdHZhciBzdHlsZSA9IHRoaXMuc3R5bGVTdGFjay5jbG9uZSgpO1xyXG5cdHZhciBpdGVtcyA9IG5vZGUub2w7XHJcblx0bm9kZS50eXBlID0gbm9kZS50eXBlIHx8ICdkZWNpbWFsJztcclxuXHRub2RlLnNlcGFyYXRvciA9IG5vZGUuc2VwYXJhdG9yIHx8ICcuJztcclxuXHRub2RlLnJldmVyc2VkID0gbm9kZS5yZXZlcnNlZCB8fCBmYWxzZTtcclxuXHRpZiAoIWlzTnVtYmVyKG5vZGUuc3RhcnQpKSB7XHJcblx0XHRub2RlLnN0YXJ0ID0gbm9kZS5yZXZlcnNlZCA/IGl0ZW1zLmxlbmd0aCA6IDE7XHJcblx0fVxyXG5cdG5vZGUuX2dhcFNpemUgPSB0aGlzLmdhcFNpemVGb3JMaXN0KCk7XHJcblx0bm9kZS5fbWluV2lkdGggPSAwO1xyXG5cdG5vZGUuX21heFdpZHRoID0gMDtcclxuXHJcblx0dmFyIGNvdW50ZXIgPSBub2RlLnN0YXJ0O1xyXG5cdGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldID0gdGhpcy5tZWFzdXJlTm9kZShpdGVtc1tpXSk7XHJcblxyXG5cdFx0aWYgKCFpdGVtLm9sICYmICFpdGVtLnVsKSB7XHJcblx0XHRcdHZhciBjb3VudGVyVmFsdWUgPSBpc051bWJlcihpdGVtLmNvdW50ZXIpID8gaXRlbS5jb3VudGVyIDogY291bnRlcjtcclxuXHRcdFx0aXRlbS5saXN0TWFya2VyID0gdGhpcy5idWlsZE9yZGVyZWRNYXJrZXIoY291bnRlclZhbHVlLCBzdHlsZSwgaXRlbS5saXN0VHlwZSB8fCBub2RlLnR5cGUsIG5vZGUuc2VwYXJhdG9yKTtcclxuXHRcdFx0aWYgKGl0ZW0ubGlzdE1hcmtlci5faW5saW5lcykge1xyXG5cdFx0XHRcdG5vZGUuX2dhcFNpemUud2lkdGggPSBNYXRoLm1heChub2RlLl9nYXBTaXplLndpZHRoLCBpdGVtLmxpc3RNYXJrZXIuX2lubGluZXNbMF0ud2lkdGgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAobm9kZS5yZXZlcnNlZCkge1xyXG5cdFx0XHRcdGNvdW50ZXItLTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb3VudGVyKys7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRub2RlLl9taW5XaWR0aCA9IE1hdGgubWF4KG5vZGUuX21pbldpZHRoLCBpdGVtc1tpXS5fbWluV2lkdGgpO1xyXG5cdFx0bm9kZS5fbWF4V2lkdGggPSBNYXRoLm1heChub2RlLl9tYXhXaWR0aCwgaXRlbXNbaV0uX21heFdpZHRoKTtcclxuXHR9XHJcblxyXG5cdG5vZGUuX21pbldpZHRoICs9IG5vZGUuX2dhcFNpemUud2lkdGg7XHJcblx0bm9kZS5fbWF4V2lkdGggKz0gbm9kZS5fZ2FwU2l6ZS53aWR0aDtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gaXRlbXNbaV07XHJcblx0XHRpZiAoIWl0ZW0ub2wgJiYgIWl0ZW0udWwpIHtcclxuXHRcdFx0aXRlbS5saXN0TWFya2VyLl9taW5XaWR0aCA9IGl0ZW0ubGlzdE1hcmtlci5fbWF4V2lkdGggPSBub2RlLl9nYXBTaXplLndpZHRoO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5vZGU7XHJcbn07XHJcblxyXG5Eb2NNZWFzdXJlLnByb3RvdHlwZS5tZWFzdXJlQ29sdW1ucyA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblx0dmFyIGNvbHVtbnMgPSBub2RlLmNvbHVtbnM7XHJcblx0bm9kZS5fZ2FwID0gdGhpcy5zdHlsZVN0YWNrLmdldFByb3BlcnR5KCdjb2x1bW5HYXAnKSB8fCAwO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbCA9IGNvbHVtbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRjb2x1bW5zW2ldID0gdGhpcy5tZWFzdXJlTm9kZShjb2x1bW5zW2ldKTtcclxuXHR9XHJcblxyXG5cdHZhciBtZWFzdXJlcyA9IENvbHVtbkNhbGN1bGF0b3IubWVhc3VyZU1pbk1heChjb2x1bW5zKTtcclxuXHJcblx0dmFyIG51bUdhcHMgPSAoY29sdW1ucy5sZW5ndGggPiAwKSA/IChjb2x1bW5zLmxlbmd0aCAtIDEpIDogMDtcclxuXHRub2RlLl9taW5XaWR0aCA9IG1lYXN1cmVzLm1pbiArIG5vZGUuX2dhcCAqIG51bUdhcHM7XHJcblx0bm9kZS5fbWF4V2lkdGggPSBtZWFzdXJlcy5tYXggKyBub2RlLl9nYXAgKiBudW1HYXBzO1xyXG5cclxuXHRyZXR1cm4gbm9kZTtcclxufTtcclxuXHJcbkRvY01lYXN1cmUucHJvdG90eXBlLm1lYXN1cmVUYWJsZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblx0ZXh0ZW5kVGFibGVXaWR0aHMobm9kZSk7XHJcblx0bm9kZS5fbGF5b3V0ID0gZ2V0TGF5b3V0KHRoaXMudGFibGVMYXlvdXRzKTtcclxuXHRub2RlLl9vZmZzZXRzID0gZ2V0T2Zmc2V0cyhub2RlLl9sYXlvdXQpO1xyXG5cclxuXHR2YXIgY29sU3BhbnMgPSBbXTtcclxuXHR2YXIgY29sLCByb3csIGNvbHMsIHJvd3M7XHJcblxyXG5cdGZvciAoY29sID0gMCwgY29scyA9IG5vZGUudGFibGUuYm9keVswXS5sZW5ndGg7IGNvbCA8IGNvbHM7IGNvbCsrKSB7XHJcblx0XHR2YXIgYyA9IG5vZGUudGFibGUud2lkdGhzW2NvbF07XHJcblx0XHRjLl9taW5XaWR0aCA9IDA7XHJcblx0XHRjLl9tYXhXaWR0aCA9IDA7XHJcblxyXG5cdFx0Zm9yIChyb3cgPSAwLCByb3dzID0gbm9kZS50YWJsZS5ib2R5Lmxlbmd0aDsgcm93IDwgcm93czsgcm93KyspIHtcclxuXHRcdFx0dmFyIHJvd0RhdGEgPSBub2RlLnRhYmxlLmJvZHlbcm93XTtcclxuXHRcdFx0dmFyIGRhdGEgPSByb3dEYXRhW2NvbF07XHJcblx0XHRcdGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdNYWxmb3JtZWQgdGFibGUgcm93ICcsIHJvd0RhdGEsICdpbiBub2RlICcsIG5vZGUpO1xyXG5cdFx0XHRcdHRocm93ICdNYWxmb3JtZWQgdGFibGUgcm93LCBhIGNlbGwgaXMgdW5kZWZpbmVkLic7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGRhdGEgPT09IG51bGwpIHsgLy8gdHJhbnNmb3JtIHRvIG9iamVjdFxyXG5cdFx0XHRcdGRhdGEgPSAnJztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCFkYXRhLl9zcGFuKSB7XHJcblx0XHRcdFx0ZGF0YSA9IHJvd0RhdGFbY29sXSA9IHRoaXMuc3R5bGVTdGFjay5hdXRvKGRhdGEsIG1lYXN1cmVDYih0aGlzLCBkYXRhKSk7XHJcblxyXG5cdFx0XHRcdGlmIChkYXRhLmNvbFNwYW4gJiYgZGF0YS5jb2xTcGFuID4gMSkge1xyXG5cdFx0XHRcdFx0bWFya1NwYW5zKHJvd0RhdGEsIGNvbCwgZGF0YS5jb2xTcGFuKTtcclxuXHRcdFx0XHRcdGNvbFNwYW5zLnB1c2goeyBjb2w6IGNvbCwgc3BhbjogZGF0YS5jb2xTcGFuLCBtaW5XaWR0aDogZGF0YS5fbWluV2lkdGgsIG1heFdpZHRoOiBkYXRhLl9tYXhXaWR0aCB9KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Yy5fbWluV2lkdGggPSBNYXRoLm1heChjLl9taW5XaWR0aCwgZGF0YS5fbWluV2lkdGgpO1xyXG5cdFx0XHRcdFx0Yy5fbWF4V2lkdGggPSBNYXRoLm1heChjLl9tYXhXaWR0aCwgZGF0YS5fbWF4V2lkdGgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGRhdGEucm93U3BhbiAmJiBkYXRhLnJvd1NwYW4gPiAxKSB7XHJcblx0XHRcdFx0bWFya1ZTcGFucyhub2RlLnRhYmxlLCByb3csIGNvbCwgZGF0YS5yb3dTcGFuKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZXh0ZW5kV2lkdGhzRm9yQ29sU3BhbnMoKTtcclxuXHJcblx0dmFyIG1lYXN1cmVzID0gQ29sdW1uQ2FsY3VsYXRvci5tZWFzdXJlTWluTWF4KG5vZGUudGFibGUud2lkdGhzKTtcclxuXHJcblx0bm9kZS5fbWluV2lkdGggPSBtZWFzdXJlcy5taW4gKyBub2RlLl9vZmZzZXRzLnRvdGFsO1xyXG5cdG5vZGUuX21heFdpZHRoID0gbWVhc3VyZXMubWF4ICsgbm9kZS5fb2Zmc2V0cy50b3RhbDtcclxuXHJcblx0cmV0dXJuIG5vZGU7XHJcblxyXG5cdGZ1bmN0aW9uIG1lYXN1cmVDYihfdGhpcywgZGF0YSkge1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKGlzT2JqZWN0KGRhdGEpKSB7XHJcblx0XHRcdFx0ZGF0YS5maWxsQ29sb3IgPSBfdGhpcy5zdHlsZVN0YWNrLmdldFByb3BlcnR5KCdmaWxsQ29sb3InKTtcclxuXHRcdFx0XHRkYXRhLmZpbGxPcGFjaXR5ID0gX3RoaXMuc3R5bGVTdGFjay5nZXRQcm9wZXJ0eSgnZmlsbE9wYWNpdHknKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gX3RoaXMubWVhc3VyZU5vZGUoZGF0YSk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0TGF5b3V0KHRhYmxlTGF5b3V0cykge1xyXG5cdFx0dmFyIGxheW91dCA9IG5vZGUubGF5b3V0O1xyXG5cclxuXHRcdGlmIChpc1N0cmluZyhsYXlvdXQpKSB7XHJcblx0XHRcdGxheW91dCA9IHRhYmxlTGF5b3V0c1tsYXlvdXRdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkZWZhdWx0TGF5b3V0ID0ge1xyXG5cdFx0XHRoTGluZVdpZHRoOiBmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG5cdFx0XHRcdHJldHVybiAxO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHR2TGluZVdpZHRoOiBmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG5cdFx0XHRcdHJldHVybiAxO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRoTGluZUNvbG9yOiBmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG5cdFx0XHRcdHJldHVybiAnYmxhY2snO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHR2TGluZUNvbG9yOiBmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG5cdFx0XHRcdHJldHVybiAnYmxhY2snO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRoTGluZVN0eWxlOiBmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHR2TGluZVN0eWxlOiBmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRwYWRkaW5nTGVmdDogZnVuY3Rpb24gKGksIG5vZGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gNDtcclxuXHRcdFx0fSxcclxuXHRcdFx0cGFkZGluZ1JpZ2h0OiBmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG5cdFx0XHRcdHJldHVybiA0O1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRwYWRkaW5nVG9wOiBmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG5cdFx0XHRcdHJldHVybiAyO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRwYWRkaW5nQm90dG9tOiBmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG5cdFx0XHRcdHJldHVybiAyO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRmaWxsQ29sb3I6IGZ1bmN0aW9uIChpLCBub2RlKSB7XHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH0sXHJcblx0XHRcdGZpbGxPcGFjaXR5OiBmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG5cdFx0XHRcdHJldHVybiAxO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRkZWZhdWx0Qm9yZGVyOiB0cnVlXHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiBwYWNrKGRlZmF1bHRMYXlvdXQsIGxheW91dCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRPZmZzZXRzKGxheW91dCkge1xyXG5cdFx0dmFyIG9mZnNldHMgPSBbXTtcclxuXHRcdHZhciB0b3RhbE9mZnNldCA9IDA7XHJcblx0XHR2YXIgcHJldlJpZ2h0UGFkZGluZyA9IDA7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLnRhYmxlLndpZHRocy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0dmFyIGxPZmZzZXQgPSBwcmV2UmlnaHRQYWRkaW5nICsgbGF5b3V0LnZMaW5lV2lkdGgoaSwgbm9kZSkgKyBsYXlvdXQucGFkZGluZ0xlZnQoaSwgbm9kZSk7XHJcblx0XHRcdG9mZnNldHMucHVzaChsT2Zmc2V0KTtcclxuXHRcdFx0dG90YWxPZmZzZXQgKz0gbE9mZnNldDtcclxuXHRcdFx0cHJldlJpZ2h0UGFkZGluZyA9IGxheW91dC5wYWRkaW5nUmlnaHQoaSwgbm9kZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dG90YWxPZmZzZXQgKz0gcHJldlJpZ2h0UGFkZGluZyArIGxheW91dC52TGluZVdpZHRoKG5vZGUudGFibGUud2lkdGhzLmxlbmd0aCwgbm9kZSk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dG90YWw6IHRvdGFsT2Zmc2V0LFxyXG5cdFx0XHRvZmZzZXRzOiBvZmZzZXRzXHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZXh0ZW5kV2lkdGhzRm9yQ29sU3BhbnMoKSB7XHJcblx0XHR2YXIgcSwgajtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNvbFNwYW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHR2YXIgc3BhbiA9IGNvbFNwYW5zW2ldO1xyXG5cclxuXHRcdFx0dmFyIGN1cnJlbnRNaW5NYXggPSBnZXRNaW5NYXgoc3Bhbi5jb2wsIHNwYW4uc3Bhbiwgbm9kZS5fb2Zmc2V0cyk7XHJcblx0XHRcdHZhciBtaW5EaWZmZXJlbmNlID0gc3Bhbi5taW5XaWR0aCAtIGN1cnJlbnRNaW5NYXgubWluV2lkdGg7XHJcblx0XHRcdHZhciBtYXhEaWZmZXJlbmNlID0gc3Bhbi5tYXhXaWR0aCAtIGN1cnJlbnRNaW5NYXgubWF4V2lkdGg7XHJcblxyXG5cdFx0XHRpZiAobWluRGlmZmVyZW5jZSA+IDApIHtcclxuXHRcdFx0XHRxID0gbWluRGlmZmVyZW5jZSAvIHNwYW4uc3BhbjtcclxuXHJcblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IHNwYW4uc3BhbjsgaisrKSB7XHJcblx0XHRcdFx0XHRub2RlLnRhYmxlLndpZHRoc1tzcGFuLmNvbCArIGpdLl9taW5XaWR0aCArPSBxO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKG1heERpZmZlcmVuY2UgPiAwKSB7XHJcblx0XHRcdFx0cSA9IG1heERpZmZlcmVuY2UgLyBzcGFuLnNwYW47XHJcblxyXG5cdFx0XHRcdGZvciAoaiA9IDA7IGogPCBzcGFuLnNwYW47IGorKykge1xyXG5cdFx0XHRcdFx0bm9kZS50YWJsZS53aWR0aHNbc3Bhbi5jb2wgKyBqXS5fbWF4V2lkdGggKz0gcTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldE1pbk1heChjb2wsIHNwYW4sIG9mZnNldHMpIHtcclxuXHRcdHZhciByZXN1bHQgPSB7IG1pbldpZHRoOiAwLCBtYXhXaWR0aDogMCB9O1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbjsgaSsrKSB7XHJcblx0XHRcdHJlc3VsdC5taW5XaWR0aCArPSBub2RlLnRhYmxlLndpZHRoc1tjb2wgKyBpXS5fbWluV2lkdGggKyAoaSA/IG9mZnNldHMub2Zmc2V0c1tjb2wgKyBpXSA6IDApO1xyXG5cdFx0XHRyZXN1bHQubWF4V2lkdGggKz0gbm9kZS50YWJsZS53aWR0aHNbY29sICsgaV0uX21heFdpZHRoICsgKGkgPyBvZmZzZXRzLm9mZnNldHNbY29sICsgaV0gOiAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gbWFya1NwYW5zKHJvd0RhdGEsIGNvbCwgc3Bhbikge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBzcGFuOyBpKyspIHtcclxuXHRcdFx0cm93RGF0YVtjb2wgKyBpXSA9IHtcclxuXHRcdFx0XHRfc3BhbjogdHJ1ZSxcclxuXHRcdFx0XHRfbWluV2lkdGg6IDAsXHJcblx0XHRcdFx0X21heFdpZHRoOiAwLFxyXG5cdFx0XHRcdHJvd1NwYW46IHJvd0RhdGFbY29sXS5yb3dTcGFuXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBtYXJrVlNwYW5zKHRhYmxlLCByb3csIGNvbCwgc3Bhbikge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBzcGFuOyBpKyspIHtcclxuXHRcdFx0dGFibGUuYm9keVtyb3cgKyBpXVtjb2xdID0ge1xyXG5cdFx0XHRcdF9zcGFuOiB0cnVlLFxyXG5cdFx0XHRcdF9taW5XaWR0aDogMCxcclxuXHRcdFx0XHRfbWF4V2lkdGg6IDAsXHJcblx0XHRcdFx0ZmlsbENvbG9yOiB0YWJsZS5ib2R5W3Jvd11bY29sXS5maWxsQ29sb3IsXHJcblx0XHRcdFx0ZmlsbE9wYWNpdHk6IHRhYmxlLmJvZHlbcm93XVtjb2xdLmZpbGxPcGFjaXR5XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBleHRlbmRUYWJsZVdpZHRocyhub2RlKSB7XHJcblx0XHRpZiAoIW5vZGUudGFibGUud2lkdGhzKSB7XHJcblx0XHRcdG5vZGUudGFibGUud2lkdGhzID0gJ2F1dG8nO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpc1N0cmluZyhub2RlLnRhYmxlLndpZHRocykpIHtcclxuXHRcdFx0bm9kZS50YWJsZS53aWR0aHMgPSBbbm9kZS50YWJsZS53aWR0aHNdO1xyXG5cclxuXHRcdFx0d2hpbGUgKG5vZGUudGFibGUud2lkdGhzLmxlbmd0aCA8IG5vZGUudGFibGUuYm9keVswXS5sZW5ndGgpIHtcclxuXHRcdFx0XHRub2RlLnRhYmxlLndpZHRocy5wdXNoKG5vZGUudGFibGUud2lkdGhzW25vZGUudGFibGUud2lkdGhzLmxlbmd0aCAtIDFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS50YWJsZS53aWR0aHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRcdHZhciB3ID0gbm9kZS50YWJsZS53aWR0aHNbaV07XHJcblx0XHRcdGlmIChpc051bWJlcih3KSB8fCBpc1N0cmluZyh3KSkge1xyXG5cdFx0XHRcdG5vZGUudGFibGUud2lkdGhzW2ldID0geyB3aWR0aDogdyB9O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuRG9jTWVhc3VyZS5wcm90b3R5cGUubWVhc3VyZUNhbnZhcyA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblx0dmFyIHcgPSAwLCBoID0gMDtcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNhbnZhcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdHZhciB2ZWN0b3IgPSBub2RlLmNhbnZhc1tpXTtcclxuXHJcblx0XHRzd2l0Y2ggKHZlY3Rvci50eXBlKSB7XHJcblx0XHRcdGNhc2UgJ2VsbGlwc2UnOlxyXG5cdFx0XHRcdHcgPSBNYXRoLm1heCh3LCB2ZWN0b3IueCArIHZlY3Rvci5yMSk7XHJcblx0XHRcdFx0aCA9IE1hdGgubWF4KGgsIHZlY3Rvci55ICsgdmVjdG9yLnIyKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSAncmVjdCc6XHJcblx0XHRcdFx0dyA9IE1hdGgubWF4KHcsIHZlY3Rvci54ICsgdmVjdG9yLncpO1xyXG5cdFx0XHRcdGggPSBNYXRoLm1heChoLCB2ZWN0b3IueSArIHZlY3Rvci5oKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSAnbGluZSc6XHJcblx0XHRcdFx0dyA9IE1hdGgubWF4KHcsIHZlY3Rvci54MSwgdmVjdG9yLngyKTtcclxuXHRcdFx0XHRoID0gTWF0aC5tYXgoaCwgdmVjdG9yLnkxLCB2ZWN0b3IueTIpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlICdwb2x5bGluZSc6XHJcblx0XHRcdFx0Zm9yICh2YXIgaTIgPSAwLCBsMiA9IHZlY3Rvci5wb2ludHMubGVuZ3RoOyBpMiA8IGwyOyBpMisrKSB7XHJcblx0XHRcdFx0XHR3ID0gTWF0aC5tYXgodywgdmVjdG9yLnBvaW50c1tpMl0ueCk7XHJcblx0XHRcdFx0XHRoID0gTWF0aC5tYXgoaCwgdmVjdG9yLnBvaW50c1tpMl0ueSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0bm9kZS5fbWluV2lkdGggPSBub2RlLl9tYXhXaWR0aCA9IHc7XHJcblx0bm9kZS5fbWluSGVpZ2h0ID0gbm9kZS5fbWF4SGVpZ2h0ID0gaDtcclxuXHRub2RlLl9hbGlnbm1lbnQgPSB0aGlzLnN0eWxlU3RhY2suZ2V0UHJvcGVydHkoJ2FsaWdubWVudCcpO1xyXG5cclxuXHRyZXR1cm4gbm9kZTtcclxufTtcclxuXHJcbkRvY01lYXN1cmUucHJvdG90eXBlLm1lYXN1cmVRciA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblx0bm9kZSA9IHFyRW5jb2Rlci5tZWFzdXJlKG5vZGUpO1xyXG5cdG5vZGUuX2FsaWdubWVudCA9IHRoaXMuc3R5bGVTdGFjay5nZXRQcm9wZXJ0eSgnYWxpZ25tZW50Jyk7XHJcblx0cmV0dXJuIG5vZGU7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IERvY01lYXN1cmU7XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/docMeasure.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/docPreprocessor.js":
/*!*****************************************************!*\
  !*** ./node_modules/pdfmake/src/docPreprocessor.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar isString = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isString);\r\nvar isNumber = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isNumber);\r\nvar isBoolean = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isBoolean);\r\nvar isArray = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isArray);\r\nvar isUndefined = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isUndefined);\r\nvar fontStringify = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").fontStringify);\r\n\r\nfunction DocPreprocessor() {\r\n\r\n}\r\n\r\nDocPreprocessor.prototype.preprocessDocument = function (docStructure) {\r\n\tthis.parentNode = null;\r\n\tthis.tocs = [];\r\n\tthis.nodeReferences = [];\r\n\treturn this.preprocessNode(docStructure);\r\n};\r\n\r\nDocPreprocessor.prototype.preprocessNode = function (node) {\r\n\t// expand shortcuts and casting values\r\n\tif (isArray(node)) {\r\n\t\tnode = { stack: node };\r\n\t} else if (isString(node)) {\r\n\t\tnode = { text: node };\r\n\t} else if (isNumber(node) || isBoolean(node)) {\r\n\t\tnode = { text: node.toString() };\r\n\t} else if (node === undefined || node === null) {\r\n\t\tnode = { text: '' };\r\n\t} else if (Object.keys(node).length === 0) { // empty object\r\n\t\tnode = { text: '' };\r\n\t} else if ('text' in node && (node.text === undefined || node.text === null)) {\r\n\t\tnode.text = '';\r\n\t}\r\n\r\n\tif (node.columns) {\r\n\t\treturn this.preprocessColumns(node);\r\n\t} else if (node.stack) {\r\n\t\treturn this.preprocessVerticalContainer(node);\r\n\t} else if (node.ul) {\r\n\t\treturn this.preprocessList(node);\r\n\t} else if (node.ol) {\r\n\t\treturn this.preprocessList(node);\r\n\t} else if (node.table) {\r\n\t\treturn this.preprocessTable(node);\r\n\t} else if (node.text !== undefined) {\r\n\t\treturn this.preprocessText(node);\r\n\t} else if (node.toc) {\r\n\t\treturn this.preprocessToc(node);\r\n\t} else if (node.image) {\r\n\t\treturn this.preprocessImage(node);\r\n\t} else if (node.svg) {\r\n\t\treturn this.preprocessSVG(node);\r\n\t} else if (node.canvas) {\r\n\t\treturn this.preprocessCanvas(node);\r\n\t} else if (node.qr) {\r\n\t\treturn this.preprocessQr(node);\r\n\t} else if (node.pageReference || node.textReference) {\r\n\t\treturn this.preprocessText(node);\r\n\t} else {\r\n\t\tthrow 'Unrecognized document structure: ' + JSON.stringify(node, fontStringify);\r\n\t}\r\n};\r\n\r\nDocPreprocessor.prototype.preprocessColumns = function (node) {\r\n\tvar columns = node.columns;\r\n\r\n\tfor (var i = 0, l = columns.length; i < l; i++) {\r\n\t\tcolumns[i] = this.preprocessNode(columns[i]);\r\n\t}\r\n\r\n\treturn node;\r\n};\r\n\r\nDocPreprocessor.prototype.preprocessVerticalContainer = function (node) {\r\n\tvar items = node.stack;\r\n\r\n\tfor (var i = 0, l = items.length; i < l; i++) {\r\n\t\titems[i] = this.preprocessNode(items[i]);\r\n\t}\r\n\r\n\treturn node;\r\n};\r\n\r\nDocPreprocessor.prototype.preprocessList = function (node) {\r\n\tvar items = node.ul || node.ol;\r\n\r\n\tfor (var i = 0, l = items.length; i < l; i++) {\r\n\t\titems[i] = this.preprocessNode(items[i]);\r\n\t}\r\n\r\n\treturn node;\r\n};\r\n\r\nDocPreprocessor.prototype.preprocessTable = function (node) {\r\n\tvar col, row, cols, rows;\r\n\r\n\tfor (col = 0, cols = node.table.body[0].length; col < cols; col++) {\r\n\t\tfor (row = 0, rows = node.table.body.length; row < rows; row++) {\r\n\t\t\tvar rowData = node.table.body[row];\r\n\t\t\tvar data = rowData[col];\r\n\t\t\tif (data !== undefined) {\r\n\t\t\t\tif (data === null) { // transform to object\r\n\t\t\t\t\tdata = '';\r\n\t\t\t\t}\r\n\t\t\t\tif (!data._span) {\r\n\t\t\t\t\trowData[col] = this.preprocessNode(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn node;\r\n};\r\n\r\nDocPreprocessor.prototype.preprocessText = function (node) {\r\n\tif (node.tocItem) {\r\n\t\tif (!isArray(node.tocItem)) {\r\n\t\t\tnode.tocItem = [node.tocItem];\r\n\t\t}\r\n\r\n\t\tfor (var i = 0, l = node.tocItem.length; i < l; i++) {\r\n\t\t\tif (!isString(node.tocItem[i])) {\r\n\t\t\t\tnode.tocItem[i] = '_default_';\r\n\t\t\t}\r\n\r\n\t\t\tvar tocItemId = node.tocItem[i];\r\n\r\n\t\t\tif (!this.tocs[tocItemId]) {\r\n\t\t\t\tthis.tocs[tocItemId] = { toc: { _items: [], _pseudo: true } };\r\n\t\t\t}\r\n\r\n\t\t\tif (!node.id) {\r\n\t\t\t\tnode.id = 'toc-' + tocItemId + '-' + this.tocs[tocItemId].toc._items.length;\r\n\t\t\t}\r\n\r\n\t\t\tvar tocItemRef = {\r\n\t\t\t\t_nodeRef: this._getNodeForNodeRef(node),\r\n\t\t\t\t_textNodeRef: node\r\n\t\t\t};\r\n\t\t\tthis.tocs[tocItemId].toc._items.push(tocItemRef);\r\n\t\t}\r\n\t}\r\n\r\n\tif (node.id) {\r\n\t\tif (this.nodeReferences[node.id]) {\r\n\t\t\tif (!this.nodeReferences[node.id]._pseudo) {\r\n\t\t\t\tthrow \"Node id '\" + node.id + \"' already exists\";\r\n\t\t\t}\r\n\r\n\t\t\tthis.nodeReferences[node.id]._nodeRef = this._getNodeForNodeRef(node);\r\n\t\t\tthis.nodeReferences[node.id]._textNodeRef = node;\r\n\t\t\tthis.nodeReferences[node.id]._pseudo = false;\r\n\t\t} else {\r\n\t\t\tthis.nodeReferences[node.id] = {\r\n\t\t\t\t_nodeRef: this._getNodeForNodeRef(node),\r\n\t\t\t\t_textNodeRef: node\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\tif (node.pageReference) {\r\n\t\tif (!this.nodeReferences[node.pageReference]) {\r\n\t\t\tthis.nodeReferences[node.pageReference] = {\r\n\t\t\t\t_nodeRef: {},\r\n\t\t\t\t_textNodeRef: {},\r\n\t\t\t\t_pseudo: true\r\n\t\t\t};\r\n\t\t}\r\n\t\tnode.text = '00000';\r\n\t\tnode.linkToDestination = node.pageReference;\r\n\t\tnode._pageRef = this.nodeReferences[node.pageReference];\r\n\t}\r\n\r\n\tif (node.textReference) {\r\n\t\tif (!this.nodeReferences[node.textReference]) {\r\n\t\t\tthis.nodeReferences[node.textReference] = { _nodeRef: {}, _pseudo: true };\r\n\t\t}\r\n\r\n\t\tnode.text = '';\r\n\t\tnode.linkToDestination = node.textReference;\r\n\t\tnode._textRef = this.nodeReferences[node.textReference];\r\n\t}\r\n\r\n\tif (node.text && node.text.text) {\r\n\t\tnode.text = [this.preprocessNode(node.text)];\r\n\t} else if (isArray(node.text)) {\r\n\t\tvar isSetParentNode = false;\r\n\t\tif (this.parentNode === null) {\r\n\t\t\tthis.parentNode = node;\r\n\t\t\tisSetParentNode = true;\r\n\t\t}\r\n\r\n\t\tfor (var i = 0, l = node.text.length; i < l; i++) {\r\n\t\t\tnode.text[i] = this.preprocessNode(node.text[i]);\r\n\t\t}\r\n\r\n\t\tif (isSetParentNode) {\r\n\t\t\tthis.parentNode = null;\r\n\t\t}\r\n\t}\r\n\r\n\treturn node;\r\n};\r\n\r\nDocPreprocessor.prototype.preprocessToc = function (node) {\r\n\tif (!node.toc.id) {\r\n\t\tnode.toc.id = '_default_';\r\n\t}\r\n\r\n\tnode.toc.title = node.toc.title ? this.preprocessNode(node.toc.title) : null;\r\n\tnode.toc._items = [];\r\n\r\n\tif (this.tocs[node.toc.id]) {\r\n\t\tif (!this.tocs[node.toc.id].toc._pseudo) {\r\n\t\t\tthrow \"TOC '\" + node.toc.id + \"' already exists\";\r\n\t\t}\r\n\r\n\t\tnode.toc._items = this.tocs[node.toc.id].toc._items;\r\n\t}\r\n\r\n\tthis.tocs[node.toc.id] = node;\r\n\r\n\treturn node;\r\n};\r\n\r\nDocPreprocessor.prototype.preprocessImage = function (node) {\r\n\tif (!isUndefined(node.image.type) && !isUndefined(node.image.data) && (node.image.type === 'Buffer') && isArray(node.image.data)) {\r\n\t\tnode.image = Buffer.from(node.image.data);\r\n\t}\r\n\treturn node;\r\n};\r\n\r\nDocPreprocessor.prototype.preprocessSVG = function (node) {\r\n\treturn node;\r\n};\r\n\r\nDocPreprocessor.prototype.preprocessCanvas = function (node) {\r\n\treturn node;\r\n};\r\n\r\nDocPreprocessor.prototype.preprocessQr = function (node) {\r\n\treturn node;\r\n};\r\n\r\nDocPreprocessor.prototype._getNodeForNodeRef = function (node) {\r\n\tif (this.parentNode) {\r\n\t\treturn this.parentNode;\r\n\t}\r\n\r\n\treturn node;\r\n};\r\n\r\nmodule.exports = DocPreprocessor;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvZG9jUHJlcHJvY2Vzc29yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxlQUFlLDhGQUE2QjtBQUM1QyxlQUFlLDhGQUE2QjtBQUM1QyxnQkFBZ0IsK0ZBQThCO0FBQzlDLGNBQWMsNkZBQTRCO0FBQzFDLGtCQUFrQixpR0FBZ0M7QUFDbEQsb0JBQW9CLG1HQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsR0FBRztBQUNILFdBQVc7QUFDWCxHQUFHO0FBQ0gsV0FBVztBQUNYLEdBQUc7QUFDSCxXQUFXO0FBQ1gsR0FBRywyQ0FBMkM7QUFDOUMsV0FBVztBQUNYLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFlBQVk7QUFDN0QsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9nYXNjYXQvcHJpc21hcXVhbnQvcHJpc21hLXF1YW50dW0vbm9kZV9tb2R1bGVzL3BkZm1ha2Uvc3JjL2RvY1ByZXByb2Nlc3Nvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgaXNTdHJpbmcgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc1N0cmluZztcclxudmFyIGlzTnVtYmVyID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuaXNOdW1iZXI7XHJcbnZhciBpc0Jvb2xlYW4gPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc0Jvb2xlYW47XHJcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuaXNBcnJheTtcclxudmFyIGlzVW5kZWZpbmVkID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuaXNVbmRlZmluZWQ7XHJcbnZhciBmb250U3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuZm9udFN0cmluZ2lmeTtcclxuXHJcbmZ1bmN0aW9uIERvY1ByZXByb2Nlc3NvcigpIHtcclxuXHJcbn1cclxuXHJcbkRvY1ByZXByb2Nlc3Nvci5wcm90b3R5cGUucHJlcHJvY2Vzc0RvY3VtZW50ID0gZnVuY3Rpb24gKGRvY1N0cnVjdHVyZSkge1xyXG5cdHRoaXMucGFyZW50Tm9kZSA9IG51bGw7XHJcblx0dGhpcy50b2NzID0gW107XHJcblx0dGhpcy5ub2RlUmVmZXJlbmNlcyA9IFtdO1xyXG5cdHJldHVybiB0aGlzLnByZXByb2Nlc3NOb2RlKGRvY1N0cnVjdHVyZSk7XHJcbn07XHJcblxyXG5Eb2NQcmVwcm9jZXNzb3IucHJvdG90eXBlLnByZXByb2Nlc3NOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuXHQvLyBleHBhbmQgc2hvcnRjdXRzIGFuZCBjYXN0aW5nIHZhbHVlc1xyXG5cdGlmIChpc0FycmF5KG5vZGUpKSB7XHJcblx0XHRub2RlID0geyBzdGFjazogbm9kZSB9O1xyXG5cdH0gZWxzZSBpZiAoaXNTdHJpbmcobm9kZSkpIHtcclxuXHRcdG5vZGUgPSB7IHRleHQ6IG5vZGUgfTtcclxuXHR9IGVsc2UgaWYgKGlzTnVtYmVyKG5vZGUpIHx8IGlzQm9vbGVhbihub2RlKSkge1xyXG5cdFx0bm9kZSA9IHsgdGV4dDogbm9kZS50b1N0cmluZygpIH07XHJcblx0fSBlbHNlIGlmIChub2RlID09PSB1bmRlZmluZWQgfHwgbm9kZSA9PT0gbnVsbCkge1xyXG5cdFx0bm9kZSA9IHsgdGV4dDogJycgfTtcclxuXHR9IGVsc2UgaWYgKE9iamVjdC5rZXlzKG5vZGUpLmxlbmd0aCA9PT0gMCkgeyAvLyBlbXB0eSBvYmplY3RcclxuXHRcdG5vZGUgPSB7IHRleHQ6ICcnIH07XHJcblx0fSBlbHNlIGlmICgndGV4dCcgaW4gbm9kZSAmJiAobm9kZS50ZXh0ID09PSB1bmRlZmluZWQgfHwgbm9kZS50ZXh0ID09PSBudWxsKSkge1xyXG5cdFx0bm9kZS50ZXh0ID0gJyc7XHJcblx0fVxyXG5cclxuXHRpZiAobm9kZS5jb2x1bW5zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcmVwcm9jZXNzQ29sdW1ucyhub2RlKTtcclxuXHR9IGVsc2UgaWYgKG5vZGUuc3RhY2spIHtcclxuXHRcdHJldHVybiB0aGlzLnByZXByb2Nlc3NWZXJ0aWNhbENvbnRhaW5lcihub2RlKTtcclxuXHR9IGVsc2UgaWYgKG5vZGUudWwpIHtcclxuXHRcdHJldHVybiB0aGlzLnByZXByb2Nlc3NMaXN0KG5vZGUpO1xyXG5cdH0gZWxzZSBpZiAobm9kZS5vbCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJlcHJvY2Vzc0xpc3Qobm9kZSk7XHJcblx0fSBlbHNlIGlmIChub2RlLnRhYmxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcmVwcm9jZXNzVGFibGUobm9kZSk7XHJcblx0fSBlbHNlIGlmIChub2RlLnRleHQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJlcHJvY2Vzc1RleHQobm9kZSk7XHJcblx0fSBlbHNlIGlmIChub2RlLnRvYykge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJlcHJvY2Vzc1RvYyhub2RlKTtcclxuXHR9IGVsc2UgaWYgKG5vZGUuaW1hZ2UpIHtcclxuXHRcdHJldHVybiB0aGlzLnByZXByb2Nlc3NJbWFnZShub2RlKTtcclxuXHR9IGVsc2UgaWYgKG5vZGUuc3ZnKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcmVwcm9jZXNzU1ZHKG5vZGUpO1xyXG5cdH0gZWxzZSBpZiAobm9kZS5jYW52YXMpIHtcclxuXHRcdHJldHVybiB0aGlzLnByZXByb2Nlc3NDYW52YXMobm9kZSk7XHJcblx0fSBlbHNlIGlmIChub2RlLnFyKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcmVwcm9jZXNzUXIobm9kZSk7XHJcblx0fSBlbHNlIGlmIChub2RlLnBhZ2VSZWZlcmVuY2UgfHwgbm9kZS50ZXh0UmVmZXJlbmNlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wcmVwcm9jZXNzVGV4dChub2RlKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgJ1VucmVjb2duaXplZCBkb2N1bWVudCBzdHJ1Y3R1cmU6ICcgKyBKU09OLnN0cmluZ2lmeShub2RlLCBmb250U3RyaW5naWZ5KTtcclxuXHR9XHJcbn07XHJcblxyXG5Eb2NQcmVwcm9jZXNzb3IucHJvdG90eXBlLnByZXByb2Nlc3NDb2x1bW5zID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuXHR2YXIgY29sdW1ucyA9IG5vZGUuY29sdW1ucztcclxuXHJcblx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb2x1bW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0Y29sdW1uc1tpXSA9IHRoaXMucHJlcHJvY2Vzc05vZGUoY29sdW1uc1tpXSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbm9kZTtcclxufTtcclxuXHJcbkRvY1ByZXByb2Nlc3Nvci5wcm90b3R5cGUucHJlcHJvY2Vzc1ZlcnRpY2FsQ29udGFpbmVyID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuXHR2YXIgaXRlbXMgPSBub2RlLnN0YWNrO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0aXRlbXNbaV0gPSB0aGlzLnByZXByb2Nlc3NOb2RlKGl0ZW1zW2ldKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBub2RlO1xyXG59O1xyXG5cclxuRG9jUHJlcHJvY2Vzc29yLnByb3RvdHlwZS5wcmVwcm9jZXNzTGlzdCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblx0dmFyIGl0ZW1zID0gbm9kZS51bCB8fCBub2RlLm9sO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0aXRlbXNbaV0gPSB0aGlzLnByZXByb2Nlc3NOb2RlKGl0ZW1zW2ldKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBub2RlO1xyXG59O1xyXG5cclxuRG9jUHJlcHJvY2Vzc29yLnByb3RvdHlwZS5wcmVwcm9jZXNzVGFibGUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG5cdHZhciBjb2wsIHJvdywgY29scywgcm93cztcclxuXHJcblx0Zm9yIChjb2wgPSAwLCBjb2xzID0gbm9kZS50YWJsZS5ib2R5WzBdLmxlbmd0aDsgY29sIDwgY29sczsgY29sKyspIHtcclxuXHRcdGZvciAocm93ID0gMCwgcm93cyA9IG5vZGUudGFibGUuYm9keS5sZW5ndGg7IHJvdyA8IHJvd3M7IHJvdysrKSB7XHJcblx0XHRcdHZhciByb3dEYXRhID0gbm9kZS50YWJsZS5ib2R5W3Jvd107XHJcblx0XHRcdHZhciBkYXRhID0gcm93RGF0YVtjb2xdO1xyXG5cdFx0XHRpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0aWYgKGRhdGEgPT09IG51bGwpIHsgLy8gdHJhbnNmb3JtIHRvIG9iamVjdFxyXG5cdFx0XHRcdFx0ZGF0YSA9ICcnO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoIWRhdGEuX3NwYW4pIHtcclxuXHRcdFx0XHRcdHJvd0RhdGFbY29sXSA9IHRoaXMucHJlcHJvY2Vzc05vZGUoZGF0YSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbm9kZTtcclxufTtcclxuXHJcbkRvY1ByZXByb2Nlc3Nvci5wcm90b3R5cGUucHJlcHJvY2Vzc1RleHQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG5cdGlmIChub2RlLnRvY0l0ZW0pIHtcclxuXHRcdGlmICghaXNBcnJheShub2RlLnRvY0l0ZW0pKSB7XHJcblx0XHRcdG5vZGUudG9jSXRlbSA9IFtub2RlLnRvY0l0ZW1dO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS50b2NJdGVtLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHRpZiAoIWlzU3RyaW5nKG5vZGUudG9jSXRlbVtpXSkpIHtcclxuXHRcdFx0XHRub2RlLnRvY0l0ZW1baV0gPSAnX2RlZmF1bHRfJztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHRvY0l0ZW1JZCA9IG5vZGUudG9jSXRlbVtpXTtcclxuXHJcblx0XHRcdGlmICghdGhpcy50b2NzW3RvY0l0ZW1JZF0pIHtcclxuXHRcdFx0XHR0aGlzLnRvY3NbdG9jSXRlbUlkXSA9IHsgdG9jOiB7IF9pdGVtczogW10sIF9wc2V1ZG86IHRydWUgfSB9O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIW5vZGUuaWQpIHtcclxuXHRcdFx0XHRub2RlLmlkID0gJ3RvYy0nICsgdG9jSXRlbUlkICsgJy0nICsgdGhpcy50b2NzW3RvY0l0ZW1JZF0udG9jLl9pdGVtcy5sZW5ndGg7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB0b2NJdGVtUmVmID0ge1xyXG5cdFx0XHRcdF9ub2RlUmVmOiB0aGlzLl9nZXROb2RlRm9yTm9kZVJlZihub2RlKSxcclxuXHRcdFx0XHRfdGV4dE5vZGVSZWY6IG5vZGVcclxuXHRcdFx0fTtcclxuXHRcdFx0dGhpcy50b2NzW3RvY0l0ZW1JZF0udG9jLl9pdGVtcy5wdXNoKHRvY0l0ZW1SZWYpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKG5vZGUuaWQpIHtcclxuXHRcdGlmICh0aGlzLm5vZGVSZWZlcmVuY2VzW25vZGUuaWRdKSB7XHJcblx0XHRcdGlmICghdGhpcy5ub2RlUmVmZXJlbmNlc1tub2RlLmlkXS5fcHNldWRvKSB7XHJcblx0XHRcdFx0dGhyb3cgXCJOb2RlIGlkICdcIiArIG5vZGUuaWQgKyBcIicgYWxyZWFkeSBleGlzdHNcIjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5ub2RlUmVmZXJlbmNlc1tub2RlLmlkXS5fbm9kZVJlZiA9IHRoaXMuX2dldE5vZGVGb3JOb2RlUmVmKG5vZGUpO1xyXG5cdFx0XHR0aGlzLm5vZGVSZWZlcmVuY2VzW25vZGUuaWRdLl90ZXh0Tm9kZVJlZiA9IG5vZGU7XHJcblx0XHRcdHRoaXMubm9kZVJlZmVyZW5jZXNbbm9kZS5pZF0uX3BzZXVkbyA9IGZhbHNlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5ub2RlUmVmZXJlbmNlc1tub2RlLmlkXSA9IHtcclxuXHRcdFx0XHRfbm9kZVJlZjogdGhpcy5fZ2V0Tm9kZUZvck5vZGVSZWYobm9kZSksXHJcblx0XHRcdFx0X3RleHROb2RlUmVmOiBub2RlXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAobm9kZS5wYWdlUmVmZXJlbmNlKSB7XHJcblx0XHRpZiAoIXRoaXMubm9kZVJlZmVyZW5jZXNbbm9kZS5wYWdlUmVmZXJlbmNlXSkge1xyXG5cdFx0XHR0aGlzLm5vZGVSZWZlcmVuY2VzW25vZGUucGFnZVJlZmVyZW5jZV0gPSB7XHJcblx0XHRcdFx0X25vZGVSZWY6IHt9LFxyXG5cdFx0XHRcdF90ZXh0Tm9kZVJlZjoge30sXHJcblx0XHRcdFx0X3BzZXVkbzogdHJ1ZVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdFx0bm9kZS50ZXh0ID0gJzAwMDAwJztcclxuXHRcdG5vZGUubGlua1RvRGVzdGluYXRpb24gPSBub2RlLnBhZ2VSZWZlcmVuY2U7XHJcblx0XHRub2RlLl9wYWdlUmVmID0gdGhpcy5ub2RlUmVmZXJlbmNlc1tub2RlLnBhZ2VSZWZlcmVuY2VdO1xyXG5cdH1cclxuXHJcblx0aWYgKG5vZGUudGV4dFJlZmVyZW5jZSkge1xyXG5cdFx0aWYgKCF0aGlzLm5vZGVSZWZlcmVuY2VzW25vZGUudGV4dFJlZmVyZW5jZV0pIHtcclxuXHRcdFx0dGhpcy5ub2RlUmVmZXJlbmNlc1tub2RlLnRleHRSZWZlcmVuY2VdID0geyBfbm9kZVJlZjoge30sIF9wc2V1ZG86IHRydWUgfTtcclxuXHRcdH1cclxuXHJcblx0XHRub2RlLnRleHQgPSAnJztcclxuXHRcdG5vZGUubGlua1RvRGVzdGluYXRpb24gPSBub2RlLnRleHRSZWZlcmVuY2U7XHJcblx0XHRub2RlLl90ZXh0UmVmID0gdGhpcy5ub2RlUmVmZXJlbmNlc1tub2RlLnRleHRSZWZlcmVuY2VdO1xyXG5cdH1cclxuXHJcblx0aWYgKG5vZGUudGV4dCAmJiBub2RlLnRleHQudGV4dCkge1xyXG5cdFx0bm9kZS50ZXh0ID0gW3RoaXMucHJlcHJvY2Vzc05vZGUobm9kZS50ZXh0KV07XHJcblx0fSBlbHNlIGlmIChpc0FycmF5KG5vZGUudGV4dCkpIHtcclxuXHRcdHZhciBpc1NldFBhcmVudE5vZGUgPSBmYWxzZTtcclxuXHRcdGlmICh0aGlzLnBhcmVudE5vZGUgPT09IG51bGwpIHtcclxuXHRcdFx0dGhpcy5wYXJlbnROb2RlID0gbm9kZTtcclxuXHRcdFx0aXNTZXRQYXJlbnROb2RlID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUudGV4dC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0bm9kZS50ZXh0W2ldID0gdGhpcy5wcmVwcm9jZXNzTm9kZShub2RlLnRleHRbaV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpc1NldFBhcmVudE5vZGUpIHtcclxuXHRcdFx0dGhpcy5wYXJlbnROb2RlID0gbnVsbDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBub2RlO1xyXG59O1xyXG5cclxuRG9jUHJlcHJvY2Vzc29yLnByb3RvdHlwZS5wcmVwcm9jZXNzVG9jID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuXHRpZiAoIW5vZGUudG9jLmlkKSB7XHJcblx0XHRub2RlLnRvYy5pZCA9ICdfZGVmYXVsdF8nO1xyXG5cdH1cclxuXHJcblx0bm9kZS50b2MudGl0bGUgPSBub2RlLnRvYy50aXRsZSA/IHRoaXMucHJlcHJvY2Vzc05vZGUobm9kZS50b2MudGl0bGUpIDogbnVsbDtcclxuXHRub2RlLnRvYy5faXRlbXMgPSBbXTtcclxuXHJcblx0aWYgKHRoaXMudG9jc1tub2RlLnRvYy5pZF0pIHtcclxuXHRcdGlmICghdGhpcy50b2NzW25vZGUudG9jLmlkXS50b2MuX3BzZXVkbykge1xyXG5cdFx0XHR0aHJvdyBcIlRPQyAnXCIgKyBub2RlLnRvYy5pZCArIFwiJyBhbHJlYWR5IGV4aXN0c1wiO1xyXG5cdFx0fVxyXG5cclxuXHRcdG5vZGUudG9jLl9pdGVtcyA9IHRoaXMudG9jc1tub2RlLnRvYy5pZF0udG9jLl9pdGVtcztcclxuXHR9XHJcblxyXG5cdHRoaXMudG9jc1tub2RlLnRvYy5pZF0gPSBub2RlO1xyXG5cclxuXHRyZXR1cm4gbm9kZTtcclxufTtcclxuXHJcbkRvY1ByZXByb2Nlc3Nvci5wcm90b3R5cGUucHJlcHJvY2Vzc0ltYWdlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuXHRpZiAoIWlzVW5kZWZpbmVkKG5vZGUuaW1hZ2UudHlwZSkgJiYgIWlzVW5kZWZpbmVkKG5vZGUuaW1hZ2UuZGF0YSkgJiYgKG5vZGUuaW1hZ2UudHlwZSA9PT0gJ0J1ZmZlcicpICYmIGlzQXJyYXkobm9kZS5pbWFnZS5kYXRhKSkge1xyXG5cdFx0bm9kZS5pbWFnZSA9IEJ1ZmZlci5mcm9tKG5vZGUuaW1hZ2UuZGF0YSk7XHJcblx0fVxyXG5cdHJldHVybiBub2RlO1xyXG59O1xyXG5cclxuRG9jUHJlcHJvY2Vzc29yLnByb3RvdHlwZS5wcmVwcm9jZXNzU1ZHID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuXHRyZXR1cm4gbm9kZTtcclxufTtcclxuXHJcbkRvY1ByZXByb2Nlc3Nvci5wcm90b3R5cGUucHJlcHJvY2Vzc0NhbnZhcyA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblx0cmV0dXJuIG5vZGU7XHJcbn07XHJcblxyXG5Eb2NQcmVwcm9jZXNzb3IucHJvdG90eXBlLnByZXByb2Nlc3NRciA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblx0cmV0dXJuIG5vZGU7XHJcbn07XHJcblxyXG5Eb2NQcmVwcm9jZXNzb3IucHJvdG90eXBlLl9nZXROb2RlRm9yTm9kZVJlZiA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblx0aWYgKHRoaXMucGFyZW50Tm9kZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMucGFyZW50Tm9kZTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBub2RlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEb2NQcmVwcm9jZXNzb3I7XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/docPreprocessor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/documentContext.js":
/*!*****************************************************!*\
  !*** ./node_modules/pdfmake/src/documentContext.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar TraversalTracker = __webpack_require__(/*! ./traversalTracker */ \"(rsc)/./node_modules/pdfmake/src/traversalTracker.js\");\r\nvar isString = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isString);\r\n\r\n/**\r\n * Creates an instance of DocumentContext - a store for current x, y positions and available width/height.\r\n * It facilitates column divisions and vertical sync\r\n */\r\nfunction DocumentContext(pageSize, pageMargins) {\r\n\tthis.pages = [];\r\n\r\n\tthis.pageMargins = pageMargins;\r\n\r\n\tthis.x = pageMargins.left;\r\n\tthis.availableWidth = pageSize.width - pageMargins.left - pageMargins.right;\r\n\tthis.availableHeight = 0;\r\n\tthis.page = -1;\r\n\r\n\tthis.snapshots = [];\r\n\r\n\tthis.tracker = new TraversalTracker();\r\n\r\n\tthis.backgroundLength = [];\r\n\r\n\tthis.addPage(pageSize);\r\n}\r\n\r\nDocumentContext.prototype.beginColumnGroup = function (marginXTopParent, bottomByPage = {}) {\r\n\tthis.snapshots.push({\r\n\t\tx: this.x,\r\n\t\ty: this.y,\r\n\t\tavailableHeight: this.availableHeight,\r\n\t\tavailableWidth: this.availableWidth,\r\n\t\tpage: this.page,\r\n\t\tbottomByPage: bottomByPage ? bottomByPage : {},\r\n\t\tbottomMost: {\r\n\t\t\tx: this.x,\r\n\t\t\ty: this.y,\r\n\t\t\tavailableHeight: this.availableHeight,\r\n\t\t\tavailableWidth: this.availableWidth,\r\n\t\t\tpage: this.page\r\n\t\t},\r\n\t\tlastColumnWidth: this.lastColumnWidth\r\n\t});\r\n\r\n\tthis.lastColumnWidth = 0;\r\n\tif (marginXTopParent) {\r\n\t\tthis.marginXTopParent = marginXTopParent;\r\n\t}\r\n};\r\n\r\nDocumentContext.prototype.updateBottomByPage = function () {\r\n\tconst lastSnapshot = this.snapshots[this.snapshots.length - 1];\r\n\tconst lastPage = this.page;\r\n\tlet previousBottom = -Number.MIN_VALUE;\r\n\tif (lastSnapshot.bottomByPage[lastPage]) {\r\n\t\tpreviousBottom = lastSnapshot.bottomByPage[lastPage];\r\n\t}\r\n\tlastSnapshot.bottomByPage[lastPage] = Math.max(previousBottom, this.y);\r\n};\r\n\r\nDocumentContext.prototype.resetMarginXTopParent = function () {\r\n\tthis.marginXTopParent = null;\r\n};\r\n\r\nDocumentContext.prototype.beginColumn = function (width, offset, endingCell) {\r\n\tvar saved = this.snapshots[this.snapshots.length - 1];\r\n\r\n\tthis.calculateBottomMost(saved, endingCell);\r\n\r\n\tthis.page = saved.page;\r\n\tthis.x = this.x + this.lastColumnWidth + (offset || 0);\r\n\tthis.y = saved.y;\r\n\tthis.availableWidth = width;\t//saved.availableWidth - offset;\r\n\tthis.availableHeight = saved.availableHeight;\r\n\r\n\tthis.lastColumnWidth = width;\r\n};\r\n\r\nDocumentContext.prototype.calculateBottomMost = function (destContext, endingCell) {\r\n\tif (endingCell) {\r\n\t\tthis.saveContextInEndingCell(endingCell);\r\n\t} else {\r\n\t\tdestContext.bottomMost = bottomMostContext(this, destContext.bottomMost);\r\n\t}\r\n};\r\n\r\nDocumentContext.prototype.markEnding = function (endingCell, originalXOffset, discountY) {\r\n\tthis.page = endingCell._columnEndingContext.page;\r\n\tthis.x = endingCell._columnEndingContext.x + originalXOffset;\r\n\tthis.y = endingCell._columnEndingContext.y - discountY;\r\n\tthis.availableWidth = endingCell._columnEndingContext.availableWidth;\r\n\tthis.availableHeight = endingCell._columnEndingContext.availableHeight;\r\n\tthis.lastColumnWidth = endingCell._columnEndingContext.lastColumnWidth;\r\n};\r\n\r\nDocumentContext.prototype.saveContextInEndingCell = function (endingCell) {\r\n\tendingCell._columnEndingContext = {\r\n\t\tpage: this.page,\r\n\t\tx: this.x,\r\n\t\ty: this.y,\r\n\t\tavailableHeight: this.availableHeight,\r\n\t\tavailableWidth: this.availableWidth,\r\n\t\tlastColumnWidth: this.lastColumnWidth\r\n\t};\r\n};\r\n\r\nDocumentContext.prototype.completeColumnGroup = function (height, endingCell) {\r\n\tvar saved = this.snapshots.pop();\r\n\r\n\tthis.calculateBottomMost(saved, endingCell);\r\n\r\n\tthis.x = saved.x;\r\n\r\n\tvar y = saved.bottomMost.y;\r\n\tif (height) {\r\n\t\tif (saved.page === saved.bottomMost.page) {\r\n\t\t\tif ((saved.y + height) > y) {\r\n\t\t\t\ty = saved.y + height;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ty += height;\r\n\t\t}\r\n\t}\r\n\r\n\tthis.y = y;\r\n\tthis.page = saved.bottomMost.page;\r\n\tthis.availableWidth = saved.availableWidth;\r\n\tthis.availableHeight = saved.bottomMost.availableHeight;\r\n\tif (height) {\r\n\t\tthis.availableHeight -= (y - saved.bottomMost.y);\r\n\t}\r\n\tthis.lastColumnWidth = saved.lastColumnWidth;\r\n\treturn saved.bottomByPage;\r\n};\r\n\r\nDocumentContext.prototype.addMargin = function (left, right) {\r\n\tthis.x += left;\r\n\tthis.availableWidth -= left + (right || 0);\r\n};\r\n\r\nDocumentContext.prototype.moveDown = function (offset) {\r\n\tthis.y += offset;\r\n\tthis.availableHeight -= offset;\r\n\r\n\treturn this.availableHeight > 0;\r\n};\r\n\r\nDocumentContext.prototype.initializePage = function () {\r\n\tthis.y = this.pageMargins.top;\r\n\tthis.availableHeight = this.getCurrentPage().pageSize.height - this.pageMargins.top - this.pageMargins.bottom;\r\n\tconst { pageCtx, isSnapshot } = this.pageSnapshot();\r\n\tpageCtx.availableWidth = this.getCurrentPage().pageSize.width - this.pageMargins.left - this.pageMargins.right;\r\n\tif (isSnapshot && this.marginXTopParent) {\r\n\t\tpageCtx.availableWidth -= this.marginXTopParent[0];\r\n\t\tpageCtx.availableWidth -= this.marginXTopParent[1];\r\n\t}\r\n};\r\n\r\nDocumentContext.prototype.pageSnapshot = function () {\r\n\tif (this.snapshots[0]) {\r\n\t\treturn { pageCtx: this.snapshots[0], isSnapshot: true };\r\n\t} else {\r\n\t\treturn { pageCtx: this, isSnapshot: false };\r\n\t}\r\n};\r\n\r\nDocumentContext.prototype.moveTo = function (x, y) {\r\n\tif (x !== undefined && x !== null) {\r\n\t\tthis.x = x;\r\n\t\tthis.availableWidth = this.getCurrentPage().pageSize.width - this.x - this.pageMargins.right;\r\n\t}\r\n\tif (y !== undefined && y !== null) {\r\n\t\tthis.y = y;\r\n\t\tthis.availableHeight = this.getCurrentPage().pageSize.height - this.y - this.pageMargins.bottom;\r\n\t}\r\n};\r\n\r\nDocumentContext.prototype.moveToRelative = function (x, y) {\r\n\tif (x !== undefined && x !== null) {\r\n\t\tthis.x = this.x + x;\r\n\t}\r\n\tif (y !== undefined && y !== null) {\r\n\t\tthis.y = this.y + y;\r\n\t}\r\n};\r\n\r\nDocumentContext.prototype.beginDetachedBlock = function () {\r\n\tthis.snapshots.push({\r\n\t\tx: this.x,\r\n\t\ty: this.y,\r\n\t\tavailableHeight: this.availableHeight,\r\n\t\tavailableWidth: this.availableWidth,\r\n\t\tpage: this.page,\r\n\t\tlastColumnWidth: this.lastColumnWidth\r\n\t});\r\n};\r\n\r\nDocumentContext.prototype.endDetachedBlock = function () {\r\n\tvar saved = this.snapshots.pop();\r\n\r\n\tthis.x = saved.x;\r\n\tthis.y = saved.y;\r\n\tthis.availableWidth = saved.availableWidth;\r\n\tthis.availableHeight = saved.availableHeight;\r\n\tthis.page = saved.page;\r\n\tthis.lastColumnWidth = saved.lastColumnWidth;\r\n};\r\n\r\nfunction pageOrientation(pageOrientationString, currentPageOrientation) {\r\n\tif (pageOrientationString === undefined) {\r\n\t\treturn currentPageOrientation;\r\n\t} else if (isString(pageOrientationString) && (pageOrientationString.toLowerCase() === 'landscape')) {\r\n\t\treturn 'landscape';\r\n\t} else {\r\n\t\treturn 'portrait';\r\n\t}\r\n}\r\n\r\nvar getPageSize = function (currentPage, newPageOrientation) {\r\n\r\n\tnewPageOrientation = pageOrientation(newPageOrientation, currentPage.pageSize.orientation);\r\n\r\n\tif (newPageOrientation !== currentPage.pageSize.orientation) {\r\n\t\treturn {\r\n\t\t\torientation: newPageOrientation,\r\n\t\t\twidth: currentPage.pageSize.height,\r\n\t\t\theight: currentPage.pageSize.width\r\n\t\t};\r\n\t} else {\r\n\t\treturn {\r\n\t\t\torientation: currentPage.pageSize.orientation,\r\n\t\t\twidth: currentPage.pageSize.width,\r\n\t\t\theight: currentPage.pageSize.height\r\n\t\t};\r\n\t}\r\n\r\n};\r\n\r\n\r\nDocumentContext.prototype.moveToNextPage = function (pageOrientation) {\r\n\tvar nextPageIndex = this.page + 1;\r\n\r\n\tvar prevPage = this.page;\r\n\tvar prevY = this.y;\r\n\r\n\t// If we are in a column group\r\n\tif (this.snapshots.length > 0) {\r\n\t\tvar lastSnapshot = this.snapshots[this.snapshots.length - 1];\r\n\t\t// We have to update prevY accordingly by also taking into consideration\r\n\t\t// the 'y' of cells that don't break page\r\n\t\tif (lastSnapshot.bottomMost && lastSnapshot.bottomMost.y) {\r\n\t\t\tprevY = Math.max(this.y, lastSnapshot.bottomMost.y);\r\n\t\t}\r\n\t}\r\n\r\n\tvar createNewPage = nextPageIndex >= this.pages.length;\r\n\tif (createNewPage) {\r\n\t\tvar currentAvailableWidth = this.availableWidth;\r\n\t\tvar currentPageOrientation = this.getCurrentPage().pageSize.orientation;\r\n\r\n\t\tvar pageSize = getPageSize(this.getCurrentPage(), pageOrientation);\r\n\t\tthis.addPage(pageSize);\r\n\r\n\t\tif (currentPageOrientation === pageSize.orientation) {\r\n\t\t\tthis.availableWidth = currentAvailableWidth;\r\n\t\t}\r\n\t} else {\r\n\t\tthis.page = nextPageIndex;\r\n\t\tthis.initializePage();\r\n\t}\r\n\r\n\treturn {\r\n\t\tnewPageCreated: createNewPage,\r\n\t\tprevPage: prevPage,\r\n\t\tprevY: prevY,\r\n\t\ty: this.y\r\n\t};\r\n};\r\n\r\n\r\nDocumentContext.prototype.addPage = function (pageSize) {\r\n\tvar page = { items: [], pageSize: pageSize };\r\n\tthis.pages.push(page);\r\n\tthis.backgroundLength.push(0);\r\n\tthis.page = this.pages.length - 1;\r\n\tthis.initializePage();\r\n\r\n\tthis.tracker.emit('pageAdded');\r\n\r\n\treturn page;\r\n};\r\n\r\nDocumentContext.prototype.getCurrentPage = function () {\r\n\tif (this.page < 0 || this.page >= this.pages.length) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\treturn this.pages[this.page];\r\n};\r\n\r\nDocumentContext.prototype.getCurrentPosition = function () {\r\n\tvar pageSize = this.getCurrentPage().pageSize;\r\n\tvar innerHeight = pageSize.height - this.pageMargins.top - this.pageMargins.bottom;\r\n\tvar innerWidth = pageSize.width - this.pageMargins.left - this.pageMargins.right;\r\n\r\n\treturn {\r\n\t\tpageNumber: this.page + 1,\r\n\t\tpageOrientation: pageSize.orientation,\r\n\t\tpageInnerHeight: innerHeight,\r\n\t\tpageInnerWidth: innerWidth,\r\n\t\tleft: this.x,\r\n\t\ttop: this.y,\r\n\t\tverticalRatio: ((this.y - this.pageMargins.top) / innerHeight),\r\n\t\thorizontalRatio: ((this.x - this.pageMargins.left) / innerWidth)\r\n\t};\r\n};\r\n\r\nfunction bottomMostContext(c1, c2) {\r\n\tvar r;\r\n\r\n\tif (c1.page > c2.page) {\r\n\t\tr = c1;\r\n\t} else if (c2.page > c1.page) {\r\n\t\tr = c2;\r\n\t} else {\r\n\t\tr = (c1.y > c2.y) ? c1 : c2;\r\n\t}\r\n\r\n\treturn {\r\n\t\tpage: r.page,\r\n\t\tx: r.x,\r\n\t\ty: r.y,\r\n\t\tavailableHeight: r.availableHeight,\r\n\t\tavailableWidth: r.availableWidth\r\n\t};\r\n}\r\n\r\nmodule.exports = DocumentContext;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvZG9jdW1lbnRDb250ZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyxnRkFBb0I7QUFDbkQsZUFBZSw4RkFBNkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsc0JBQXNCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxHQUFHO0FBQ0gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvZ2FzY2F0L3ByaXNtYXF1YW50L3ByaXNtYS1xdWFudHVtL25vZGVfbW9kdWxlcy9wZGZtYWtlL3NyYy9kb2N1bWVudENvbnRleHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFRyYXZlcnNhbFRyYWNrZXIgPSByZXF1aXJlKCcuL3RyYXZlcnNhbFRyYWNrZXInKTtcclxudmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuaXNTdHJpbmc7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBEb2N1bWVudENvbnRleHQgLSBhIHN0b3JlIGZvciBjdXJyZW50IHgsIHkgcG9zaXRpb25zIGFuZCBhdmFpbGFibGUgd2lkdGgvaGVpZ2h0LlxyXG4gKiBJdCBmYWNpbGl0YXRlcyBjb2x1bW4gZGl2aXNpb25zIGFuZCB2ZXJ0aWNhbCBzeW5jXHJcbiAqL1xyXG5mdW5jdGlvbiBEb2N1bWVudENvbnRleHQocGFnZVNpemUsIHBhZ2VNYXJnaW5zKSB7XHJcblx0dGhpcy5wYWdlcyA9IFtdO1xyXG5cclxuXHR0aGlzLnBhZ2VNYXJnaW5zID0gcGFnZU1hcmdpbnM7XHJcblxyXG5cdHRoaXMueCA9IHBhZ2VNYXJnaW5zLmxlZnQ7XHJcblx0dGhpcy5hdmFpbGFibGVXaWR0aCA9IHBhZ2VTaXplLndpZHRoIC0gcGFnZU1hcmdpbnMubGVmdCAtIHBhZ2VNYXJnaW5zLnJpZ2h0O1xyXG5cdHRoaXMuYXZhaWxhYmxlSGVpZ2h0ID0gMDtcclxuXHR0aGlzLnBhZ2UgPSAtMTtcclxuXHJcblx0dGhpcy5zbmFwc2hvdHMgPSBbXTtcclxuXHJcblx0dGhpcy50cmFja2VyID0gbmV3IFRyYXZlcnNhbFRyYWNrZXIoKTtcclxuXHJcblx0dGhpcy5iYWNrZ3JvdW5kTGVuZ3RoID0gW107XHJcblxyXG5cdHRoaXMuYWRkUGFnZShwYWdlU2l6ZSk7XHJcbn1cclxuXHJcbkRvY3VtZW50Q29udGV4dC5wcm90b3R5cGUuYmVnaW5Db2x1bW5Hcm91cCA9IGZ1bmN0aW9uIChtYXJnaW5YVG9wUGFyZW50LCBib3R0b21CeVBhZ2UgPSB7fSkge1xyXG5cdHRoaXMuc25hcHNob3RzLnB1c2goe1xyXG5cdFx0eDogdGhpcy54LFxyXG5cdFx0eTogdGhpcy55LFxyXG5cdFx0YXZhaWxhYmxlSGVpZ2h0OiB0aGlzLmF2YWlsYWJsZUhlaWdodCxcclxuXHRcdGF2YWlsYWJsZVdpZHRoOiB0aGlzLmF2YWlsYWJsZVdpZHRoLFxyXG5cdFx0cGFnZTogdGhpcy5wYWdlLFxyXG5cdFx0Ym90dG9tQnlQYWdlOiBib3R0b21CeVBhZ2UgPyBib3R0b21CeVBhZ2UgOiB7fSxcclxuXHRcdGJvdHRvbU1vc3Q6IHtcclxuXHRcdFx0eDogdGhpcy54LFxyXG5cdFx0XHR5OiB0aGlzLnksXHJcblx0XHRcdGF2YWlsYWJsZUhlaWdodDogdGhpcy5hdmFpbGFibGVIZWlnaHQsXHJcblx0XHRcdGF2YWlsYWJsZVdpZHRoOiB0aGlzLmF2YWlsYWJsZVdpZHRoLFxyXG5cdFx0XHRwYWdlOiB0aGlzLnBhZ2VcclxuXHRcdH0sXHJcblx0XHRsYXN0Q29sdW1uV2lkdGg6IHRoaXMubGFzdENvbHVtbldpZHRoXHJcblx0fSk7XHJcblxyXG5cdHRoaXMubGFzdENvbHVtbldpZHRoID0gMDtcclxuXHRpZiAobWFyZ2luWFRvcFBhcmVudCkge1xyXG5cdFx0dGhpcy5tYXJnaW5YVG9wUGFyZW50ID0gbWFyZ2luWFRvcFBhcmVudDtcclxuXHR9XHJcbn07XHJcblxyXG5Eb2N1bWVudENvbnRleHQucHJvdG90eXBlLnVwZGF0ZUJvdHRvbUJ5UGFnZSA9IGZ1bmN0aW9uICgpIHtcclxuXHRjb25zdCBsYXN0U25hcHNob3QgPSB0aGlzLnNuYXBzaG90c1t0aGlzLnNuYXBzaG90cy5sZW5ndGggLSAxXTtcclxuXHRjb25zdCBsYXN0UGFnZSA9IHRoaXMucGFnZTtcclxuXHRsZXQgcHJldmlvdXNCb3R0b20gPSAtTnVtYmVyLk1JTl9WQUxVRTtcclxuXHRpZiAobGFzdFNuYXBzaG90LmJvdHRvbUJ5UGFnZVtsYXN0UGFnZV0pIHtcclxuXHRcdHByZXZpb3VzQm90dG9tID0gbGFzdFNuYXBzaG90LmJvdHRvbUJ5UGFnZVtsYXN0UGFnZV07XHJcblx0fVxyXG5cdGxhc3RTbmFwc2hvdC5ib3R0b21CeVBhZ2VbbGFzdFBhZ2VdID0gTWF0aC5tYXgocHJldmlvdXNCb3R0b20sIHRoaXMueSk7XHJcbn07XHJcblxyXG5Eb2N1bWVudENvbnRleHQucHJvdG90eXBlLnJlc2V0TWFyZ2luWFRvcFBhcmVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHR0aGlzLm1hcmdpblhUb3BQYXJlbnQgPSBudWxsO1xyXG59O1xyXG5cclxuRG9jdW1lbnRDb250ZXh0LnByb3RvdHlwZS5iZWdpbkNvbHVtbiA9IGZ1bmN0aW9uICh3aWR0aCwgb2Zmc2V0LCBlbmRpbmdDZWxsKSB7XHJcblx0dmFyIHNhdmVkID0gdGhpcy5zbmFwc2hvdHNbdGhpcy5zbmFwc2hvdHMubGVuZ3RoIC0gMV07XHJcblxyXG5cdHRoaXMuY2FsY3VsYXRlQm90dG9tTW9zdChzYXZlZCwgZW5kaW5nQ2VsbCk7XHJcblxyXG5cdHRoaXMucGFnZSA9IHNhdmVkLnBhZ2U7XHJcblx0dGhpcy54ID0gdGhpcy54ICsgdGhpcy5sYXN0Q29sdW1uV2lkdGggKyAob2Zmc2V0IHx8IDApO1xyXG5cdHRoaXMueSA9IHNhdmVkLnk7XHJcblx0dGhpcy5hdmFpbGFibGVXaWR0aCA9IHdpZHRoO1x0Ly9zYXZlZC5hdmFpbGFibGVXaWR0aCAtIG9mZnNldDtcclxuXHR0aGlzLmF2YWlsYWJsZUhlaWdodCA9IHNhdmVkLmF2YWlsYWJsZUhlaWdodDtcclxuXHJcblx0dGhpcy5sYXN0Q29sdW1uV2lkdGggPSB3aWR0aDtcclxufTtcclxuXHJcbkRvY3VtZW50Q29udGV4dC5wcm90b3R5cGUuY2FsY3VsYXRlQm90dG9tTW9zdCA9IGZ1bmN0aW9uIChkZXN0Q29udGV4dCwgZW5kaW5nQ2VsbCkge1xyXG5cdGlmIChlbmRpbmdDZWxsKSB7XHJcblx0XHR0aGlzLnNhdmVDb250ZXh0SW5FbmRpbmdDZWxsKGVuZGluZ0NlbGwpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRkZXN0Q29udGV4dC5ib3R0b21Nb3N0ID0gYm90dG9tTW9zdENvbnRleHQodGhpcywgZGVzdENvbnRleHQuYm90dG9tTW9zdCk7XHJcblx0fVxyXG59O1xyXG5cclxuRG9jdW1lbnRDb250ZXh0LnByb3RvdHlwZS5tYXJrRW5kaW5nID0gZnVuY3Rpb24gKGVuZGluZ0NlbGwsIG9yaWdpbmFsWE9mZnNldCwgZGlzY291bnRZKSB7XHJcblx0dGhpcy5wYWdlID0gZW5kaW5nQ2VsbC5fY29sdW1uRW5kaW5nQ29udGV4dC5wYWdlO1xyXG5cdHRoaXMueCA9IGVuZGluZ0NlbGwuX2NvbHVtbkVuZGluZ0NvbnRleHQueCArIG9yaWdpbmFsWE9mZnNldDtcclxuXHR0aGlzLnkgPSBlbmRpbmdDZWxsLl9jb2x1bW5FbmRpbmdDb250ZXh0LnkgLSBkaXNjb3VudFk7XHJcblx0dGhpcy5hdmFpbGFibGVXaWR0aCA9IGVuZGluZ0NlbGwuX2NvbHVtbkVuZGluZ0NvbnRleHQuYXZhaWxhYmxlV2lkdGg7XHJcblx0dGhpcy5hdmFpbGFibGVIZWlnaHQgPSBlbmRpbmdDZWxsLl9jb2x1bW5FbmRpbmdDb250ZXh0LmF2YWlsYWJsZUhlaWdodDtcclxuXHR0aGlzLmxhc3RDb2x1bW5XaWR0aCA9IGVuZGluZ0NlbGwuX2NvbHVtbkVuZGluZ0NvbnRleHQubGFzdENvbHVtbldpZHRoO1xyXG59O1xyXG5cclxuRG9jdW1lbnRDb250ZXh0LnByb3RvdHlwZS5zYXZlQ29udGV4dEluRW5kaW5nQ2VsbCA9IGZ1bmN0aW9uIChlbmRpbmdDZWxsKSB7XHJcblx0ZW5kaW5nQ2VsbC5fY29sdW1uRW5kaW5nQ29udGV4dCA9IHtcclxuXHRcdHBhZ2U6IHRoaXMucGFnZSxcclxuXHRcdHg6IHRoaXMueCxcclxuXHRcdHk6IHRoaXMueSxcclxuXHRcdGF2YWlsYWJsZUhlaWdodDogdGhpcy5hdmFpbGFibGVIZWlnaHQsXHJcblx0XHRhdmFpbGFibGVXaWR0aDogdGhpcy5hdmFpbGFibGVXaWR0aCxcclxuXHRcdGxhc3RDb2x1bW5XaWR0aDogdGhpcy5sYXN0Q29sdW1uV2lkdGhcclxuXHR9O1xyXG59O1xyXG5cclxuRG9jdW1lbnRDb250ZXh0LnByb3RvdHlwZS5jb21wbGV0ZUNvbHVtbkdyb3VwID0gZnVuY3Rpb24gKGhlaWdodCwgZW5kaW5nQ2VsbCkge1xyXG5cdHZhciBzYXZlZCA9IHRoaXMuc25hcHNob3RzLnBvcCgpO1xyXG5cclxuXHR0aGlzLmNhbGN1bGF0ZUJvdHRvbU1vc3Qoc2F2ZWQsIGVuZGluZ0NlbGwpO1xyXG5cclxuXHR0aGlzLnggPSBzYXZlZC54O1xyXG5cclxuXHR2YXIgeSA9IHNhdmVkLmJvdHRvbU1vc3QueTtcclxuXHRpZiAoaGVpZ2h0KSB7XHJcblx0XHRpZiAoc2F2ZWQucGFnZSA9PT0gc2F2ZWQuYm90dG9tTW9zdC5wYWdlKSB7XHJcblx0XHRcdGlmICgoc2F2ZWQueSArIGhlaWdodCkgPiB5KSB7XHJcblx0XHRcdFx0eSA9IHNhdmVkLnkgKyBoZWlnaHQ7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHkgKz0gaGVpZ2h0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dGhpcy55ID0geTtcclxuXHR0aGlzLnBhZ2UgPSBzYXZlZC5ib3R0b21Nb3N0LnBhZ2U7XHJcblx0dGhpcy5hdmFpbGFibGVXaWR0aCA9IHNhdmVkLmF2YWlsYWJsZVdpZHRoO1xyXG5cdHRoaXMuYXZhaWxhYmxlSGVpZ2h0ID0gc2F2ZWQuYm90dG9tTW9zdC5hdmFpbGFibGVIZWlnaHQ7XHJcblx0aWYgKGhlaWdodCkge1xyXG5cdFx0dGhpcy5hdmFpbGFibGVIZWlnaHQgLT0gKHkgLSBzYXZlZC5ib3R0b21Nb3N0LnkpO1xyXG5cdH1cclxuXHR0aGlzLmxhc3RDb2x1bW5XaWR0aCA9IHNhdmVkLmxhc3RDb2x1bW5XaWR0aDtcclxuXHRyZXR1cm4gc2F2ZWQuYm90dG9tQnlQYWdlO1xyXG59O1xyXG5cclxuRG9jdW1lbnRDb250ZXh0LnByb3RvdHlwZS5hZGRNYXJnaW4gPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcclxuXHR0aGlzLnggKz0gbGVmdDtcclxuXHR0aGlzLmF2YWlsYWJsZVdpZHRoIC09IGxlZnQgKyAocmlnaHQgfHwgMCk7XHJcbn07XHJcblxyXG5Eb2N1bWVudENvbnRleHQucHJvdG90eXBlLm1vdmVEb3duID0gZnVuY3Rpb24gKG9mZnNldCkge1xyXG5cdHRoaXMueSArPSBvZmZzZXQ7XHJcblx0dGhpcy5hdmFpbGFibGVIZWlnaHQgLT0gb2Zmc2V0O1xyXG5cclxuXHRyZXR1cm4gdGhpcy5hdmFpbGFibGVIZWlnaHQgPiAwO1xyXG59O1xyXG5cclxuRG9jdW1lbnRDb250ZXh0LnByb3RvdHlwZS5pbml0aWFsaXplUGFnZSA9IGZ1bmN0aW9uICgpIHtcclxuXHR0aGlzLnkgPSB0aGlzLnBhZ2VNYXJnaW5zLnRvcDtcclxuXHR0aGlzLmF2YWlsYWJsZUhlaWdodCA9IHRoaXMuZ2V0Q3VycmVudFBhZ2UoKS5wYWdlU2l6ZS5oZWlnaHQgLSB0aGlzLnBhZ2VNYXJnaW5zLnRvcCAtIHRoaXMucGFnZU1hcmdpbnMuYm90dG9tO1xyXG5cdGNvbnN0IHsgcGFnZUN0eCwgaXNTbmFwc2hvdCB9ID0gdGhpcy5wYWdlU25hcHNob3QoKTtcclxuXHRwYWdlQ3R4LmF2YWlsYWJsZVdpZHRoID0gdGhpcy5nZXRDdXJyZW50UGFnZSgpLnBhZ2VTaXplLndpZHRoIC0gdGhpcy5wYWdlTWFyZ2lucy5sZWZ0IC0gdGhpcy5wYWdlTWFyZ2lucy5yaWdodDtcclxuXHRpZiAoaXNTbmFwc2hvdCAmJiB0aGlzLm1hcmdpblhUb3BQYXJlbnQpIHtcclxuXHRcdHBhZ2VDdHguYXZhaWxhYmxlV2lkdGggLT0gdGhpcy5tYXJnaW5YVG9wUGFyZW50WzBdO1xyXG5cdFx0cGFnZUN0eC5hdmFpbGFibGVXaWR0aCAtPSB0aGlzLm1hcmdpblhUb3BQYXJlbnRbMV07XHJcblx0fVxyXG59O1xyXG5cclxuRG9jdW1lbnRDb250ZXh0LnByb3RvdHlwZS5wYWdlU25hcHNob3QgPSBmdW5jdGlvbiAoKSB7XHJcblx0aWYgKHRoaXMuc25hcHNob3RzWzBdKSB7XHJcblx0XHRyZXR1cm4geyBwYWdlQ3R4OiB0aGlzLnNuYXBzaG90c1swXSwgaXNTbmFwc2hvdDogdHJ1ZSB9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4geyBwYWdlQ3R4OiB0aGlzLCBpc1NuYXBzaG90OiBmYWxzZSB9O1xyXG5cdH1cclxufTtcclxuXHJcbkRvY3VtZW50Q29udGV4dC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcclxuXHRpZiAoeCAhPT0gdW5kZWZpbmVkICYmIHggIT09IG51bGwpIHtcclxuXHRcdHRoaXMueCA9IHg7XHJcblx0XHR0aGlzLmF2YWlsYWJsZVdpZHRoID0gdGhpcy5nZXRDdXJyZW50UGFnZSgpLnBhZ2VTaXplLndpZHRoIC0gdGhpcy54IC0gdGhpcy5wYWdlTWFyZ2lucy5yaWdodDtcclxuXHR9XHJcblx0aWYgKHkgIT09IHVuZGVmaW5lZCAmJiB5ICE9PSBudWxsKSB7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cdFx0dGhpcy5hdmFpbGFibGVIZWlnaHQgPSB0aGlzLmdldEN1cnJlbnRQYWdlKCkucGFnZVNpemUuaGVpZ2h0IC0gdGhpcy55IC0gdGhpcy5wYWdlTWFyZ2lucy5ib3R0b207XHJcblx0fVxyXG59O1xyXG5cclxuRG9jdW1lbnRDb250ZXh0LnByb3RvdHlwZS5tb3ZlVG9SZWxhdGl2ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XHJcblx0aWYgKHggIT09IHVuZGVmaW5lZCAmJiB4ICE9PSBudWxsKSB7XHJcblx0XHR0aGlzLnggPSB0aGlzLnggKyB4O1xyXG5cdH1cclxuXHRpZiAoeSAhPT0gdW5kZWZpbmVkICYmIHkgIT09IG51bGwpIHtcclxuXHRcdHRoaXMueSA9IHRoaXMueSArIHk7XHJcblx0fVxyXG59O1xyXG5cclxuRG9jdW1lbnRDb250ZXh0LnByb3RvdHlwZS5iZWdpbkRldGFjaGVkQmxvY2sgPSBmdW5jdGlvbiAoKSB7XHJcblx0dGhpcy5zbmFwc2hvdHMucHVzaCh7XHJcblx0XHR4OiB0aGlzLngsXHJcblx0XHR5OiB0aGlzLnksXHJcblx0XHRhdmFpbGFibGVIZWlnaHQ6IHRoaXMuYXZhaWxhYmxlSGVpZ2h0LFxyXG5cdFx0YXZhaWxhYmxlV2lkdGg6IHRoaXMuYXZhaWxhYmxlV2lkdGgsXHJcblx0XHRwYWdlOiB0aGlzLnBhZ2UsXHJcblx0XHRsYXN0Q29sdW1uV2lkdGg6IHRoaXMubGFzdENvbHVtbldpZHRoXHJcblx0fSk7XHJcbn07XHJcblxyXG5Eb2N1bWVudENvbnRleHQucHJvdG90eXBlLmVuZERldGFjaGVkQmxvY2sgPSBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHNhdmVkID0gdGhpcy5zbmFwc2hvdHMucG9wKCk7XHJcblxyXG5cdHRoaXMueCA9IHNhdmVkLng7XHJcblx0dGhpcy55ID0gc2F2ZWQueTtcclxuXHR0aGlzLmF2YWlsYWJsZVdpZHRoID0gc2F2ZWQuYXZhaWxhYmxlV2lkdGg7XHJcblx0dGhpcy5hdmFpbGFibGVIZWlnaHQgPSBzYXZlZC5hdmFpbGFibGVIZWlnaHQ7XHJcblx0dGhpcy5wYWdlID0gc2F2ZWQucGFnZTtcclxuXHR0aGlzLmxhc3RDb2x1bW5XaWR0aCA9IHNhdmVkLmxhc3RDb2x1bW5XaWR0aDtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHBhZ2VPcmllbnRhdGlvbihwYWdlT3JpZW50YXRpb25TdHJpbmcsIGN1cnJlbnRQYWdlT3JpZW50YXRpb24pIHtcclxuXHRpZiAocGFnZU9yaWVudGF0aW9uU3RyaW5nID09PSB1bmRlZmluZWQpIHtcclxuXHRcdHJldHVybiBjdXJyZW50UGFnZU9yaWVudGF0aW9uO1xyXG5cdH0gZWxzZSBpZiAoaXNTdHJpbmcocGFnZU9yaWVudGF0aW9uU3RyaW5nKSAmJiAocGFnZU9yaWVudGF0aW9uU3RyaW5nLnRvTG93ZXJDYXNlKCkgPT09ICdsYW5kc2NhcGUnKSkge1xyXG5cdFx0cmV0dXJuICdsYW5kc2NhcGUnO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gJ3BvcnRyYWl0JztcclxuXHR9XHJcbn1cclxuXHJcbnZhciBnZXRQYWdlU2l6ZSA9IGZ1bmN0aW9uIChjdXJyZW50UGFnZSwgbmV3UGFnZU9yaWVudGF0aW9uKSB7XHJcblxyXG5cdG5ld1BhZ2VPcmllbnRhdGlvbiA9IHBhZ2VPcmllbnRhdGlvbihuZXdQYWdlT3JpZW50YXRpb24sIGN1cnJlbnRQYWdlLnBhZ2VTaXplLm9yaWVudGF0aW9uKTtcclxuXHJcblx0aWYgKG5ld1BhZ2VPcmllbnRhdGlvbiAhPT0gY3VycmVudFBhZ2UucGFnZVNpemUub3JpZW50YXRpb24pIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdG9yaWVudGF0aW9uOiBuZXdQYWdlT3JpZW50YXRpb24sXHJcblx0XHRcdHdpZHRoOiBjdXJyZW50UGFnZS5wYWdlU2l6ZS5oZWlnaHQsXHJcblx0XHRcdGhlaWdodDogY3VycmVudFBhZ2UucGFnZVNpemUud2lkdGhcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdG9yaWVudGF0aW9uOiBjdXJyZW50UGFnZS5wYWdlU2l6ZS5vcmllbnRhdGlvbixcclxuXHRcdFx0d2lkdGg6IGN1cnJlbnRQYWdlLnBhZ2VTaXplLndpZHRoLFxyXG5cdFx0XHRoZWlnaHQ6IGN1cnJlbnRQYWdlLnBhZ2VTaXplLmhlaWdodFxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG59O1xyXG5cclxuXHJcbkRvY3VtZW50Q29udGV4dC5wcm90b3R5cGUubW92ZVRvTmV4dFBhZ2UgPSBmdW5jdGlvbiAocGFnZU9yaWVudGF0aW9uKSB7XHJcblx0dmFyIG5leHRQYWdlSW5kZXggPSB0aGlzLnBhZ2UgKyAxO1xyXG5cclxuXHR2YXIgcHJldlBhZ2UgPSB0aGlzLnBhZ2U7XHJcblx0dmFyIHByZXZZID0gdGhpcy55O1xyXG5cclxuXHQvLyBJZiB3ZSBhcmUgaW4gYSBjb2x1bW4gZ3JvdXBcclxuXHRpZiAodGhpcy5zbmFwc2hvdHMubGVuZ3RoID4gMCkge1xyXG5cdFx0dmFyIGxhc3RTbmFwc2hvdCA9IHRoaXMuc25hcHNob3RzW3RoaXMuc25hcHNob3RzLmxlbmd0aCAtIDFdO1xyXG5cdFx0Ly8gV2UgaGF2ZSB0byB1cGRhdGUgcHJldlkgYWNjb3JkaW5nbHkgYnkgYWxzbyB0YWtpbmcgaW50byBjb25zaWRlcmF0aW9uXHJcblx0XHQvLyB0aGUgJ3knIG9mIGNlbGxzIHRoYXQgZG9uJ3QgYnJlYWsgcGFnZVxyXG5cdFx0aWYgKGxhc3RTbmFwc2hvdC5ib3R0b21Nb3N0ICYmIGxhc3RTbmFwc2hvdC5ib3R0b21Nb3N0LnkpIHtcclxuXHRcdFx0cHJldlkgPSBNYXRoLm1heCh0aGlzLnksIGxhc3RTbmFwc2hvdC5ib3R0b21Nb3N0LnkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dmFyIGNyZWF0ZU5ld1BhZ2UgPSBuZXh0UGFnZUluZGV4ID49IHRoaXMucGFnZXMubGVuZ3RoO1xyXG5cdGlmIChjcmVhdGVOZXdQYWdlKSB7XHJcblx0XHR2YXIgY3VycmVudEF2YWlsYWJsZVdpZHRoID0gdGhpcy5hdmFpbGFibGVXaWR0aDtcclxuXHRcdHZhciBjdXJyZW50UGFnZU9yaWVudGF0aW9uID0gdGhpcy5nZXRDdXJyZW50UGFnZSgpLnBhZ2VTaXplLm9yaWVudGF0aW9uO1xyXG5cclxuXHRcdHZhciBwYWdlU2l6ZSA9IGdldFBhZ2VTaXplKHRoaXMuZ2V0Q3VycmVudFBhZ2UoKSwgcGFnZU9yaWVudGF0aW9uKTtcclxuXHRcdHRoaXMuYWRkUGFnZShwYWdlU2l6ZSk7XHJcblxyXG5cdFx0aWYgKGN1cnJlbnRQYWdlT3JpZW50YXRpb24gPT09IHBhZ2VTaXplLm9yaWVudGF0aW9uKSB7XHJcblx0XHRcdHRoaXMuYXZhaWxhYmxlV2lkdGggPSBjdXJyZW50QXZhaWxhYmxlV2lkdGg7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdHRoaXMucGFnZSA9IG5leHRQYWdlSW5kZXg7XHJcblx0XHR0aGlzLmluaXRpYWxpemVQYWdlKCk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0bmV3UGFnZUNyZWF0ZWQ6IGNyZWF0ZU5ld1BhZ2UsXHJcblx0XHRwcmV2UGFnZTogcHJldlBhZ2UsXHJcblx0XHRwcmV2WTogcHJldlksXHJcblx0XHR5OiB0aGlzLnlcclxuXHR9O1xyXG59O1xyXG5cclxuXHJcbkRvY3VtZW50Q29udGV4dC5wcm90b3R5cGUuYWRkUGFnZSA9IGZ1bmN0aW9uIChwYWdlU2l6ZSkge1xyXG5cdHZhciBwYWdlID0geyBpdGVtczogW10sIHBhZ2VTaXplOiBwYWdlU2l6ZSB9O1xyXG5cdHRoaXMucGFnZXMucHVzaChwYWdlKTtcclxuXHR0aGlzLmJhY2tncm91bmRMZW5ndGgucHVzaCgwKTtcclxuXHR0aGlzLnBhZ2UgPSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDE7XHJcblx0dGhpcy5pbml0aWFsaXplUGFnZSgpO1xyXG5cclxuXHR0aGlzLnRyYWNrZXIuZW1pdCgncGFnZUFkZGVkJyk7XHJcblxyXG5cdHJldHVybiBwYWdlO1xyXG59O1xyXG5cclxuRG9jdW1lbnRDb250ZXh0LnByb3RvdHlwZS5nZXRDdXJyZW50UGFnZSA9IGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5wYWdlIDwgMCB8fCB0aGlzLnBhZ2UgPj0gdGhpcy5wYWdlcy5sZW5ndGgpIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXMucGFnZXNbdGhpcy5wYWdlXTtcclxufTtcclxuXHJcbkRvY3VtZW50Q29udGV4dC5wcm90b3R5cGUuZ2V0Q3VycmVudFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdHZhciBwYWdlU2l6ZSA9IHRoaXMuZ2V0Q3VycmVudFBhZ2UoKS5wYWdlU2l6ZTtcclxuXHR2YXIgaW5uZXJIZWlnaHQgPSBwYWdlU2l6ZS5oZWlnaHQgLSB0aGlzLnBhZ2VNYXJnaW5zLnRvcCAtIHRoaXMucGFnZU1hcmdpbnMuYm90dG9tO1xyXG5cdHZhciBpbm5lcldpZHRoID0gcGFnZVNpemUud2lkdGggLSB0aGlzLnBhZ2VNYXJnaW5zLmxlZnQgLSB0aGlzLnBhZ2VNYXJnaW5zLnJpZ2h0O1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0cGFnZU51bWJlcjogdGhpcy5wYWdlICsgMSxcclxuXHRcdHBhZ2VPcmllbnRhdGlvbjogcGFnZVNpemUub3JpZW50YXRpb24sXHJcblx0XHRwYWdlSW5uZXJIZWlnaHQ6IGlubmVySGVpZ2h0LFxyXG5cdFx0cGFnZUlubmVyV2lkdGg6IGlubmVyV2lkdGgsXHJcblx0XHRsZWZ0OiB0aGlzLngsXHJcblx0XHR0b3A6IHRoaXMueSxcclxuXHRcdHZlcnRpY2FsUmF0aW86ICgodGhpcy55IC0gdGhpcy5wYWdlTWFyZ2lucy50b3ApIC8gaW5uZXJIZWlnaHQpLFxyXG5cdFx0aG9yaXpvbnRhbFJhdGlvOiAoKHRoaXMueCAtIHRoaXMucGFnZU1hcmdpbnMubGVmdCkgLyBpbm5lcldpZHRoKVxyXG5cdH07XHJcbn07XHJcblxyXG5mdW5jdGlvbiBib3R0b21Nb3N0Q29udGV4dChjMSwgYzIpIHtcclxuXHR2YXIgcjtcclxuXHJcblx0aWYgKGMxLnBhZ2UgPiBjMi5wYWdlKSB7XHJcblx0XHRyID0gYzE7XHJcblx0fSBlbHNlIGlmIChjMi5wYWdlID4gYzEucGFnZSkge1xyXG5cdFx0ciA9IGMyO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyID0gKGMxLnkgPiBjMi55KSA/IGMxIDogYzI7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0cGFnZTogci5wYWdlLFxyXG5cdFx0eDogci54LFxyXG5cdFx0eTogci55LFxyXG5cdFx0YXZhaWxhYmxlSGVpZ2h0OiByLmF2YWlsYWJsZUhlaWdodCxcclxuXHRcdGF2YWlsYWJsZVdpZHRoOiByLmF2YWlsYWJsZVdpZHRoXHJcblx0fTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBEb2N1bWVudENvbnRleHQ7XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/documentContext.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/elementWriter.js":
/*!***************************************************!*\
  !*** ./node_modules/pdfmake/src/elementWriter.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar Line = __webpack_require__(/*! ./line */ \"(rsc)/./node_modules/pdfmake/src/line.js\");\r\nvar isNumber = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isNumber);\r\nvar pack = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").pack);\r\nvar offsetVector = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").offsetVector);\r\nvar DocumentContext = __webpack_require__(/*! ./documentContext */ \"(rsc)/./node_modules/pdfmake/src/documentContext.js\");\r\n\r\n/**\r\n * Creates an instance of ElementWriter - a line/vector writer, which adds\r\n * elements to current page and sets their positions based on the context\r\n */\r\nfunction ElementWriter(context, tracker) {\r\n\tthis.context = context;\r\n\tthis.contextStack = [];\r\n\tthis.tracker = tracker;\r\n}\r\n\r\nfunction addPageItem(page, item, index) {\r\n\tif (index === null || index === undefined || index < 0 || index > page.items.length) {\r\n\t\tpage.items.push(item);\r\n\t} else {\r\n\t\tpage.items.splice(index, 0, item);\r\n\t}\r\n}\r\n\r\nElementWriter.prototype.addLine = function (line, dontUpdateContextPosition, index) {\r\n\tvar height = line.getHeight();\r\n\tvar context = this.context;\r\n\tvar page = context.getCurrentPage(),\r\n\t\tposition = this.getCurrentPositionOnPage();\r\n\r\n\tif (context.availableHeight < height || !page) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tline.x = context.x + (line.x || 0);\r\n\tline.y = context.y + (line.y || 0);\r\n\r\n\tthis.alignLine(line);\r\n\r\n\taddPageItem(page, {\r\n\t\ttype: 'line',\r\n\t\titem: line\r\n\t}, index);\r\n\tthis.tracker.emit('lineAdded', line);\r\n\r\n\tif (!dontUpdateContextPosition) {\r\n\t\tcontext.moveDown(height);\r\n\t}\r\n\r\n\treturn position;\r\n};\r\n\r\nElementWriter.prototype.alignLine = function (line) {\r\n\tvar width = this.context.availableWidth;\r\n\tvar lineWidth = line.getWidth();\r\n\r\n\tvar alignment = line.inlines && line.inlines.length > 0 && line.inlines[0].alignment;\r\n\r\n\tvar offset = 0;\r\n\tswitch (alignment) {\r\n\t\tcase 'right':\r\n\t\t\toffset = width - lineWidth;\r\n\t\t\tbreak;\r\n\t\tcase 'center':\r\n\t\t\toffset = (width - lineWidth) / 2;\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\tif (offset) {\r\n\t\tline.x = (line.x || 0) + offset;\r\n\t}\r\n\r\n\tif (alignment === 'justify' &&\r\n\t\t!line.newLineForced &&\r\n\t\t!line.lastLineInParagraph &&\r\n\t\tline.inlines.length > 1) {\r\n\t\tvar additionalSpacing = (width - lineWidth) / (line.inlines.length - 1);\r\n\r\n\t\tfor (var i = 1, l = line.inlines.length; i < l; i++) {\r\n\t\t\toffset = i * additionalSpacing;\r\n\r\n\t\t\tline.inlines[i].x += offset;\r\n\t\t\tline.inlines[i].justifyShift = additionalSpacing;\r\n\t\t}\r\n\t}\r\n};\r\n\r\nElementWriter.prototype.addImage = function (image, index, type) {\r\n\tvar context = this.context;\r\n\tvar page = context.getCurrentPage(),\r\n\t\tposition = this.getCurrentPositionOnPage();\r\n\r\n\tif (!page || (image.absolutePosition === undefined && context.availableHeight < image._height && page.items.length > 0)) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (image._x === undefined) {\r\n\t\timage._x = image.x || 0;\r\n\t}\r\n\r\n\timage.x = context.x + image._x;\r\n\timage.y = context.y;\r\n\r\n\tthis.alignImage(image);\r\n\r\n\taddPageItem(page, {\r\n\t\ttype: type || 'image',\r\n\t\titem: image\r\n\t}, index);\r\n\r\n\tcontext.moveDown(image._height);\r\n\r\n\treturn position;\r\n};\r\n\r\nElementWriter.prototype.addSVG = function (image, index) {\r\n\treturn this.addImage(image, index, 'svg');\r\n};\r\n\r\nElementWriter.prototype.addQr = function (qr, index) {\r\n\tvar context = this.context;\r\n\tvar page = context.getCurrentPage(),\r\n\t\tposition = this.getCurrentPositionOnPage();\r\n\r\n\tif (!page || (qr.absolutePosition === undefined && context.availableHeight < qr._height)) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (qr._x === undefined) {\r\n\t\tqr._x = qr.x || 0;\r\n\t}\r\n\r\n\tqr.x = context.x + qr._x;\r\n\tqr.y = context.y;\r\n\r\n\tthis.alignImage(qr);\r\n\r\n\tfor (var i = 0, l = qr._canvas.length; i < l; i++) {\r\n\t\tvar vector = qr._canvas[i];\r\n\t\tvector.x += qr.x;\r\n\t\tvector.y += qr.y;\r\n\t\tthis.addVector(vector, true, true, index);\r\n\t}\r\n\r\n\tcontext.moveDown(qr._height);\r\n\r\n\treturn position;\r\n};\r\n\r\nElementWriter.prototype.alignImage = function (image) {\r\n\tvar width = this.context.availableWidth;\r\n\tvar imageWidth = image._minWidth;\r\n\tvar offset = 0;\r\n\tswitch (image._alignment) {\r\n\t\tcase 'right':\r\n\t\t\toffset = width - imageWidth;\r\n\t\t\tbreak;\r\n\t\tcase 'center':\r\n\t\t\toffset = (width - imageWidth) / 2;\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\tif (offset) {\r\n\t\timage.x = (image.x || 0) + offset;\r\n\t}\r\n};\r\n\r\nElementWriter.prototype.alignCanvas = function (node) {\r\n\tvar width = this.context.availableWidth;\r\n\tvar canvasWidth = node._minWidth;\r\n\tvar offset = 0;\r\n\tswitch (node._alignment) {\r\n\t\tcase 'right':\r\n\t\t\toffset = width - canvasWidth;\r\n\t\t\tbreak;\r\n\t\tcase 'center':\r\n\t\t\toffset = (width - canvasWidth) / 2;\r\n\t\t\tbreak;\r\n\t}\r\n\tif (offset) {\r\n\t\tnode.canvas.forEach(function (vector) {\r\n\t\t\toffsetVector(vector, offset, 0);\r\n\t\t});\r\n\t}\r\n};\r\n\r\nElementWriter.prototype.addVector = function (vector, ignoreContextX, ignoreContextY, index, forcePage) {\r\n\tvar context = this.context;\r\n\tvar page = context.getCurrentPage();\r\n\tif (isNumber(forcePage)) {\r\n\t\tpage = context.pages[forcePage];\r\n\t}\r\n\tvar position = this.getCurrentPositionOnPage();\r\n\r\n\tif (page) {\r\n\t\toffsetVector(vector, ignoreContextX ? 0 : context.x, ignoreContextY ? 0 : context.y);\r\n\t\taddPageItem(page, {\r\n\t\t\ttype: 'vector',\r\n\t\t\titem: vector\r\n\t\t}, index);\r\n\t\treturn position;\r\n\t}\r\n};\r\n\r\nElementWriter.prototype.beginClip = function (width, height) {\r\n\tvar ctx = this.context;\r\n\tvar page = ctx.getCurrentPage();\r\n\tpage.items.push({\r\n\t\ttype: 'beginClip',\r\n\t\titem: { x: ctx.x, y: ctx.y, width: width, height: height }\r\n\t});\r\n\treturn true;\r\n};\r\n\r\nElementWriter.prototype.endClip = function () {\r\n\tvar ctx = this.context;\r\n\tvar page = ctx.getCurrentPage();\r\n\tpage.items.push({\r\n\t\ttype: 'endClip'\r\n\t});\r\n\treturn true;\r\n};\r\n\r\nfunction cloneLine(line) {\r\n\tvar result = new Line(line.maxWidth);\r\n\r\n\tfor (var key in line) {\r\n\t\tif (line.hasOwnProperty(key)) {\r\n\t\t\tresult[key] = line[key];\r\n\t\t}\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nElementWriter.prototype.addFragment = function (block, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition) {\r\n\tvar ctx = this.context;\r\n\tvar page = ctx.getCurrentPage();\r\n\r\n\tif (!useBlockXOffset && block.height > ctx.availableHeight) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tblock.items.forEach(function (item) {\r\n\t\tswitch (item.type) {\r\n\t\t\tcase 'line':\r\n\t\t\t\tvar l = cloneLine(item.item);\r\n\r\n\t\t\t\tif (l._node) {\r\n\t\t\t\t\tl._node.positions[0].pageNumber = ctx.page + 1;\r\n\t\t\t\t}\r\n\t\t\t\tl.x = (l.x || 0) + (useBlockXOffset ? (block.xOffset || 0) : ctx.x);\r\n\t\t\t\tl.y = (l.y || 0) + (useBlockYOffset ? (block.yOffset || 0) : ctx.y);\r\n\r\n\t\t\t\tpage.items.push({\r\n\t\t\t\t\ttype: 'line',\r\n\t\t\t\t\titem: l\r\n\t\t\t\t});\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'vector':\r\n\t\t\t\tvar v = pack(item.item);\r\n\r\n\t\t\t\toffsetVector(v, useBlockXOffset ? (block.xOffset || 0) : ctx.x, useBlockYOffset ? (block.yOffset || 0) : ctx.y);\r\n\t\t\t\tif (v._isFillColorFromUnbreakable) {\r\n\t\t\t\t\t// If the item is a fillColor from an unbreakable block\r\n\t\t\t\t\t// We have to add it at the beginning of the items body array of the page\r\n\t\t\t\t\tdelete v._isFillColorFromUnbreakable;\r\n\t\t\t\t\tconst endOfBackgroundItemsIndex = ctx.backgroundLength[ctx.page];\r\n\t\t\t\t\tpage.items.splice(endOfBackgroundItemsIndex, 0, {\r\n\t\t\t\t\t\ttype: 'vector',\r\n\t\t\t\t\t\titem: v\r\n\t\t\t\t\t});\r\n\t\t\t\t} else {\r\n\t\t\t\t\tpage.items.push({\r\n\t\t\t\t\t\ttype: 'vector',\r\n\t\t\t\t\t\titem: v\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'image':\r\n\t\t\tcase 'svg':\r\n\t\t\t\tvar img = pack(item.item);\r\n\r\n\t\t\t\timg.x = (img.x || 0) + (useBlockXOffset ? (block.xOffset || 0) : ctx.x);\r\n\t\t\t\timg.y = (img.y || 0) + (useBlockYOffset ? (block.yOffset || 0) : ctx.y);\r\n\r\n\t\t\t\tpage.items.push({\r\n\t\t\t\t\ttype: item.type,\r\n\t\t\t\t\titem: img\r\n\t\t\t\t});\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t});\r\n\r\n\tif (!dontUpdateContextPosition) {\r\n\t\tctx.moveDown(block.height);\r\n\t}\r\n\r\n\treturn true;\r\n};\r\n\r\n/**\r\n * Pushes the provided context onto the stack or creates a new one\r\n *\r\n * pushContext(context) - pushes the provided context and makes it current\r\n * pushContext(width, height) - creates and pushes a new context with the specified width and height\r\n * pushContext() - creates a new context for unbreakable blocks (with current availableWidth and full-page-height)\r\n */\r\nElementWriter.prototype.pushContext = function (contextOrWidth, height) {\r\n\tif (contextOrWidth === undefined) {\r\n\t\theight = this.context.getCurrentPage().height - this.context.pageMargins.top - this.context.pageMargins.bottom;\r\n\t\tcontextOrWidth = this.context.availableWidth;\r\n\t}\r\n\r\n\tif (isNumber(contextOrWidth)) {\r\n\t\tcontextOrWidth = new DocumentContext({ width: contextOrWidth, height: height }, { left: 0, right: 0, top: 0, bottom: 0 });\r\n\t}\r\n\r\n\tthis.contextStack.push(this.context);\r\n\tthis.context = contextOrWidth;\r\n};\r\n\r\nElementWriter.prototype.popContext = function () {\r\n\tthis.context = this.contextStack.pop();\r\n};\r\n\r\nElementWriter.prototype.getCurrentPositionOnPage = function () {\r\n\treturn (this.contextStack[0] || this.context).getCurrentPosition();\r\n};\r\n\r\n\r\nmodule.exports = ElementWriter;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvZWxlbWVudFdyaXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHdEQUFRO0FBQzNCLGVBQWUsOEZBQTZCO0FBQzVDLFdBQVcsMEZBQXlCO0FBQ3BDLG1CQUFtQixrR0FBaUM7QUFDcEQsc0JBQXNCLG1CQUFPLENBQUMsOEVBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx1Q0FBdUMsSUFBSSxzQ0FBc0M7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2dhc2NhdC9wcmlzbWFxdWFudC9wcmlzbWEtcXVhbnR1bS9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvZWxlbWVudFdyaXRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgTGluZSA9IHJlcXVpcmUoJy4vbGluZScpO1xyXG52YXIgaXNOdW1iZXIgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc051bWJlcjtcclxudmFyIHBhY2sgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5wYWNrO1xyXG52YXIgb2Zmc2V0VmVjdG9yID0gcmVxdWlyZSgnLi9oZWxwZXJzJykub2Zmc2V0VmVjdG9yO1xyXG52YXIgRG9jdW1lbnRDb250ZXh0ID0gcmVxdWlyZSgnLi9kb2N1bWVudENvbnRleHQnKTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEVsZW1lbnRXcml0ZXIgLSBhIGxpbmUvdmVjdG9yIHdyaXRlciwgd2hpY2ggYWRkc1xyXG4gKiBlbGVtZW50cyB0byBjdXJyZW50IHBhZ2UgYW5kIHNldHMgdGhlaXIgcG9zaXRpb25zIGJhc2VkIG9uIHRoZSBjb250ZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBFbGVtZW50V3JpdGVyKGNvbnRleHQsIHRyYWNrZXIpIHtcclxuXHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG5cdHRoaXMuY29udGV4dFN0YWNrID0gW107XHJcblx0dGhpcy50cmFja2VyID0gdHJhY2tlcjtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkUGFnZUl0ZW0ocGFnZSwgaXRlbSwgaW5kZXgpIHtcclxuXHRpZiAoaW5kZXggPT09IG51bGwgfHwgaW5kZXggPT09IHVuZGVmaW5lZCB8fCBpbmRleCA8IDAgfHwgaW5kZXggPiBwYWdlLml0ZW1zLmxlbmd0aCkge1xyXG5cdFx0cGFnZS5pdGVtcy5wdXNoKGl0ZW0pO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRwYWdlLml0ZW1zLnNwbGljZShpbmRleCwgMCwgaXRlbSk7XHJcblx0fVxyXG59XHJcblxyXG5FbGVtZW50V3JpdGVyLnByb3RvdHlwZS5hZGRMaW5lID0gZnVuY3Rpb24gKGxpbmUsIGRvbnRVcGRhdGVDb250ZXh0UG9zaXRpb24sIGluZGV4KSB7XHJcblx0dmFyIGhlaWdodCA9IGxpbmUuZ2V0SGVpZ2h0KCk7XHJcblx0dmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcblx0dmFyIHBhZ2UgPSBjb250ZXh0LmdldEN1cnJlbnRQYWdlKCksXHJcblx0XHRwb3NpdGlvbiA9IHRoaXMuZ2V0Q3VycmVudFBvc2l0aW9uT25QYWdlKCk7XHJcblxyXG5cdGlmIChjb250ZXh0LmF2YWlsYWJsZUhlaWdodCA8IGhlaWdodCB8fCAhcGFnZSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0bGluZS54ID0gY29udGV4dC54ICsgKGxpbmUueCB8fCAwKTtcclxuXHRsaW5lLnkgPSBjb250ZXh0LnkgKyAobGluZS55IHx8IDApO1xyXG5cclxuXHR0aGlzLmFsaWduTGluZShsaW5lKTtcclxuXHJcblx0YWRkUGFnZUl0ZW0ocGFnZSwge1xyXG5cdFx0dHlwZTogJ2xpbmUnLFxyXG5cdFx0aXRlbTogbGluZVxyXG5cdH0sIGluZGV4KTtcclxuXHR0aGlzLnRyYWNrZXIuZW1pdCgnbGluZUFkZGVkJywgbGluZSk7XHJcblxyXG5cdGlmICghZG9udFVwZGF0ZUNvbnRleHRQb3NpdGlvbikge1xyXG5cdFx0Y29udGV4dC5tb3ZlRG93bihoZWlnaHQpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBvc2l0aW9uO1xyXG59O1xyXG5cclxuRWxlbWVudFdyaXRlci5wcm90b3R5cGUuYWxpZ25MaW5lID0gZnVuY3Rpb24gKGxpbmUpIHtcclxuXHR2YXIgd2lkdGggPSB0aGlzLmNvbnRleHQuYXZhaWxhYmxlV2lkdGg7XHJcblx0dmFyIGxpbmVXaWR0aCA9IGxpbmUuZ2V0V2lkdGgoKTtcclxuXHJcblx0dmFyIGFsaWdubWVudCA9IGxpbmUuaW5saW5lcyAmJiBsaW5lLmlubGluZXMubGVuZ3RoID4gMCAmJiBsaW5lLmlubGluZXNbMF0uYWxpZ25tZW50O1xyXG5cclxuXHR2YXIgb2Zmc2V0ID0gMDtcclxuXHRzd2l0Y2ggKGFsaWdubWVudCkge1xyXG5cdFx0Y2FzZSAncmlnaHQnOlxyXG5cdFx0XHRvZmZzZXQgPSB3aWR0aCAtIGxpbmVXaWR0aDtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlICdjZW50ZXInOlxyXG5cdFx0XHRvZmZzZXQgPSAod2lkdGggLSBsaW5lV2lkdGgpIC8gMjtcclxuXHRcdFx0YnJlYWs7XHJcblx0fVxyXG5cclxuXHRpZiAob2Zmc2V0KSB7XHJcblx0XHRsaW5lLnggPSAobGluZS54IHx8IDApICsgb2Zmc2V0O1xyXG5cdH1cclxuXHJcblx0aWYgKGFsaWdubWVudCA9PT0gJ2p1c3RpZnknICYmXHJcblx0XHQhbGluZS5uZXdMaW5lRm9yY2VkICYmXHJcblx0XHQhbGluZS5sYXN0TGluZUluUGFyYWdyYXBoICYmXHJcblx0XHRsaW5lLmlubGluZXMubGVuZ3RoID4gMSkge1xyXG5cdFx0dmFyIGFkZGl0aW9uYWxTcGFjaW5nID0gKHdpZHRoIC0gbGluZVdpZHRoKSAvIChsaW5lLmlubGluZXMubGVuZ3RoIC0gMSk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBsaW5lLmlubGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRcdG9mZnNldCA9IGkgKiBhZGRpdGlvbmFsU3BhY2luZztcclxuXHJcblx0XHRcdGxpbmUuaW5saW5lc1tpXS54ICs9IG9mZnNldDtcclxuXHRcdFx0bGluZS5pbmxpbmVzW2ldLmp1c3RpZnlTaGlmdCA9IGFkZGl0aW9uYWxTcGFjaW5nO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbkVsZW1lbnRXcml0ZXIucHJvdG90eXBlLmFkZEltYWdlID0gZnVuY3Rpb24gKGltYWdlLCBpbmRleCwgdHlwZSkge1xyXG5cdHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG5cdHZhciBwYWdlID0gY29udGV4dC5nZXRDdXJyZW50UGFnZSgpLFxyXG5cdFx0cG9zaXRpb24gPSB0aGlzLmdldEN1cnJlbnRQb3NpdGlvbk9uUGFnZSgpO1xyXG5cclxuXHRpZiAoIXBhZ2UgfHwgKGltYWdlLmFic29sdXRlUG9zaXRpb24gPT09IHVuZGVmaW5lZCAmJiBjb250ZXh0LmF2YWlsYWJsZUhlaWdodCA8IGltYWdlLl9oZWlnaHQgJiYgcGFnZS5pdGVtcy5sZW5ndGggPiAwKSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0aWYgKGltYWdlLl94ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdGltYWdlLl94ID0gaW1hZ2UueCB8fCAwO1xyXG5cdH1cclxuXHJcblx0aW1hZ2UueCA9IGNvbnRleHQueCArIGltYWdlLl94O1xyXG5cdGltYWdlLnkgPSBjb250ZXh0Lnk7XHJcblxyXG5cdHRoaXMuYWxpZ25JbWFnZShpbWFnZSk7XHJcblxyXG5cdGFkZFBhZ2VJdGVtKHBhZ2UsIHtcclxuXHRcdHR5cGU6IHR5cGUgfHwgJ2ltYWdlJyxcclxuXHRcdGl0ZW06IGltYWdlXHJcblx0fSwgaW5kZXgpO1xyXG5cclxuXHRjb250ZXh0Lm1vdmVEb3duKGltYWdlLl9oZWlnaHQpO1xyXG5cclxuXHRyZXR1cm4gcG9zaXRpb247XHJcbn07XHJcblxyXG5FbGVtZW50V3JpdGVyLnByb3RvdHlwZS5hZGRTVkcgPSBmdW5jdGlvbiAoaW1hZ2UsIGluZGV4KSB7XHJcblx0cmV0dXJuIHRoaXMuYWRkSW1hZ2UoaW1hZ2UsIGluZGV4LCAnc3ZnJyk7XHJcbn07XHJcblxyXG5FbGVtZW50V3JpdGVyLnByb3RvdHlwZS5hZGRRciA9IGZ1bmN0aW9uIChxciwgaW5kZXgpIHtcclxuXHR2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuXHR2YXIgcGFnZSA9IGNvbnRleHQuZ2V0Q3VycmVudFBhZ2UoKSxcclxuXHRcdHBvc2l0aW9uID0gdGhpcy5nZXRDdXJyZW50UG9zaXRpb25PblBhZ2UoKTtcclxuXHJcblx0aWYgKCFwYWdlIHx8IChxci5hYnNvbHV0ZVBvc2l0aW9uID09PSB1bmRlZmluZWQgJiYgY29udGV4dC5hdmFpbGFibGVIZWlnaHQgPCBxci5faGVpZ2h0KSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0aWYgKHFyLl94ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdHFyLl94ID0gcXIueCB8fCAwO1xyXG5cdH1cclxuXHJcblx0cXIueCA9IGNvbnRleHQueCArIHFyLl94O1xyXG5cdHFyLnkgPSBjb250ZXh0Lnk7XHJcblxyXG5cdHRoaXMuYWxpZ25JbWFnZShxcik7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsID0gcXIuX2NhbnZhcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdHZhciB2ZWN0b3IgPSBxci5fY2FudmFzW2ldO1xyXG5cdFx0dmVjdG9yLnggKz0gcXIueDtcclxuXHRcdHZlY3Rvci55ICs9IHFyLnk7XHJcblx0XHR0aGlzLmFkZFZlY3Rvcih2ZWN0b3IsIHRydWUsIHRydWUsIGluZGV4KTtcclxuXHR9XHJcblxyXG5cdGNvbnRleHQubW92ZURvd24ocXIuX2hlaWdodCk7XHJcblxyXG5cdHJldHVybiBwb3NpdGlvbjtcclxufTtcclxuXHJcbkVsZW1lbnRXcml0ZXIucHJvdG90eXBlLmFsaWduSW1hZ2UgPSBmdW5jdGlvbiAoaW1hZ2UpIHtcclxuXHR2YXIgd2lkdGggPSB0aGlzLmNvbnRleHQuYXZhaWxhYmxlV2lkdGg7XHJcblx0dmFyIGltYWdlV2lkdGggPSBpbWFnZS5fbWluV2lkdGg7XHJcblx0dmFyIG9mZnNldCA9IDA7XHJcblx0c3dpdGNoIChpbWFnZS5fYWxpZ25tZW50KSB7XHJcblx0XHRjYXNlICdyaWdodCc6XHJcblx0XHRcdG9mZnNldCA9IHdpZHRoIC0gaW1hZ2VXaWR0aDtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlICdjZW50ZXInOlxyXG5cdFx0XHRvZmZzZXQgPSAod2lkdGggLSBpbWFnZVdpZHRoKSAvIDI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdH1cclxuXHJcblx0aWYgKG9mZnNldCkge1xyXG5cdFx0aW1hZ2UueCA9IChpbWFnZS54IHx8IDApICsgb2Zmc2V0O1xyXG5cdH1cclxufTtcclxuXHJcbkVsZW1lbnRXcml0ZXIucHJvdG90eXBlLmFsaWduQ2FudmFzID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuXHR2YXIgd2lkdGggPSB0aGlzLmNvbnRleHQuYXZhaWxhYmxlV2lkdGg7XHJcblx0dmFyIGNhbnZhc1dpZHRoID0gbm9kZS5fbWluV2lkdGg7XHJcblx0dmFyIG9mZnNldCA9IDA7XHJcblx0c3dpdGNoIChub2RlLl9hbGlnbm1lbnQpIHtcclxuXHRcdGNhc2UgJ3JpZ2h0JzpcclxuXHRcdFx0b2Zmc2V0ID0gd2lkdGggLSBjYW52YXNXaWR0aDtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlICdjZW50ZXInOlxyXG5cdFx0XHRvZmZzZXQgPSAod2lkdGggLSBjYW52YXNXaWR0aCkgLyAyO1xyXG5cdFx0XHRicmVhaztcclxuXHR9XHJcblx0aWYgKG9mZnNldCkge1xyXG5cdFx0bm9kZS5jYW52YXMuZm9yRWFjaChmdW5jdGlvbiAodmVjdG9yKSB7XHJcblx0XHRcdG9mZnNldFZlY3Rvcih2ZWN0b3IsIG9mZnNldCwgMCk7XHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG5FbGVtZW50V3JpdGVyLnByb3RvdHlwZS5hZGRWZWN0b3IgPSBmdW5jdGlvbiAodmVjdG9yLCBpZ25vcmVDb250ZXh0WCwgaWdub3JlQ29udGV4dFksIGluZGV4LCBmb3JjZVBhZ2UpIHtcclxuXHR2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuXHR2YXIgcGFnZSA9IGNvbnRleHQuZ2V0Q3VycmVudFBhZ2UoKTtcclxuXHRpZiAoaXNOdW1iZXIoZm9yY2VQYWdlKSkge1xyXG5cdFx0cGFnZSA9IGNvbnRleHQucGFnZXNbZm9yY2VQYWdlXTtcclxuXHR9XHJcblx0dmFyIHBvc2l0aW9uID0gdGhpcy5nZXRDdXJyZW50UG9zaXRpb25PblBhZ2UoKTtcclxuXHJcblx0aWYgKHBhZ2UpIHtcclxuXHRcdG9mZnNldFZlY3Rvcih2ZWN0b3IsIGlnbm9yZUNvbnRleHRYID8gMCA6IGNvbnRleHQueCwgaWdub3JlQ29udGV4dFkgPyAwIDogY29udGV4dC55KTtcclxuXHRcdGFkZFBhZ2VJdGVtKHBhZ2UsIHtcclxuXHRcdFx0dHlwZTogJ3ZlY3RvcicsXHJcblx0XHRcdGl0ZW06IHZlY3RvclxyXG5cdFx0fSwgaW5kZXgpO1xyXG5cdFx0cmV0dXJuIHBvc2l0aW9uO1xyXG5cdH1cclxufTtcclxuXHJcbkVsZW1lbnRXcml0ZXIucHJvdG90eXBlLmJlZ2luQ2xpcCA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XHJcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuXHR2YXIgcGFnZSA9IGN0eC5nZXRDdXJyZW50UGFnZSgpO1xyXG5cdHBhZ2UuaXRlbXMucHVzaCh7XHJcblx0XHR0eXBlOiAnYmVnaW5DbGlwJyxcclxuXHRcdGl0ZW06IHsgeDogY3R4LngsIHk6IGN0eC55LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH1cclxuXHR9KTtcclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbkVsZW1lbnRXcml0ZXIucHJvdG90eXBlLmVuZENsaXAgPSBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuXHR2YXIgcGFnZSA9IGN0eC5nZXRDdXJyZW50UGFnZSgpO1xyXG5cdHBhZ2UuaXRlbXMucHVzaCh7XHJcblx0XHR0eXBlOiAnZW5kQ2xpcCdcclxuXHR9KTtcclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNsb25lTGluZShsaW5lKSB7XHJcblx0dmFyIHJlc3VsdCA9IG5ldyBMaW5lKGxpbmUubWF4V2lkdGgpO1xyXG5cclxuXHRmb3IgKHZhciBrZXkgaW4gbGluZSkge1xyXG5cdFx0aWYgKGxpbmUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG5cdFx0XHRyZXN1bHRba2V5XSA9IGxpbmVba2V5XTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbkVsZW1lbnRXcml0ZXIucHJvdG90eXBlLmFkZEZyYWdtZW50ID0gZnVuY3Rpb24gKGJsb2NrLCB1c2VCbG9ja1hPZmZzZXQsIHVzZUJsb2NrWU9mZnNldCwgZG9udFVwZGF0ZUNvbnRleHRQb3NpdGlvbikge1xyXG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XHJcblx0dmFyIHBhZ2UgPSBjdHguZ2V0Q3VycmVudFBhZ2UoKTtcclxuXHJcblx0aWYgKCF1c2VCbG9ja1hPZmZzZXQgJiYgYmxvY2suaGVpZ2h0ID4gY3R4LmF2YWlsYWJsZUhlaWdodCkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0YmxvY2suaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG5cdFx0c3dpdGNoIChpdGVtLnR5cGUpIHtcclxuXHRcdFx0Y2FzZSAnbGluZSc6XHJcblx0XHRcdFx0dmFyIGwgPSBjbG9uZUxpbmUoaXRlbS5pdGVtKTtcclxuXHJcblx0XHRcdFx0aWYgKGwuX25vZGUpIHtcclxuXHRcdFx0XHRcdGwuX25vZGUucG9zaXRpb25zWzBdLnBhZ2VOdW1iZXIgPSBjdHgucGFnZSArIDE7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGwueCA9IChsLnggfHwgMCkgKyAodXNlQmxvY2tYT2Zmc2V0ID8gKGJsb2NrLnhPZmZzZXQgfHwgMCkgOiBjdHgueCk7XHJcblx0XHRcdFx0bC55ID0gKGwueSB8fCAwKSArICh1c2VCbG9ja1lPZmZzZXQgPyAoYmxvY2sueU9mZnNldCB8fCAwKSA6IGN0eC55KTtcclxuXHJcblx0XHRcdFx0cGFnZS5pdGVtcy5wdXNoKHtcclxuXHRcdFx0XHRcdHR5cGU6ICdsaW5lJyxcclxuXHRcdFx0XHRcdGl0ZW06IGxcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ3ZlY3Rvcic6XHJcblx0XHRcdFx0dmFyIHYgPSBwYWNrKGl0ZW0uaXRlbSk7XHJcblxyXG5cdFx0XHRcdG9mZnNldFZlY3Rvcih2LCB1c2VCbG9ja1hPZmZzZXQgPyAoYmxvY2sueE9mZnNldCB8fCAwKSA6IGN0eC54LCB1c2VCbG9ja1lPZmZzZXQgPyAoYmxvY2sueU9mZnNldCB8fCAwKSA6IGN0eC55KTtcclxuXHRcdFx0XHRpZiAodi5faXNGaWxsQ29sb3JGcm9tVW5icmVha2FibGUpIHtcclxuXHRcdFx0XHRcdC8vIElmIHRoZSBpdGVtIGlzIGEgZmlsbENvbG9yIGZyb20gYW4gdW5icmVha2FibGUgYmxvY2tcclxuXHRcdFx0XHRcdC8vIFdlIGhhdmUgdG8gYWRkIGl0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGl0ZW1zIGJvZHkgYXJyYXkgb2YgdGhlIHBhZ2VcclxuXHRcdFx0XHRcdGRlbGV0ZSB2Ll9pc0ZpbGxDb2xvckZyb21VbmJyZWFrYWJsZTtcclxuXHRcdFx0XHRcdGNvbnN0IGVuZE9mQmFja2dyb3VuZEl0ZW1zSW5kZXggPSBjdHguYmFja2dyb3VuZExlbmd0aFtjdHgucGFnZV07XHJcblx0XHRcdFx0XHRwYWdlLml0ZW1zLnNwbGljZShlbmRPZkJhY2tncm91bmRJdGVtc0luZGV4LCAwLCB7XHJcblx0XHRcdFx0XHRcdHR5cGU6ICd2ZWN0b3InLFxyXG5cdFx0XHRcdFx0XHRpdGVtOiB2XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cGFnZS5pdGVtcy5wdXNoKHtcclxuXHRcdFx0XHRcdFx0dHlwZTogJ3ZlY3RvcicsXHJcblx0XHRcdFx0XHRcdGl0ZW06IHZcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgJ2ltYWdlJzpcclxuXHRcdFx0Y2FzZSAnc3ZnJzpcclxuXHRcdFx0XHR2YXIgaW1nID0gcGFjayhpdGVtLml0ZW0pO1xyXG5cclxuXHRcdFx0XHRpbWcueCA9IChpbWcueCB8fCAwKSArICh1c2VCbG9ja1hPZmZzZXQgPyAoYmxvY2sueE9mZnNldCB8fCAwKSA6IGN0eC54KTtcclxuXHRcdFx0XHRpbWcueSA9IChpbWcueSB8fCAwKSArICh1c2VCbG9ja1lPZmZzZXQgPyAoYmxvY2sueU9mZnNldCB8fCAwKSA6IGN0eC55KTtcclxuXHJcblx0XHRcdFx0cGFnZS5pdGVtcy5wdXNoKHtcclxuXHRcdFx0XHRcdHR5cGU6IGl0ZW0udHlwZSxcclxuXHRcdFx0XHRcdGl0ZW06IGltZ1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRpZiAoIWRvbnRVcGRhdGVDb250ZXh0UG9zaXRpb24pIHtcclxuXHRcdGN0eC5tb3ZlRG93bihibG9jay5oZWlnaHQpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuICogUHVzaGVzIHRoZSBwcm92aWRlZCBjb250ZXh0IG9udG8gdGhlIHN0YWNrIG9yIGNyZWF0ZXMgYSBuZXcgb25lXHJcbiAqXHJcbiAqIHB1c2hDb250ZXh0KGNvbnRleHQpIC0gcHVzaGVzIHRoZSBwcm92aWRlZCBjb250ZXh0IGFuZCBtYWtlcyBpdCBjdXJyZW50XHJcbiAqIHB1c2hDb250ZXh0KHdpZHRoLCBoZWlnaHQpIC0gY3JlYXRlcyBhbmQgcHVzaGVzIGEgbmV3IGNvbnRleHQgd2l0aCB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHRcclxuICogcHVzaENvbnRleHQoKSAtIGNyZWF0ZXMgYSBuZXcgY29udGV4dCBmb3IgdW5icmVha2FibGUgYmxvY2tzICh3aXRoIGN1cnJlbnQgYXZhaWxhYmxlV2lkdGggYW5kIGZ1bGwtcGFnZS1oZWlnaHQpXHJcbiAqL1xyXG5FbGVtZW50V3JpdGVyLnByb3RvdHlwZS5wdXNoQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0T3JXaWR0aCwgaGVpZ2h0KSB7XHJcblx0aWYgKGNvbnRleHRPcldpZHRoID09PSB1bmRlZmluZWQpIHtcclxuXHRcdGhlaWdodCA9IHRoaXMuY29udGV4dC5nZXRDdXJyZW50UGFnZSgpLmhlaWdodCAtIHRoaXMuY29udGV4dC5wYWdlTWFyZ2lucy50b3AgLSB0aGlzLmNvbnRleHQucGFnZU1hcmdpbnMuYm90dG9tO1xyXG5cdFx0Y29udGV4dE9yV2lkdGggPSB0aGlzLmNvbnRleHQuYXZhaWxhYmxlV2lkdGg7XHJcblx0fVxyXG5cclxuXHRpZiAoaXNOdW1iZXIoY29udGV4dE9yV2lkdGgpKSB7XHJcblx0XHRjb250ZXh0T3JXaWR0aCA9IG5ldyBEb2N1bWVudENvbnRleHQoeyB3aWR0aDogY29udGV4dE9yV2lkdGgsIGhlaWdodDogaGVpZ2h0IH0sIHsgbGVmdDogMCwgcmlnaHQ6IDAsIHRvcDogMCwgYm90dG9tOiAwIH0pO1xyXG5cdH1cclxuXHJcblx0dGhpcy5jb250ZXh0U3RhY2sucHVzaCh0aGlzLmNvbnRleHQpO1xyXG5cdHRoaXMuY29udGV4dCA9IGNvbnRleHRPcldpZHRoO1xyXG59O1xyXG5cclxuRWxlbWVudFdyaXRlci5wcm90b3R5cGUucG9wQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuXHR0aGlzLmNvbnRleHQgPSB0aGlzLmNvbnRleHRTdGFjay5wb3AoKTtcclxufTtcclxuXHJcbkVsZW1lbnRXcml0ZXIucHJvdG90eXBlLmdldEN1cnJlbnRQb3NpdGlvbk9uUGFnZSA9IGZ1bmN0aW9uICgpIHtcclxuXHRyZXR1cm4gKHRoaXMuY29udGV4dFN0YWNrWzBdIHx8IHRoaXMuY29udGV4dCkuZ2V0Q3VycmVudFBvc2l0aW9uKCk7XHJcbn07XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50V3JpdGVyO1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/elementWriter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/fontProvider.js":
/*!**************************************************!*\
  !*** ./node_modules/pdfmake/src/fontProvider.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar isArray = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isArray);\r\n\r\nfunction typeName(bold, italics) {\r\n\tvar type = 'normal';\r\n\tif (bold && italics) {\r\n\t\ttype = 'bolditalics';\r\n\t} else if (bold) {\r\n\t\ttype = 'bold';\r\n\t} else if (italics) {\r\n\t\ttype = 'italics';\r\n\t}\r\n\treturn type;\r\n}\r\n\r\nfunction FontProvider(fontDescriptors, pdfKitDoc) {\r\n\tthis.fonts = {};\r\n\tthis.pdfKitDoc = pdfKitDoc;\r\n\tthis.fontCache = {};\r\n\r\n\tfor (var font in fontDescriptors) {\r\n\t\tif (fontDescriptors.hasOwnProperty(font)) {\r\n\t\t\tvar fontDef = fontDescriptors[font];\r\n\r\n\t\t\tthis.fonts[font] = {\r\n\t\t\t\tnormal: fontDef.normal,\r\n\t\t\t\tbold: fontDef.bold,\r\n\t\t\t\titalics: fontDef.italics,\r\n\t\t\t\tbolditalics: fontDef.bolditalics\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nFontProvider.prototype.getFontType = function (bold, italics) {\r\n\treturn typeName(bold, italics);\r\n};\r\n\r\nFontProvider.prototype.getFontFile = function (familyName, bold, italics) {\r\n\tvar type = this.getFontType(bold, italics);\r\n\tif (!this.fonts[familyName] || !this.fonts[familyName][type]) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\treturn this.fonts[familyName][type];\r\n};\r\n\r\nFontProvider.prototype.provideFont = function (familyName, bold, italics) {\r\n\tvar type = this.getFontType(bold, italics);\r\n\tif (this.getFontFile(familyName, bold, italics) === null) {\r\n\t\tthrow new Error('Font \\'' + familyName + '\\' in style \\'' + type + '\\' is not defined in the font section of the document definition.');\r\n\t}\r\n\r\n\tthis.fontCache[familyName] = this.fontCache[familyName] || {};\r\n\r\n\tif (!this.fontCache[familyName][type]) {\r\n\t\tvar def = this.fonts[familyName][type];\r\n\t\tif (!isArray(def)) {\r\n\t\t\tdef = [def];\r\n\t\t}\r\n\t\tthis.fontCache[familyName][type] = this.pdfKitDoc.font.apply(this.pdfKitDoc, def)._font;\r\n\t}\r\n\r\n\treturn this.fontCache[familyName][type];\r\n};\r\n\r\nmodule.exports = FontProvider;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvZm9udFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxjQUFjLDZGQUE0QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvZ2FzY2F0L3ByaXNtYXF1YW50L3ByaXNtYS1xdWFudHVtL25vZGVfbW9kdWxlcy9wZGZtYWtlL3NyYy9mb250UHJvdmlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc0FycmF5O1xyXG5cclxuZnVuY3Rpb24gdHlwZU5hbWUoYm9sZCwgaXRhbGljcykge1xyXG5cdHZhciB0eXBlID0gJ25vcm1hbCc7XHJcblx0aWYgKGJvbGQgJiYgaXRhbGljcykge1xyXG5cdFx0dHlwZSA9ICdib2xkaXRhbGljcyc7XHJcblx0fSBlbHNlIGlmIChib2xkKSB7XHJcblx0XHR0eXBlID0gJ2JvbGQnO1xyXG5cdH0gZWxzZSBpZiAoaXRhbGljcykge1xyXG5cdFx0dHlwZSA9ICdpdGFsaWNzJztcclxuXHR9XHJcblx0cmV0dXJuIHR5cGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEZvbnRQcm92aWRlcihmb250RGVzY3JpcHRvcnMsIHBkZktpdERvYykge1xyXG5cdHRoaXMuZm9udHMgPSB7fTtcclxuXHR0aGlzLnBkZktpdERvYyA9IHBkZktpdERvYztcclxuXHR0aGlzLmZvbnRDYWNoZSA9IHt9O1xyXG5cclxuXHRmb3IgKHZhciBmb250IGluIGZvbnREZXNjcmlwdG9ycykge1xyXG5cdFx0aWYgKGZvbnREZXNjcmlwdG9ycy5oYXNPd25Qcm9wZXJ0eShmb250KSkge1xyXG5cdFx0XHR2YXIgZm9udERlZiA9IGZvbnREZXNjcmlwdG9yc1tmb250XTtcclxuXHJcblx0XHRcdHRoaXMuZm9udHNbZm9udF0gPSB7XHJcblx0XHRcdFx0bm9ybWFsOiBmb250RGVmLm5vcm1hbCxcclxuXHRcdFx0XHRib2xkOiBmb250RGVmLmJvbGQsXHJcblx0XHRcdFx0aXRhbGljczogZm9udERlZi5pdGFsaWNzLFxyXG5cdFx0XHRcdGJvbGRpdGFsaWNzOiBmb250RGVmLmJvbGRpdGFsaWNzXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5Gb250UHJvdmlkZXIucHJvdG90eXBlLmdldEZvbnRUeXBlID0gZnVuY3Rpb24gKGJvbGQsIGl0YWxpY3MpIHtcclxuXHRyZXR1cm4gdHlwZU5hbWUoYm9sZCwgaXRhbGljcyk7XHJcbn07XHJcblxyXG5Gb250UHJvdmlkZXIucHJvdG90eXBlLmdldEZvbnRGaWxlID0gZnVuY3Rpb24gKGZhbWlseU5hbWUsIGJvbGQsIGl0YWxpY3MpIHtcclxuXHR2YXIgdHlwZSA9IHRoaXMuZ2V0Rm9udFR5cGUoYm9sZCwgaXRhbGljcyk7XHJcblx0aWYgKCF0aGlzLmZvbnRzW2ZhbWlseU5hbWVdIHx8ICF0aGlzLmZvbnRzW2ZhbWlseU5hbWVdW3R5cGVdKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzLmZvbnRzW2ZhbWlseU5hbWVdW3R5cGVdO1xyXG59O1xyXG5cclxuRm9udFByb3ZpZGVyLnByb3RvdHlwZS5wcm92aWRlRm9udCA9IGZ1bmN0aW9uIChmYW1pbHlOYW1lLCBib2xkLCBpdGFsaWNzKSB7XHJcblx0dmFyIHR5cGUgPSB0aGlzLmdldEZvbnRUeXBlKGJvbGQsIGl0YWxpY3MpO1xyXG5cdGlmICh0aGlzLmdldEZvbnRGaWxlKGZhbWlseU5hbWUsIGJvbGQsIGl0YWxpY3MpID09PSBudWxsKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ZvbnQgXFwnJyArIGZhbWlseU5hbWUgKyAnXFwnIGluIHN0eWxlIFxcJycgKyB0eXBlICsgJ1xcJyBpcyBub3QgZGVmaW5lZCBpbiB0aGUgZm9udCBzZWN0aW9uIG9mIHRoZSBkb2N1bWVudCBkZWZpbml0aW9uLicpO1xyXG5cdH1cclxuXHJcblx0dGhpcy5mb250Q2FjaGVbZmFtaWx5TmFtZV0gPSB0aGlzLmZvbnRDYWNoZVtmYW1pbHlOYW1lXSB8fCB7fTtcclxuXHJcblx0aWYgKCF0aGlzLmZvbnRDYWNoZVtmYW1pbHlOYW1lXVt0eXBlXSkge1xyXG5cdFx0dmFyIGRlZiA9IHRoaXMuZm9udHNbZmFtaWx5TmFtZV1bdHlwZV07XHJcblx0XHRpZiAoIWlzQXJyYXkoZGVmKSkge1xyXG5cdFx0XHRkZWYgPSBbZGVmXTtcclxuXHRcdH1cclxuXHRcdHRoaXMuZm9udENhY2hlW2ZhbWlseU5hbWVdW3R5cGVdID0gdGhpcy5wZGZLaXREb2MuZm9udC5hcHBseSh0aGlzLnBkZktpdERvYywgZGVmKS5fZm9udDtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzLmZvbnRDYWNoZVtmYW1pbHlOYW1lXVt0eXBlXTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRm9udFByb3ZpZGVyO1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/fontProvider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/helpers.js":
/*!*********************************************!*\
  !*** ./node_modules/pdfmake/src/helpers.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\nfunction isString(variable) {\r\n\treturn typeof variable === 'string' || variable instanceof String;\r\n}\r\n\r\nfunction isNumber(variable) {\r\n\treturn typeof variable === 'number' || variable instanceof Number;\r\n}\r\n\r\nfunction isBoolean(variable) {\r\n\treturn typeof variable === 'boolean';\r\n}\r\n\r\nfunction isArray(variable) {\r\n\treturn Array.isArray(variable);\r\n}\r\n\r\nfunction isFunction(variable) {\r\n\treturn typeof variable === 'function';\r\n}\r\n\r\nfunction isObject(variable) {\r\n\treturn variable !== null && typeof variable === 'object';\r\n}\r\n\r\nfunction isNull(variable) {\r\n\treturn variable === null;\r\n}\r\n\r\nfunction isUndefined(variable) {\r\n\treturn variable === undefined;\r\n}\r\n\r\n/**\r\n * @param {any} variable\r\n * @returns {boolean}\r\n */\r\nfunction isPositiveInteger(variable) {\r\n\tif (!isNumber(variable) || !Number.isInteger(variable) || variable <= 0) {\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nfunction pack() {\r\n\tvar result = {};\r\n\r\n\tfor (var i = 0, l = arguments.length; i < l; i++) {\r\n\t\tvar obj = arguments[i];\r\n\r\n\t\tif (obj) {\r\n\t\t\tfor (var key in obj) {\r\n\t\t\t\tif (obj.hasOwnProperty(key)) {\r\n\t\t\t\t\tresult[key] = obj[key];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nfunction offsetVector(vector, x, y) {\r\n\tswitch (vector.type) {\r\n\t\tcase 'ellipse':\r\n\t\tcase 'rect':\r\n\t\t\tvector.x += x;\r\n\t\t\tvector.y += y;\r\n\t\t\tbreak;\r\n\t\tcase 'line':\r\n\t\t\tvector.x1 += x;\r\n\t\t\tvector.x2 += x;\r\n\t\t\tvector.y1 += y;\r\n\t\t\tvector.y2 += y;\r\n\t\t\tbreak;\r\n\t\tcase 'polyline':\r\n\t\t\tfor (var i = 0, l = vector.points.length; i < l; i++) {\r\n\t\t\t\tvector.points[i].x += x;\r\n\t\t\t\tvector.points[i].y += y;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t}\r\n}\r\n\r\nfunction fontStringify(key, val) {\r\n\tif (key === 'font') {\r\n\t\treturn 'font';\r\n\t}\r\n\treturn val;\r\n}\r\n\r\nfunction getNodeId(node) {\r\n\tif (node.id) {\r\n\t\treturn node.id;\r\n\t}\r\n\r\n\tif (isArray(node.text)) {\r\n\t\tfor (var i = 0, l = node.text.length; i < l; i++) {\r\n\t\t\tvar n = node.text[i];\r\n\t\t\tvar nodeId = getNodeId(n);\r\n\t\t\tif (nodeId) {\r\n\t\t\t\treturn nodeId;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn null;\r\n}\r\n\r\nfunction isPattern(color) {\r\n\treturn isArray(color) && color.length === 2;\r\n}\r\n\r\n// converts from a [<pattern name>, <color>] as used by pdfmake\r\n// into [<pattern object>, <color>] as used by pdfkit\r\n// (the pattern has to be registered in the doc definition of course)\r\nfunction getPattern(color, patterns) {\r\n\treturn [patterns[color[0]], color[1]];\r\n}\r\n\r\nmodule.exports = {\r\n\tisString: isString,\r\n\tisNumber: isNumber,\r\n\tisBoolean: isBoolean,\r\n\tisArray: isArray,\r\n\tisFunction: isFunction,\r\n\tisObject: isObject,\r\n\tisNull: isNull,\r\n\tisUndefined: isUndefined,\r\n\tisPositiveInteger: isPositiveInteger,\r\n\tpack: pack,\r\n\tfontStringify: fontStringify,\r\n\toffsetVector: offsetVector,\r\n\tgetNodeId: getNodeId,\r\n\tisPattern: isPattern,\r\n\tgetPattern: getPattern\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9nYXNjYXQvcHJpc21hcXVhbnQvcHJpc21hLXF1YW50dW0vbm9kZV9tb2R1bGVzL3BkZm1ha2Uvc3JjL2hlbHBlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZnVuY3Rpb24gaXNTdHJpbmcodmFyaWFibGUpIHtcclxuXHRyZXR1cm4gdHlwZW9mIHZhcmlhYmxlID09PSAnc3RyaW5nJyB8fCB2YXJpYWJsZSBpbnN0YW5jZW9mIFN0cmluZztcclxufVxyXG5cclxuZnVuY3Rpb24gaXNOdW1iZXIodmFyaWFibGUpIHtcclxuXHRyZXR1cm4gdHlwZW9mIHZhcmlhYmxlID09PSAnbnVtYmVyJyB8fCB2YXJpYWJsZSBpbnN0YW5jZW9mIE51bWJlcjtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNCb29sZWFuKHZhcmlhYmxlKSB7XHJcblx0cmV0dXJuIHR5cGVvZiB2YXJpYWJsZSA9PT0gJ2Jvb2xlYW4nO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0FycmF5KHZhcmlhYmxlKSB7XHJcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFyaWFibGUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhcmlhYmxlKSB7XHJcblx0cmV0dXJuIHR5cGVvZiB2YXJpYWJsZSA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG5cclxuZnVuY3Rpb24gaXNPYmplY3QodmFyaWFibGUpIHtcclxuXHRyZXR1cm4gdmFyaWFibGUgIT09IG51bGwgJiYgdHlwZW9mIHZhcmlhYmxlID09PSAnb2JqZWN0JztcclxufVxyXG5cclxuZnVuY3Rpb24gaXNOdWxsKHZhcmlhYmxlKSB7XHJcblx0cmV0dXJuIHZhcmlhYmxlID09PSBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YXJpYWJsZSkge1xyXG5cdHJldHVybiB2YXJpYWJsZSA9PT0gdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogQHBhcmFtIHthbnl9IHZhcmlhYmxlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNQb3NpdGl2ZUludGVnZXIodmFyaWFibGUpIHtcclxuXHRpZiAoIWlzTnVtYmVyKHZhcmlhYmxlKSB8fCAhTnVtYmVyLmlzSW50ZWdlcih2YXJpYWJsZSkgfHwgdmFyaWFibGUgPD0gMCkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFjaygpIHtcclxuXHR2YXIgcmVzdWx0ID0ge307XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0dmFyIG9iaiA9IGFyZ3VtZW50c1tpXTtcclxuXHJcblx0XHRpZiAob2JqKSB7XHJcblx0XHRcdGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuXHRcdFx0XHRpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuXHRcdFx0XHRcdHJlc3VsdFtrZXldID0gb2JqW2tleV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBvZmZzZXRWZWN0b3IodmVjdG9yLCB4LCB5KSB7XHJcblx0c3dpdGNoICh2ZWN0b3IudHlwZSkge1xyXG5cdFx0Y2FzZSAnZWxsaXBzZSc6XHJcblx0XHRjYXNlICdyZWN0JzpcclxuXHRcdFx0dmVjdG9yLnggKz0geDtcclxuXHRcdFx0dmVjdG9yLnkgKz0geTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlICdsaW5lJzpcclxuXHRcdFx0dmVjdG9yLngxICs9IHg7XHJcblx0XHRcdHZlY3Rvci54MiArPSB4O1xyXG5cdFx0XHR2ZWN0b3IueTEgKz0geTtcclxuXHRcdFx0dmVjdG9yLnkyICs9IHk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSAncG9seWxpbmUnOlxyXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHZlY3Rvci5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRcdFx0dmVjdG9yLnBvaW50c1tpXS54ICs9IHg7XHJcblx0XHRcdFx0dmVjdG9yLnBvaW50c1tpXS55ICs9IHk7XHJcblx0XHRcdH1cclxuXHRcdFx0YnJlYWs7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBmb250U3RyaW5naWZ5KGtleSwgdmFsKSB7XHJcblx0aWYgKGtleSA9PT0gJ2ZvbnQnKSB7XHJcblx0XHRyZXR1cm4gJ2ZvbnQnO1xyXG5cdH1cclxuXHRyZXR1cm4gdmFsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXROb2RlSWQobm9kZSkge1xyXG5cdGlmIChub2RlLmlkKSB7XHJcblx0XHRyZXR1cm4gbm9kZS5pZDtcclxuXHR9XHJcblxyXG5cdGlmIChpc0FycmF5KG5vZGUudGV4dCkpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS50ZXh0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHR2YXIgbiA9IG5vZGUudGV4dFtpXTtcclxuXHRcdFx0dmFyIG5vZGVJZCA9IGdldE5vZGVJZChuKTtcclxuXHRcdFx0aWYgKG5vZGVJZCkge1xyXG5cdFx0XHRcdHJldHVybiBub2RlSWQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBudWxsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1BhdHRlcm4oY29sb3IpIHtcclxuXHRyZXR1cm4gaXNBcnJheShjb2xvcikgJiYgY29sb3IubGVuZ3RoID09PSAyO1xyXG59XHJcblxyXG4vLyBjb252ZXJ0cyBmcm9tIGEgWzxwYXR0ZXJuIG5hbWU+LCA8Y29sb3I+XSBhcyB1c2VkIGJ5IHBkZm1ha2VcclxuLy8gaW50byBbPHBhdHRlcm4gb2JqZWN0PiwgPGNvbG9yPl0gYXMgdXNlZCBieSBwZGZraXRcclxuLy8gKHRoZSBwYXR0ZXJuIGhhcyB0byBiZSByZWdpc3RlcmVkIGluIHRoZSBkb2MgZGVmaW5pdGlvbiBvZiBjb3Vyc2UpXHJcbmZ1bmN0aW9uIGdldFBhdHRlcm4oY29sb3IsIHBhdHRlcm5zKSB7XHJcblx0cmV0dXJuIFtwYXR0ZXJuc1tjb2xvclswXV0sIGNvbG9yWzFdXTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0aXNTdHJpbmc6IGlzU3RyaW5nLFxyXG5cdGlzTnVtYmVyOiBpc051bWJlcixcclxuXHRpc0Jvb2xlYW46IGlzQm9vbGVhbixcclxuXHRpc0FycmF5OiBpc0FycmF5LFxyXG5cdGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXHJcblx0aXNPYmplY3Q6IGlzT2JqZWN0LFxyXG5cdGlzTnVsbDogaXNOdWxsLFxyXG5cdGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcclxuXHRpc1Bvc2l0aXZlSW50ZWdlcjogaXNQb3NpdGl2ZUludGVnZXIsXHJcblx0cGFjazogcGFjayxcclxuXHRmb250U3RyaW5naWZ5OiBmb250U3RyaW5naWZ5LFxyXG5cdG9mZnNldFZlY3Rvcjogb2Zmc2V0VmVjdG9yLFxyXG5cdGdldE5vZGVJZDogZ2V0Tm9kZUlkLFxyXG5cdGlzUGF0dGVybjogaXNQYXR0ZXJuLFxyXG5cdGdldFBhdHRlcm46IGdldFBhdHRlcm5cclxufTtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/imageMeasure.js":
/*!**************************************************!*\
  !*** ./node_modules/pdfmake/src/imageMeasure.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar fs = __webpack_require__(/*! fs */ \"fs\");\r\n\r\nfunction ImageMeasure(pdfKitDoc, imageDictionary) {\r\n\tthis.pdfKitDoc = pdfKitDoc;\r\n\tthis.imageDictionary = imageDictionary || {};\r\n}\r\n\r\nImageMeasure.prototype.measureImage = function (src) {\r\n\tvar image;\r\n\tvar that = this;\r\n\r\n\tif (!this.pdfKitDoc._imageRegistry[src]) {\r\n\t\ttry {\r\n\t\t\timage = this.pdfKitDoc.openImage(realImageSrc(src));\r\n\t\t\tif (!image) {\r\n\t\t\t\tthrow 'No image';\r\n\t\t\t}\r\n\t\t} catch (error) {\r\n\t\t\tthrow 'Invalid image: ' + error.toString() + '\\nImages dictionary should contain dataURL entries (or local file paths in node.js)';\r\n\t\t}\r\n\t\timage.embed(this.pdfKitDoc);\r\n\t\tthis.pdfKitDoc._imageRegistry[src] = image;\r\n\t} else {\r\n\t\timage = this.pdfKitDoc._imageRegistry[src];\r\n\t}\r\n\r\n\tvar imageSize = { width: image.width, height: image.height };\r\n\r\n\t// If EXIF orientation calls for it, swap width and height\r\n\tif (image.orientation > 4) {\r\n\t\timageSize = { width: image.height, height: image.width };\r\n\t}\r\n\r\n\treturn imageSize;\r\n\r\n\tfunction realImageSrc(src) {\r\n\t\tvar img = that.imageDictionary[src];\r\n\r\n\t\tif (!img) {\r\n\t\t\treturn src;\r\n\t\t}\r\n\r\n\t\tif (typeof img === 'object') {\r\n\t\t\tthrow 'Not supported image definition: ' + JSON.stringify(img);\r\n\t\t}\r\n\r\n\t\tif (fs.existsSync(img)) {\r\n\t\t\treturn fs.readFileSync(img);\r\n\t\t}\r\n\r\n\t\tvar index = img.indexOf('base64,');\r\n\t\tif (index < 0) {\r\n\t\t\treturn that.imageDictionary[src];\r\n\t\t}\r\n\r\n\t\treturn Buffer.from(img.substring(index + 7), 'base64');\r\n\t}\r\n};\r\n\r\nmodule.exports = ImageMeasure;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvaW1hZ2VNZWFzdXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxTQUFTLG1CQUFPLENBQUMsY0FBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2dhc2NhdC9wcmlzbWFxdWFudC9wcmlzbWEtcXVhbnR1bS9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvaW1hZ2VNZWFzdXJlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XHJcblxyXG5mdW5jdGlvbiBJbWFnZU1lYXN1cmUocGRmS2l0RG9jLCBpbWFnZURpY3Rpb25hcnkpIHtcclxuXHR0aGlzLnBkZktpdERvYyA9IHBkZktpdERvYztcclxuXHR0aGlzLmltYWdlRGljdGlvbmFyeSA9IGltYWdlRGljdGlvbmFyeSB8fCB7fTtcclxufVxyXG5cclxuSW1hZ2VNZWFzdXJlLnByb3RvdHlwZS5tZWFzdXJlSW1hZ2UgPSBmdW5jdGlvbiAoc3JjKSB7XHJcblx0dmFyIGltYWdlO1xyXG5cdHZhciB0aGF0ID0gdGhpcztcclxuXHJcblx0aWYgKCF0aGlzLnBkZktpdERvYy5faW1hZ2VSZWdpc3RyeVtzcmNdKSB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHRpbWFnZSA9IHRoaXMucGRmS2l0RG9jLm9wZW5JbWFnZShyZWFsSW1hZ2VTcmMoc3JjKSk7XHJcblx0XHRcdGlmICghaW1hZ2UpIHtcclxuXHRcdFx0XHR0aHJvdyAnTm8gaW1hZ2UnO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlcnJvcikge1xyXG5cdFx0XHR0aHJvdyAnSW52YWxpZCBpbWFnZTogJyArIGVycm9yLnRvU3RyaW5nKCkgKyAnXFxuSW1hZ2VzIGRpY3Rpb25hcnkgc2hvdWxkIGNvbnRhaW4gZGF0YVVSTCBlbnRyaWVzIChvciBsb2NhbCBmaWxlIHBhdGhzIGluIG5vZGUuanMpJztcclxuXHRcdH1cclxuXHRcdGltYWdlLmVtYmVkKHRoaXMucGRmS2l0RG9jKTtcclxuXHRcdHRoaXMucGRmS2l0RG9jLl9pbWFnZVJlZ2lzdHJ5W3NyY10gPSBpbWFnZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0aW1hZ2UgPSB0aGlzLnBkZktpdERvYy5faW1hZ2VSZWdpc3RyeVtzcmNdO1xyXG5cdH1cclxuXHJcblx0dmFyIGltYWdlU2l6ZSA9IHsgd2lkdGg6IGltYWdlLndpZHRoLCBoZWlnaHQ6IGltYWdlLmhlaWdodCB9O1xyXG5cclxuXHQvLyBJZiBFWElGIG9yaWVudGF0aW9uIGNhbGxzIGZvciBpdCwgc3dhcCB3aWR0aCBhbmQgaGVpZ2h0XHJcblx0aWYgKGltYWdlLm9yaWVudGF0aW9uID4gNCkge1xyXG5cdFx0aW1hZ2VTaXplID0geyB3aWR0aDogaW1hZ2UuaGVpZ2h0LCBoZWlnaHQ6IGltYWdlLndpZHRoIH07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gaW1hZ2VTaXplO1xyXG5cclxuXHRmdW5jdGlvbiByZWFsSW1hZ2VTcmMoc3JjKSB7XHJcblx0XHR2YXIgaW1nID0gdGhhdC5pbWFnZURpY3Rpb25hcnlbc3JjXTtcclxuXHJcblx0XHRpZiAoIWltZykge1xyXG5cdFx0XHRyZXR1cm4gc3JjO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2YgaW1nID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHR0aHJvdyAnTm90IHN1cHBvcnRlZCBpbWFnZSBkZWZpbml0aW9uOiAnICsgSlNPTi5zdHJpbmdpZnkoaW1nKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZnMuZXhpc3RzU3luYyhpbWcpKSB7XHJcblx0XHRcdHJldHVybiBmcy5yZWFkRmlsZVN5bmMoaW1nKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW5kZXggPSBpbWcuaW5kZXhPZignYmFzZTY0LCcpO1xyXG5cdFx0aWYgKGluZGV4IDwgMCkge1xyXG5cdFx0XHRyZXR1cm4gdGhhdC5pbWFnZURpY3Rpb25hcnlbc3JjXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gQnVmZmVyLmZyb20oaW1nLnN1YnN0cmluZyhpbmRleCArIDcpLCAnYmFzZTY0Jyk7XHJcblx0fVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZU1lYXN1cmU7XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/imageMeasure.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/layoutBuilder.js":
/*!***************************************************!*\
  !*** ./node_modules/pdfmake/src/layoutBuilder.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar TraversalTracker = __webpack_require__(/*! ./traversalTracker */ \"(rsc)/./node_modules/pdfmake/src/traversalTracker.js\");\r\nvar DocPreprocessor = __webpack_require__(/*! ./docPreprocessor */ \"(rsc)/./node_modules/pdfmake/src/docPreprocessor.js\");\r\nvar DocMeasure = __webpack_require__(/*! ./docMeasure */ \"(rsc)/./node_modules/pdfmake/src/docMeasure.js\");\r\nvar DocumentContext = __webpack_require__(/*! ./documentContext */ \"(rsc)/./node_modules/pdfmake/src/documentContext.js\");\r\nvar PageElementWriter = __webpack_require__(/*! ./pageElementWriter */ \"(rsc)/./node_modules/pdfmake/src/pageElementWriter.js\");\r\nvar ColumnCalculator = __webpack_require__(/*! ./columnCalculator */ \"(rsc)/./node_modules/pdfmake/src/columnCalculator.js\");\r\nvar TableProcessor = __webpack_require__(/*! ./tableProcessor */ \"(rsc)/./node_modules/pdfmake/src/tableProcessor.js\");\r\nvar Line = __webpack_require__(/*! ./line */ \"(rsc)/./node_modules/pdfmake/src/line.js\");\r\nvar isString = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isString);\r\nvar isArray = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isArray);\r\nvar isUndefined = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isUndefined);\r\nvar isNull = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isNull);\r\nvar pack = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").pack);\r\nvar offsetVector = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").offsetVector);\r\nvar fontStringify = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").fontStringify);\r\nvar getNodeId = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").getNodeId);\r\nvar isFunction = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isFunction);\r\nvar TextTools = __webpack_require__(/*! ./textTools */ \"(rsc)/./node_modules/pdfmake/src/textTools.js\");\r\nvar StyleContextStack = __webpack_require__(/*! ./styleContextStack */ \"(rsc)/./node_modules/pdfmake/src/styleContextStack.js\");\r\nvar isNumber = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isNumber);\r\n\r\nfunction addAll(target, otherArray) {\r\n\totherArray.forEach(function (item) {\r\n\t\ttarget.push(item);\r\n\t});\r\n}\r\n\r\n/**\r\n * Creates an instance of LayoutBuilder - layout engine which turns document-definition-object\r\n * into a set of pages, lines, inlines and vectors ready to be rendered into a PDF\r\n *\r\n * @param {Object} pageSize - an object defining page width and height\r\n * @param {Object} pageMargins - an object defining top, left, right and bottom margins\r\n */\r\nfunction LayoutBuilder(pageSize, pageMargins, imageMeasure, svgMeasure) {\r\n\tthis.pageSize = pageSize;\r\n\tthis.pageMargins = pageMargins;\r\n\tthis.tracker = new TraversalTracker();\r\n\tthis.imageMeasure = imageMeasure;\r\n\tthis.svgMeasure = svgMeasure;\r\n\tthis.tableLayouts = {};\r\n\tthis.nestedLevel = 0;\r\n}\r\n\r\nLayoutBuilder.prototype.registerTableLayouts = function (tableLayouts) {\r\n\tthis.tableLayouts = pack(this.tableLayouts, tableLayouts);\r\n};\r\n\r\n/**\r\n * Executes layout engine on document-definition-object and creates an array of pages\r\n * containing positioned Blocks, Lines and inlines\r\n *\r\n * @param {Object} docStructure document-definition-object\r\n * @param {Object} fontProvider font provider\r\n * @param {Object} styleDictionary dictionary with style definitions\r\n * @param {Object} defaultStyle default style definition\r\n * @return {Array} an array of pages\r\n */\r\nLayoutBuilder.prototype.layoutDocument = function (docStructure, fontProvider, styleDictionary, defaultStyle, background, header, footer, images, watermark, pageBreakBeforeFct) {\r\n\r\n\tfunction addPageBreaksIfNecessary(linearNodeList, pages) {\r\n\r\n\t\tif (!isFunction(pageBreakBeforeFct)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tlinearNodeList = linearNodeList.filter(function (node) {\r\n\t\t\treturn node.positions.length > 0;\r\n\t\t});\r\n\r\n\t\tlinearNodeList.forEach(function (node) {\r\n\t\t\tvar nodeInfo = {};\r\n\t\t\t[\r\n\t\t\t\t'id', 'text', 'ul', 'ol', 'table', 'image', 'qr', 'canvas', 'svg', 'columns',\r\n\t\t\t\t'headlineLevel', 'style', 'pageBreak', 'pageOrientation',\r\n\t\t\t\t'width', 'height'\r\n\t\t\t].forEach(function (key) {\r\n\t\t\t\tif (node[key] !== undefined) {\r\n\t\t\t\t\tnodeInfo[key] = node[key];\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tnodeInfo.startPosition = node.positions[0];\r\n\t\t\tnodeInfo.pageNumbers = Array.from(new Set(node.positions.map(function (node) { return node.pageNumber; })));\r\n\t\t\tnodeInfo.pages = pages.length;\r\n\t\t\tnodeInfo.stack = isArray(node.stack);\r\n\r\n\t\t\tnode.nodeInfo = nodeInfo;\r\n\t\t});\r\n\r\n\t\tfor (var index = 0; index < linearNodeList.length; index++) {\r\n\t\t\tvar node = linearNodeList[index];\r\n\t\t\tif (node.pageBreak !== 'before' && !node.pageBreakCalculated) {\r\n\t\t\t\tnode.pageBreakCalculated = true;\r\n\t\t\t\tvar pageNumber = node.nodeInfo.pageNumbers[0];\r\n\t\t\t\tvar followingNodesOnPage = [];\r\n\t\t\t\tvar nodesOnNextPage = [];\r\n\t\t\t\tvar previousNodesOnPage = [];\r\n\t\t\t\tif (pageBreakBeforeFct.length > 1) {\r\n\t\t\t\t\tfor (var ii = index + 1, l = linearNodeList.length; ii < l; ii++) {\r\n\t\t\t\t\t\tif (linearNodeList[ii].nodeInfo.pageNumbers.indexOf(pageNumber) > -1) {\r\n\t\t\t\t\t\t\tfollowingNodesOnPage.push(linearNodeList[ii].nodeInfo);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (pageBreakBeforeFct.length > 2 && linearNodeList[ii].nodeInfo.pageNumbers.indexOf(pageNumber + 1) > -1) {\r\n\t\t\t\t\t\t\tnodesOnNextPage.push(linearNodeList[ii].nodeInfo);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (pageBreakBeforeFct.length > 3) {\r\n\t\t\t\t\tfor (var ii = 0; ii < index; ii++) {\r\n\t\t\t\t\t\tif (linearNodeList[ii].nodeInfo.pageNumbers.indexOf(pageNumber) > -1) {\r\n\t\t\t\t\t\t\tpreviousNodesOnPage.push(linearNodeList[ii].nodeInfo);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (pageBreakBeforeFct(node.nodeInfo, followingNodesOnPage, nodesOnNextPage, previousNodesOnPage)) {\r\n\t\t\t\t\tnode.pageBreak = 'before';\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tthis.docPreprocessor = new DocPreprocessor();\r\n\tthis.docMeasure = new DocMeasure(fontProvider, styleDictionary, defaultStyle, this.imageMeasure, this.svgMeasure, this.tableLayouts, images);\r\n\r\n\r\n\tfunction resetXYs(result) {\r\n\t\tresult.linearNodeList.forEach(function (node) {\r\n\t\t\tnode.resetXY();\r\n\t\t});\r\n\t}\r\n\r\n\tvar result = this.tryLayoutDocument(docStructure, fontProvider, styleDictionary, defaultStyle, background, header, footer, images, watermark);\r\n\twhile (addPageBreaksIfNecessary(result.linearNodeList, result.pages)) {\r\n\t\tresetXYs(result);\r\n\t\tresult = this.tryLayoutDocument(docStructure, fontProvider, styleDictionary, defaultStyle, background, header, footer, images, watermark);\r\n\t}\r\n\r\n\treturn result.pages;\r\n};\r\n\r\nLayoutBuilder.prototype.tryLayoutDocument = function (docStructure, fontProvider, styleDictionary, defaultStyle, background, header, footer, images, watermark, pageBreakBeforeFct) {\r\n\r\n\tthis.linearNodeList = [];\r\n\tdocStructure = this.docPreprocessor.preprocessDocument(docStructure);\r\n\tdocStructure = this.docMeasure.measureDocument(docStructure);\r\n\r\n\tthis.writer = new PageElementWriter(\r\n\t\tnew DocumentContext(this.pageSize, this.pageMargins), this.tracker);\r\n\r\n\tvar _this = this;\r\n\tthis.writer.context().tracker.startTracking('pageAdded', function () {\r\n\t\t_this.addBackground(background);\r\n\t});\r\n\r\n\tthis.addBackground(background);\r\n\tthis.processNode(docStructure);\r\n\tthis.addHeadersAndFooters(header, footer);\r\n\tif (watermark != null) {\r\n\t\tthis.addWatermark(watermark, fontProvider, defaultStyle);\r\n\t}\r\n\r\n\treturn { pages: this.writer.context().pages, linearNodeList: this.linearNodeList };\r\n};\r\n\r\n\r\nLayoutBuilder.prototype.addBackground = function (background) {\r\n\tvar backgroundGetter = isFunction(background) ? background : function () {\r\n\t\treturn background;\r\n\t};\r\n\r\n\tvar context = this.writer.context();\r\n\tvar pageSize = context.getCurrentPage().pageSize;\r\n\r\n\tvar pageBackground = backgroundGetter(context.page + 1, pageSize);\r\n\r\n\tif (pageBackground) {\r\n\t\tthis.writer.beginUnbreakableBlock(pageSize.width, pageSize.height);\r\n\t\tpageBackground = this.docPreprocessor.preprocessDocument(pageBackground);\r\n\t\tthis.processNode(this.docMeasure.measureDocument(pageBackground));\r\n\t\tthis.writer.commitUnbreakableBlock(0, 0);\r\n\t\tcontext.backgroundLength[context.page] += pageBackground.positions.length;\r\n\t}\r\n};\r\n\r\nLayoutBuilder.prototype.addStaticRepeatable = function (headerOrFooter, sizeFunction) {\r\n\tthis.addDynamicRepeatable(function () {\r\n\t\treturn JSON.parse(JSON.stringify(headerOrFooter)); // copy to new object\r\n\t}, sizeFunction);\r\n};\r\n\r\nLayoutBuilder.prototype.addDynamicRepeatable = function (nodeGetter, sizeFunction) {\r\n\tvar pages = this.writer.context().pages;\r\n\r\n\tfor (var pageIndex = 0, l = pages.length; pageIndex < l; pageIndex++) {\r\n\t\tthis.writer.context().page = pageIndex;\r\n\r\n\t\tvar node = nodeGetter(pageIndex + 1, l, this.writer.context().pages[pageIndex].pageSize);\r\n\r\n\t\tif (node) {\r\n\t\t\tvar sizes = sizeFunction(this.writer.context().getCurrentPage().pageSize, this.pageMargins);\r\n\t\t\tthis.writer.beginUnbreakableBlock(sizes.width, sizes.height);\r\n\t\t\tnode = this.docPreprocessor.preprocessDocument(node);\r\n\t\t\tthis.processNode(this.docMeasure.measureDocument(node));\r\n\t\t\tthis.writer.commitUnbreakableBlock(sizes.x, sizes.y);\r\n\t\t}\r\n\t}\r\n};\r\n\r\nLayoutBuilder.prototype.addHeadersAndFooters = function (header, footer) {\r\n\tvar headerSizeFct = function (pageSize, pageMargins) {\r\n\t\treturn {\r\n\t\t\tx: 0,\r\n\t\t\ty: 0,\r\n\t\t\twidth: pageSize.width,\r\n\t\t\theight: pageMargins.top\r\n\t\t};\r\n\t};\r\n\r\n\tvar footerSizeFct = function (pageSize, pageMargins) {\r\n\t\treturn {\r\n\t\t\tx: 0,\r\n\t\t\ty: pageSize.height - pageMargins.bottom,\r\n\t\t\twidth: pageSize.width,\r\n\t\t\theight: pageMargins.bottom\r\n\t\t};\r\n\t};\r\n\r\n\tif (isFunction(header)) {\r\n\t\tthis.addDynamicRepeatable(header, headerSizeFct);\r\n\t} else if (header) {\r\n\t\tthis.addStaticRepeatable(header, headerSizeFct);\r\n\t}\r\n\r\n\tif (isFunction(footer)) {\r\n\t\tthis.addDynamicRepeatable(footer, footerSizeFct);\r\n\t} else if (footer) {\r\n\t\tthis.addStaticRepeatable(footer, footerSizeFct);\r\n\t}\r\n};\r\n\r\nLayoutBuilder.prototype.addWatermark = function (watermark, fontProvider, defaultStyle) {\r\n\tif (isString(watermark)) {\r\n\t\twatermark = { 'text': watermark };\r\n\t}\r\n\r\n\tif (!watermark.text) { // empty watermark text\r\n\t\treturn;\r\n\t}\r\n\r\n\tvar pages = this.writer.context().pages;\r\n\tfor (var i = 0, l = pages.length; i < l; i++) {\r\n\t\tpages[i].watermark = getWatermarkObject({ ...watermark }, pages[i].pageSize, fontProvider, defaultStyle);\r\n\t}\r\n\r\n\tfunction getWatermarkObject(watermark, pageSize, fontProvider, defaultStyle) {\r\n\t\twatermark.font = watermark.font || defaultStyle.font || 'Roboto';\r\n\t\twatermark.fontSize = watermark.fontSize || 'auto';\r\n\t\twatermark.color = watermark.color || 'black';\r\n\t\twatermark.opacity = isNumber(watermark.opacity) ? watermark.opacity : 0.6;\r\n\t\twatermark.bold = watermark.bold || false;\r\n\t\twatermark.italics = watermark.italics || false;\r\n\t\twatermark.angle = !isUndefined(watermark.angle) && !isNull(watermark.angle) ? watermark.angle : null;\r\n\r\n\t\tif (watermark.angle === null) {\r\n\t\t\twatermark.angle = Math.atan2(pageSize.height, pageSize.width) * -180 / Math.PI;\r\n\t\t}\r\n\r\n\t\tif (watermark.fontSize === 'auto') {\r\n\t\t\twatermark.fontSize = getWatermarkFontSize(pageSize, watermark, fontProvider);\r\n\t\t}\r\n\r\n\t\tvar watermarkObject = {\r\n\t\t\ttext: watermark.text,\r\n\t\t\tfont: fontProvider.provideFont(watermark.font, watermark.bold, watermark.italics),\r\n\t\t\tfontSize: watermark.fontSize,\r\n\t\t\tcolor: watermark.color,\r\n\t\t\topacity: watermark.opacity,\r\n\t\t\tangle: watermark.angle\r\n\t\t};\r\n\r\n\t\twatermarkObject._size = getWatermarkSize(watermark, fontProvider);\r\n\r\n\t\treturn watermarkObject;\r\n\t}\r\n\r\n\tfunction getWatermarkSize(watermark, fontProvider) {\r\n\t\tvar textTools = new TextTools(fontProvider);\r\n\t\tvar styleContextStack = new StyleContextStack(null, { font: watermark.font, bold: watermark.bold, italics: watermark.italics });\r\n\r\n\t\tstyleContextStack.push({\r\n\t\t\tfontSize: watermark.fontSize\r\n\t\t});\r\n\r\n\t\tvar size = textTools.sizeOfString(watermark.text, styleContextStack);\r\n\t\tvar rotatedSize = textTools.sizeOfRotatedText(watermark.text, watermark.angle, styleContextStack);\r\n\r\n\t\treturn { size: size, rotatedSize: rotatedSize };\r\n\t}\r\n\r\n\tfunction getWatermarkFontSize(pageSize, watermark, fontProvider) {\r\n\t\tvar textTools = new TextTools(fontProvider);\r\n\t\tvar styleContextStack = new StyleContextStack(null, { font: watermark.font, bold: watermark.bold, italics: watermark.italics });\r\n\t\tvar rotatedSize;\r\n\r\n\t\t/**\r\n\t\t * Binary search the best font size.\r\n\t\t * Initial bounds [0, 1000]\r\n\t\t * Break when range < 1\r\n\t\t */\r\n\t\tvar a = 0;\r\n\t\tvar b = 1000;\r\n\t\tvar c = (a + b) / 2;\r\n\t\twhile (Math.abs(a - b) > 1) {\r\n\t\t\tstyleContextStack.push({\r\n\t\t\t\tfontSize: c\r\n\t\t\t});\r\n\t\t\trotatedSize = textTools.sizeOfRotatedText(watermark.text, watermark.angle, styleContextStack);\r\n\t\t\tif (rotatedSize.width > pageSize.width) {\r\n\t\t\t\tb = c;\r\n\t\t\t\tc = (a + b) / 2;\r\n\t\t\t} else if (rotatedSize.width < pageSize.width) {\r\n\t\t\t\tif (rotatedSize.height > pageSize.height) {\r\n\t\t\t\t\tb = c;\r\n\t\t\t\t\tc = (a + b) / 2;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ta = c;\r\n\t\t\t\t\tc = (a + b) / 2;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tstyleContextStack.pop();\r\n\t\t}\r\n\t\t/*\r\n\t\t End binary search\r\n\t\t */\r\n\t\treturn c;\r\n\t}\r\n};\r\n\r\nfunction decorateNode(node) {\r\n\tvar x = node.x, y = node.y;\r\n\tnode.positions = [];\r\n\r\n\tif (isArray(node.canvas)) {\r\n\t\tnode.canvas.forEach(function (vector) {\r\n\t\t\tvar x = vector.x, y = vector.y, x1 = vector.x1, y1 = vector.y1, x2 = vector.x2, y2 = vector.y2;\r\n\t\t\tvector.resetXY = function () {\r\n\t\t\t\tvector.x = x;\r\n\t\t\t\tvector.y = y;\r\n\t\t\t\tvector.x1 = x1;\r\n\t\t\t\tvector.y1 = y1;\r\n\t\t\t\tvector.x2 = x2;\r\n\t\t\t\tvector.y2 = y2;\r\n\t\t\t};\r\n\t\t});\r\n\t}\r\n\r\n\tnode.resetXY = function () {\r\n\t\tnode.x = x;\r\n\t\tnode.y = y;\r\n\t\tif (isArray(node.canvas)) {\r\n\t\t\tnode.canvas.forEach(function (vector) {\r\n\t\t\t\tvector.resetXY();\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n}\r\n\r\nLayoutBuilder.prototype.processNode = function (node) {\r\n\tvar self = this;\r\n\r\n\tthis.linearNodeList.push(node);\r\n\tdecorateNode(node);\r\n\r\n\tapplyMargins(function () {\r\n\t\tvar unbreakable = node.unbreakable;\r\n\t\tif (unbreakable) {\r\n\t\t\tself.writer.beginUnbreakableBlock();\r\n\t\t}\r\n\r\n\t\tvar absPosition = node.absolutePosition;\r\n\t\tif (absPosition) {\r\n\t\t\tself.writer.context().beginDetachedBlock();\r\n\t\t\tself.writer.context().moveTo(absPosition.x || 0, absPosition.y || 0);\r\n\t\t}\r\n\r\n\t\tvar relPosition = node.relativePosition;\r\n\t\tif (relPosition) {\r\n\t\t\tself.writer.context().beginDetachedBlock();\r\n\t\t\tself.writer.context().moveToRelative(relPosition.x || 0, relPosition.y || 0);\r\n\t\t}\r\n\r\n\t\tif (node.stack) {\r\n\t\t\tself.processVerticalContainer(node);\r\n\t\t} else if (node.columns) {\r\n\t\t\tself.processColumns(node);\r\n\t\t} else if (node.ul) {\r\n\t\t\tself.processList(false, node);\r\n\t\t} else if (node.ol) {\r\n\t\t\tself.processList(true, node);\r\n\t\t} else if (node.table) {\r\n\t\t\tself.processTable(node);\r\n\t\t} else if (node.text !== undefined) {\r\n\t\t\tself.processLeaf(node);\r\n\t\t} else if (node.toc) {\r\n\t\t\tself.processToc(node);\r\n\t\t} else if (node.image) {\r\n\t\t\tself.processImage(node);\r\n\t\t} else if (node.svg) {\r\n\t\t\tself.processSVG(node);\r\n\t\t} else if (node.canvas) {\r\n\t\t\tself.processCanvas(node);\r\n\t\t} else if (node.qr) {\r\n\t\t\tself.processQr(node);\r\n\t\t} else if (!node._span) {\r\n\t\t\tthrow 'Unrecognized document structure: ' + JSON.stringify(node, fontStringify);\r\n\t\t}\r\n\r\n\t\tif (absPosition || relPosition) {\r\n\t\t\tself.writer.context().endDetachedBlock();\r\n\t\t}\r\n\r\n\t\tif (unbreakable) {\r\n\t\t\tself.writer.commitUnbreakableBlock();\r\n\t\t}\r\n\t});\r\n\r\n\tfunction applyMargins(callback) {\r\n\t\tvar margin = node._margin;\r\n\r\n\t\tif (node.pageBreak === 'before') {\r\n\t\t\tself.writer.moveToNextPage(node.pageOrientation);\r\n\t\t} else if (node.pageBreak === 'beforeOdd') {\r\n\t\t\tself.writer.moveToNextPage(node.pageOrientation);\r\n\t\t\tif ((self.writer.context().page + 1) % 2 === 1) {\r\n\t\t\t\tself.writer.moveToNextPage(node.pageOrientation);\r\n\t\t\t}\r\n\t\t} else if (node.pageBreak === 'beforeEven') {\r\n\t\t\tself.writer.moveToNextPage(node.pageOrientation);\r\n\t\t\tif ((self.writer.context().page + 1) % 2 === 0) {\r\n\t\t\t\tself.writer.moveToNextPage(node.pageOrientation);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst isDetachedBlock = node.relativePosition || node.absolutePosition;\r\n\r\n\t\t// Detached nodes have no margins, their position is only determined by 'x' and 'y'\r\n\t\tif (margin && !isDetachedBlock) {\r\n\t\t\tconst availableHeight = self.writer.context().availableHeight;\r\n\t\t\t// If top margin is bigger than available space, move to next page\r\n\t\t\t// Necessary for nodes inside tables\r\n\t\t\tif (availableHeight - margin[1] < 0) {\r\n\t\t\t\t// Consume the whole available space\r\n\t\t\t\tself.writer.context().moveDown(availableHeight);\r\n\t\t\t\tself.writer.moveToNextPage(node.pageOrientation);\r\n\t\t\t\t/**\r\n\t\t\t\t * TODO - Something to consider:\r\n\t\t\t\t * Right now the node starts at the top of next page (after header)\r\n\t\t\t\t * Another option would be to apply just the top margin that has not been consumed in the page before\r\n\t\t\t\t * It would something like: this.write.context().moveDown(margin[1] - availableHeight)\r\n\t\t\t\t */\r\n\t\t\t} else {\r\n\t\t\t\tself.writer.context().moveDown(margin[1]);\r\n\t\t\t}\r\n\r\n\t\t\t// Apply lateral margins\r\n\t\t\tself.writer.context().addMargin(margin[0], margin[2]);\r\n\t\t}\r\n\r\n\t\tcallback();\r\n\r\n\t\t// Detached nodes have no margins, their position is only determined by 'x' and 'y'\r\n\t\tif (margin && !isDetachedBlock) {\r\n\t\t\tconst availableHeight = self.writer.context().availableHeight;\r\n\t\t\t// If bottom margin is bigger than available space, move to next page\r\n\t\t\t// Necessary for nodes inside tables\r\n\t\t\tif (availableHeight - margin[3] < 0) {\r\n\t\t\t\tself.writer.context().moveDown(availableHeight);\r\n\t\t\t\tself.writer.moveToNextPage(node.pageOrientation);\r\n\t\t\t\t/**\r\n\t\t\t\t * TODO - Something to consider:\r\n\t\t\t\t * Right now next node starts at the top of next page (after header)\r\n\t\t\t\t * Another option would be to apply the bottom margin that has not been consumed in the next page?\r\n\t\t\t\t * It would something like: this.write.context().moveDown(margin[3] - availableHeight)\r\n\t\t\t\t */\r\n\t\t\t} else {\r\n\t\t\t\tself.writer.context().moveDown(margin[3]);\r\n\t\t\t}\r\n\r\n\t\t\t// Apply lateral margins\r\n\t\t\tself.writer.context().addMargin(-margin[0], -margin[2]);\r\n\t\t}\r\n\r\n\t\tif (node.pageBreak === 'after') {\r\n\t\t\tself.writer.moveToNextPage(node.pageOrientation);\r\n\t\t} else if (node.pageBreak === 'afterOdd') {\r\n\t\t\tself.writer.moveToNextPage(node.pageOrientation);\r\n\t\t\tif ((self.writer.context().page + 1) % 2 === 1) {\r\n\t\t\t\tself.writer.moveToNextPage(node.pageOrientation);\r\n\t\t\t}\r\n\t\t} else if (node.pageBreak === 'afterEven') {\r\n\t\t\tself.writer.moveToNextPage(node.pageOrientation);\r\n\t\t\tif ((self.writer.context().page + 1) % 2 === 0) {\r\n\t\t\t\tself.writer.moveToNextPage(node.pageOrientation);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// vertical container\r\nLayoutBuilder.prototype.processVerticalContainer = function (node) {\r\n\tvar self = this;\r\n\tnode.stack.forEach(function (item) {\r\n\t\tself.processNode(item);\r\n\t\taddAll(node.positions, item.positions);\r\n\r\n\t\t//TODO: paragraph gap\r\n\t});\r\n};\r\n\r\n// columns\r\nLayoutBuilder.prototype.processColumns = function (columnNode) {\r\n\tthis.nestedLevel++;\r\n\tvar columns = columnNode.columns;\r\n\tvar availableWidth = this.writer.context().availableWidth;\r\n\tvar gaps = gapArray(columnNode._gap);\r\n\r\n\tif (gaps) {\r\n\t\tavailableWidth -= (gaps.length - 1) * columnNode._gap;\r\n\t}\r\n\r\n\tColumnCalculator.buildColumnWidths(columns, availableWidth);\r\n\tvar result = this.processRow({\r\n\t\tmarginX: columnNode._margin ? [columnNode._margin[0], columnNode._margin[2]] : [0, 0],\r\n\t\tcells: columns,\r\n\t\twidths: columns,\r\n\t\tgaps\r\n\t});\r\n\taddAll(columnNode.positions, result.positions);\r\n\r\n\tthis.nestedLevel--;\r\n\tif (this.nestedLevel === 0) {\r\n\t\tthis.writer.context().resetMarginXTopParent();\r\n\t}\r\n\r\n\tfunction gapArray(gap) {\r\n\t\tif (!gap) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tvar gaps = [];\r\n\t\tgaps.push(0);\r\n\r\n\t\tfor (var i = columns.length - 1; i > 0; i--) {\r\n\t\t\tgaps.push(gap);\r\n\t\t}\r\n\r\n\t\treturn gaps;\r\n\t}\r\n};\r\n\r\n/**\r\n * Searches for a cell in the same row that starts a rowspan and is positioned immediately before the current cell.\r\n * Alternatively, it finds a cell where the colspan initiating the rowspan extends to the cell just before the current one.\r\n *\r\n * @param {Array<object>} arr - An array representing cells in a row.\r\n * @param {number} i - The index of the current cell to search backward from.\r\n * @returns {object|null} The starting cell of the rowspan if found; otherwise, `null`.\r\n */\r\nLayoutBuilder.prototype._findStartingRowSpanCell = function (arr, i) {\r\n\tvar requiredColspan = 1;\r\n\tfor (var index = i - 1; index >= 0; index--) {\r\n\t\tif (!arr[index]._span) {\r\n\t\t\tif (arr[index].rowSpan > 1 && (arr[index].colSpan || 1) === requiredColspan) {\r\n\t\t\t\treturn arr[index];\r\n\t\t\t} else {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t\trequiredColspan++;\r\n\t}\r\n\treturn null;\r\n};\r\n\r\n/**\r\n * Retrieves a page break description for a specified page from a list of page breaks.\r\n *\r\n * @param {Array<object>} pageBreaks - An array of page break descriptions, each containing `prevPage` properties.\r\n * @param {number} page - The page number to find the associated page break for.\r\n * @returns {object|undefined} The page break description object for the specified page if found; otherwise, `undefined`.\r\n */\r\nLayoutBuilder.prototype._getPageBreak = function (pageBreaks, page) {\r\n\treturn pageBreaks.find(desc => desc.prevPage === page);\r\n};\r\n\r\nLayoutBuilder.prototype._getPageBreakListBySpan = function (tableNode, page, rowIndex) {\r\n\tif (!tableNode || !tableNode._breaksBySpan) {\r\n\t\treturn null;\r\n\t}\r\n\tconst breaksList = tableNode._breaksBySpan.filter(desc => desc.prevPage === page && rowIndex <= desc.rowIndexOfSpanEnd);\r\n\r\n\tvar y = Number.MAX_VALUE,\r\n\t\tprevY = Number.MIN_VALUE;\r\n\r\n\tbreaksList.forEach(b => {\r\n\t\tprevY = Math.max(b.prevY, prevY);\r\n\t\ty = Math.min(b.y, y);\r\n\t});\r\n\r\n\treturn {\r\n\t\tprevPage: page,\r\n\t\tprevY: prevY,\r\n\t\ty: y\r\n\t};\r\n};\r\n\r\nLayoutBuilder.prototype._findSameRowPageBreakByRowSpanData = function (breaksBySpan, page, rowIndex) {\r\n\tif (!breaksBySpan) {\r\n\t\treturn null;\r\n\t}\r\n\treturn breaksBySpan.find(desc => desc.prevPage === page && rowIndex === desc.rowIndexOfSpanEnd);\r\n};\r\n\r\nLayoutBuilder.prototype._updatePageBreaksData = function (pageBreaks, tableNode, rowIndex) {\r\n\tObject.keys(tableNode._bottomByPage).forEach(p => {\r\n\t\tconst page = Number(p);\r\n\t\tconst pageBreak = this._getPageBreak(pageBreaks, page);\r\n\t\tif (pageBreak) {\r\n\t\t\tpageBreak.prevY = Math.max(pageBreak.prevY, tableNode._bottomByPage[page]);\r\n\t\t}\r\n\t\tif (tableNode._breaksBySpan && tableNode._breaksBySpan.length > 0) {\r\n\t\t\tconst breaksBySpanList = tableNode._breaksBySpan.filter(pb => pb.prevPage === page && rowIndex <= pb.rowIndexOfSpanEnd);\r\n\t\t\tif (breaksBySpanList && breaksBySpanList.length > 0) {\r\n\t\t\t\tbreaksBySpanList.forEach(b => {\r\n\t\t\t\t\tb.prevY = Math.max(b.prevY, tableNode._bottomByPage[page]);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n};\r\n\r\n/**\r\n * Resolves the Y-coordinates for a target object by comparing two break points.\r\n *\r\n * @param {object} break1 - The first break point with `prevY` and `y` properties.\r\n * @param {object} break2 - The second break point with `prevY` and `y` properties.\r\n * @param {object} target - The target object to be updated with resolved Y-coordinates.\r\n * @property {number} target.prevY - Updated to the maximum `prevY` value between `break1` and `break2`.\r\n * @property {number} target.y - Updated to the minimum `y` value between `break1` and `break2`.\r\n */\r\nLayoutBuilder.prototype._resolveBreakY = function (break1, break2, target) {\r\n\ttarget.prevY = Math.max(break1.prevY, break2.prevY);\r\n\ttarget.y = Math.min(break1.y, break2.y);\r\n};\r\n\r\nLayoutBuilder.prototype._storePageBreakData = function (data, startsRowSpan, pageBreaks, tableNode) {\r\n\tvar pageDesc;\r\n\tvar pageDescBySpan;\r\n\r\n\tif (!startsRowSpan) {\r\n\t\tpageDesc = this._getPageBreak(pageBreaks, data.prevPage);\r\n\t\tpageDescBySpan = this._getPageBreakListBySpan(tableNode, data.prevPage, data.rowIndex);\r\n\t\tif (!pageDesc) {\r\n\t\t\tpageDesc = Object.assign({}, data);\r\n\t\t\tpageBreaks.push(pageDesc);\r\n\t\t}\r\n\r\n\t\tif (pageDescBySpan) {\r\n\t\t\tthis._resolveBreakY(pageDesc, pageDescBySpan, pageDesc);\r\n\t\t}\r\n\t\tthis._resolveBreakY(pageDesc, data, pageDesc);\r\n\t} else {\r\n\t\tvar breaksBySpan = tableNode && tableNode._breaksBySpan || null;\r\n\t\tpageDescBySpan = this._findSameRowPageBreakByRowSpanData(breaksBySpan, data.prevPage, data.rowIndex);\r\n\t\tif (!pageDescBySpan) {\r\n\t\t\tpageDescBySpan = Object.assign({}, data, {\r\n\t\t\t\trowIndexOfSpanEnd: data.rowIndex + data.rowSpan - 1\r\n\t\t\t});\r\n\t\t\tif (!tableNode._breaksBySpan) {\r\n\t\t\t\ttableNode._breaksBySpan = [];\r\n\t\t\t}\r\n\t\t\ttableNode._breaksBySpan.push(pageDescBySpan);\r\n\t\t}\r\n\t\tpageDescBySpan.prevY = Math.max(pageDescBySpan.prevY, data.prevY);\r\n\t\tpageDescBySpan.y = Math.min(pageDescBySpan.y, data.y);\r\n\t\tpageDesc = this._getPageBreak(pageBreaks, data.prevPage);\r\n\t\tif (pageDesc) {\r\n\t\t\tthis._resolveBreakY(pageDesc, pageDescBySpan, pageDesc);\r\n\t\t}\r\n\t}\r\n};\r\n\r\n/**\r\n * Calculates the left offset for a column based on the specified gap values.\r\n *\r\n * @param {number} i - The index of the column for which the offset is being calculated.\r\n * @param {Array<number>} gaps - An array of gap values for each column.\r\n * @returns {number} The left offset for the column. Returns `gaps[i]` if it exists, otherwise `0`.\r\n */\r\nLayoutBuilder.prototype._colLeftOffset = function (i, gaps) {\r\n\tif (gaps && gaps.length > i) {\r\n\t\treturn gaps[i];\r\n\t}\r\n\treturn 0;\r\n};\r\n\r\n/**\r\n * Retrieves the ending cell for a row span in case it exists in a specified table column.\r\n *\r\n * @param {Array<Array<object>>} tableBody - The table body, represented as a 2D array of cell objects.\r\n * @param {number} rowIndex - The index of the starting row for the row span.\r\n * @param {object} column - The column object containing row span information.\r\n * @param {number} columnIndex - The index of the column within the row.\r\n * @returns {object|null} The cell at the end of the row span if it exists; otherwise, `null`.\r\n * @throws {Error} If the row span extends beyond the total row count.\r\n */\r\nLayoutBuilder.prototype._getRowSpanEndingCell = function (tableBody, rowIndex, column, columnIndex) {\r\n\tif (column.rowSpan && column.rowSpan > 1) {\r\n\t\tvar endingRow = rowIndex + column.rowSpan - 1;\r\n\t\tif (endingRow >= tableBody.length) {\r\n\t\t\tthrow new Error(`Row span for column ${columnIndex} (with indexes starting from 0) exceeded row count`);\r\n\t\t}\r\n\t\treturn tableBody[endingRow][columnIndex];\r\n\t}\r\n\r\n\treturn null;\r\n};\r\n\r\nLayoutBuilder.prototype.processRow = function ({ marginX = [0, 0], dontBreakRows = false, rowsWithoutPageBreak = 0, cells, widths, gaps, tableNode, tableBody, rowIndex, height }) {\r\n\tvar self = this;\r\n\tvar isUnbreakableRow = dontBreakRows || rowIndex <= rowsWithoutPageBreak - 1;\r\n\tvar pageBreaks = [];\r\n\tvar pageBreaksByRowSpan = [];\r\n\tvar positions = [];\r\n\tvar willBreakByHeight = false;\r\n\twidths = widths || cells;\r\n\r\n\t// Check if row should break by height\r\n\tif (!isUnbreakableRow && height > self.writer.context().availableHeight) {\r\n\t\twillBreakByHeight = true;\r\n\t}\r\n\r\n\t// Use the marginX if we are in a top level table/column (not nested)\r\n\tconst marginXParent = self.nestedLevel === 1 ? marginX : null;\r\n\tconst _bottomByPage = tableNode ? tableNode._bottomByPage : null;\r\n\tthis.writer.context().beginColumnGroup(marginXParent, _bottomByPage);\r\n\r\n\tfor (var i = 0, l = cells.length; i < l; i++) {\r\n\t\tvar cell = cells[i];\r\n\r\n\t\t// Page change handler\r\n\r\n\t\tthis.tracker.auto('pageChanged', storePageBreakClosure, function () {\r\n\t\t\tvar width = widths[i]._calcWidth;\r\n\t\t\tvar leftOffset = self._colLeftOffset(i, gaps);\r\n\t\t\t// Check if exists and retrieve the cell that started the rowspan in case we are in the cell just after\r\n\t\t\tvar startingSpanCell = self._findStartingRowSpanCell(cells, i);\r\n\r\n\t\t\tif (cell.colSpan && cell.colSpan > 1) {\r\n\t\t\t\tfor (var j = 1; j < cell.colSpan; j++) {\r\n\t\t\t\t\twidth += widths[++i]._calcWidth + gaps[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// if rowspan starts in this cell, we retrieve the last cell affected by the rowspan\r\n\t\t\tconst rowSpanEndingCell = self._getRowSpanEndingCell(tableBody, rowIndex, cell, i);\r\n\t\t\tif (rowSpanEndingCell) {\r\n\t\t\t\t// We store a reference of the ending cell in the first cell of the rowspan\r\n\t\t\t\tcell._endingCell = rowSpanEndingCell;\r\n\t\t\t\tcell._endingCell._startingRowSpanY = cell._startingRowSpanY;\r\n\t\t\t}\r\n\r\n\t\t\t// If we are after a cell that started a rowspan\r\n\t\t\tvar endOfRowSpanCell = null;\r\n\t\t\tif (startingSpanCell && startingSpanCell._endingCell) {\r\n\t\t\t\t// Reference to the last cell of the rowspan\r\n\t\t\t\tendOfRowSpanCell = startingSpanCell._endingCell;\r\n\t\t\t\t// Store if we are in an unbreakable block when we save the context and the originalX\r\n\t\t\t\tif (self.writer.transactionLevel > 0) {\r\n\t\t\t\t\tendOfRowSpanCell._isUnbreakableContext = true;\r\n\t\t\t\t\tendOfRowSpanCell._originalXOffset = self.writer.originalX;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// We pass the endingSpanCell reference to store the context just after processing rowspan cell\r\n\t\t\tself.writer.context().beginColumn(width, leftOffset, endOfRowSpanCell);\r\n\r\n\t\t\tif (!cell._span) {\r\n\t\t\t\tself.processNode(cell);\r\n\t\t\t\tself.writer.context().updateBottomByPage();\r\n\t\t\t\taddAll(positions, cell.positions);\r\n\t\t\t} else if (cell._columnEndingContext) {\r\n\t\t\t\tvar discountY = 0;\r\n\t\t\t\tif (dontBreakRows) {\r\n\t\t\t\t\t// Calculate how many points we have to discount to Y when dontBreakRows and rowSpan are combined\r\n\t\t\t\t\tconst ctxBeforeRowSpanLastRow = self.writer.writer.contextStack[self.writer.writer.contextStack.length - 1];\r\n\t\t\t\t\tdiscountY = ctxBeforeRowSpanLastRow.y - cell._startingRowSpanY;\r\n\t\t\t\t}\r\n\t\t\t\tvar originalXOffset = 0;\r\n\t\t\t\t// If context was saved from an unbreakable block and we are not in an unbreakable block anymore\r\n\t\t\t\t// We have to sum the originalX (X before starting unbreakable block) to X\r\n\t\t\t\tif (cell._isUnbreakableContext && !self.writer.transactionLevel) {\r\n\t\t\t\t\toriginalXOffset = cell._originalXOffset;\r\n\t\t\t\t}\r\n\t\t\t\t// row-span ending\r\n\t\t\t\t// Recover the context after processing the rowspanned cell\r\n\t\t\t\tself.writer.context().markEnding(cell, originalXOffset, discountY);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// Check if last cell is part of a span\r\n\tvar endingSpanCell = null;\r\n\tvar lastColumn = cells.length > 0 ? cells[cells.length - 1] : null;\r\n\tif (lastColumn) {\r\n\t\t// Previous column cell has a rowspan\r\n\t\tif (lastColumn._endingCell) {\r\n\t\t\tendingSpanCell = lastColumn._endingCell;\r\n\t\t\t// Previous column cell is part of a span\r\n\t\t} else if (lastColumn._span === true) {\r\n\t\t\t// We get the cell that started the span where we set a reference to the ending cell\r\n\t\t\tconst startingSpanCell = this._findStartingRowSpanCell(cells, cells.length);\r\n\t\t\tif (startingSpanCell) {\r\n\t\t\t\t// Context will be stored here (ending cell)\r\n\t\t\t\tendingSpanCell = startingSpanCell._endingCell;\r\n\t\t\t\t// Store if we are in an unbreakable block when we save the context and the originalX\r\n\t\t\t\tif (this.writer.transactionLevel > 0) {\r\n\t\t\t\t\tendingSpanCell._isUnbreakableContext = true;\r\n\t\t\t\t\tendingSpanCell._originalXOffset = this.writer.originalX;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// If content did not break page, check if we should break by height\r\n\tif (willBreakByHeight && !isUnbreakableRow && pageBreaks.length === 0) {\r\n\t\tthis.writer.context().moveDown(this.writer.context().availableHeight);\r\n\t\tthis.writer.moveToNextPage();\r\n\t}\r\n\r\n\tvar bottomByPage = this.writer.context().completeColumnGroup(height, endingSpanCell);\r\n\r\n\tif (tableNode) {\r\n\t\ttableNode._bottomByPage = bottomByPage;\r\n\t\t// If there are page breaks in this row, update data with prevY of last cell\r\n\t\tthis._updatePageBreaksData(pageBreaks, tableNode, rowIndex);\r\n\t}\r\n\r\n\treturn {\r\n\t\tpageBreaksBySpan: pageBreaksByRowSpan,\r\n\t\tpageBreaks: pageBreaks,\r\n\t\tpositions: positions\r\n\t};\r\n\r\n\tfunction storePageBreakClosure(data) {\r\n\t\tconst startsRowSpan = cell.rowSpan && cell.rowSpan > 1;\r\n\t\tif (startsRowSpan) {\r\n\t\t\tdata.rowSpan = cell.rowSpan;\r\n\t\t}\r\n\t\tdata.rowIndex = rowIndex;\r\n\t\tself._storePageBreakData(data, startsRowSpan, pageBreaks, tableNode);\r\n\t}\r\n\r\n};\r\n\r\n// lists\r\nLayoutBuilder.prototype.processList = function (orderedList, node) {\r\n\tvar self = this,\r\n\t\titems = orderedList ? node.ol : node.ul,\r\n\t\tgapSize = node._gapSize;\r\n\r\n\tthis.writer.context().addMargin(gapSize.width);\r\n\r\n\tvar nextMarker;\r\n\tthis.tracker.auto('lineAdded', addMarkerToFirstLeaf, function () {\r\n\t\titems.forEach(function (item) {\r\n\t\t\tnextMarker = item.listMarker;\r\n\t\t\tself.processNode(item);\r\n\t\t\taddAll(node.positions, item.positions);\r\n\t\t});\r\n\t});\r\n\r\n\tthis.writer.context().addMargin(-gapSize.width);\r\n\r\n\tfunction addMarkerToFirstLeaf(line) {\r\n\t\t// I'm not very happy with the way list processing is implemented\r\n\t\t// (both code and algorithm should be rethinked)\r\n\t\tif (nextMarker) {\r\n\t\t\tvar marker = nextMarker;\r\n\t\t\tnextMarker = null;\r\n\r\n\t\t\tif (marker.canvas) {\r\n\t\t\t\tvar vector = marker.canvas[0];\r\n\r\n\t\t\t\toffsetVector(vector, -marker._minWidth, 0);\r\n\t\t\t\tself.writer.addVector(vector);\r\n\t\t\t} else if (marker._inlines) {\r\n\t\t\t\tvar markerLine = new Line(self.pageSize.width);\r\n\t\t\t\tmarkerLine.addInline(marker._inlines[0]);\r\n\t\t\t\tmarkerLine.x = -marker._minWidth;\r\n\t\t\t\tmarkerLine.y = line.getAscenderHeight() - markerLine.getAscenderHeight();\r\n\t\t\t\tself.writer.addLine(markerLine, true);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// tables\r\nLayoutBuilder.prototype.processTable = function (tableNode) {\r\n\tthis.nestedLevel++;\r\n\tvar processor = new TableProcessor(tableNode);\r\n\r\n\tprocessor.beginTable(this.writer);\r\n\r\n\tvar rowHeights = tableNode.table.heights;\r\n\tfor (var i = 0, l = tableNode.table.body.length; i < l; i++) {\r\n\t\t// if dontBreakRows and row starts a rowspan\r\n\t\t// we store the 'y' of the beginning of each rowSpan\r\n\t\tif (processor.dontBreakRows) {\r\n\t\t\ttableNode.table.body[i].forEach(cell => {\r\n\t\t\t\tif (cell.rowSpan && cell.rowSpan > 1) {\r\n\t\t\t\t\tcell._startingRowSpanY = this.writer.context().y;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tprocessor.beginRow(i, this.writer);\r\n\r\n\t\tvar height;\r\n\t\tif (isFunction(rowHeights)) {\r\n\t\t\theight = rowHeights(i);\r\n\t\t} else if (isArray(rowHeights)) {\r\n\t\t\theight = rowHeights[i];\r\n\t\t} else {\r\n\t\t\theight = rowHeights;\r\n\t\t}\r\n\r\n\t\tif (height === 'auto') {\r\n\t\t\theight = undefined;\r\n\t\t}\r\n\r\n\t\tvar pageBeforeProcessing = this.writer.context().page;\r\n\r\n\t\tvar result = this.processRow({\r\n\t\t\tmarginX: tableNode._margin ? [tableNode._margin[0], tableNode._margin[2]] : [0, 0],\r\n\t\t\tdontBreakRows: processor.dontBreakRows,\r\n\t\t\trowsWithoutPageBreak: processor.rowsWithoutPageBreak,\r\n\t\t\tcells: tableNode.table.body[i],\r\n\t\t\twidths: tableNode.table.widths,\r\n\t\t\tgaps: tableNode._offsets.offsets,\r\n\t\t\ttableBody: tableNode.table.body,\r\n\t\t\ttableNode,\r\n\t\t\trowIndex: i,\r\n\t\t\theight\r\n\t\t});\r\n\t\taddAll(tableNode.positions, result.positions);\r\n\r\n\t\tif (!result.pageBreaks || result.pageBreaks.length === 0) {\r\n\t\t\tvar breaksBySpan = tableNode && tableNode._breaksBySpan || null;\r\n\t\t\tvar breakBySpanData = this._findSameRowPageBreakByRowSpanData(breaksBySpan, pageBeforeProcessing, i);\r\n\t\t\tif (breakBySpanData) {\r\n\t\t\t\tvar finalBreakBySpanData = this._getPageBreakListBySpan(tableNode, breakBySpanData.prevPage, i);\r\n\t\t\t\tresult.pageBreaks.push(finalBreakBySpanData);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tprocessor.endRow(i, this.writer, result.pageBreaks);\r\n\t}\r\n\r\n\tprocessor.endTable(this.writer);\r\n\tthis.nestedLevel--;\r\n\tif (this.nestedLevel === 0) {\r\n\t\tthis.writer.context().resetMarginXTopParent();\r\n\t}\r\n};\r\n\r\n// leafs (texts)\r\nLayoutBuilder.prototype.processLeaf = function (node) {\r\n\tvar line = this.buildNextLine(node);\r\n\tif (line && (node.tocItem || node.id)) {\r\n\t\tline._node = node;\r\n\t}\r\n\tvar currentHeight = (line) ? line.getHeight() : 0;\r\n\tvar maxHeight = node.maxHeight || -1;\r\n\r\n\tif (line) {\r\n\t\tvar nodeId = getNodeId(node);\r\n\t\tif (nodeId) {\r\n\t\t\tline.id = nodeId;\r\n\t\t}\r\n\t}\r\n\r\n\tif (node._tocItemRef) {\r\n\t\tline._pageNodeRef = node._tocItemRef;\r\n\t}\r\n\r\n\tif (node._pageRef) {\r\n\t\tline._pageNodeRef = node._pageRef._nodeRef;\r\n\t}\r\n\r\n\tif (line && line.inlines && isArray(line.inlines)) {\r\n\t\tfor (var i = 0, l = line.inlines.length; i < l; i++) {\r\n\t\t\tif (line.inlines[i]._tocItemRef) {\r\n\t\t\t\tline.inlines[i]._pageNodeRef = line.inlines[i]._tocItemRef;\r\n\t\t\t}\r\n\r\n\t\t\tif (line.inlines[i]._pageRef) {\r\n\t\t\t\tline.inlines[i]._pageNodeRef = line.inlines[i]._pageRef._nodeRef;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\twhile (line && (maxHeight === -1 || currentHeight < maxHeight)) {\r\n\t\tvar positions = this.writer.addLine(line);\r\n\t\tnode.positions.push(positions);\r\n\t\tline = this.buildNextLine(node);\r\n\t\tif (line) {\r\n\t\t\tcurrentHeight += line.getHeight();\r\n\t\t}\r\n\t}\r\n};\r\n\r\nLayoutBuilder.prototype.processToc = function (node) {\r\n\tif (node.toc.title) {\r\n\t\tthis.processNode(node.toc.title);\r\n\t}\r\n\tif (node.toc._table) {\r\n\t\tthis.processNode(node.toc._table);\r\n\t}\r\n};\r\n\r\nLayoutBuilder.prototype.buildNextLine = function (textNode) {\r\n\r\n\tfunction cloneInline(inline) {\r\n\t\tvar newInline = inline.constructor();\r\n\t\tfor (var key in inline) {\r\n\t\t\tnewInline[key] = inline[key];\r\n\t\t}\r\n\t\treturn newInline;\r\n\t}\r\n\r\n\tfunction findMaxFitLength(text, maxWidth, measureFn) {\r\n\t\tlet low = 1;\r\n\t\tlet high = text.length;\r\n\t\tlet bestFit = 1;\r\n\r\n\t\twhile (low <= high) {\r\n\t\t\tconst mid = Math.floor((low + high) / 2);\r\n\t\t\tconst part = text.substring(0, mid);\r\n\t\t\tconst width = measureFn(part);\r\n\r\n\t\t\tif (width <= maxWidth) {\r\n\t\t\t\tbestFit = mid;\r\n\t\t\t\tlow = mid + 1;\r\n\t\t\t} else {\r\n\t\t\t\thigh = mid - 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn bestFit;\r\n\t}\r\n\r\n\tif (!textNode._inlines || textNode._inlines.length === 0) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tvar line = new Line(this.writer.context().availableWidth);\r\n\tvar textTools = new TextTools(null);\r\n\r\n\tvar isForceContinue = false;\r\n\twhile (textNode._inlines && textNode._inlines.length > 0 &&\r\n\t\t(line.hasEnoughSpaceForInline(textNode._inlines[0], textNode._inlines.slice(1)) || isForceContinue)) {\r\n\t\tvar isHardWrap = false;\r\n\t\tvar inline = textNode._inlines.shift();\r\n\t\tisForceContinue = false;\r\n\r\n\t\tif (!inline.noWrap && inline.text.length > 1 && inline.width > line.getAvailableWidth()) {\r\n\t\t\tvar maxChars = findMaxFitLength(inline.text, line.getAvailableWidth(), function (txt) {\r\n\t\t\t\treturn textTools.widthOfString(txt, inline.font, inline.fontSize, inline.characterSpacing, inline.fontFeatures)\r\n\t\t\t});\r\n\t\t\tif (maxChars < inline.text.length) {\r\n\t\t\t\tvar newInline = cloneInline(inline);\r\n\r\n\t\t\t\tnewInline.text = inline.text.substr(maxChars);\r\n\t\t\t\tinline.text = inline.text.substr(0, maxChars);\r\n\r\n\t\t\t\tnewInline.width = textTools.widthOfString(newInline.text, newInline.font, newInline.fontSize, newInline.characterSpacing, newInline.fontFeatures);\r\n\t\t\t\tinline.width = textTools.widthOfString(inline.text, inline.font, inline.fontSize, inline.characterSpacing, inline.fontFeatures);\r\n\r\n\t\t\t\ttextNode._inlines.unshift(newInline);\r\n\t\t\t\tisHardWrap = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tline.addInline(inline);\r\n\r\n\t\tisForceContinue = inline.noNewLine && !isHardWrap;\r\n\t}\r\n\r\n\tline.lastLineInParagraph = textNode._inlines.length === 0;\r\n\r\n\treturn line;\r\n};\r\n\r\n// images\r\nLayoutBuilder.prototype.processImage = function (node) {\r\n\tvar position = this.writer.addImage(node);\r\n\tnode.positions.push(position);\r\n};\r\n\r\nLayoutBuilder.prototype.processSVG = function (node) {\r\n\tvar position = this.writer.addSVG(node);\r\n\tnode.positions.push(position);\r\n};\r\n\r\nLayoutBuilder.prototype.processCanvas = function (node) {\r\n\tvar height = node._minHeight;\r\n\r\n\tif (node.absolutePosition === undefined && this.writer.context().availableHeight < height) {\r\n\t\t// TODO: support for canvas larger than a page\r\n\t\t// TODO: support for other overflow methods\r\n\r\n\t\tthis.writer.moveToNextPage();\r\n\t}\r\n\r\n\tthis.writer.alignCanvas(node);\r\n\r\n\tnode.canvas.forEach(function (vector) {\r\n\t\tvar position = this.writer.addVector(vector);\r\n\t\tnode.positions.push(position);\r\n\t}, this);\r\n\r\n\tthis.writer.context().moveDown(height);\r\n};\r\n\r\nLayoutBuilder.prototype.processQr = function (node) {\r\n\tvar position = this.writer.addQr(node);\r\n\tnode.positions.push(position);\r\n};\r\n\r\nmodule.exports = LayoutBuilder;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvbGF5b3V0QnVpbGRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsZ0ZBQW9CO0FBQ25ELHNCQUFzQixtQkFBTyxDQUFDLDhFQUFtQjtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQyxvRUFBYztBQUN2QyxzQkFBc0IsbUJBQU8sQ0FBQyw4RUFBbUI7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsa0ZBQXFCO0FBQ3JELHVCQUF1QixtQkFBTyxDQUFDLGdGQUFvQjtBQUNuRCxxQkFBcUIsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDL0MsV0FBVyxtQkFBTyxDQUFDLHdEQUFRO0FBQzNCLGVBQWUsOEZBQTZCO0FBQzVDLGNBQWMsNkZBQTRCO0FBQzFDLGtCQUFrQixpR0FBZ0M7QUFDbEQsYUFBYSw0RkFBMkI7QUFDeEMsV0FBVywwRkFBeUI7QUFDcEMsbUJBQW1CLGtHQUFpQztBQUNwRCxvQkFBb0IsbUdBQWtDO0FBQ3RELGdCQUFnQiwrRkFBOEI7QUFDOUMsaUJBQWlCLGdHQUErQjtBQUNoRCxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBYTtBQUNyQyx3QkFBd0IsbUJBQU8sQ0FBQyxrRkFBcUI7QUFDckQsZUFBZSw4RkFBNkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0ZBQWtGLHlCQUF5QjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZUFBZTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQyw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHdFQUF3RTtBQUNoSTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsd0VBQXdFO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixhQUFhLGFBQWEsMkNBQTJDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixhQUFhLGtCQUFrQixtRUFBbUU7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsYUFBYSxrREFBa0Q7QUFDNUUsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnSUFBZ0k7QUFDakw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvZ2FzY2F0L3ByaXNtYXF1YW50L3ByaXNtYS1xdWFudHVtL25vZGVfbW9kdWxlcy9wZGZtYWtlL3NyYy9sYXlvdXRCdWlsZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBUcmF2ZXJzYWxUcmFja2VyID0gcmVxdWlyZSgnLi90cmF2ZXJzYWxUcmFja2VyJyk7XHJcbnZhciBEb2NQcmVwcm9jZXNzb3IgPSByZXF1aXJlKCcuL2RvY1ByZXByb2Nlc3NvcicpO1xyXG52YXIgRG9jTWVhc3VyZSA9IHJlcXVpcmUoJy4vZG9jTWVhc3VyZScpO1xyXG52YXIgRG9jdW1lbnRDb250ZXh0ID0gcmVxdWlyZSgnLi9kb2N1bWVudENvbnRleHQnKTtcclxudmFyIFBhZ2VFbGVtZW50V3JpdGVyID0gcmVxdWlyZSgnLi9wYWdlRWxlbWVudFdyaXRlcicpO1xyXG52YXIgQ29sdW1uQ2FsY3VsYXRvciA9IHJlcXVpcmUoJy4vY29sdW1uQ2FsY3VsYXRvcicpO1xyXG52YXIgVGFibGVQcm9jZXNzb3IgPSByZXF1aXJlKCcuL3RhYmxlUHJvY2Vzc29yJyk7XHJcbnZhciBMaW5lID0gcmVxdWlyZSgnLi9saW5lJyk7XHJcbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoJy4vaGVscGVycycpLmlzU3RyaW5nO1xyXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaGVscGVycycpLmlzQXJyYXk7XHJcbnZhciBpc1VuZGVmaW5lZCA9IHJlcXVpcmUoJy4vaGVscGVycycpLmlzVW5kZWZpbmVkO1xyXG52YXIgaXNOdWxsID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuaXNOdWxsO1xyXG52YXIgcGFjayA9IHJlcXVpcmUoJy4vaGVscGVycycpLnBhY2s7XHJcbnZhciBvZmZzZXRWZWN0b3IgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5vZmZzZXRWZWN0b3I7XHJcbnZhciBmb250U3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuZm9udFN0cmluZ2lmeTtcclxudmFyIGdldE5vZGVJZCA9IHJlcXVpcmUoJy4vaGVscGVycycpLmdldE5vZGVJZDtcclxudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc0Z1bmN0aW9uO1xyXG52YXIgVGV4dFRvb2xzID0gcmVxdWlyZSgnLi90ZXh0VG9vbHMnKTtcclxudmFyIFN0eWxlQ29udGV4dFN0YWNrID0gcmVxdWlyZSgnLi9zdHlsZUNvbnRleHRTdGFjaycpO1xyXG52YXIgaXNOdW1iZXIgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc051bWJlcjtcclxuXHJcbmZ1bmN0aW9uIGFkZEFsbCh0YXJnZXQsIG90aGVyQXJyYXkpIHtcclxuXHRvdGhlckFycmF5LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuXHRcdHRhcmdldC5wdXNoKGl0ZW0pO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBMYXlvdXRCdWlsZGVyIC0gbGF5b3V0IGVuZ2luZSB3aGljaCB0dXJucyBkb2N1bWVudC1kZWZpbml0aW9uLW9iamVjdFxyXG4gKiBpbnRvIGEgc2V0IG9mIHBhZ2VzLCBsaW5lcywgaW5saW5lcyBhbmQgdmVjdG9ycyByZWFkeSB0byBiZSByZW5kZXJlZCBpbnRvIGEgUERGXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWdlU2l6ZSAtIGFuIG9iamVjdCBkZWZpbmluZyBwYWdlIHdpZHRoIGFuZCBoZWlnaHRcclxuICogQHBhcmFtIHtPYmplY3R9IHBhZ2VNYXJnaW5zIC0gYW4gb2JqZWN0IGRlZmluaW5nIHRvcCwgbGVmdCwgcmlnaHQgYW5kIGJvdHRvbSBtYXJnaW5zXHJcbiAqL1xyXG5mdW5jdGlvbiBMYXlvdXRCdWlsZGVyKHBhZ2VTaXplLCBwYWdlTWFyZ2lucywgaW1hZ2VNZWFzdXJlLCBzdmdNZWFzdXJlKSB7XHJcblx0dGhpcy5wYWdlU2l6ZSA9IHBhZ2VTaXplO1xyXG5cdHRoaXMucGFnZU1hcmdpbnMgPSBwYWdlTWFyZ2lucztcclxuXHR0aGlzLnRyYWNrZXIgPSBuZXcgVHJhdmVyc2FsVHJhY2tlcigpO1xyXG5cdHRoaXMuaW1hZ2VNZWFzdXJlID0gaW1hZ2VNZWFzdXJlO1xyXG5cdHRoaXMuc3ZnTWVhc3VyZSA9IHN2Z01lYXN1cmU7XHJcblx0dGhpcy50YWJsZUxheW91dHMgPSB7fTtcclxuXHR0aGlzLm5lc3RlZExldmVsID0gMDtcclxufVxyXG5cclxuTGF5b3V0QnVpbGRlci5wcm90b3R5cGUucmVnaXN0ZXJUYWJsZUxheW91dHMgPSBmdW5jdGlvbiAodGFibGVMYXlvdXRzKSB7XHJcblx0dGhpcy50YWJsZUxheW91dHMgPSBwYWNrKHRoaXMudGFibGVMYXlvdXRzLCB0YWJsZUxheW91dHMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV4ZWN1dGVzIGxheW91dCBlbmdpbmUgb24gZG9jdW1lbnQtZGVmaW5pdGlvbi1vYmplY3QgYW5kIGNyZWF0ZXMgYW4gYXJyYXkgb2YgcGFnZXNcclxuICogY29udGFpbmluZyBwb3NpdGlvbmVkIEJsb2NrcywgTGluZXMgYW5kIGlubGluZXNcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGRvY1N0cnVjdHVyZSBkb2N1bWVudC1kZWZpbml0aW9uLW9iamVjdFxyXG4gKiBAcGFyYW0ge09iamVjdH0gZm9udFByb3ZpZGVyIGZvbnQgcHJvdmlkZXJcclxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlRGljdGlvbmFyeSBkaWN0aW9uYXJ5IHdpdGggc3R5bGUgZGVmaW5pdGlvbnNcclxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRTdHlsZSBkZWZhdWx0IHN0eWxlIGRlZmluaXRpb25cclxuICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHBhZ2VzXHJcbiAqL1xyXG5MYXlvdXRCdWlsZGVyLnByb3RvdHlwZS5sYXlvdXREb2N1bWVudCA9IGZ1bmN0aW9uIChkb2NTdHJ1Y3R1cmUsIGZvbnRQcm92aWRlciwgc3R5bGVEaWN0aW9uYXJ5LCBkZWZhdWx0U3R5bGUsIGJhY2tncm91bmQsIGhlYWRlciwgZm9vdGVyLCBpbWFnZXMsIHdhdGVybWFyaywgcGFnZUJyZWFrQmVmb3JlRmN0KSB7XHJcblxyXG5cdGZ1bmN0aW9uIGFkZFBhZ2VCcmVha3NJZk5lY2Vzc2FyeShsaW5lYXJOb2RlTGlzdCwgcGFnZXMpIHtcclxuXHJcblx0XHRpZiAoIWlzRnVuY3Rpb24ocGFnZUJyZWFrQmVmb3JlRmN0KSkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0bGluZWFyTm9kZUxpc3QgPSBsaW5lYXJOb2RlTGlzdC5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcclxuXHRcdFx0cmV0dXJuIG5vZGUucG9zaXRpb25zLmxlbmd0aCA+IDA7XHJcblx0XHR9KTtcclxuXHJcblx0XHRsaW5lYXJOb2RlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcblx0XHRcdHZhciBub2RlSW5mbyA9IHt9O1xyXG5cdFx0XHRbXHJcblx0XHRcdFx0J2lkJywgJ3RleHQnLCAndWwnLCAnb2wnLCAndGFibGUnLCAnaW1hZ2UnLCAncXInLCAnY2FudmFzJywgJ3N2ZycsICdjb2x1bW5zJyxcclxuXHRcdFx0XHQnaGVhZGxpbmVMZXZlbCcsICdzdHlsZScsICdwYWdlQnJlYWsnLCAncGFnZU9yaWVudGF0aW9uJyxcclxuXHRcdFx0XHQnd2lkdGgnLCAnaGVpZ2h0J1xyXG5cdFx0XHRdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG5cdFx0XHRcdGlmIChub2RlW2tleV0gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0bm9kZUluZm9ba2V5XSA9IG5vZGVba2V5XTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRub2RlSW5mby5zdGFydFBvc2l0aW9uID0gbm9kZS5wb3NpdGlvbnNbMF07XHJcblx0XHRcdG5vZGVJbmZvLnBhZ2VOdW1iZXJzID0gQXJyYXkuZnJvbShuZXcgU2V0KG5vZGUucG9zaXRpb25zLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5wYWdlTnVtYmVyOyB9KSkpO1xyXG5cdFx0XHRub2RlSW5mby5wYWdlcyA9IHBhZ2VzLmxlbmd0aDtcclxuXHRcdFx0bm9kZUluZm8uc3RhY2sgPSBpc0FycmF5KG5vZGUuc3RhY2spO1xyXG5cclxuXHRcdFx0bm9kZS5ub2RlSW5mbyA9IG5vZGVJbmZvO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxpbmVhck5vZGVMaXN0Lmxlbmd0aDsgaW5kZXgrKykge1xyXG5cdFx0XHR2YXIgbm9kZSA9IGxpbmVhck5vZGVMaXN0W2luZGV4XTtcclxuXHRcdFx0aWYgKG5vZGUucGFnZUJyZWFrICE9PSAnYmVmb3JlJyAmJiAhbm9kZS5wYWdlQnJlYWtDYWxjdWxhdGVkKSB7XHJcblx0XHRcdFx0bm9kZS5wYWdlQnJlYWtDYWxjdWxhdGVkID0gdHJ1ZTtcclxuXHRcdFx0XHR2YXIgcGFnZU51bWJlciA9IG5vZGUubm9kZUluZm8ucGFnZU51bWJlcnNbMF07XHJcblx0XHRcdFx0dmFyIGZvbGxvd2luZ05vZGVzT25QYWdlID0gW107XHJcblx0XHRcdFx0dmFyIG5vZGVzT25OZXh0UGFnZSA9IFtdO1xyXG5cdFx0XHRcdHZhciBwcmV2aW91c05vZGVzT25QYWdlID0gW107XHJcblx0XHRcdFx0aWYgKHBhZ2VCcmVha0JlZm9yZUZjdC5sZW5ndGggPiAxKSB7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBpaSA9IGluZGV4ICsgMSwgbCA9IGxpbmVhck5vZGVMaXN0Lmxlbmd0aDsgaWkgPCBsOyBpaSsrKSB7XHJcblx0XHRcdFx0XHRcdGlmIChsaW5lYXJOb2RlTGlzdFtpaV0ubm9kZUluZm8ucGFnZU51bWJlcnMuaW5kZXhPZihwYWdlTnVtYmVyKSA+IC0xKSB7XHJcblx0XHRcdFx0XHRcdFx0Zm9sbG93aW5nTm9kZXNPblBhZ2UucHVzaChsaW5lYXJOb2RlTGlzdFtpaV0ubm9kZUluZm8pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmIChwYWdlQnJlYWtCZWZvcmVGY3QubGVuZ3RoID4gMiAmJiBsaW5lYXJOb2RlTGlzdFtpaV0ubm9kZUluZm8ucGFnZU51bWJlcnMuaW5kZXhPZihwYWdlTnVtYmVyICsgMSkgPiAtMSkge1xyXG5cdFx0XHRcdFx0XHRcdG5vZGVzT25OZXh0UGFnZS5wdXNoKGxpbmVhck5vZGVMaXN0W2lpXS5ub2RlSW5mbyk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHBhZ2VCcmVha0JlZm9yZUZjdC5sZW5ndGggPiAzKSB7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBpaSA9IDA7IGlpIDwgaW5kZXg7IGlpKyspIHtcclxuXHRcdFx0XHRcdFx0aWYgKGxpbmVhck5vZGVMaXN0W2lpXS5ub2RlSW5mby5wYWdlTnVtYmVycy5pbmRleE9mKHBhZ2VOdW1iZXIpID4gLTEpIHtcclxuXHRcdFx0XHRcdFx0XHRwcmV2aW91c05vZGVzT25QYWdlLnB1c2gobGluZWFyTm9kZUxpc3RbaWldLm5vZGVJbmZvKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAocGFnZUJyZWFrQmVmb3JlRmN0KG5vZGUubm9kZUluZm8sIGZvbGxvd2luZ05vZGVzT25QYWdlLCBub2Rlc09uTmV4dFBhZ2UsIHByZXZpb3VzTm9kZXNPblBhZ2UpKSB7XHJcblx0XHRcdFx0XHRub2RlLnBhZ2VCcmVhayA9ICdiZWZvcmUnO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0dGhpcy5kb2NQcmVwcm9jZXNzb3IgPSBuZXcgRG9jUHJlcHJvY2Vzc29yKCk7XHJcblx0dGhpcy5kb2NNZWFzdXJlID0gbmV3IERvY01lYXN1cmUoZm9udFByb3ZpZGVyLCBzdHlsZURpY3Rpb25hcnksIGRlZmF1bHRTdHlsZSwgdGhpcy5pbWFnZU1lYXN1cmUsIHRoaXMuc3ZnTWVhc3VyZSwgdGhpcy50YWJsZUxheW91dHMsIGltYWdlcyk7XHJcblxyXG5cclxuXHRmdW5jdGlvbiByZXNldFhZcyhyZXN1bHQpIHtcclxuXHRcdHJlc3VsdC5saW5lYXJOb2RlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcblx0XHRcdG5vZGUucmVzZXRYWSgpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHR2YXIgcmVzdWx0ID0gdGhpcy50cnlMYXlvdXREb2N1bWVudChkb2NTdHJ1Y3R1cmUsIGZvbnRQcm92aWRlciwgc3R5bGVEaWN0aW9uYXJ5LCBkZWZhdWx0U3R5bGUsIGJhY2tncm91bmQsIGhlYWRlciwgZm9vdGVyLCBpbWFnZXMsIHdhdGVybWFyayk7XHJcblx0d2hpbGUgKGFkZFBhZ2VCcmVha3NJZk5lY2Vzc2FyeShyZXN1bHQubGluZWFyTm9kZUxpc3QsIHJlc3VsdC5wYWdlcykpIHtcclxuXHRcdHJlc2V0WFlzKHJlc3VsdCk7XHJcblx0XHRyZXN1bHQgPSB0aGlzLnRyeUxheW91dERvY3VtZW50KGRvY1N0cnVjdHVyZSwgZm9udFByb3ZpZGVyLCBzdHlsZURpY3Rpb25hcnksIGRlZmF1bHRTdHlsZSwgYmFja2dyb3VuZCwgaGVhZGVyLCBmb290ZXIsIGltYWdlcywgd2F0ZXJtYXJrKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXN1bHQucGFnZXM7XHJcbn07XHJcblxyXG5MYXlvdXRCdWlsZGVyLnByb3RvdHlwZS50cnlMYXlvdXREb2N1bWVudCA9IGZ1bmN0aW9uIChkb2NTdHJ1Y3R1cmUsIGZvbnRQcm92aWRlciwgc3R5bGVEaWN0aW9uYXJ5LCBkZWZhdWx0U3R5bGUsIGJhY2tncm91bmQsIGhlYWRlciwgZm9vdGVyLCBpbWFnZXMsIHdhdGVybWFyaywgcGFnZUJyZWFrQmVmb3JlRmN0KSB7XHJcblxyXG5cdHRoaXMubGluZWFyTm9kZUxpc3QgPSBbXTtcclxuXHRkb2NTdHJ1Y3R1cmUgPSB0aGlzLmRvY1ByZXByb2Nlc3Nvci5wcmVwcm9jZXNzRG9jdW1lbnQoZG9jU3RydWN0dXJlKTtcclxuXHRkb2NTdHJ1Y3R1cmUgPSB0aGlzLmRvY01lYXN1cmUubWVhc3VyZURvY3VtZW50KGRvY1N0cnVjdHVyZSk7XHJcblxyXG5cdHRoaXMud3JpdGVyID0gbmV3IFBhZ2VFbGVtZW50V3JpdGVyKFxyXG5cdFx0bmV3IERvY3VtZW50Q29udGV4dCh0aGlzLnBhZ2VTaXplLCB0aGlzLnBhZ2VNYXJnaW5zKSwgdGhpcy50cmFja2VyKTtcclxuXHJcblx0dmFyIF90aGlzID0gdGhpcztcclxuXHR0aGlzLndyaXRlci5jb250ZXh0KCkudHJhY2tlci5zdGFydFRyYWNraW5nKCdwYWdlQWRkZWQnLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRfdGhpcy5hZGRCYWNrZ3JvdW5kKGJhY2tncm91bmQpO1xyXG5cdH0pO1xyXG5cclxuXHR0aGlzLmFkZEJhY2tncm91bmQoYmFja2dyb3VuZCk7XHJcblx0dGhpcy5wcm9jZXNzTm9kZShkb2NTdHJ1Y3R1cmUpO1xyXG5cdHRoaXMuYWRkSGVhZGVyc0FuZEZvb3RlcnMoaGVhZGVyLCBmb290ZXIpO1xyXG5cdGlmICh3YXRlcm1hcmsgIT0gbnVsbCkge1xyXG5cdFx0dGhpcy5hZGRXYXRlcm1hcmsod2F0ZXJtYXJrLCBmb250UHJvdmlkZXIsIGRlZmF1bHRTdHlsZSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4geyBwYWdlczogdGhpcy53cml0ZXIuY29udGV4dCgpLnBhZ2VzLCBsaW5lYXJOb2RlTGlzdDogdGhpcy5saW5lYXJOb2RlTGlzdCB9O1xyXG59O1xyXG5cclxuXHJcbkxheW91dEJ1aWxkZXIucHJvdG90eXBlLmFkZEJhY2tncm91bmQgPSBmdW5jdGlvbiAoYmFja2dyb3VuZCkge1xyXG5cdHZhciBiYWNrZ3JvdW5kR2V0dGVyID0gaXNGdW5jdGlvbihiYWNrZ3JvdW5kKSA/IGJhY2tncm91bmQgOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gYmFja2dyb3VuZDtcclxuXHR9O1xyXG5cclxuXHR2YXIgY29udGV4dCA9IHRoaXMud3JpdGVyLmNvbnRleHQoKTtcclxuXHR2YXIgcGFnZVNpemUgPSBjb250ZXh0LmdldEN1cnJlbnRQYWdlKCkucGFnZVNpemU7XHJcblxyXG5cdHZhciBwYWdlQmFja2dyb3VuZCA9IGJhY2tncm91bmRHZXR0ZXIoY29udGV4dC5wYWdlICsgMSwgcGFnZVNpemUpO1xyXG5cclxuXHRpZiAocGFnZUJhY2tncm91bmQpIHtcclxuXHRcdHRoaXMud3JpdGVyLmJlZ2luVW5icmVha2FibGVCbG9jayhwYWdlU2l6ZS53aWR0aCwgcGFnZVNpemUuaGVpZ2h0KTtcclxuXHRcdHBhZ2VCYWNrZ3JvdW5kID0gdGhpcy5kb2NQcmVwcm9jZXNzb3IucHJlcHJvY2Vzc0RvY3VtZW50KHBhZ2VCYWNrZ3JvdW5kKTtcclxuXHRcdHRoaXMucHJvY2Vzc05vZGUodGhpcy5kb2NNZWFzdXJlLm1lYXN1cmVEb2N1bWVudChwYWdlQmFja2dyb3VuZCkpO1xyXG5cdFx0dGhpcy53cml0ZXIuY29tbWl0VW5icmVha2FibGVCbG9jaygwLCAwKTtcclxuXHRcdGNvbnRleHQuYmFja2dyb3VuZExlbmd0aFtjb250ZXh0LnBhZ2VdICs9IHBhZ2VCYWNrZ3JvdW5kLnBvc2l0aW9ucy5sZW5ndGg7XHJcblx0fVxyXG59O1xyXG5cclxuTGF5b3V0QnVpbGRlci5wcm90b3R5cGUuYWRkU3RhdGljUmVwZWF0YWJsZSA9IGZ1bmN0aW9uIChoZWFkZXJPckZvb3Rlciwgc2l6ZUZ1bmN0aW9uKSB7XHJcblx0dGhpcy5hZGREeW5hbWljUmVwZWF0YWJsZShmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShoZWFkZXJPckZvb3RlcikpOyAvLyBjb3B5IHRvIG5ldyBvYmplY3RcclxuXHR9LCBzaXplRnVuY3Rpb24pO1xyXG59O1xyXG5cclxuTGF5b3V0QnVpbGRlci5wcm90b3R5cGUuYWRkRHluYW1pY1JlcGVhdGFibGUgPSBmdW5jdGlvbiAobm9kZUdldHRlciwgc2l6ZUZ1bmN0aW9uKSB7XHJcblx0dmFyIHBhZ2VzID0gdGhpcy53cml0ZXIuY29udGV4dCgpLnBhZ2VzO1xyXG5cclxuXHRmb3IgKHZhciBwYWdlSW5kZXggPSAwLCBsID0gcGFnZXMubGVuZ3RoOyBwYWdlSW5kZXggPCBsOyBwYWdlSW5kZXgrKykge1xyXG5cdFx0dGhpcy53cml0ZXIuY29udGV4dCgpLnBhZ2UgPSBwYWdlSW5kZXg7XHJcblxyXG5cdFx0dmFyIG5vZGUgPSBub2RlR2V0dGVyKHBhZ2VJbmRleCArIDEsIGwsIHRoaXMud3JpdGVyLmNvbnRleHQoKS5wYWdlc1twYWdlSW5kZXhdLnBhZ2VTaXplKTtcclxuXHJcblx0XHRpZiAobm9kZSkge1xyXG5cdFx0XHR2YXIgc2l6ZXMgPSBzaXplRnVuY3Rpb24odGhpcy53cml0ZXIuY29udGV4dCgpLmdldEN1cnJlbnRQYWdlKCkucGFnZVNpemUsIHRoaXMucGFnZU1hcmdpbnMpO1xyXG5cdFx0XHR0aGlzLndyaXRlci5iZWdpblVuYnJlYWthYmxlQmxvY2soc2l6ZXMud2lkdGgsIHNpemVzLmhlaWdodCk7XHJcblx0XHRcdG5vZGUgPSB0aGlzLmRvY1ByZXByb2Nlc3Nvci5wcmVwcm9jZXNzRG9jdW1lbnQobm9kZSk7XHJcblx0XHRcdHRoaXMucHJvY2Vzc05vZGUodGhpcy5kb2NNZWFzdXJlLm1lYXN1cmVEb2N1bWVudChub2RlKSk7XHJcblx0XHRcdHRoaXMud3JpdGVyLmNvbW1pdFVuYnJlYWthYmxlQmxvY2soc2l6ZXMueCwgc2l6ZXMueSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuTGF5b3V0QnVpbGRlci5wcm90b3R5cGUuYWRkSGVhZGVyc0FuZEZvb3RlcnMgPSBmdW5jdGlvbiAoaGVhZGVyLCBmb290ZXIpIHtcclxuXHR2YXIgaGVhZGVyU2l6ZUZjdCA9IGZ1bmN0aW9uIChwYWdlU2l6ZSwgcGFnZU1hcmdpbnMpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHg6IDAsXHJcblx0XHRcdHk6IDAsXHJcblx0XHRcdHdpZHRoOiBwYWdlU2l6ZS53aWR0aCxcclxuXHRcdFx0aGVpZ2h0OiBwYWdlTWFyZ2lucy50b3BcclxuXHRcdH07XHJcblx0fTtcclxuXHJcblx0dmFyIGZvb3RlclNpemVGY3QgPSBmdW5jdGlvbiAocGFnZVNpemUsIHBhZ2VNYXJnaW5zKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR4OiAwLFxyXG5cdFx0XHR5OiBwYWdlU2l6ZS5oZWlnaHQgLSBwYWdlTWFyZ2lucy5ib3R0b20sXHJcblx0XHRcdHdpZHRoOiBwYWdlU2l6ZS53aWR0aCxcclxuXHRcdFx0aGVpZ2h0OiBwYWdlTWFyZ2lucy5ib3R0b21cclxuXHRcdH07XHJcblx0fTtcclxuXHJcblx0aWYgKGlzRnVuY3Rpb24oaGVhZGVyKSkge1xyXG5cdFx0dGhpcy5hZGREeW5hbWljUmVwZWF0YWJsZShoZWFkZXIsIGhlYWRlclNpemVGY3QpO1xyXG5cdH0gZWxzZSBpZiAoaGVhZGVyKSB7XHJcblx0XHR0aGlzLmFkZFN0YXRpY1JlcGVhdGFibGUoaGVhZGVyLCBoZWFkZXJTaXplRmN0KTtcclxuXHR9XHJcblxyXG5cdGlmIChpc0Z1bmN0aW9uKGZvb3RlcikpIHtcclxuXHRcdHRoaXMuYWRkRHluYW1pY1JlcGVhdGFibGUoZm9vdGVyLCBmb290ZXJTaXplRmN0KTtcclxuXHR9IGVsc2UgaWYgKGZvb3Rlcikge1xyXG5cdFx0dGhpcy5hZGRTdGF0aWNSZXBlYXRhYmxlKGZvb3RlciwgZm9vdGVyU2l6ZUZjdCk7XHJcblx0fVxyXG59O1xyXG5cclxuTGF5b3V0QnVpbGRlci5wcm90b3R5cGUuYWRkV2F0ZXJtYXJrID0gZnVuY3Rpb24gKHdhdGVybWFyaywgZm9udFByb3ZpZGVyLCBkZWZhdWx0U3R5bGUpIHtcclxuXHRpZiAoaXNTdHJpbmcod2F0ZXJtYXJrKSkge1xyXG5cdFx0d2F0ZXJtYXJrID0geyAndGV4dCc6IHdhdGVybWFyayB9O1xyXG5cdH1cclxuXHJcblx0aWYgKCF3YXRlcm1hcmsudGV4dCkgeyAvLyBlbXB0eSB3YXRlcm1hcmsgdGV4dFxyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0dmFyIHBhZ2VzID0gdGhpcy53cml0ZXIuY29udGV4dCgpLnBhZ2VzO1xyXG5cdGZvciAodmFyIGkgPSAwLCBsID0gcGFnZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRwYWdlc1tpXS53YXRlcm1hcmsgPSBnZXRXYXRlcm1hcmtPYmplY3QoeyAuLi53YXRlcm1hcmsgfSwgcGFnZXNbaV0ucGFnZVNpemUsIGZvbnRQcm92aWRlciwgZGVmYXVsdFN0eWxlKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldFdhdGVybWFya09iamVjdCh3YXRlcm1hcmssIHBhZ2VTaXplLCBmb250UHJvdmlkZXIsIGRlZmF1bHRTdHlsZSkge1xyXG5cdFx0d2F0ZXJtYXJrLmZvbnQgPSB3YXRlcm1hcmsuZm9udCB8fCBkZWZhdWx0U3R5bGUuZm9udCB8fCAnUm9ib3RvJztcclxuXHRcdHdhdGVybWFyay5mb250U2l6ZSA9IHdhdGVybWFyay5mb250U2l6ZSB8fCAnYXV0byc7XHJcblx0XHR3YXRlcm1hcmsuY29sb3IgPSB3YXRlcm1hcmsuY29sb3IgfHwgJ2JsYWNrJztcclxuXHRcdHdhdGVybWFyay5vcGFjaXR5ID0gaXNOdW1iZXIod2F0ZXJtYXJrLm9wYWNpdHkpID8gd2F0ZXJtYXJrLm9wYWNpdHkgOiAwLjY7XHJcblx0XHR3YXRlcm1hcmsuYm9sZCA9IHdhdGVybWFyay5ib2xkIHx8IGZhbHNlO1xyXG5cdFx0d2F0ZXJtYXJrLml0YWxpY3MgPSB3YXRlcm1hcmsuaXRhbGljcyB8fCBmYWxzZTtcclxuXHRcdHdhdGVybWFyay5hbmdsZSA9ICFpc1VuZGVmaW5lZCh3YXRlcm1hcmsuYW5nbGUpICYmICFpc051bGwod2F0ZXJtYXJrLmFuZ2xlKSA/IHdhdGVybWFyay5hbmdsZSA6IG51bGw7XHJcblxyXG5cdFx0aWYgKHdhdGVybWFyay5hbmdsZSA9PT0gbnVsbCkge1xyXG5cdFx0XHR3YXRlcm1hcmsuYW5nbGUgPSBNYXRoLmF0YW4yKHBhZ2VTaXplLmhlaWdodCwgcGFnZVNpemUud2lkdGgpICogLTE4MCAvIE1hdGguUEk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHdhdGVybWFyay5mb250U2l6ZSA9PT0gJ2F1dG8nKSB7XHJcblx0XHRcdHdhdGVybWFyay5mb250U2l6ZSA9IGdldFdhdGVybWFya0ZvbnRTaXplKHBhZ2VTaXplLCB3YXRlcm1hcmssIGZvbnRQcm92aWRlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHdhdGVybWFya09iamVjdCA9IHtcclxuXHRcdFx0dGV4dDogd2F0ZXJtYXJrLnRleHQsXHJcblx0XHRcdGZvbnQ6IGZvbnRQcm92aWRlci5wcm92aWRlRm9udCh3YXRlcm1hcmsuZm9udCwgd2F0ZXJtYXJrLmJvbGQsIHdhdGVybWFyay5pdGFsaWNzKSxcclxuXHRcdFx0Zm9udFNpemU6IHdhdGVybWFyay5mb250U2l6ZSxcclxuXHRcdFx0Y29sb3I6IHdhdGVybWFyay5jb2xvcixcclxuXHRcdFx0b3BhY2l0eTogd2F0ZXJtYXJrLm9wYWNpdHksXHJcblx0XHRcdGFuZ2xlOiB3YXRlcm1hcmsuYW5nbGVcclxuXHRcdH07XHJcblxyXG5cdFx0d2F0ZXJtYXJrT2JqZWN0Ll9zaXplID0gZ2V0V2F0ZXJtYXJrU2l6ZSh3YXRlcm1hcmssIGZvbnRQcm92aWRlcik7XHJcblxyXG5cdFx0cmV0dXJuIHdhdGVybWFya09iamVjdDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldFdhdGVybWFya1NpemUod2F0ZXJtYXJrLCBmb250UHJvdmlkZXIpIHtcclxuXHRcdHZhciB0ZXh0VG9vbHMgPSBuZXcgVGV4dFRvb2xzKGZvbnRQcm92aWRlcik7XHJcblx0XHR2YXIgc3R5bGVDb250ZXh0U3RhY2sgPSBuZXcgU3R5bGVDb250ZXh0U3RhY2sobnVsbCwgeyBmb250OiB3YXRlcm1hcmsuZm9udCwgYm9sZDogd2F0ZXJtYXJrLmJvbGQsIGl0YWxpY3M6IHdhdGVybWFyay5pdGFsaWNzIH0pO1xyXG5cclxuXHRcdHN0eWxlQ29udGV4dFN0YWNrLnB1c2goe1xyXG5cdFx0XHRmb250U2l6ZTogd2F0ZXJtYXJrLmZvbnRTaXplXHJcblx0XHR9KTtcclxuXHJcblx0XHR2YXIgc2l6ZSA9IHRleHRUb29scy5zaXplT2ZTdHJpbmcod2F0ZXJtYXJrLnRleHQsIHN0eWxlQ29udGV4dFN0YWNrKTtcclxuXHRcdHZhciByb3RhdGVkU2l6ZSA9IHRleHRUb29scy5zaXplT2ZSb3RhdGVkVGV4dCh3YXRlcm1hcmsudGV4dCwgd2F0ZXJtYXJrLmFuZ2xlLCBzdHlsZUNvbnRleHRTdGFjayk7XHJcblxyXG5cdFx0cmV0dXJuIHsgc2l6ZTogc2l6ZSwgcm90YXRlZFNpemU6IHJvdGF0ZWRTaXplIH07XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRXYXRlcm1hcmtGb250U2l6ZShwYWdlU2l6ZSwgd2F0ZXJtYXJrLCBmb250UHJvdmlkZXIpIHtcclxuXHRcdHZhciB0ZXh0VG9vbHMgPSBuZXcgVGV4dFRvb2xzKGZvbnRQcm92aWRlcik7XHJcblx0XHR2YXIgc3R5bGVDb250ZXh0U3RhY2sgPSBuZXcgU3R5bGVDb250ZXh0U3RhY2sobnVsbCwgeyBmb250OiB3YXRlcm1hcmsuZm9udCwgYm9sZDogd2F0ZXJtYXJrLmJvbGQsIGl0YWxpY3M6IHdhdGVybWFyay5pdGFsaWNzIH0pO1xyXG5cdFx0dmFyIHJvdGF0ZWRTaXplO1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQmluYXJ5IHNlYXJjaCB0aGUgYmVzdCBmb250IHNpemUuXHJcblx0XHQgKiBJbml0aWFsIGJvdW5kcyBbMCwgMTAwMF1cclxuXHRcdCAqIEJyZWFrIHdoZW4gcmFuZ2UgPCAxXHJcblx0XHQgKi9cclxuXHRcdHZhciBhID0gMDtcclxuXHRcdHZhciBiID0gMTAwMDtcclxuXHRcdHZhciBjID0gKGEgKyBiKSAvIDI7XHJcblx0XHR3aGlsZSAoTWF0aC5hYnMoYSAtIGIpID4gMSkge1xyXG5cdFx0XHRzdHlsZUNvbnRleHRTdGFjay5wdXNoKHtcclxuXHRcdFx0XHRmb250U2l6ZTogY1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cm90YXRlZFNpemUgPSB0ZXh0VG9vbHMuc2l6ZU9mUm90YXRlZFRleHQod2F0ZXJtYXJrLnRleHQsIHdhdGVybWFyay5hbmdsZSwgc3R5bGVDb250ZXh0U3RhY2spO1xyXG5cdFx0XHRpZiAocm90YXRlZFNpemUud2lkdGggPiBwYWdlU2l6ZS53aWR0aCkge1xyXG5cdFx0XHRcdGIgPSBjO1xyXG5cdFx0XHRcdGMgPSAoYSArIGIpIC8gMjtcclxuXHRcdFx0fSBlbHNlIGlmIChyb3RhdGVkU2l6ZS53aWR0aCA8IHBhZ2VTaXplLndpZHRoKSB7XHJcblx0XHRcdFx0aWYgKHJvdGF0ZWRTaXplLmhlaWdodCA+IHBhZ2VTaXplLmhlaWdodCkge1xyXG5cdFx0XHRcdFx0YiA9IGM7XHJcblx0XHRcdFx0XHRjID0gKGEgKyBiKSAvIDI7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGEgPSBjO1xyXG5cdFx0XHRcdFx0YyA9IChhICsgYikgLyAyO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRzdHlsZUNvbnRleHRTdGFjay5wb3AoKTtcclxuXHRcdH1cclxuXHRcdC8qXHJcblx0XHQgRW5kIGJpbmFyeSBzZWFyY2hcclxuXHRcdCAqL1xyXG5cdFx0cmV0dXJuIGM7XHJcblx0fVxyXG59O1xyXG5cclxuZnVuY3Rpb24gZGVjb3JhdGVOb2RlKG5vZGUpIHtcclxuXHR2YXIgeCA9IG5vZGUueCwgeSA9IG5vZGUueTtcclxuXHRub2RlLnBvc2l0aW9ucyA9IFtdO1xyXG5cclxuXHRpZiAoaXNBcnJheShub2RlLmNhbnZhcykpIHtcclxuXHRcdG5vZGUuY2FudmFzLmZvckVhY2goZnVuY3Rpb24gKHZlY3Rvcikge1xyXG5cdFx0XHR2YXIgeCA9IHZlY3Rvci54LCB5ID0gdmVjdG9yLnksIHgxID0gdmVjdG9yLngxLCB5MSA9IHZlY3Rvci55MSwgeDIgPSB2ZWN0b3IueDIsIHkyID0gdmVjdG9yLnkyO1xyXG5cdFx0XHR2ZWN0b3IucmVzZXRYWSA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHR2ZWN0b3IueCA9IHg7XHJcblx0XHRcdFx0dmVjdG9yLnkgPSB5O1xyXG5cdFx0XHRcdHZlY3Rvci54MSA9IHgxO1xyXG5cdFx0XHRcdHZlY3Rvci55MSA9IHkxO1xyXG5cdFx0XHRcdHZlY3Rvci54MiA9IHgyO1xyXG5cdFx0XHRcdHZlY3Rvci55MiA9IHkyO1xyXG5cdFx0XHR9O1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRub2RlLnJlc2V0WFkgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRub2RlLnggPSB4O1xyXG5cdFx0bm9kZS55ID0geTtcclxuXHRcdGlmIChpc0FycmF5KG5vZGUuY2FudmFzKSkge1xyXG5cdFx0XHRub2RlLmNhbnZhcy5mb3JFYWNoKGZ1bmN0aW9uICh2ZWN0b3IpIHtcclxuXHRcdFx0XHR2ZWN0b3IucmVzZXRYWSgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5MYXlvdXRCdWlsZGVyLnByb3RvdHlwZS5wcm9jZXNzTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuXHR0aGlzLmxpbmVhck5vZGVMaXN0LnB1c2gobm9kZSk7XHJcblx0ZGVjb3JhdGVOb2RlKG5vZGUpO1xyXG5cclxuXHRhcHBseU1hcmdpbnMoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHVuYnJlYWthYmxlID0gbm9kZS51bmJyZWFrYWJsZTtcclxuXHRcdGlmICh1bmJyZWFrYWJsZSkge1xyXG5cdFx0XHRzZWxmLndyaXRlci5iZWdpblVuYnJlYWthYmxlQmxvY2soKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYWJzUG9zaXRpb24gPSBub2RlLmFic29sdXRlUG9zaXRpb247XHJcblx0XHRpZiAoYWJzUG9zaXRpb24pIHtcclxuXHRcdFx0c2VsZi53cml0ZXIuY29udGV4dCgpLmJlZ2luRGV0YWNoZWRCbG9jaygpO1xyXG5cdFx0XHRzZWxmLndyaXRlci5jb250ZXh0KCkubW92ZVRvKGFic1Bvc2l0aW9uLnggfHwgMCwgYWJzUG9zaXRpb24ueSB8fCAwKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmVsUG9zaXRpb24gPSBub2RlLnJlbGF0aXZlUG9zaXRpb247XHJcblx0XHRpZiAocmVsUG9zaXRpb24pIHtcclxuXHRcdFx0c2VsZi53cml0ZXIuY29udGV4dCgpLmJlZ2luRGV0YWNoZWRCbG9jaygpO1xyXG5cdFx0XHRzZWxmLndyaXRlci5jb250ZXh0KCkubW92ZVRvUmVsYXRpdmUocmVsUG9zaXRpb24ueCB8fCAwLCByZWxQb3NpdGlvbi55IHx8IDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChub2RlLnN0YWNrKSB7XHJcblx0XHRcdHNlbGYucHJvY2Vzc1ZlcnRpY2FsQ29udGFpbmVyKG5vZGUpO1xyXG5cdFx0fSBlbHNlIGlmIChub2RlLmNvbHVtbnMpIHtcclxuXHRcdFx0c2VsZi5wcm9jZXNzQ29sdW1ucyhub2RlKTtcclxuXHRcdH0gZWxzZSBpZiAobm9kZS51bCkge1xyXG5cdFx0XHRzZWxmLnByb2Nlc3NMaXN0KGZhbHNlLCBub2RlKTtcclxuXHRcdH0gZWxzZSBpZiAobm9kZS5vbCkge1xyXG5cdFx0XHRzZWxmLnByb2Nlc3NMaXN0KHRydWUsIG5vZGUpO1xyXG5cdFx0fSBlbHNlIGlmIChub2RlLnRhYmxlKSB7XHJcblx0XHRcdHNlbGYucHJvY2Vzc1RhYmxlKG5vZGUpO1xyXG5cdFx0fSBlbHNlIGlmIChub2RlLnRleHQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRzZWxmLnByb2Nlc3NMZWFmKG5vZGUpO1xyXG5cdFx0fSBlbHNlIGlmIChub2RlLnRvYykge1xyXG5cdFx0XHRzZWxmLnByb2Nlc3NUb2Mobm9kZSk7XHJcblx0XHR9IGVsc2UgaWYgKG5vZGUuaW1hZ2UpIHtcclxuXHRcdFx0c2VsZi5wcm9jZXNzSW1hZ2Uobm9kZSk7XHJcblx0XHR9IGVsc2UgaWYgKG5vZGUuc3ZnKSB7XHJcblx0XHRcdHNlbGYucHJvY2Vzc1NWRyhub2RlKTtcclxuXHRcdH0gZWxzZSBpZiAobm9kZS5jYW52YXMpIHtcclxuXHRcdFx0c2VsZi5wcm9jZXNzQ2FudmFzKG5vZGUpO1xyXG5cdFx0fSBlbHNlIGlmIChub2RlLnFyKSB7XHJcblx0XHRcdHNlbGYucHJvY2Vzc1FyKG5vZGUpO1xyXG5cdFx0fSBlbHNlIGlmICghbm9kZS5fc3Bhbikge1xyXG5cdFx0XHR0aHJvdyAnVW5yZWNvZ25pemVkIGRvY3VtZW50IHN0cnVjdHVyZTogJyArIEpTT04uc3RyaW5naWZ5KG5vZGUsIGZvbnRTdHJpbmdpZnkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChhYnNQb3NpdGlvbiB8fCByZWxQb3NpdGlvbikge1xyXG5cdFx0XHRzZWxmLndyaXRlci5jb250ZXh0KCkuZW5kRGV0YWNoZWRCbG9jaygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh1bmJyZWFrYWJsZSkge1xyXG5cdFx0XHRzZWxmLndyaXRlci5jb21taXRVbmJyZWFrYWJsZUJsb2NrKCk7XHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGZ1bmN0aW9uIGFwcGx5TWFyZ2lucyhjYWxsYmFjaykge1xyXG5cdFx0dmFyIG1hcmdpbiA9IG5vZGUuX21hcmdpbjtcclxuXHJcblx0XHRpZiAobm9kZS5wYWdlQnJlYWsgPT09ICdiZWZvcmUnKSB7XHJcblx0XHRcdHNlbGYud3JpdGVyLm1vdmVUb05leHRQYWdlKG5vZGUucGFnZU9yaWVudGF0aW9uKTtcclxuXHRcdH0gZWxzZSBpZiAobm9kZS5wYWdlQnJlYWsgPT09ICdiZWZvcmVPZGQnKSB7XHJcblx0XHRcdHNlbGYud3JpdGVyLm1vdmVUb05leHRQYWdlKG5vZGUucGFnZU9yaWVudGF0aW9uKTtcclxuXHRcdFx0aWYgKChzZWxmLndyaXRlci5jb250ZXh0KCkucGFnZSArIDEpICUgMiA9PT0gMSkge1xyXG5cdFx0XHRcdHNlbGYud3JpdGVyLm1vdmVUb05leHRQYWdlKG5vZGUucGFnZU9yaWVudGF0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChub2RlLnBhZ2VCcmVhayA9PT0gJ2JlZm9yZUV2ZW4nKSB7XHJcblx0XHRcdHNlbGYud3JpdGVyLm1vdmVUb05leHRQYWdlKG5vZGUucGFnZU9yaWVudGF0aW9uKTtcclxuXHRcdFx0aWYgKChzZWxmLndyaXRlci5jb250ZXh0KCkucGFnZSArIDEpICUgMiA9PT0gMCkge1xyXG5cdFx0XHRcdHNlbGYud3JpdGVyLm1vdmVUb05leHRQYWdlKG5vZGUucGFnZU9yaWVudGF0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGlzRGV0YWNoZWRCbG9jayA9IG5vZGUucmVsYXRpdmVQb3NpdGlvbiB8fCBub2RlLmFic29sdXRlUG9zaXRpb247XHJcblxyXG5cdFx0Ly8gRGV0YWNoZWQgbm9kZXMgaGF2ZSBubyBtYXJnaW5zLCB0aGVpciBwb3NpdGlvbiBpcyBvbmx5IGRldGVybWluZWQgYnkgJ3gnIGFuZCAneSdcclxuXHRcdGlmIChtYXJnaW4gJiYgIWlzRGV0YWNoZWRCbG9jaykge1xyXG5cdFx0XHRjb25zdCBhdmFpbGFibGVIZWlnaHQgPSBzZWxmLndyaXRlci5jb250ZXh0KCkuYXZhaWxhYmxlSGVpZ2h0O1xyXG5cdFx0XHQvLyBJZiB0b3AgbWFyZ2luIGlzIGJpZ2dlciB0aGFuIGF2YWlsYWJsZSBzcGFjZSwgbW92ZSB0byBuZXh0IHBhZ2VcclxuXHRcdFx0Ly8gTmVjZXNzYXJ5IGZvciBub2RlcyBpbnNpZGUgdGFibGVzXHJcblx0XHRcdGlmIChhdmFpbGFibGVIZWlnaHQgLSBtYXJnaW5bMV0gPCAwKSB7XHJcblx0XHRcdFx0Ly8gQ29uc3VtZSB0aGUgd2hvbGUgYXZhaWxhYmxlIHNwYWNlXHJcblx0XHRcdFx0c2VsZi53cml0ZXIuY29udGV4dCgpLm1vdmVEb3duKGF2YWlsYWJsZUhlaWdodCk7XHJcblx0XHRcdFx0c2VsZi53cml0ZXIubW92ZVRvTmV4dFBhZ2Uobm9kZS5wYWdlT3JpZW50YXRpb24pO1xyXG5cdFx0XHRcdC8qKlxyXG5cdFx0XHRcdCAqIFRPRE8gLSBTb21ldGhpbmcgdG8gY29uc2lkZXI6XHJcblx0XHRcdFx0ICogUmlnaHQgbm93IHRoZSBub2RlIHN0YXJ0cyBhdCB0aGUgdG9wIG9mIG5leHQgcGFnZSAoYWZ0ZXIgaGVhZGVyKVxyXG5cdFx0XHRcdCAqIEFub3RoZXIgb3B0aW9uIHdvdWxkIGJlIHRvIGFwcGx5IGp1c3QgdGhlIHRvcCBtYXJnaW4gdGhhdCBoYXMgbm90IGJlZW4gY29uc3VtZWQgaW4gdGhlIHBhZ2UgYmVmb3JlXHJcblx0XHRcdFx0ICogSXQgd291bGQgc29tZXRoaW5nIGxpa2U6IHRoaXMud3JpdGUuY29udGV4dCgpLm1vdmVEb3duKG1hcmdpblsxXSAtIGF2YWlsYWJsZUhlaWdodClcclxuXHRcdFx0XHQgKi9cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzZWxmLndyaXRlci5jb250ZXh0KCkubW92ZURvd24obWFyZ2luWzFdKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQXBwbHkgbGF0ZXJhbCBtYXJnaW5zXHJcblx0XHRcdHNlbGYud3JpdGVyLmNvbnRleHQoKS5hZGRNYXJnaW4obWFyZ2luWzBdLCBtYXJnaW5bMl0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNhbGxiYWNrKCk7XHJcblxyXG5cdFx0Ly8gRGV0YWNoZWQgbm9kZXMgaGF2ZSBubyBtYXJnaW5zLCB0aGVpciBwb3NpdGlvbiBpcyBvbmx5IGRldGVybWluZWQgYnkgJ3gnIGFuZCAneSdcclxuXHRcdGlmIChtYXJnaW4gJiYgIWlzRGV0YWNoZWRCbG9jaykge1xyXG5cdFx0XHRjb25zdCBhdmFpbGFibGVIZWlnaHQgPSBzZWxmLndyaXRlci5jb250ZXh0KCkuYXZhaWxhYmxlSGVpZ2h0O1xyXG5cdFx0XHQvLyBJZiBib3R0b20gbWFyZ2luIGlzIGJpZ2dlciB0aGFuIGF2YWlsYWJsZSBzcGFjZSwgbW92ZSB0byBuZXh0IHBhZ2VcclxuXHRcdFx0Ly8gTmVjZXNzYXJ5IGZvciBub2RlcyBpbnNpZGUgdGFibGVzXHJcblx0XHRcdGlmIChhdmFpbGFibGVIZWlnaHQgLSBtYXJnaW5bM10gPCAwKSB7XHJcblx0XHRcdFx0c2VsZi53cml0ZXIuY29udGV4dCgpLm1vdmVEb3duKGF2YWlsYWJsZUhlaWdodCk7XHJcblx0XHRcdFx0c2VsZi53cml0ZXIubW92ZVRvTmV4dFBhZ2Uobm9kZS5wYWdlT3JpZW50YXRpb24pO1xyXG5cdFx0XHRcdC8qKlxyXG5cdFx0XHRcdCAqIFRPRE8gLSBTb21ldGhpbmcgdG8gY29uc2lkZXI6XHJcblx0XHRcdFx0ICogUmlnaHQgbm93IG5leHQgbm9kZSBzdGFydHMgYXQgdGhlIHRvcCBvZiBuZXh0IHBhZ2UgKGFmdGVyIGhlYWRlcilcclxuXHRcdFx0XHQgKiBBbm90aGVyIG9wdGlvbiB3b3VsZCBiZSB0byBhcHBseSB0aGUgYm90dG9tIG1hcmdpbiB0aGF0IGhhcyBub3QgYmVlbiBjb25zdW1lZCBpbiB0aGUgbmV4dCBwYWdlP1xyXG5cdFx0XHRcdCAqIEl0IHdvdWxkIHNvbWV0aGluZyBsaWtlOiB0aGlzLndyaXRlLmNvbnRleHQoKS5tb3ZlRG93bihtYXJnaW5bM10gLSBhdmFpbGFibGVIZWlnaHQpXHJcblx0XHRcdFx0ICovXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c2VsZi53cml0ZXIuY29udGV4dCgpLm1vdmVEb3duKG1hcmdpblszXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEFwcGx5IGxhdGVyYWwgbWFyZ2luc1xyXG5cdFx0XHRzZWxmLndyaXRlci5jb250ZXh0KCkuYWRkTWFyZ2luKC1tYXJnaW5bMF0sIC1tYXJnaW5bMl0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChub2RlLnBhZ2VCcmVhayA9PT0gJ2FmdGVyJykge1xyXG5cdFx0XHRzZWxmLndyaXRlci5tb3ZlVG9OZXh0UGFnZShub2RlLnBhZ2VPcmllbnRhdGlvbik7XHJcblx0XHR9IGVsc2UgaWYgKG5vZGUucGFnZUJyZWFrID09PSAnYWZ0ZXJPZGQnKSB7XHJcblx0XHRcdHNlbGYud3JpdGVyLm1vdmVUb05leHRQYWdlKG5vZGUucGFnZU9yaWVudGF0aW9uKTtcclxuXHRcdFx0aWYgKChzZWxmLndyaXRlci5jb250ZXh0KCkucGFnZSArIDEpICUgMiA9PT0gMSkge1xyXG5cdFx0XHRcdHNlbGYud3JpdGVyLm1vdmVUb05leHRQYWdlKG5vZGUucGFnZU9yaWVudGF0aW9uKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChub2RlLnBhZ2VCcmVhayA9PT0gJ2FmdGVyRXZlbicpIHtcclxuXHRcdFx0c2VsZi53cml0ZXIubW92ZVRvTmV4dFBhZ2Uobm9kZS5wYWdlT3JpZW50YXRpb24pO1xyXG5cdFx0XHRpZiAoKHNlbGYud3JpdGVyLmNvbnRleHQoKS5wYWdlICsgMSkgJSAyID09PSAwKSB7XHJcblx0XHRcdFx0c2VsZi53cml0ZXIubW92ZVRvTmV4dFBhZ2Uobm9kZS5wYWdlT3JpZW50YXRpb24pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuLy8gdmVydGljYWwgY29udGFpbmVyXHJcbkxheW91dEJ1aWxkZXIucHJvdG90eXBlLnByb2Nlc3NWZXJ0aWNhbENvbnRhaW5lciA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdG5vZGUuc3RhY2suZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG5cdFx0c2VsZi5wcm9jZXNzTm9kZShpdGVtKTtcclxuXHRcdGFkZEFsbChub2RlLnBvc2l0aW9ucywgaXRlbS5wb3NpdGlvbnMpO1xyXG5cclxuXHRcdC8vVE9ETzogcGFyYWdyYXBoIGdhcFxyXG5cdH0pO1xyXG59O1xyXG5cclxuLy8gY29sdW1uc1xyXG5MYXlvdXRCdWlsZGVyLnByb3RvdHlwZS5wcm9jZXNzQ29sdW1ucyA9IGZ1bmN0aW9uIChjb2x1bW5Ob2RlKSB7XHJcblx0dGhpcy5uZXN0ZWRMZXZlbCsrO1xyXG5cdHZhciBjb2x1bW5zID0gY29sdW1uTm9kZS5jb2x1bW5zO1xyXG5cdHZhciBhdmFpbGFibGVXaWR0aCA9IHRoaXMud3JpdGVyLmNvbnRleHQoKS5hdmFpbGFibGVXaWR0aDtcclxuXHR2YXIgZ2FwcyA9IGdhcEFycmF5KGNvbHVtbk5vZGUuX2dhcCk7XHJcblxyXG5cdGlmIChnYXBzKSB7XHJcblx0XHRhdmFpbGFibGVXaWR0aCAtPSAoZ2Fwcy5sZW5ndGggLSAxKSAqIGNvbHVtbk5vZGUuX2dhcDtcclxuXHR9XHJcblxyXG5cdENvbHVtbkNhbGN1bGF0b3IuYnVpbGRDb2x1bW5XaWR0aHMoY29sdW1ucywgYXZhaWxhYmxlV2lkdGgpO1xyXG5cdHZhciByZXN1bHQgPSB0aGlzLnByb2Nlc3NSb3coe1xyXG5cdFx0bWFyZ2luWDogY29sdW1uTm9kZS5fbWFyZ2luID8gW2NvbHVtbk5vZGUuX21hcmdpblswXSwgY29sdW1uTm9kZS5fbWFyZ2luWzJdXSA6IFswLCAwXSxcclxuXHRcdGNlbGxzOiBjb2x1bW5zLFxyXG5cdFx0d2lkdGhzOiBjb2x1bW5zLFxyXG5cdFx0Z2Fwc1xyXG5cdH0pO1xyXG5cdGFkZEFsbChjb2x1bW5Ob2RlLnBvc2l0aW9ucywgcmVzdWx0LnBvc2l0aW9ucyk7XHJcblxyXG5cdHRoaXMubmVzdGVkTGV2ZWwtLTtcclxuXHRpZiAodGhpcy5uZXN0ZWRMZXZlbCA9PT0gMCkge1xyXG5cdFx0dGhpcy53cml0ZXIuY29udGV4dCgpLnJlc2V0TWFyZ2luWFRvcFBhcmVudCgpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2FwQXJyYXkoZ2FwKSB7XHJcblx0XHRpZiAoIWdhcCkge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZ2FwcyA9IFtdO1xyXG5cdFx0Z2Fwcy5wdXNoKDApO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSBjb2x1bW5zLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcclxuXHRcdFx0Z2Fwcy5wdXNoKGdhcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdhcHM7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNlYXJjaGVzIGZvciBhIGNlbGwgaW4gdGhlIHNhbWUgcm93IHRoYXQgc3RhcnRzIGEgcm93c3BhbiBhbmQgaXMgcG9zaXRpb25lZCBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGN1cnJlbnQgY2VsbC5cclxuICogQWx0ZXJuYXRpdmVseSwgaXQgZmluZHMgYSBjZWxsIHdoZXJlIHRoZSBjb2xzcGFuIGluaXRpYXRpbmcgdGhlIHJvd3NwYW4gZXh0ZW5kcyB0byB0aGUgY2VsbCBqdXN0IGJlZm9yZSB0aGUgY3VycmVudCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gYXJyIC0gQW4gYXJyYXkgcmVwcmVzZW50aW5nIGNlbGxzIGluIGEgcm93LlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaSAtIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjZWxsIHRvIHNlYXJjaCBiYWNrd2FyZCBmcm9tLlxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fG51bGx9IFRoZSBzdGFydGluZyBjZWxsIG9mIHRoZSByb3dzcGFuIGlmIGZvdW5kOyBvdGhlcndpc2UsIGBudWxsYC5cclxuICovXHJcbkxheW91dEJ1aWxkZXIucHJvdG90eXBlLl9maW5kU3RhcnRpbmdSb3dTcGFuQ2VsbCA9IGZ1bmN0aW9uIChhcnIsIGkpIHtcclxuXHR2YXIgcmVxdWlyZWRDb2xzcGFuID0gMTtcclxuXHRmb3IgKHZhciBpbmRleCA9IGkgLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XHJcblx0XHRpZiAoIWFycltpbmRleF0uX3NwYW4pIHtcclxuXHRcdFx0aWYgKGFycltpbmRleF0ucm93U3BhbiA+IDEgJiYgKGFycltpbmRleF0uY29sU3BhbiB8fCAxKSA9PT0gcmVxdWlyZWRDb2xzcGFuKSB7XHJcblx0XHRcdFx0cmV0dXJuIGFycltpbmRleF07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJlcXVpcmVkQ29sc3BhbisrO1xyXG5cdH1cclxuXHRyZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgYSBwYWdlIGJyZWFrIGRlc2NyaXB0aW9uIGZvciBhIHNwZWNpZmllZCBwYWdlIGZyb20gYSBsaXN0IG9mIHBhZ2UgYnJlYWtzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5PG9iamVjdD59IHBhZ2VCcmVha3MgLSBBbiBhcnJheSBvZiBwYWdlIGJyZWFrIGRlc2NyaXB0aW9ucywgZWFjaCBjb250YWluaW5nIGBwcmV2UGFnZWAgcHJvcGVydGllcy5cclxuICogQHBhcmFtIHtudW1iZXJ9IHBhZ2UgLSBUaGUgcGFnZSBudW1iZXIgdG8gZmluZCB0aGUgYXNzb2NpYXRlZCBwYWdlIGJyZWFrIGZvci5cclxuICogQHJldHVybnMge29iamVjdHx1bmRlZmluZWR9IFRoZSBwYWdlIGJyZWFrIGRlc2NyaXB0aW9uIG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCBwYWdlIGlmIGZvdW5kOyBvdGhlcndpc2UsIGB1bmRlZmluZWRgLlxyXG4gKi9cclxuTGF5b3V0QnVpbGRlci5wcm90b3R5cGUuX2dldFBhZ2VCcmVhayA9IGZ1bmN0aW9uIChwYWdlQnJlYWtzLCBwYWdlKSB7XHJcblx0cmV0dXJuIHBhZ2VCcmVha3MuZmluZChkZXNjID0+IGRlc2MucHJldlBhZ2UgPT09IHBhZ2UpO1xyXG59O1xyXG5cclxuTGF5b3V0QnVpbGRlci5wcm90b3R5cGUuX2dldFBhZ2VCcmVha0xpc3RCeVNwYW4gPSBmdW5jdGlvbiAodGFibGVOb2RlLCBwYWdlLCByb3dJbmRleCkge1xyXG5cdGlmICghdGFibGVOb2RlIHx8ICF0YWJsZU5vZGUuX2JyZWFrc0J5U3Bhbikge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdGNvbnN0IGJyZWFrc0xpc3QgPSB0YWJsZU5vZGUuX2JyZWFrc0J5U3Bhbi5maWx0ZXIoZGVzYyA9PiBkZXNjLnByZXZQYWdlID09PSBwYWdlICYmIHJvd0luZGV4IDw9IGRlc2Mucm93SW5kZXhPZlNwYW5FbmQpO1xyXG5cclxuXHR2YXIgeSA9IE51bWJlci5NQVhfVkFMVUUsXHJcblx0XHRwcmV2WSA9IE51bWJlci5NSU5fVkFMVUU7XHJcblxyXG5cdGJyZWFrc0xpc3QuZm9yRWFjaChiID0+IHtcclxuXHRcdHByZXZZID0gTWF0aC5tYXgoYi5wcmV2WSwgcHJldlkpO1xyXG5cdFx0eSA9IE1hdGgubWluKGIueSwgeSk7XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHRwcmV2UGFnZTogcGFnZSxcclxuXHRcdHByZXZZOiBwcmV2WSxcclxuXHRcdHk6IHlcclxuXHR9O1xyXG59O1xyXG5cclxuTGF5b3V0QnVpbGRlci5wcm90b3R5cGUuX2ZpbmRTYW1lUm93UGFnZUJyZWFrQnlSb3dTcGFuRGF0YSA9IGZ1bmN0aW9uIChicmVha3NCeVNwYW4sIHBhZ2UsIHJvd0luZGV4KSB7XHJcblx0aWYgKCFicmVha3NCeVNwYW4pIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRyZXR1cm4gYnJlYWtzQnlTcGFuLmZpbmQoZGVzYyA9PiBkZXNjLnByZXZQYWdlID09PSBwYWdlICYmIHJvd0luZGV4ID09PSBkZXNjLnJvd0luZGV4T2ZTcGFuRW5kKTtcclxufTtcclxuXHJcbkxheW91dEJ1aWxkZXIucHJvdG90eXBlLl91cGRhdGVQYWdlQnJlYWtzRGF0YSA9IGZ1bmN0aW9uIChwYWdlQnJlYWtzLCB0YWJsZU5vZGUsIHJvd0luZGV4KSB7XHJcblx0T2JqZWN0LmtleXModGFibGVOb2RlLl9ib3R0b21CeVBhZ2UpLmZvckVhY2gocCA9PiB7XHJcblx0XHRjb25zdCBwYWdlID0gTnVtYmVyKHApO1xyXG5cdFx0Y29uc3QgcGFnZUJyZWFrID0gdGhpcy5fZ2V0UGFnZUJyZWFrKHBhZ2VCcmVha3MsIHBhZ2UpO1xyXG5cdFx0aWYgKHBhZ2VCcmVhaykge1xyXG5cdFx0XHRwYWdlQnJlYWsucHJldlkgPSBNYXRoLm1heChwYWdlQnJlYWsucHJldlksIHRhYmxlTm9kZS5fYm90dG9tQnlQYWdlW3BhZ2VdKTtcclxuXHRcdH1cclxuXHRcdGlmICh0YWJsZU5vZGUuX2JyZWFrc0J5U3BhbiAmJiB0YWJsZU5vZGUuX2JyZWFrc0J5U3Bhbi5sZW5ndGggPiAwKSB7XHJcblx0XHRcdGNvbnN0IGJyZWFrc0J5U3Bhbkxpc3QgPSB0YWJsZU5vZGUuX2JyZWFrc0J5U3Bhbi5maWx0ZXIocGIgPT4gcGIucHJldlBhZ2UgPT09IHBhZ2UgJiYgcm93SW5kZXggPD0gcGIucm93SW5kZXhPZlNwYW5FbmQpO1xyXG5cdFx0XHRpZiAoYnJlYWtzQnlTcGFuTGlzdCAmJiBicmVha3NCeVNwYW5MaXN0Lmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRicmVha3NCeVNwYW5MaXN0LmZvckVhY2goYiA9PiB7XHJcblx0XHRcdFx0XHRiLnByZXZZID0gTWF0aC5tYXgoYi5wcmV2WSwgdGFibGVOb2RlLl9ib3R0b21CeVBhZ2VbcGFnZV0pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVzb2x2ZXMgdGhlIFktY29vcmRpbmF0ZXMgZm9yIGEgdGFyZ2V0IG9iamVjdCBieSBjb21wYXJpbmcgdHdvIGJyZWFrIHBvaW50cy5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IGJyZWFrMSAtIFRoZSBmaXJzdCBicmVhayBwb2ludCB3aXRoIGBwcmV2WWAgYW5kIGB5YCBwcm9wZXJ0aWVzLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gYnJlYWsyIC0gVGhlIHNlY29uZCBicmVhayBwb2ludCB3aXRoIGBwcmV2WWAgYW5kIGB5YCBwcm9wZXJ0aWVzLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgdG8gYmUgdXBkYXRlZCB3aXRoIHJlc29sdmVkIFktY29vcmRpbmF0ZXMuXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0YXJnZXQucHJldlkgLSBVcGRhdGVkIHRvIHRoZSBtYXhpbXVtIGBwcmV2WWAgdmFsdWUgYmV0d2VlbiBgYnJlYWsxYCBhbmQgYGJyZWFrMmAuXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0YXJnZXQueSAtIFVwZGF0ZWQgdG8gdGhlIG1pbmltdW0gYHlgIHZhbHVlIGJldHdlZW4gYGJyZWFrMWAgYW5kIGBicmVhazJgLlxyXG4gKi9cclxuTGF5b3V0QnVpbGRlci5wcm90b3R5cGUuX3Jlc29sdmVCcmVha1kgPSBmdW5jdGlvbiAoYnJlYWsxLCBicmVhazIsIHRhcmdldCkge1xyXG5cdHRhcmdldC5wcmV2WSA9IE1hdGgubWF4KGJyZWFrMS5wcmV2WSwgYnJlYWsyLnByZXZZKTtcclxuXHR0YXJnZXQueSA9IE1hdGgubWluKGJyZWFrMS55LCBicmVhazIueSk7XHJcbn07XHJcblxyXG5MYXlvdXRCdWlsZGVyLnByb3RvdHlwZS5fc3RvcmVQYWdlQnJlYWtEYXRhID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0c1Jvd1NwYW4sIHBhZ2VCcmVha3MsIHRhYmxlTm9kZSkge1xyXG5cdHZhciBwYWdlRGVzYztcclxuXHR2YXIgcGFnZURlc2NCeVNwYW47XHJcblxyXG5cdGlmICghc3RhcnRzUm93U3Bhbikge1xyXG5cdFx0cGFnZURlc2MgPSB0aGlzLl9nZXRQYWdlQnJlYWsocGFnZUJyZWFrcywgZGF0YS5wcmV2UGFnZSk7XHJcblx0XHRwYWdlRGVzY0J5U3BhbiA9IHRoaXMuX2dldFBhZ2VCcmVha0xpc3RCeVNwYW4odGFibGVOb2RlLCBkYXRhLnByZXZQYWdlLCBkYXRhLnJvd0luZGV4KTtcclxuXHRcdGlmICghcGFnZURlc2MpIHtcclxuXHRcdFx0cGFnZURlc2MgPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhKTtcclxuXHRcdFx0cGFnZUJyZWFrcy5wdXNoKHBhZ2VEZXNjKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAocGFnZURlc2NCeVNwYW4pIHtcclxuXHRcdFx0dGhpcy5fcmVzb2x2ZUJyZWFrWShwYWdlRGVzYywgcGFnZURlc2NCeVNwYW4sIHBhZ2VEZXNjKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3Jlc29sdmVCcmVha1kocGFnZURlc2MsIGRhdGEsIHBhZ2VEZXNjKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIGJyZWFrc0J5U3BhbiA9IHRhYmxlTm9kZSAmJiB0YWJsZU5vZGUuX2JyZWFrc0J5U3BhbiB8fCBudWxsO1xyXG5cdFx0cGFnZURlc2NCeVNwYW4gPSB0aGlzLl9maW5kU2FtZVJvd1BhZ2VCcmVha0J5Um93U3BhbkRhdGEoYnJlYWtzQnlTcGFuLCBkYXRhLnByZXZQYWdlLCBkYXRhLnJvd0luZGV4KTtcclxuXHRcdGlmICghcGFnZURlc2NCeVNwYW4pIHtcclxuXHRcdFx0cGFnZURlc2NCeVNwYW4gPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XHJcblx0XHRcdFx0cm93SW5kZXhPZlNwYW5FbmQ6IGRhdGEucm93SW5kZXggKyBkYXRhLnJvd1NwYW4gLSAxXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpZiAoIXRhYmxlTm9kZS5fYnJlYWtzQnlTcGFuKSB7XHJcblx0XHRcdFx0dGFibGVOb2RlLl9icmVha3NCeVNwYW4gPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0YWJsZU5vZGUuX2JyZWFrc0J5U3Bhbi5wdXNoKHBhZ2VEZXNjQnlTcGFuKTtcclxuXHRcdH1cclxuXHRcdHBhZ2VEZXNjQnlTcGFuLnByZXZZID0gTWF0aC5tYXgocGFnZURlc2NCeVNwYW4ucHJldlksIGRhdGEucHJldlkpO1xyXG5cdFx0cGFnZURlc2NCeVNwYW4ueSA9IE1hdGgubWluKHBhZ2VEZXNjQnlTcGFuLnksIGRhdGEueSk7XHJcblx0XHRwYWdlRGVzYyA9IHRoaXMuX2dldFBhZ2VCcmVhayhwYWdlQnJlYWtzLCBkYXRhLnByZXZQYWdlKTtcclxuXHRcdGlmIChwYWdlRGVzYykge1xyXG5cdFx0XHR0aGlzLl9yZXNvbHZlQnJlYWtZKHBhZ2VEZXNjLCBwYWdlRGVzY0J5U3BhbiwgcGFnZURlc2MpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZWZ0IG9mZnNldCBmb3IgYSBjb2x1bW4gYmFzZWQgb24gdGhlIHNwZWNpZmllZCBnYXAgdmFsdWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaSAtIFRoZSBpbmRleCBvZiB0aGUgY29sdW1uIGZvciB3aGljaCB0aGUgb2Zmc2V0IGlzIGJlaW5nIGNhbGN1bGF0ZWQuXHJcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gZ2FwcyAtIEFuIGFycmF5IG9mIGdhcCB2YWx1ZXMgZm9yIGVhY2ggY29sdW1uLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbGVmdCBvZmZzZXQgZm9yIHRoZSBjb2x1bW4uIFJldHVybnMgYGdhcHNbaV1gIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIGAwYC5cclxuICovXHJcbkxheW91dEJ1aWxkZXIucHJvdG90eXBlLl9jb2xMZWZ0T2Zmc2V0ID0gZnVuY3Rpb24gKGksIGdhcHMpIHtcclxuXHRpZiAoZ2FwcyAmJiBnYXBzLmxlbmd0aCA+IGkpIHtcclxuXHRcdHJldHVybiBnYXBzW2ldO1xyXG5cdH1cclxuXHRyZXR1cm4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgdGhlIGVuZGluZyBjZWxsIGZvciBhIHJvdyBzcGFuIGluIGNhc2UgaXQgZXhpc3RzIGluIGEgc3BlY2lmaWVkIHRhYmxlIGNvbHVtbi5cclxuICpcclxuICogQHBhcmFtIHtBcnJheTxBcnJheTxvYmplY3Q+Pn0gdGFibGVCb2R5IC0gVGhlIHRhYmxlIGJvZHksIHJlcHJlc2VudGVkIGFzIGEgMkQgYXJyYXkgb2YgY2VsbCBvYmplY3RzLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHN0YXJ0aW5nIHJvdyBmb3IgdGhlIHJvdyBzcGFuLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gY29sdW1uIC0gVGhlIGNvbHVtbiBvYmplY3QgY29udGFpbmluZyByb3cgc3BhbiBpbmZvcm1hdGlvbi5cclxuICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gd2l0aGluIHRoZSByb3cuXHJcbiAqIEByZXR1cm5zIHtvYmplY3R8bnVsbH0gVGhlIGNlbGwgYXQgdGhlIGVuZCBvZiB0aGUgcm93IHNwYW4gaWYgaXQgZXhpc3RzOyBvdGhlcndpc2UsIGBudWxsYC5cclxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSByb3cgc3BhbiBleHRlbmRzIGJleW9uZCB0aGUgdG90YWwgcm93IGNvdW50LlxyXG4gKi9cclxuTGF5b3V0QnVpbGRlci5wcm90b3R5cGUuX2dldFJvd1NwYW5FbmRpbmdDZWxsID0gZnVuY3Rpb24gKHRhYmxlQm9keSwgcm93SW5kZXgsIGNvbHVtbiwgY29sdW1uSW5kZXgpIHtcclxuXHRpZiAoY29sdW1uLnJvd1NwYW4gJiYgY29sdW1uLnJvd1NwYW4gPiAxKSB7XHJcblx0XHR2YXIgZW5kaW5nUm93ID0gcm93SW5kZXggKyBjb2x1bW4ucm93U3BhbiAtIDE7XHJcblx0XHRpZiAoZW5kaW5nUm93ID49IHRhYmxlQm9keS5sZW5ndGgpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBSb3cgc3BhbiBmb3IgY29sdW1uICR7Y29sdW1uSW5kZXh9ICh3aXRoIGluZGV4ZXMgc3RhcnRpbmcgZnJvbSAwKSBleGNlZWRlZCByb3cgY291bnRgKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0YWJsZUJvZHlbZW5kaW5nUm93XVtjb2x1bW5JbmRleF07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbkxheW91dEJ1aWxkZXIucHJvdG90eXBlLnByb2Nlc3NSb3cgPSBmdW5jdGlvbiAoeyBtYXJnaW5YID0gWzAsIDBdLCBkb250QnJlYWtSb3dzID0gZmFsc2UsIHJvd3NXaXRob3V0UGFnZUJyZWFrID0gMCwgY2VsbHMsIHdpZHRocywgZ2FwcywgdGFibGVOb2RlLCB0YWJsZUJvZHksIHJvd0luZGV4LCBoZWlnaHQgfSkge1xyXG5cdHZhciBzZWxmID0gdGhpcztcclxuXHR2YXIgaXNVbmJyZWFrYWJsZVJvdyA9IGRvbnRCcmVha1Jvd3MgfHwgcm93SW5kZXggPD0gcm93c1dpdGhvdXRQYWdlQnJlYWsgLSAxO1xyXG5cdHZhciBwYWdlQnJlYWtzID0gW107XHJcblx0dmFyIHBhZ2VCcmVha3NCeVJvd1NwYW4gPSBbXTtcclxuXHR2YXIgcG9zaXRpb25zID0gW107XHJcblx0dmFyIHdpbGxCcmVha0J5SGVpZ2h0ID0gZmFsc2U7XHJcblx0d2lkdGhzID0gd2lkdGhzIHx8IGNlbGxzO1xyXG5cclxuXHQvLyBDaGVjayBpZiByb3cgc2hvdWxkIGJyZWFrIGJ5IGhlaWdodFxyXG5cdGlmICghaXNVbmJyZWFrYWJsZVJvdyAmJiBoZWlnaHQgPiBzZWxmLndyaXRlci5jb250ZXh0KCkuYXZhaWxhYmxlSGVpZ2h0KSB7XHJcblx0XHR3aWxsQnJlYWtCeUhlaWdodCA9IHRydWU7XHJcblx0fVxyXG5cclxuXHQvLyBVc2UgdGhlIG1hcmdpblggaWYgd2UgYXJlIGluIGEgdG9wIGxldmVsIHRhYmxlL2NvbHVtbiAobm90IG5lc3RlZClcclxuXHRjb25zdCBtYXJnaW5YUGFyZW50ID0gc2VsZi5uZXN0ZWRMZXZlbCA9PT0gMSA/IG1hcmdpblggOiBudWxsO1xyXG5cdGNvbnN0IF9ib3R0b21CeVBhZ2UgPSB0YWJsZU5vZGUgPyB0YWJsZU5vZGUuX2JvdHRvbUJ5UGFnZSA6IG51bGw7XHJcblx0dGhpcy53cml0ZXIuY29udGV4dCgpLmJlZ2luQ29sdW1uR3JvdXAobWFyZ2luWFBhcmVudCwgX2JvdHRvbUJ5UGFnZSk7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsID0gY2VsbHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHR2YXIgY2VsbCA9IGNlbGxzW2ldO1xyXG5cclxuXHRcdC8vIFBhZ2UgY2hhbmdlIGhhbmRsZXJcclxuXHJcblx0XHR0aGlzLnRyYWNrZXIuYXV0bygncGFnZUNoYW5nZWQnLCBzdG9yZVBhZ2VCcmVha0Nsb3N1cmUsIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyIHdpZHRoID0gd2lkdGhzW2ldLl9jYWxjV2lkdGg7XHJcblx0XHRcdHZhciBsZWZ0T2Zmc2V0ID0gc2VsZi5fY29sTGVmdE9mZnNldChpLCBnYXBzKTtcclxuXHRcdFx0Ly8gQ2hlY2sgaWYgZXhpc3RzIGFuZCByZXRyaWV2ZSB0aGUgY2VsbCB0aGF0IHN0YXJ0ZWQgdGhlIHJvd3NwYW4gaW4gY2FzZSB3ZSBhcmUgaW4gdGhlIGNlbGwganVzdCBhZnRlclxyXG5cdFx0XHR2YXIgc3RhcnRpbmdTcGFuQ2VsbCA9IHNlbGYuX2ZpbmRTdGFydGluZ1Jvd1NwYW5DZWxsKGNlbGxzLCBpKTtcclxuXHJcblx0XHRcdGlmIChjZWxsLmNvbFNwYW4gJiYgY2VsbC5jb2xTcGFuID4gMSkge1xyXG5cdFx0XHRcdGZvciAodmFyIGogPSAxOyBqIDwgY2VsbC5jb2xTcGFuOyBqKyspIHtcclxuXHRcdFx0XHRcdHdpZHRoICs9IHdpZHRoc1srK2ldLl9jYWxjV2lkdGggKyBnYXBzW2ldO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gaWYgcm93c3BhbiBzdGFydHMgaW4gdGhpcyBjZWxsLCB3ZSByZXRyaWV2ZSB0aGUgbGFzdCBjZWxsIGFmZmVjdGVkIGJ5IHRoZSByb3dzcGFuXHJcblx0XHRcdGNvbnN0IHJvd1NwYW5FbmRpbmdDZWxsID0gc2VsZi5fZ2V0Um93U3BhbkVuZGluZ0NlbGwodGFibGVCb2R5LCByb3dJbmRleCwgY2VsbCwgaSk7XHJcblx0XHRcdGlmIChyb3dTcGFuRW5kaW5nQ2VsbCkge1xyXG5cdFx0XHRcdC8vIFdlIHN0b3JlIGEgcmVmZXJlbmNlIG9mIHRoZSBlbmRpbmcgY2VsbCBpbiB0aGUgZmlyc3QgY2VsbCBvZiB0aGUgcm93c3BhblxyXG5cdFx0XHRcdGNlbGwuX2VuZGluZ0NlbGwgPSByb3dTcGFuRW5kaW5nQ2VsbDtcclxuXHRcdFx0XHRjZWxsLl9lbmRpbmdDZWxsLl9zdGFydGluZ1Jvd1NwYW5ZID0gY2VsbC5fc3RhcnRpbmdSb3dTcGFuWTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gSWYgd2UgYXJlIGFmdGVyIGEgY2VsbCB0aGF0IHN0YXJ0ZWQgYSByb3dzcGFuXHJcblx0XHRcdHZhciBlbmRPZlJvd1NwYW5DZWxsID0gbnVsbDtcclxuXHRcdFx0aWYgKHN0YXJ0aW5nU3BhbkNlbGwgJiYgc3RhcnRpbmdTcGFuQ2VsbC5fZW5kaW5nQ2VsbCkge1xyXG5cdFx0XHRcdC8vIFJlZmVyZW5jZSB0byB0aGUgbGFzdCBjZWxsIG9mIHRoZSByb3dzcGFuXHJcblx0XHRcdFx0ZW5kT2ZSb3dTcGFuQ2VsbCA9IHN0YXJ0aW5nU3BhbkNlbGwuX2VuZGluZ0NlbGw7XHJcblx0XHRcdFx0Ly8gU3RvcmUgaWYgd2UgYXJlIGluIGFuIHVuYnJlYWthYmxlIGJsb2NrIHdoZW4gd2Ugc2F2ZSB0aGUgY29udGV4dCBhbmQgdGhlIG9yaWdpbmFsWFxyXG5cdFx0XHRcdGlmIChzZWxmLndyaXRlci50cmFuc2FjdGlvbkxldmVsID4gMCkge1xyXG5cdFx0XHRcdFx0ZW5kT2ZSb3dTcGFuQ2VsbC5faXNVbmJyZWFrYWJsZUNvbnRleHQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0ZW5kT2ZSb3dTcGFuQ2VsbC5fb3JpZ2luYWxYT2Zmc2V0ID0gc2VsZi53cml0ZXIub3JpZ2luYWxYO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gV2UgcGFzcyB0aGUgZW5kaW5nU3BhbkNlbGwgcmVmZXJlbmNlIHRvIHN0b3JlIHRoZSBjb250ZXh0IGp1c3QgYWZ0ZXIgcHJvY2Vzc2luZyByb3dzcGFuIGNlbGxcclxuXHRcdFx0c2VsZi53cml0ZXIuY29udGV4dCgpLmJlZ2luQ29sdW1uKHdpZHRoLCBsZWZ0T2Zmc2V0LCBlbmRPZlJvd1NwYW5DZWxsKTtcclxuXHJcblx0XHRcdGlmICghY2VsbC5fc3Bhbikge1xyXG5cdFx0XHRcdHNlbGYucHJvY2Vzc05vZGUoY2VsbCk7XHJcblx0XHRcdFx0c2VsZi53cml0ZXIuY29udGV4dCgpLnVwZGF0ZUJvdHRvbUJ5UGFnZSgpO1xyXG5cdFx0XHRcdGFkZEFsbChwb3NpdGlvbnMsIGNlbGwucG9zaXRpb25zKTtcclxuXHRcdFx0fSBlbHNlIGlmIChjZWxsLl9jb2x1bW5FbmRpbmdDb250ZXh0KSB7XHJcblx0XHRcdFx0dmFyIGRpc2NvdW50WSA9IDA7XHJcblx0XHRcdFx0aWYgKGRvbnRCcmVha1Jvd3MpIHtcclxuXHRcdFx0XHRcdC8vIENhbGN1bGF0ZSBob3cgbWFueSBwb2ludHMgd2UgaGF2ZSB0byBkaXNjb3VudCB0byBZIHdoZW4gZG9udEJyZWFrUm93cyBhbmQgcm93U3BhbiBhcmUgY29tYmluZWRcclxuXHRcdFx0XHRcdGNvbnN0IGN0eEJlZm9yZVJvd1NwYW5MYXN0Um93ID0gc2VsZi53cml0ZXIud3JpdGVyLmNvbnRleHRTdGFja1tzZWxmLndyaXRlci53cml0ZXIuY29udGV4dFN0YWNrLmxlbmd0aCAtIDFdO1xyXG5cdFx0XHRcdFx0ZGlzY291bnRZID0gY3R4QmVmb3JlUm93U3Bhbkxhc3RSb3cueSAtIGNlbGwuX3N0YXJ0aW5nUm93U3Bhblk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciBvcmlnaW5hbFhPZmZzZXQgPSAwO1xyXG5cdFx0XHRcdC8vIElmIGNvbnRleHQgd2FzIHNhdmVkIGZyb20gYW4gdW5icmVha2FibGUgYmxvY2sgYW5kIHdlIGFyZSBub3QgaW4gYW4gdW5icmVha2FibGUgYmxvY2sgYW55bW9yZVxyXG5cdFx0XHRcdC8vIFdlIGhhdmUgdG8gc3VtIHRoZSBvcmlnaW5hbFggKFggYmVmb3JlIHN0YXJ0aW5nIHVuYnJlYWthYmxlIGJsb2NrKSB0byBYXHJcblx0XHRcdFx0aWYgKGNlbGwuX2lzVW5icmVha2FibGVDb250ZXh0ICYmICFzZWxmLndyaXRlci50cmFuc2FjdGlvbkxldmVsKSB7XHJcblx0XHRcdFx0XHRvcmlnaW5hbFhPZmZzZXQgPSBjZWxsLl9vcmlnaW5hbFhPZmZzZXQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIHJvdy1zcGFuIGVuZGluZ1xyXG5cdFx0XHRcdC8vIFJlY292ZXIgdGhlIGNvbnRleHQgYWZ0ZXIgcHJvY2Vzc2luZyB0aGUgcm93c3Bhbm5lZCBjZWxsXHJcblx0XHRcdFx0c2VsZi53cml0ZXIuY29udGV4dCgpLm1hcmtFbmRpbmcoY2VsbCwgb3JpZ2luYWxYT2Zmc2V0LCBkaXNjb3VudFkpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8vIENoZWNrIGlmIGxhc3QgY2VsbCBpcyBwYXJ0IG9mIGEgc3BhblxyXG5cdHZhciBlbmRpbmdTcGFuQ2VsbCA9IG51bGw7XHJcblx0dmFyIGxhc3RDb2x1bW4gPSBjZWxscy5sZW5ndGggPiAwID8gY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV0gOiBudWxsO1xyXG5cdGlmIChsYXN0Q29sdW1uKSB7XHJcblx0XHQvLyBQcmV2aW91cyBjb2x1bW4gY2VsbCBoYXMgYSByb3dzcGFuXHJcblx0XHRpZiAobGFzdENvbHVtbi5fZW5kaW5nQ2VsbCkge1xyXG5cdFx0XHRlbmRpbmdTcGFuQ2VsbCA9IGxhc3RDb2x1bW4uX2VuZGluZ0NlbGw7XHJcblx0XHRcdC8vIFByZXZpb3VzIGNvbHVtbiBjZWxsIGlzIHBhcnQgb2YgYSBzcGFuXHJcblx0XHR9IGVsc2UgaWYgKGxhc3RDb2x1bW4uX3NwYW4gPT09IHRydWUpIHtcclxuXHRcdFx0Ly8gV2UgZ2V0IHRoZSBjZWxsIHRoYXQgc3RhcnRlZCB0aGUgc3BhbiB3aGVyZSB3ZSBzZXQgYSByZWZlcmVuY2UgdG8gdGhlIGVuZGluZyBjZWxsXHJcblx0XHRcdGNvbnN0IHN0YXJ0aW5nU3BhbkNlbGwgPSB0aGlzLl9maW5kU3RhcnRpbmdSb3dTcGFuQ2VsbChjZWxscywgY2VsbHMubGVuZ3RoKTtcclxuXHRcdFx0aWYgKHN0YXJ0aW5nU3BhbkNlbGwpIHtcclxuXHRcdFx0XHQvLyBDb250ZXh0IHdpbGwgYmUgc3RvcmVkIGhlcmUgKGVuZGluZyBjZWxsKVxyXG5cdFx0XHRcdGVuZGluZ1NwYW5DZWxsID0gc3RhcnRpbmdTcGFuQ2VsbC5fZW5kaW5nQ2VsbDtcclxuXHRcdFx0XHQvLyBTdG9yZSBpZiB3ZSBhcmUgaW4gYW4gdW5icmVha2FibGUgYmxvY2sgd2hlbiB3ZSBzYXZlIHRoZSBjb250ZXh0IGFuZCB0aGUgb3JpZ2luYWxYXHJcblx0XHRcdFx0aWYgKHRoaXMud3JpdGVyLnRyYW5zYWN0aW9uTGV2ZWwgPiAwKSB7XHJcblx0XHRcdFx0XHRlbmRpbmdTcGFuQ2VsbC5faXNVbmJyZWFrYWJsZUNvbnRleHQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0ZW5kaW5nU3BhbkNlbGwuX29yaWdpbmFsWE9mZnNldCA9IHRoaXMud3JpdGVyLm9yaWdpbmFsWDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIElmIGNvbnRlbnQgZGlkIG5vdCBicmVhayBwYWdlLCBjaGVjayBpZiB3ZSBzaG91bGQgYnJlYWsgYnkgaGVpZ2h0XHJcblx0aWYgKHdpbGxCcmVha0J5SGVpZ2h0ICYmICFpc1VuYnJlYWthYmxlUm93ICYmIHBhZ2VCcmVha3MubGVuZ3RoID09PSAwKSB7XHJcblx0XHR0aGlzLndyaXRlci5jb250ZXh0KCkubW92ZURvd24odGhpcy53cml0ZXIuY29udGV4dCgpLmF2YWlsYWJsZUhlaWdodCk7XHJcblx0XHR0aGlzLndyaXRlci5tb3ZlVG9OZXh0UGFnZSgpO1xyXG5cdH1cclxuXHJcblx0dmFyIGJvdHRvbUJ5UGFnZSA9IHRoaXMud3JpdGVyLmNvbnRleHQoKS5jb21wbGV0ZUNvbHVtbkdyb3VwKGhlaWdodCwgZW5kaW5nU3BhbkNlbGwpO1xyXG5cclxuXHRpZiAodGFibGVOb2RlKSB7XHJcblx0XHR0YWJsZU5vZGUuX2JvdHRvbUJ5UGFnZSA9IGJvdHRvbUJ5UGFnZTtcclxuXHRcdC8vIElmIHRoZXJlIGFyZSBwYWdlIGJyZWFrcyBpbiB0aGlzIHJvdywgdXBkYXRlIGRhdGEgd2l0aCBwcmV2WSBvZiBsYXN0IGNlbGxcclxuXHRcdHRoaXMuX3VwZGF0ZVBhZ2VCcmVha3NEYXRhKHBhZ2VCcmVha3MsIHRhYmxlTm9kZSwgcm93SW5kZXgpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHBhZ2VCcmVha3NCeVNwYW46IHBhZ2VCcmVha3NCeVJvd1NwYW4sXHJcblx0XHRwYWdlQnJlYWtzOiBwYWdlQnJlYWtzLFxyXG5cdFx0cG9zaXRpb25zOiBwb3NpdGlvbnNcclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzdG9yZVBhZ2VCcmVha0Nsb3N1cmUoZGF0YSkge1xyXG5cdFx0Y29uc3Qgc3RhcnRzUm93U3BhbiA9IGNlbGwucm93U3BhbiAmJiBjZWxsLnJvd1NwYW4gPiAxO1xyXG5cdFx0aWYgKHN0YXJ0c1Jvd1NwYW4pIHtcclxuXHRcdFx0ZGF0YS5yb3dTcGFuID0gY2VsbC5yb3dTcGFuO1xyXG5cdFx0fVxyXG5cdFx0ZGF0YS5yb3dJbmRleCA9IHJvd0luZGV4O1xyXG5cdFx0c2VsZi5fc3RvcmVQYWdlQnJlYWtEYXRhKGRhdGEsIHN0YXJ0c1Jvd1NwYW4sIHBhZ2VCcmVha3MsIHRhYmxlTm9kZSk7XHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIGxpc3RzXHJcbkxheW91dEJ1aWxkZXIucHJvdG90eXBlLnByb2Nlc3NMaXN0ID0gZnVuY3Rpb24gKG9yZGVyZWRMaXN0LCBub2RlKSB7XHJcblx0dmFyIHNlbGYgPSB0aGlzLFxyXG5cdFx0aXRlbXMgPSBvcmRlcmVkTGlzdCA/IG5vZGUub2wgOiBub2RlLnVsLFxyXG5cdFx0Z2FwU2l6ZSA9IG5vZGUuX2dhcFNpemU7XHJcblxyXG5cdHRoaXMud3JpdGVyLmNvbnRleHQoKS5hZGRNYXJnaW4oZ2FwU2l6ZS53aWR0aCk7XHJcblxyXG5cdHZhciBuZXh0TWFya2VyO1xyXG5cdHRoaXMudHJhY2tlci5hdXRvKCdsaW5lQWRkZWQnLCBhZGRNYXJrZXJUb0ZpcnN0TGVhZiwgZnVuY3Rpb24gKCkge1xyXG5cdFx0aXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG5cdFx0XHRuZXh0TWFya2VyID0gaXRlbS5saXN0TWFya2VyO1xyXG5cdFx0XHRzZWxmLnByb2Nlc3NOb2RlKGl0ZW0pO1xyXG5cdFx0XHRhZGRBbGwobm9kZS5wb3NpdGlvbnMsIGl0ZW0ucG9zaXRpb25zKTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG5cclxuXHR0aGlzLndyaXRlci5jb250ZXh0KCkuYWRkTWFyZ2luKC1nYXBTaXplLndpZHRoKTtcclxuXHJcblx0ZnVuY3Rpb24gYWRkTWFya2VyVG9GaXJzdExlYWYobGluZSkge1xyXG5cdFx0Ly8gSSdtIG5vdCB2ZXJ5IGhhcHB5IHdpdGggdGhlIHdheSBsaXN0IHByb2Nlc3NpbmcgaXMgaW1wbGVtZW50ZWRcclxuXHRcdC8vIChib3RoIGNvZGUgYW5kIGFsZ29yaXRobSBzaG91bGQgYmUgcmV0aGlua2VkKVxyXG5cdFx0aWYgKG5leHRNYXJrZXIpIHtcclxuXHRcdFx0dmFyIG1hcmtlciA9IG5leHRNYXJrZXI7XHJcblx0XHRcdG5leHRNYXJrZXIgPSBudWxsO1xyXG5cclxuXHRcdFx0aWYgKG1hcmtlci5jYW52YXMpIHtcclxuXHRcdFx0XHR2YXIgdmVjdG9yID0gbWFya2VyLmNhbnZhc1swXTtcclxuXHJcblx0XHRcdFx0b2Zmc2V0VmVjdG9yKHZlY3RvciwgLW1hcmtlci5fbWluV2lkdGgsIDApO1xyXG5cdFx0XHRcdHNlbGYud3JpdGVyLmFkZFZlY3Rvcih2ZWN0b3IpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKG1hcmtlci5faW5saW5lcykge1xyXG5cdFx0XHRcdHZhciBtYXJrZXJMaW5lID0gbmV3IExpbmUoc2VsZi5wYWdlU2l6ZS53aWR0aCk7XHJcblx0XHRcdFx0bWFya2VyTGluZS5hZGRJbmxpbmUobWFya2VyLl9pbmxpbmVzWzBdKTtcclxuXHRcdFx0XHRtYXJrZXJMaW5lLnggPSAtbWFya2VyLl9taW5XaWR0aDtcclxuXHRcdFx0XHRtYXJrZXJMaW5lLnkgPSBsaW5lLmdldEFzY2VuZGVySGVpZ2h0KCkgLSBtYXJrZXJMaW5lLmdldEFzY2VuZGVySGVpZ2h0KCk7XHJcblx0XHRcdFx0c2VsZi53cml0ZXIuYWRkTGluZShtYXJrZXJMaW5lLCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbi8vIHRhYmxlc1xyXG5MYXlvdXRCdWlsZGVyLnByb3RvdHlwZS5wcm9jZXNzVGFibGUgPSBmdW5jdGlvbiAodGFibGVOb2RlKSB7XHJcblx0dGhpcy5uZXN0ZWRMZXZlbCsrO1xyXG5cdHZhciBwcm9jZXNzb3IgPSBuZXcgVGFibGVQcm9jZXNzb3IodGFibGVOb2RlKTtcclxuXHJcblx0cHJvY2Vzc29yLmJlZ2luVGFibGUodGhpcy53cml0ZXIpO1xyXG5cclxuXHR2YXIgcm93SGVpZ2h0cyA9IHRhYmxlTm9kZS50YWJsZS5oZWlnaHRzO1xyXG5cdGZvciAodmFyIGkgPSAwLCBsID0gdGFibGVOb2RlLnRhYmxlLmJvZHkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHQvLyBpZiBkb250QnJlYWtSb3dzIGFuZCByb3cgc3RhcnRzIGEgcm93c3BhblxyXG5cdFx0Ly8gd2Ugc3RvcmUgdGhlICd5JyBvZiB0aGUgYmVnaW5uaW5nIG9mIGVhY2ggcm93U3BhblxyXG5cdFx0aWYgKHByb2Nlc3Nvci5kb250QnJlYWtSb3dzKSB7XHJcblx0XHRcdHRhYmxlTm9kZS50YWJsZS5ib2R5W2ldLmZvckVhY2goY2VsbCA9PiB7XHJcblx0XHRcdFx0aWYgKGNlbGwucm93U3BhbiAmJiBjZWxsLnJvd1NwYW4gPiAxKSB7XHJcblx0XHRcdFx0XHRjZWxsLl9zdGFydGluZ1Jvd1NwYW5ZID0gdGhpcy53cml0ZXIuY29udGV4dCgpLnk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRwcm9jZXNzb3IuYmVnaW5Sb3coaSwgdGhpcy53cml0ZXIpO1xyXG5cclxuXHRcdHZhciBoZWlnaHQ7XHJcblx0XHRpZiAoaXNGdW5jdGlvbihyb3dIZWlnaHRzKSkge1xyXG5cdFx0XHRoZWlnaHQgPSByb3dIZWlnaHRzKGkpO1xyXG5cdFx0fSBlbHNlIGlmIChpc0FycmF5KHJvd0hlaWdodHMpKSB7XHJcblx0XHRcdGhlaWdodCA9IHJvd0hlaWdodHNbaV07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoZWlnaHQgPSByb3dIZWlnaHRzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChoZWlnaHQgPT09ICdhdXRvJykge1xyXG5cdFx0XHRoZWlnaHQgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHBhZ2VCZWZvcmVQcm9jZXNzaW5nID0gdGhpcy53cml0ZXIuY29udGV4dCgpLnBhZ2U7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IHRoaXMucHJvY2Vzc1Jvdyh7XHJcblx0XHRcdG1hcmdpblg6IHRhYmxlTm9kZS5fbWFyZ2luID8gW3RhYmxlTm9kZS5fbWFyZ2luWzBdLCB0YWJsZU5vZGUuX21hcmdpblsyXV0gOiBbMCwgMF0sXHJcblx0XHRcdGRvbnRCcmVha1Jvd3M6IHByb2Nlc3Nvci5kb250QnJlYWtSb3dzLFxyXG5cdFx0XHRyb3dzV2l0aG91dFBhZ2VCcmVhazogcHJvY2Vzc29yLnJvd3NXaXRob3V0UGFnZUJyZWFrLFxyXG5cdFx0XHRjZWxsczogdGFibGVOb2RlLnRhYmxlLmJvZHlbaV0sXHJcblx0XHRcdHdpZHRoczogdGFibGVOb2RlLnRhYmxlLndpZHRocyxcclxuXHRcdFx0Z2FwczogdGFibGVOb2RlLl9vZmZzZXRzLm9mZnNldHMsXHJcblx0XHRcdHRhYmxlQm9keTogdGFibGVOb2RlLnRhYmxlLmJvZHksXHJcblx0XHRcdHRhYmxlTm9kZSxcclxuXHRcdFx0cm93SW5kZXg6IGksXHJcblx0XHRcdGhlaWdodFxyXG5cdFx0fSk7XHJcblx0XHRhZGRBbGwodGFibGVOb2RlLnBvc2l0aW9ucywgcmVzdWx0LnBvc2l0aW9ucyk7XHJcblxyXG5cdFx0aWYgKCFyZXN1bHQucGFnZUJyZWFrcyB8fCByZXN1bHQucGFnZUJyZWFrcy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0dmFyIGJyZWFrc0J5U3BhbiA9IHRhYmxlTm9kZSAmJiB0YWJsZU5vZGUuX2JyZWFrc0J5U3BhbiB8fCBudWxsO1xyXG5cdFx0XHR2YXIgYnJlYWtCeVNwYW5EYXRhID0gdGhpcy5fZmluZFNhbWVSb3dQYWdlQnJlYWtCeVJvd1NwYW5EYXRhKGJyZWFrc0J5U3BhbiwgcGFnZUJlZm9yZVByb2Nlc3NpbmcsIGkpO1xyXG5cdFx0XHRpZiAoYnJlYWtCeVNwYW5EYXRhKSB7XHJcblx0XHRcdFx0dmFyIGZpbmFsQnJlYWtCeVNwYW5EYXRhID0gdGhpcy5fZ2V0UGFnZUJyZWFrTGlzdEJ5U3Bhbih0YWJsZU5vZGUsIGJyZWFrQnlTcGFuRGF0YS5wcmV2UGFnZSwgaSk7XHJcblx0XHRcdFx0cmVzdWx0LnBhZ2VCcmVha3MucHVzaChmaW5hbEJyZWFrQnlTcGFuRGF0YSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRwcm9jZXNzb3IuZW5kUm93KGksIHRoaXMud3JpdGVyLCByZXN1bHQucGFnZUJyZWFrcyk7XHJcblx0fVxyXG5cclxuXHRwcm9jZXNzb3IuZW5kVGFibGUodGhpcy53cml0ZXIpO1xyXG5cdHRoaXMubmVzdGVkTGV2ZWwtLTtcclxuXHRpZiAodGhpcy5uZXN0ZWRMZXZlbCA9PT0gMCkge1xyXG5cdFx0dGhpcy53cml0ZXIuY29udGV4dCgpLnJlc2V0TWFyZ2luWFRvcFBhcmVudCgpO1xyXG5cdH1cclxufTtcclxuXHJcbi8vIGxlYWZzICh0ZXh0cylcclxuTGF5b3V0QnVpbGRlci5wcm90b3R5cGUucHJvY2Vzc0xlYWYgPSBmdW5jdGlvbiAobm9kZSkge1xyXG5cdHZhciBsaW5lID0gdGhpcy5idWlsZE5leHRMaW5lKG5vZGUpO1xyXG5cdGlmIChsaW5lICYmIChub2RlLnRvY0l0ZW0gfHwgbm9kZS5pZCkpIHtcclxuXHRcdGxpbmUuX25vZGUgPSBub2RlO1xyXG5cdH1cclxuXHR2YXIgY3VycmVudEhlaWdodCA9IChsaW5lKSA/IGxpbmUuZ2V0SGVpZ2h0KCkgOiAwO1xyXG5cdHZhciBtYXhIZWlnaHQgPSBub2RlLm1heEhlaWdodCB8fCAtMTtcclxuXHJcblx0aWYgKGxpbmUpIHtcclxuXHRcdHZhciBub2RlSWQgPSBnZXROb2RlSWQobm9kZSk7XHJcblx0XHRpZiAobm9kZUlkKSB7XHJcblx0XHRcdGxpbmUuaWQgPSBub2RlSWQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAobm9kZS5fdG9jSXRlbVJlZikge1xyXG5cdFx0bGluZS5fcGFnZU5vZGVSZWYgPSBub2RlLl90b2NJdGVtUmVmO1xyXG5cdH1cclxuXHJcblx0aWYgKG5vZGUuX3BhZ2VSZWYpIHtcclxuXHRcdGxpbmUuX3BhZ2VOb2RlUmVmID0gbm9kZS5fcGFnZVJlZi5fbm9kZVJlZjtcclxuXHR9XHJcblxyXG5cdGlmIChsaW5lICYmIGxpbmUuaW5saW5lcyAmJiBpc0FycmF5KGxpbmUuaW5saW5lcykpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGluZS5pbmxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHRpZiAobGluZS5pbmxpbmVzW2ldLl90b2NJdGVtUmVmKSB7XHJcblx0XHRcdFx0bGluZS5pbmxpbmVzW2ldLl9wYWdlTm9kZVJlZiA9IGxpbmUuaW5saW5lc1tpXS5fdG9jSXRlbVJlZjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGxpbmUuaW5saW5lc1tpXS5fcGFnZVJlZikge1xyXG5cdFx0XHRcdGxpbmUuaW5saW5lc1tpXS5fcGFnZU5vZGVSZWYgPSBsaW5lLmlubGluZXNbaV0uX3BhZ2VSZWYuX25vZGVSZWY7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHdoaWxlIChsaW5lICYmIChtYXhIZWlnaHQgPT09IC0xIHx8IGN1cnJlbnRIZWlnaHQgPCBtYXhIZWlnaHQpKSB7XHJcblx0XHR2YXIgcG9zaXRpb25zID0gdGhpcy53cml0ZXIuYWRkTGluZShsaW5lKTtcclxuXHRcdG5vZGUucG9zaXRpb25zLnB1c2gocG9zaXRpb25zKTtcclxuXHRcdGxpbmUgPSB0aGlzLmJ1aWxkTmV4dExpbmUobm9kZSk7XHJcblx0XHRpZiAobGluZSkge1xyXG5cdFx0XHRjdXJyZW50SGVpZ2h0ICs9IGxpbmUuZ2V0SGVpZ2h0KCk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuTGF5b3V0QnVpbGRlci5wcm90b3R5cGUucHJvY2Vzc1RvYyA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblx0aWYgKG5vZGUudG9jLnRpdGxlKSB7XHJcblx0XHR0aGlzLnByb2Nlc3NOb2RlKG5vZGUudG9jLnRpdGxlKTtcclxuXHR9XHJcblx0aWYgKG5vZGUudG9jLl90YWJsZSkge1xyXG5cdFx0dGhpcy5wcm9jZXNzTm9kZShub2RlLnRvYy5fdGFibGUpO1xyXG5cdH1cclxufTtcclxuXHJcbkxheW91dEJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkTmV4dExpbmUgPSBmdW5jdGlvbiAodGV4dE5vZGUpIHtcclxuXHJcblx0ZnVuY3Rpb24gY2xvbmVJbmxpbmUoaW5saW5lKSB7XHJcblx0XHR2YXIgbmV3SW5saW5lID0gaW5saW5lLmNvbnN0cnVjdG9yKCk7XHJcblx0XHRmb3IgKHZhciBrZXkgaW4gaW5saW5lKSB7XHJcblx0XHRcdG5ld0lubGluZVtrZXldID0gaW5saW5lW2tleV07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3SW5saW5lO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZmluZE1heEZpdExlbmd0aCh0ZXh0LCBtYXhXaWR0aCwgbWVhc3VyZUZuKSB7XHJcblx0XHRsZXQgbG93ID0gMTtcclxuXHRcdGxldCBoaWdoID0gdGV4dC5sZW5ndGg7XHJcblx0XHRsZXQgYmVzdEZpdCA9IDE7XHJcblxyXG5cdFx0d2hpbGUgKGxvdyA8PSBoaWdoKSB7XHJcblx0XHRcdGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XHJcblx0XHRcdGNvbnN0IHBhcnQgPSB0ZXh0LnN1YnN0cmluZygwLCBtaWQpO1xyXG5cdFx0XHRjb25zdCB3aWR0aCA9IG1lYXN1cmVGbihwYXJ0KTtcclxuXHJcblx0XHRcdGlmICh3aWR0aCA8PSBtYXhXaWR0aCkge1xyXG5cdFx0XHRcdGJlc3RGaXQgPSBtaWQ7XHJcblx0XHRcdFx0bG93ID0gbWlkICsgMTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRoaWdoID0gbWlkIC0gMTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBiZXN0Rml0O1xyXG5cdH1cclxuXHJcblx0aWYgKCF0ZXh0Tm9kZS5faW5saW5lcyB8fCB0ZXh0Tm9kZS5faW5saW5lcy5sZW5ndGggPT09IDApIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0dmFyIGxpbmUgPSBuZXcgTGluZSh0aGlzLndyaXRlci5jb250ZXh0KCkuYXZhaWxhYmxlV2lkdGgpO1xyXG5cdHZhciB0ZXh0VG9vbHMgPSBuZXcgVGV4dFRvb2xzKG51bGwpO1xyXG5cclxuXHR2YXIgaXNGb3JjZUNvbnRpbnVlID0gZmFsc2U7XHJcblx0d2hpbGUgKHRleHROb2RlLl9pbmxpbmVzICYmIHRleHROb2RlLl9pbmxpbmVzLmxlbmd0aCA+IDAgJiZcclxuXHRcdChsaW5lLmhhc0Vub3VnaFNwYWNlRm9ySW5saW5lKHRleHROb2RlLl9pbmxpbmVzWzBdLCB0ZXh0Tm9kZS5faW5saW5lcy5zbGljZSgxKSkgfHwgaXNGb3JjZUNvbnRpbnVlKSkge1xyXG5cdFx0dmFyIGlzSGFyZFdyYXAgPSBmYWxzZTtcclxuXHRcdHZhciBpbmxpbmUgPSB0ZXh0Tm9kZS5faW5saW5lcy5zaGlmdCgpO1xyXG5cdFx0aXNGb3JjZUNvbnRpbnVlID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKCFpbmxpbmUubm9XcmFwICYmIGlubGluZS50ZXh0Lmxlbmd0aCA+IDEgJiYgaW5saW5lLndpZHRoID4gbGluZS5nZXRBdmFpbGFibGVXaWR0aCgpKSB7XHJcblx0XHRcdHZhciBtYXhDaGFycyA9IGZpbmRNYXhGaXRMZW5ndGgoaW5saW5lLnRleHQsIGxpbmUuZ2V0QXZhaWxhYmxlV2lkdGgoKSwgZnVuY3Rpb24gKHR4dCkge1xyXG5cdFx0XHRcdHJldHVybiB0ZXh0VG9vbHMud2lkdGhPZlN0cmluZyh0eHQsIGlubGluZS5mb250LCBpbmxpbmUuZm9udFNpemUsIGlubGluZS5jaGFyYWN0ZXJTcGFjaW5nLCBpbmxpbmUuZm9udEZlYXR1cmVzKVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0aWYgKG1heENoYXJzIDwgaW5saW5lLnRleHQubGVuZ3RoKSB7XHJcblx0XHRcdFx0dmFyIG5ld0lubGluZSA9IGNsb25lSW5saW5lKGlubGluZSk7XHJcblxyXG5cdFx0XHRcdG5ld0lubGluZS50ZXh0ID0gaW5saW5lLnRleHQuc3Vic3RyKG1heENoYXJzKTtcclxuXHRcdFx0XHRpbmxpbmUudGV4dCA9IGlubGluZS50ZXh0LnN1YnN0cigwLCBtYXhDaGFycyk7XHJcblxyXG5cdFx0XHRcdG5ld0lubGluZS53aWR0aCA9IHRleHRUb29scy53aWR0aE9mU3RyaW5nKG5ld0lubGluZS50ZXh0LCBuZXdJbmxpbmUuZm9udCwgbmV3SW5saW5lLmZvbnRTaXplLCBuZXdJbmxpbmUuY2hhcmFjdGVyU3BhY2luZywgbmV3SW5saW5lLmZvbnRGZWF0dXJlcyk7XHJcblx0XHRcdFx0aW5saW5lLndpZHRoID0gdGV4dFRvb2xzLndpZHRoT2ZTdHJpbmcoaW5saW5lLnRleHQsIGlubGluZS5mb250LCBpbmxpbmUuZm9udFNpemUsIGlubGluZS5jaGFyYWN0ZXJTcGFjaW5nLCBpbmxpbmUuZm9udEZlYXR1cmVzKTtcclxuXHJcblx0XHRcdFx0dGV4dE5vZGUuX2lubGluZXMudW5zaGlmdChuZXdJbmxpbmUpO1xyXG5cdFx0XHRcdGlzSGFyZFdyYXAgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0bGluZS5hZGRJbmxpbmUoaW5saW5lKTtcclxuXHJcblx0XHRpc0ZvcmNlQ29udGludWUgPSBpbmxpbmUubm9OZXdMaW5lICYmICFpc0hhcmRXcmFwO1xyXG5cdH1cclxuXHJcblx0bGluZS5sYXN0TGluZUluUGFyYWdyYXBoID0gdGV4dE5vZGUuX2lubGluZXMubGVuZ3RoID09PSAwO1xyXG5cclxuXHRyZXR1cm4gbGluZTtcclxufTtcclxuXHJcbi8vIGltYWdlc1xyXG5MYXlvdXRCdWlsZGVyLnByb3RvdHlwZS5wcm9jZXNzSW1hZ2UgPSBmdW5jdGlvbiAobm9kZSkge1xyXG5cdHZhciBwb3NpdGlvbiA9IHRoaXMud3JpdGVyLmFkZEltYWdlKG5vZGUpO1xyXG5cdG5vZGUucG9zaXRpb25zLnB1c2gocG9zaXRpb24pO1xyXG59O1xyXG5cclxuTGF5b3V0QnVpbGRlci5wcm90b3R5cGUucHJvY2Vzc1NWRyA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblx0dmFyIHBvc2l0aW9uID0gdGhpcy53cml0ZXIuYWRkU1ZHKG5vZGUpO1xyXG5cdG5vZGUucG9zaXRpb25zLnB1c2gocG9zaXRpb24pO1xyXG59O1xyXG5cclxuTGF5b3V0QnVpbGRlci5wcm90b3R5cGUucHJvY2Vzc0NhbnZhcyA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblx0dmFyIGhlaWdodCA9IG5vZGUuX21pbkhlaWdodDtcclxuXHJcblx0aWYgKG5vZGUuYWJzb2x1dGVQb3NpdGlvbiA9PT0gdW5kZWZpbmVkICYmIHRoaXMud3JpdGVyLmNvbnRleHQoKS5hdmFpbGFibGVIZWlnaHQgPCBoZWlnaHQpIHtcclxuXHRcdC8vIFRPRE86IHN1cHBvcnQgZm9yIGNhbnZhcyBsYXJnZXIgdGhhbiBhIHBhZ2VcclxuXHRcdC8vIFRPRE86IHN1cHBvcnQgZm9yIG90aGVyIG92ZXJmbG93IG1ldGhvZHNcclxuXHJcblx0XHR0aGlzLndyaXRlci5tb3ZlVG9OZXh0UGFnZSgpO1xyXG5cdH1cclxuXHJcblx0dGhpcy53cml0ZXIuYWxpZ25DYW52YXMobm9kZSk7XHJcblxyXG5cdG5vZGUuY2FudmFzLmZvckVhY2goZnVuY3Rpb24gKHZlY3Rvcikge1xyXG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy53cml0ZXIuYWRkVmVjdG9yKHZlY3Rvcik7XHJcblx0XHRub2RlLnBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uKTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0dGhpcy53cml0ZXIuY29udGV4dCgpLm1vdmVEb3duKGhlaWdodCk7XHJcbn07XHJcblxyXG5MYXlvdXRCdWlsZGVyLnByb3RvdHlwZS5wcm9jZXNzUXIgPSBmdW5jdGlvbiAobm9kZSkge1xyXG5cdHZhciBwb3NpdGlvbiA9IHRoaXMud3JpdGVyLmFkZFFyKG5vZGUpO1xyXG5cdG5vZGUucG9zaXRpb25zLnB1c2gocG9zaXRpb24pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMYXlvdXRCdWlsZGVyO1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/layoutBuilder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/line.js":
/*!******************************************!*\
  !*** ./node_modules/pdfmake/src/line.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\n/**\r\n * Creates an instance of Line\r\n *\r\n * @constructor\r\n * @this {Line}\r\n * @param {Number} Maximum width this line can have\r\n */\r\nfunction Line(maxWidth) {\r\n\tthis.maxWidth = maxWidth;\r\n\tthis.leadingCut = 0;\r\n\tthis.trailingCut = 0;\r\n\tthis.inlineWidths = 0;\r\n\tthis.inlines = [];\r\n}\r\n\r\nLine.prototype.getAscenderHeight = function () {\r\n\tvar y = 0;\r\n\r\n\tthis.inlines.forEach(function (inline) {\r\n\t\ty = Math.max(y, inline.font.ascender / 1000 * inline.fontSize);\r\n\t});\r\n\treturn y;\r\n};\r\n\r\nLine.prototype.hasEnoughSpaceForInline = function (inline, nextInlines) {\r\n\tnextInlines = nextInlines || [];\r\n\r\n\tif (this.inlines.length === 0) {\r\n\t\treturn true;\r\n\t}\r\n\tif (this.newLineForced) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar inlineWidth = inline.width;\r\n\tvar inlineTrailingCut = inline.trailingCut || 0;\r\n\tif (inline.noNewLine) {\r\n\t\tfor (var i = 0, l = nextInlines.length; i < l; i++) {\r\n\t\t\tvar nextInline = nextInlines[i];\r\n\t\t\tinlineWidth += nextInline.width;\r\n\t\t\tinlineTrailingCut += nextInline.trailingCut || 0;\r\n\t\t\tif (!nextInline.noNewLine) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn (this.inlineWidths + inlineWidth - this.leadingCut - inlineTrailingCut) <= this.maxWidth;\r\n};\r\n\r\nLine.prototype.addInline = function (inline) {\r\n\tif (this.inlines.length === 0) {\r\n\t\tthis.leadingCut = inline.leadingCut || 0;\r\n\t}\r\n\tthis.trailingCut = inline.trailingCut || 0;\r\n\r\n\tinline.x = this.inlineWidths - this.leadingCut;\r\n\r\n\tthis.inlines.push(inline);\r\n\tthis.inlineWidths += inline.width;\r\n\r\n\tif (inline.lineEnd) {\r\n\t\tthis.newLineForced = true;\r\n\t}\r\n};\r\n\r\nLine.prototype.getWidth = function () {\r\n\treturn this.inlineWidths - this.leadingCut - this.trailingCut;\r\n};\r\n\r\nLine.prototype.getAvailableWidth = function () {\r\n\treturn this.maxWidth - this.getWidth();\r\n};\r\n\r\n/**\r\n * Returns line height\r\n * @return {Number}\r\n */\r\nLine.prototype.getHeight = function () {\r\n\tvar max = 0;\r\n\r\n\tthis.inlines.forEach(function (item) {\r\n\t\tmax = Math.max(max, item.height || 0);\r\n\t});\r\n\r\n\treturn max;\r\n};\r\n\r\nmodule.exports = Line;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvbGluZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9nYXNjYXQvcHJpc21hcXVhbnQvcHJpc21hLXF1YW50dW0vbm9kZV9tb2R1bGVzL3BkZm1ha2Uvc3JjL2xpbmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgTGluZVxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHRoaXMge0xpbmV9XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBNYXhpbXVtIHdpZHRoIHRoaXMgbGluZSBjYW4gaGF2ZVxyXG4gKi9cclxuZnVuY3Rpb24gTGluZShtYXhXaWR0aCkge1xyXG5cdHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcclxuXHR0aGlzLmxlYWRpbmdDdXQgPSAwO1xyXG5cdHRoaXMudHJhaWxpbmdDdXQgPSAwO1xyXG5cdHRoaXMuaW5saW5lV2lkdGhzID0gMDtcclxuXHR0aGlzLmlubGluZXMgPSBbXTtcclxufVxyXG5cclxuTGluZS5wcm90b3R5cGUuZ2V0QXNjZW5kZXJIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHkgPSAwO1xyXG5cclxuXHR0aGlzLmlubGluZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5saW5lKSB7XHJcblx0XHR5ID0gTWF0aC5tYXgoeSwgaW5saW5lLmZvbnQuYXNjZW5kZXIgLyAxMDAwICogaW5saW5lLmZvbnRTaXplKTtcclxuXHR9KTtcclxuXHRyZXR1cm4geTtcclxufTtcclxuXHJcbkxpbmUucHJvdG90eXBlLmhhc0Vub3VnaFNwYWNlRm9ySW5saW5lID0gZnVuY3Rpb24gKGlubGluZSwgbmV4dElubGluZXMpIHtcclxuXHRuZXh0SW5saW5lcyA9IG5leHRJbmxpbmVzIHx8IFtdO1xyXG5cclxuXHRpZiAodGhpcy5pbmxpbmVzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdGlmICh0aGlzLm5ld0xpbmVGb3JjZWQpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdHZhciBpbmxpbmVXaWR0aCA9IGlubGluZS53aWR0aDtcclxuXHR2YXIgaW5saW5lVHJhaWxpbmdDdXQgPSBpbmxpbmUudHJhaWxpbmdDdXQgfHwgMDtcclxuXHRpZiAoaW5saW5lLm5vTmV3TGluZSkge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBuZXh0SW5saW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0dmFyIG5leHRJbmxpbmUgPSBuZXh0SW5saW5lc1tpXTtcclxuXHRcdFx0aW5saW5lV2lkdGggKz0gbmV4dElubGluZS53aWR0aDtcclxuXHRcdFx0aW5saW5lVHJhaWxpbmdDdXQgKz0gbmV4dElubGluZS50cmFpbGluZ0N1dCB8fCAwO1xyXG5cdFx0XHRpZiAoIW5leHRJbmxpbmUubm9OZXdMaW5lKSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiAodGhpcy5pbmxpbmVXaWR0aHMgKyBpbmxpbmVXaWR0aCAtIHRoaXMubGVhZGluZ0N1dCAtIGlubGluZVRyYWlsaW5nQ3V0KSA8PSB0aGlzLm1heFdpZHRoO1xyXG59O1xyXG5cclxuTGluZS5wcm90b3R5cGUuYWRkSW5saW5lID0gZnVuY3Rpb24gKGlubGluZSkge1xyXG5cdGlmICh0aGlzLmlubGluZXMubGVuZ3RoID09PSAwKSB7XHJcblx0XHR0aGlzLmxlYWRpbmdDdXQgPSBpbmxpbmUubGVhZGluZ0N1dCB8fCAwO1xyXG5cdH1cclxuXHR0aGlzLnRyYWlsaW5nQ3V0ID0gaW5saW5lLnRyYWlsaW5nQ3V0IHx8IDA7XHJcblxyXG5cdGlubGluZS54ID0gdGhpcy5pbmxpbmVXaWR0aHMgLSB0aGlzLmxlYWRpbmdDdXQ7XHJcblxyXG5cdHRoaXMuaW5saW5lcy5wdXNoKGlubGluZSk7XHJcblx0dGhpcy5pbmxpbmVXaWR0aHMgKz0gaW5saW5lLndpZHRoO1xyXG5cclxuXHRpZiAoaW5saW5lLmxpbmVFbmQpIHtcclxuXHRcdHRoaXMubmV3TGluZUZvcmNlZCA9IHRydWU7XHJcblx0fVxyXG59O1xyXG5cclxuTGluZS5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIHRoaXMuaW5saW5lV2lkdGhzIC0gdGhpcy5sZWFkaW5nQ3V0IC0gdGhpcy50cmFpbGluZ0N1dDtcclxufTtcclxuXHJcbkxpbmUucHJvdG90eXBlLmdldEF2YWlsYWJsZVdpZHRoID0gZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiB0aGlzLm1heFdpZHRoIC0gdGhpcy5nZXRXaWR0aCgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgbGluZSBoZWlnaHRcclxuICogQHJldHVybiB7TnVtYmVyfVxyXG4gKi9cclxuTGluZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG5cdHZhciBtYXggPSAwO1xyXG5cclxuXHR0aGlzLmlubGluZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG5cdFx0bWF4ID0gTWF0aC5tYXgobWF4LCBpdGVtLmhlaWdodCB8fCAwKTtcclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIG1heDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTGluZTtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/line.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/pageElementWriter.js":
/*!*******************************************************!*\
  !*** ./node_modules/pdfmake/src/pageElementWriter.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar isUndefined = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isUndefined);\r\nvar ElementWriter = __webpack_require__(/*! ./elementWriter */ \"(rsc)/./node_modules/pdfmake/src/elementWriter.js\");\r\n\r\n/**\r\n * Creates an instance of PageElementWriter - an extended ElementWriter\r\n * which can handle:\r\n * - page-breaks (it adds new pages when there's not enough space left),\r\n * - repeatable fragments (like table-headers, which are repeated everytime\r\n *                         a page-break occurs)\r\n * - transactions (used for unbreakable-blocks when we want to make sure\r\n *                 whole block will be rendered on the same page)\r\n */\r\nfunction PageElementWriter(context, tracker) {\r\n\tthis.transactionLevel = 0;\r\n\tthis.repeatables = [];\r\n\tthis.tracker = tracker;\r\n\tthis.writer = new ElementWriter(context, tracker);\r\n}\r\n\r\nfunction fitOnPage(self, addFct) {\r\n\tvar position = addFct(self);\r\n\tif (!position) {\r\n\t\tself.moveToNextPage();\r\n\t\tposition = addFct(self);\r\n\t}\r\n\treturn position;\r\n}\r\n\r\nPageElementWriter.prototype.addLine = function (line, dontUpdateContextPosition, index) {\r\n\treturn fitOnPage(this, function (self) {\r\n\t\treturn self.writer.addLine(line, dontUpdateContextPosition, index);\r\n\t});\r\n};\r\n\r\nPageElementWriter.prototype.addImage = function (image, index) {\r\n\treturn fitOnPage(this, function (self) {\r\n\t\treturn self.writer.addImage(image, index);\r\n\t});\r\n};\r\n\r\nPageElementWriter.prototype.addSVG = function (image, index) {\r\n\treturn fitOnPage(this, function (self) {\r\n\t\treturn self.writer.addSVG(image, index);\r\n\t});\r\n};\r\n\r\nPageElementWriter.prototype.addQr = function (qr, index) {\r\n\treturn fitOnPage(this, function (self) {\r\n\t\treturn self.writer.addQr(qr, index);\r\n\t});\r\n};\r\n\r\nPageElementWriter.prototype.addVector = function (vector, ignoreContextX, ignoreContextY, index, forcePage) {\r\n\treturn this.writer.addVector(vector, ignoreContextX, ignoreContextY, index, forcePage);\r\n};\r\n\r\nPageElementWriter.prototype.beginClip = function (width, height) {\r\n\treturn this.writer.beginClip(width, height);\r\n};\r\n\r\nPageElementWriter.prototype.endClip = function () {\r\n\treturn this.writer.endClip();\r\n};\r\n\r\nPageElementWriter.prototype.alignCanvas = function (node) {\r\n\tthis.writer.alignCanvas(node);\r\n};\r\n\r\nPageElementWriter.prototype.addFragment = function (fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition) {\r\n\tif (!this.writer.addFragment(fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition)) {\r\n\t\tthis.moveToNextPage();\r\n\t\tthis.writer.addFragment(fragment, useBlockXOffset, useBlockYOffset, dontUpdateContextPosition);\r\n\t}\r\n};\r\n\r\nPageElementWriter.prototype.moveToNextPage = function (pageOrientation) {\r\n\r\n\tvar nextPage = this.writer.context.moveToNextPage(pageOrientation);\r\n\r\n\t// moveToNextPage is called multiple times for table, because is called for each column\r\n\t// and repeatables are inserted only in the first time. If columns are used, is needed\r\n\t// call for table in first column and then for table in the second column (is other repeatables).\r\n\tthis.repeatables.forEach(function (rep) {\r\n\t\tif (isUndefined(rep.insertedOnPages[this.writer.context.page])) {\r\n\t\t\trep.insertedOnPages[this.writer.context.page] = true;\r\n\t\t\tthis.writer.addFragment(rep, true);\r\n\t\t} else {\r\n\t\t\tthis.writer.context.moveDown(rep.height);\r\n\t\t}\r\n\t}, this);\r\n\r\n\tthis.writer.tracker.emit('pageChanged', {\r\n\t\tprevPage: nextPage.prevPage,\r\n\t\tprevY: nextPage.prevY,\r\n\t\ty: this.writer.context.y\r\n\t});\r\n};\r\n\r\nPageElementWriter.prototype.beginUnbreakableBlock = function (width, height) {\r\n\tif (this.transactionLevel++ === 0) {\r\n\t\tthis.originalX = this.writer.context.x;\r\n\t\tthis.writer.pushContext(width, height);\r\n\t}\r\n};\r\n\r\nPageElementWriter.prototype.commitUnbreakableBlock = function (forcedX, forcedY) {\r\n\tif (--this.transactionLevel === 0) {\r\n\t\tvar unbreakableContext = this.writer.context;\r\n\t\tthis.writer.popContext();\r\n\r\n\t\tvar nbPages = unbreakableContext.pages.length;\r\n\t\tif (nbPages > 0) {\r\n\t\t\t// no support for multi-page unbreakableBlocks\r\n\t\t\tvar fragment = unbreakableContext.pages[0];\r\n\t\t\tfragment.xOffset = forcedX;\r\n\t\t\tfragment.yOffset = forcedY;\r\n\r\n\t\t\t//TODO: vectors can influence height in some situations\r\n\t\t\tif (nbPages > 1) {\r\n\t\t\t\t// on out-of-context blocs (headers, footers, background) height should be the whole DocumentContext height\r\n\t\t\t\tif (forcedX !== undefined || forcedY !== undefined) {\r\n\t\t\t\t\tfragment.height = unbreakableContext.getCurrentPage().pageSize.height - unbreakableContext.pageMargins.top - unbreakableContext.pageMargins.bottom;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfragment.height = this.writer.context.getCurrentPage().pageSize.height - this.writer.context.pageMargins.top - this.writer.context.pageMargins.bottom;\r\n\t\t\t\t\tfor (var i = 0, l = this.repeatables.length; i < l; i++) {\r\n\t\t\t\t\t\tfragment.height -= this.repeatables[i].height;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfragment.height = unbreakableContext.y;\r\n\t\t\t}\r\n\r\n\t\t\tif (forcedX !== undefined || forcedY !== undefined) {\r\n\t\t\t\tthis.writer.addFragment(fragment, true, true, true);\r\n\t\t\t} else {\r\n\t\t\t\tthis.addFragment(fragment);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\nPageElementWriter.prototype.currentBlockToRepeatable = function () {\r\n\tvar unbreakableContext = this.writer.context;\r\n\tvar rep = { items: [] };\r\n\r\n\tunbreakableContext.pages[0].items.forEach(function (item) {\r\n\t\trep.items.push(item);\r\n\t});\r\n\r\n\trep.xOffset = this.originalX;\r\n\r\n\t//TODO: vectors can influence height in some situations\r\n\trep.height = unbreakableContext.y;\r\n\r\n\trep.insertedOnPages = [];\r\n\r\n\treturn rep;\r\n};\r\n\r\nPageElementWriter.prototype.pushToRepeatables = function (rep) {\r\n\tthis.repeatables.push(rep);\r\n};\r\n\r\nPageElementWriter.prototype.popFromRepeatables = function () {\r\n\tthis.repeatables.pop();\r\n};\r\n\r\nPageElementWriter.prototype.context = function () {\r\n\treturn this.writer.context;\r\n};\r\n\r\nmodule.exports = PageElementWriter;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvcGFnZUVsZW1lbnRXcml0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLGtCQUFrQixpR0FBZ0M7QUFDbEQsb0JBQW9CLG1CQUFPLENBQUMsMEVBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9nYXNjYXQvcHJpc21hcXVhbnQvcHJpc21hLXF1YW50dW0vbm9kZV9tb2R1bGVzL3BkZm1ha2Uvc3JjL3BhZ2VFbGVtZW50V3JpdGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBpc1VuZGVmaW5lZCA9IHJlcXVpcmUoJy4vaGVscGVycycpLmlzVW5kZWZpbmVkO1xyXG52YXIgRWxlbWVudFdyaXRlciA9IHJlcXVpcmUoJy4vZWxlbWVudFdyaXRlcicpO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUGFnZUVsZW1lbnRXcml0ZXIgLSBhbiBleHRlbmRlZCBFbGVtZW50V3JpdGVyXHJcbiAqIHdoaWNoIGNhbiBoYW5kbGU6XHJcbiAqIC0gcGFnZS1icmVha3MgKGl0IGFkZHMgbmV3IHBhZ2VzIHdoZW4gdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIGxlZnQpLFxyXG4gKiAtIHJlcGVhdGFibGUgZnJhZ21lbnRzIChsaWtlIHRhYmxlLWhlYWRlcnMsIHdoaWNoIGFyZSByZXBlYXRlZCBldmVyeXRpbWVcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgYSBwYWdlLWJyZWFrIG9jY3VycylcclxuICogLSB0cmFuc2FjdGlvbnMgKHVzZWQgZm9yIHVuYnJlYWthYmxlLWJsb2NrcyB3aGVuIHdlIHdhbnQgdG8gbWFrZSBzdXJlXHJcbiAqICAgICAgICAgICAgICAgICB3aG9sZSBibG9jayB3aWxsIGJlIHJlbmRlcmVkIG9uIHRoZSBzYW1lIHBhZ2UpXHJcbiAqL1xyXG5mdW5jdGlvbiBQYWdlRWxlbWVudFdyaXRlcihjb250ZXh0LCB0cmFja2VyKSB7XHJcblx0dGhpcy50cmFuc2FjdGlvbkxldmVsID0gMDtcclxuXHR0aGlzLnJlcGVhdGFibGVzID0gW107XHJcblx0dGhpcy50cmFja2VyID0gdHJhY2tlcjtcclxuXHR0aGlzLndyaXRlciA9IG5ldyBFbGVtZW50V3JpdGVyKGNvbnRleHQsIHRyYWNrZXIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaXRPblBhZ2Uoc2VsZiwgYWRkRmN0KSB7XHJcblx0dmFyIHBvc2l0aW9uID0gYWRkRmN0KHNlbGYpO1xyXG5cdGlmICghcG9zaXRpb24pIHtcclxuXHRcdHNlbGYubW92ZVRvTmV4dFBhZ2UoKTtcclxuXHRcdHBvc2l0aW9uID0gYWRkRmN0KHNlbGYpO1xyXG5cdH1cclxuXHRyZXR1cm4gcG9zaXRpb247XHJcbn1cclxuXHJcblBhZ2VFbGVtZW50V3JpdGVyLnByb3RvdHlwZS5hZGRMaW5lID0gZnVuY3Rpb24gKGxpbmUsIGRvbnRVcGRhdGVDb250ZXh0UG9zaXRpb24sIGluZGV4KSB7XHJcblx0cmV0dXJuIGZpdE9uUGFnZSh0aGlzLCBmdW5jdGlvbiAoc2VsZikge1xyXG5cdFx0cmV0dXJuIHNlbGYud3JpdGVyLmFkZExpbmUobGluZSwgZG9udFVwZGF0ZUNvbnRleHRQb3NpdGlvbiwgaW5kZXgpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuUGFnZUVsZW1lbnRXcml0ZXIucHJvdG90eXBlLmFkZEltYWdlID0gZnVuY3Rpb24gKGltYWdlLCBpbmRleCkge1xyXG5cdHJldHVybiBmaXRPblBhZ2UodGhpcywgZnVuY3Rpb24gKHNlbGYpIHtcclxuXHRcdHJldHVybiBzZWxmLndyaXRlci5hZGRJbWFnZShpbWFnZSwgaW5kZXgpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuUGFnZUVsZW1lbnRXcml0ZXIucHJvdG90eXBlLmFkZFNWRyA9IGZ1bmN0aW9uIChpbWFnZSwgaW5kZXgpIHtcclxuXHRyZXR1cm4gZml0T25QYWdlKHRoaXMsIGZ1bmN0aW9uIChzZWxmKSB7XHJcblx0XHRyZXR1cm4gc2VsZi53cml0ZXIuYWRkU1ZHKGltYWdlLCBpbmRleCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5QYWdlRWxlbWVudFdyaXRlci5wcm90b3R5cGUuYWRkUXIgPSBmdW5jdGlvbiAocXIsIGluZGV4KSB7XHJcblx0cmV0dXJuIGZpdE9uUGFnZSh0aGlzLCBmdW5jdGlvbiAoc2VsZikge1xyXG5cdFx0cmV0dXJuIHNlbGYud3JpdGVyLmFkZFFyKHFyLCBpbmRleCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5QYWdlRWxlbWVudFdyaXRlci5wcm90b3R5cGUuYWRkVmVjdG9yID0gZnVuY3Rpb24gKHZlY3RvciwgaWdub3JlQ29udGV4dFgsIGlnbm9yZUNvbnRleHRZLCBpbmRleCwgZm9yY2VQYWdlKSB7XHJcblx0cmV0dXJuIHRoaXMud3JpdGVyLmFkZFZlY3Rvcih2ZWN0b3IsIGlnbm9yZUNvbnRleHRYLCBpZ25vcmVDb250ZXh0WSwgaW5kZXgsIGZvcmNlUGFnZSk7XHJcbn07XHJcblxyXG5QYWdlRWxlbWVudFdyaXRlci5wcm90b3R5cGUuYmVnaW5DbGlwID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcclxuXHRyZXR1cm4gdGhpcy53cml0ZXIuYmVnaW5DbGlwKHdpZHRoLCBoZWlnaHQpO1xyXG59O1xyXG5cclxuUGFnZUVsZW1lbnRXcml0ZXIucHJvdG90eXBlLmVuZENsaXAgPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIHRoaXMud3JpdGVyLmVuZENsaXAoKTtcclxufTtcclxuXHJcblBhZ2VFbGVtZW50V3JpdGVyLnByb3RvdHlwZS5hbGlnbkNhbnZhcyA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblx0dGhpcy53cml0ZXIuYWxpZ25DYW52YXMobm9kZSk7XHJcbn07XHJcblxyXG5QYWdlRWxlbWVudFdyaXRlci5wcm90b3R5cGUuYWRkRnJhZ21lbnQgPSBmdW5jdGlvbiAoZnJhZ21lbnQsIHVzZUJsb2NrWE9mZnNldCwgdXNlQmxvY2tZT2Zmc2V0LCBkb250VXBkYXRlQ29udGV4dFBvc2l0aW9uKSB7XHJcblx0aWYgKCF0aGlzLndyaXRlci5hZGRGcmFnbWVudChmcmFnbWVudCwgdXNlQmxvY2tYT2Zmc2V0LCB1c2VCbG9ja1lPZmZzZXQsIGRvbnRVcGRhdGVDb250ZXh0UG9zaXRpb24pKSB7XHJcblx0XHR0aGlzLm1vdmVUb05leHRQYWdlKCk7XHJcblx0XHR0aGlzLndyaXRlci5hZGRGcmFnbWVudChmcmFnbWVudCwgdXNlQmxvY2tYT2Zmc2V0LCB1c2VCbG9ja1lPZmZzZXQsIGRvbnRVcGRhdGVDb250ZXh0UG9zaXRpb24pO1xyXG5cdH1cclxufTtcclxuXHJcblBhZ2VFbGVtZW50V3JpdGVyLnByb3RvdHlwZS5tb3ZlVG9OZXh0UGFnZSA9IGZ1bmN0aW9uIChwYWdlT3JpZW50YXRpb24pIHtcclxuXHJcblx0dmFyIG5leHRQYWdlID0gdGhpcy53cml0ZXIuY29udGV4dC5tb3ZlVG9OZXh0UGFnZShwYWdlT3JpZW50YXRpb24pO1xyXG5cclxuXHQvLyBtb3ZlVG9OZXh0UGFnZSBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZm9yIHRhYmxlLCBiZWNhdXNlIGlzIGNhbGxlZCBmb3IgZWFjaCBjb2x1bW5cclxuXHQvLyBhbmQgcmVwZWF0YWJsZXMgYXJlIGluc2VydGVkIG9ubHkgaW4gdGhlIGZpcnN0IHRpbWUuIElmIGNvbHVtbnMgYXJlIHVzZWQsIGlzIG5lZWRlZFxyXG5cdC8vIGNhbGwgZm9yIHRhYmxlIGluIGZpcnN0IGNvbHVtbiBhbmQgdGhlbiBmb3IgdGFibGUgaW4gdGhlIHNlY29uZCBjb2x1bW4gKGlzIG90aGVyIHJlcGVhdGFibGVzKS5cclxuXHR0aGlzLnJlcGVhdGFibGVzLmZvckVhY2goZnVuY3Rpb24gKHJlcCkge1xyXG5cdFx0aWYgKGlzVW5kZWZpbmVkKHJlcC5pbnNlcnRlZE9uUGFnZXNbdGhpcy53cml0ZXIuY29udGV4dC5wYWdlXSkpIHtcclxuXHRcdFx0cmVwLmluc2VydGVkT25QYWdlc1t0aGlzLndyaXRlci5jb250ZXh0LnBhZ2VdID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy53cml0ZXIuYWRkRnJhZ21lbnQocmVwLCB0cnVlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMud3JpdGVyLmNvbnRleHQubW92ZURvd24ocmVwLmhlaWdodCk7XHJcblx0XHR9XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cdHRoaXMud3JpdGVyLnRyYWNrZXIuZW1pdCgncGFnZUNoYW5nZWQnLCB7XHJcblx0XHRwcmV2UGFnZTogbmV4dFBhZ2UucHJldlBhZ2UsXHJcblx0XHRwcmV2WTogbmV4dFBhZ2UucHJldlksXHJcblx0XHR5OiB0aGlzLndyaXRlci5jb250ZXh0LnlcclxuXHR9KTtcclxufTtcclxuXHJcblBhZ2VFbGVtZW50V3JpdGVyLnByb3RvdHlwZS5iZWdpblVuYnJlYWthYmxlQmxvY2sgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xyXG5cdGlmICh0aGlzLnRyYW5zYWN0aW9uTGV2ZWwrKyA9PT0gMCkge1xyXG5cdFx0dGhpcy5vcmlnaW5hbFggPSB0aGlzLndyaXRlci5jb250ZXh0Lng7XHJcblx0XHR0aGlzLndyaXRlci5wdXNoQ29udGV4dCh3aWR0aCwgaGVpZ2h0KTtcclxuXHR9XHJcbn07XHJcblxyXG5QYWdlRWxlbWVudFdyaXRlci5wcm90b3R5cGUuY29tbWl0VW5icmVha2FibGVCbG9jayA9IGZ1bmN0aW9uIChmb3JjZWRYLCBmb3JjZWRZKSB7XHJcblx0aWYgKC0tdGhpcy50cmFuc2FjdGlvbkxldmVsID09PSAwKSB7XHJcblx0XHR2YXIgdW5icmVha2FibGVDb250ZXh0ID0gdGhpcy53cml0ZXIuY29udGV4dDtcclxuXHRcdHRoaXMud3JpdGVyLnBvcENvbnRleHQoKTtcclxuXHJcblx0XHR2YXIgbmJQYWdlcyA9IHVuYnJlYWthYmxlQ29udGV4dC5wYWdlcy5sZW5ndGg7XHJcblx0XHRpZiAobmJQYWdlcyA+IDApIHtcclxuXHRcdFx0Ly8gbm8gc3VwcG9ydCBmb3IgbXVsdGktcGFnZSB1bmJyZWFrYWJsZUJsb2Nrc1xyXG5cdFx0XHR2YXIgZnJhZ21lbnQgPSB1bmJyZWFrYWJsZUNvbnRleHQucGFnZXNbMF07XHJcblx0XHRcdGZyYWdtZW50LnhPZmZzZXQgPSBmb3JjZWRYO1xyXG5cdFx0XHRmcmFnbWVudC55T2Zmc2V0ID0gZm9yY2VkWTtcclxuXHJcblx0XHRcdC8vVE9ETzogdmVjdG9ycyBjYW4gaW5mbHVlbmNlIGhlaWdodCBpbiBzb21lIHNpdHVhdGlvbnNcclxuXHRcdFx0aWYgKG5iUGFnZXMgPiAxKSB7XHJcblx0XHRcdFx0Ly8gb24gb3V0LW9mLWNvbnRleHQgYmxvY3MgKGhlYWRlcnMsIGZvb3RlcnMsIGJhY2tncm91bmQpIGhlaWdodCBzaG91bGQgYmUgdGhlIHdob2xlIERvY3VtZW50Q29udGV4dCBoZWlnaHRcclxuXHRcdFx0XHRpZiAoZm9yY2VkWCAhPT0gdW5kZWZpbmVkIHx8IGZvcmNlZFkgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0ZnJhZ21lbnQuaGVpZ2h0ID0gdW5icmVha2FibGVDb250ZXh0LmdldEN1cnJlbnRQYWdlKCkucGFnZVNpemUuaGVpZ2h0IC0gdW5icmVha2FibGVDb250ZXh0LnBhZ2VNYXJnaW5zLnRvcCAtIHVuYnJlYWthYmxlQ29udGV4dC5wYWdlTWFyZ2lucy5ib3R0b207XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGZyYWdtZW50LmhlaWdodCA9IHRoaXMud3JpdGVyLmNvbnRleHQuZ2V0Q3VycmVudFBhZ2UoKS5wYWdlU2l6ZS5oZWlnaHQgLSB0aGlzLndyaXRlci5jb250ZXh0LnBhZ2VNYXJnaW5zLnRvcCAtIHRoaXMud3JpdGVyLmNvbnRleHQucGFnZU1hcmdpbnMuYm90dG9tO1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnJlcGVhdGFibGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRmcmFnbWVudC5oZWlnaHQgLT0gdGhpcy5yZXBlYXRhYmxlc1tpXS5oZWlnaHQ7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGZyYWdtZW50LmhlaWdodCA9IHVuYnJlYWthYmxlQ29udGV4dC55O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoZm9yY2VkWCAhPT0gdW5kZWZpbmVkIHx8IGZvcmNlZFkgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHRoaXMud3JpdGVyLmFkZEZyYWdtZW50KGZyYWdtZW50LCB0cnVlLCB0cnVlLCB0cnVlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmFkZEZyYWdtZW50KGZyYWdtZW50KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcblBhZ2VFbGVtZW50V3JpdGVyLnByb3RvdHlwZS5jdXJyZW50QmxvY2tUb1JlcGVhdGFibGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHVuYnJlYWthYmxlQ29udGV4dCA9IHRoaXMud3JpdGVyLmNvbnRleHQ7XHJcblx0dmFyIHJlcCA9IHsgaXRlbXM6IFtdIH07XHJcblxyXG5cdHVuYnJlYWthYmxlQ29udGV4dC5wYWdlc1swXS5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcblx0XHRyZXAuaXRlbXMucHVzaChpdGVtKTtcclxuXHR9KTtcclxuXHJcblx0cmVwLnhPZmZzZXQgPSB0aGlzLm9yaWdpbmFsWDtcclxuXHJcblx0Ly9UT0RPOiB2ZWN0b3JzIGNhbiBpbmZsdWVuY2UgaGVpZ2h0IGluIHNvbWUgc2l0dWF0aW9uc1xyXG5cdHJlcC5oZWlnaHQgPSB1bmJyZWFrYWJsZUNvbnRleHQueTtcclxuXHJcblx0cmVwLmluc2VydGVkT25QYWdlcyA9IFtdO1xyXG5cclxuXHRyZXR1cm4gcmVwO1xyXG59O1xyXG5cclxuUGFnZUVsZW1lbnRXcml0ZXIucHJvdG90eXBlLnB1c2hUb1JlcGVhdGFibGVzID0gZnVuY3Rpb24gKHJlcCkge1xyXG5cdHRoaXMucmVwZWF0YWJsZXMucHVzaChyZXApO1xyXG59O1xyXG5cclxuUGFnZUVsZW1lbnRXcml0ZXIucHJvdG90eXBlLnBvcEZyb21SZXBlYXRhYmxlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHR0aGlzLnJlcGVhdGFibGVzLnBvcCgpO1xyXG59O1xyXG5cclxuUGFnZUVsZW1lbnRXcml0ZXIucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XHJcblx0cmV0dXJuIHRoaXMud3JpdGVyLmNvbnRleHQ7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhZ2VFbGVtZW50V3JpdGVyO1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/pageElementWriter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/pdfKitEngine.js":
/*!**************************************************!*\
  !*** ./node_modules/pdfmake/src/pdfKitEngine.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nfunction _interopDefault(ex) {\r\n\treturn (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex;\r\n}\r\n\r\nvar PdfKit = _interopDefault(__webpack_require__(/*! @foliojs-fork/pdfkit */ \"(rsc)/./node_modules/@foliojs-fork/pdfkit/js/pdfkit.es.js\"));\r\n\r\nfunction getEngineInstance() {\r\n\treturn PdfKit;\r\n}\r\n\r\nfunction createPdfDocument(options) {\r\n\toptions = options || {};\r\n\treturn new PdfKit(options);\r\n}\r\n\r\nmodule.exports = {\r\n\tgetEngineInstance: getEngineInstance,\r\n\tcreatePdfDocument: createPdfDocument\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvcGRmS2l0RW5naW5lLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLHVGQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9nYXNjYXQvcHJpc21hcXVhbnQvcHJpc21hLXF1YW50dW0vbm9kZV9tb2R1bGVzL3BkZm1ha2Uvc3JjL3BkZktpdEVuZ2luZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQoZXgpIHtcclxuXHRyZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4O1xyXG59XHJcblxyXG52YXIgUGRmS2l0ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ0Bmb2xpb2pzLWZvcmsvcGRma2l0JykpO1xyXG5cclxuZnVuY3Rpb24gZ2V0RW5naW5lSW5zdGFuY2UoKSB7XHJcblx0cmV0dXJuIFBkZktpdDtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUGRmRG9jdW1lbnQob3B0aW9ucykge1xyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdHJldHVybiBuZXcgUGRmS2l0KG9wdGlvbnMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHRnZXRFbmdpbmVJbnN0YW5jZTogZ2V0RW5naW5lSW5zdGFuY2UsXHJcblx0Y3JlYXRlUGRmRG9jdW1lbnQ6IGNyZWF0ZVBkZkRvY3VtZW50XHJcbn07XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/pdfKitEngine.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/printer.js":
/*!*********************************************!*\
  !*** ./node_modules/pdfmake/src/printer.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*eslint no-unused-vars: [\"error\", {\"args\": \"none\"}]*/\r\n\r\n\r\nvar PdfKitEngine = __webpack_require__(/*! ./pdfKitEngine */ \"(rsc)/./node_modules/pdfmake/src/pdfKitEngine.js\");\r\nvar FontProvider = __webpack_require__(/*! ./fontProvider */ \"(rsc)/./node_modules/pdfmake/src/fontProvider.js\");\r\nvar LayoutBuilder = __webpack_require__(/*! ./layoutBuilder */ \"(rsc)/./node_modules/pdfmake/src/layoutBuilder.js\");\r\nvar sizes = __webpack_require__(/*! ./standardPageSizes */ \"(rsc)/./node_modules/pdfmake/src/standardPageSizes.js\");\r\nvar ImageMeasure = __webpack_require__(/*! ./imageMeasure */ \"(rsc)/./node_modules/pdfmake/src/imageMeasure.js\");\r\nvar SVGMeasure = __webpack_require__(/*! ./svgMeasure */ \"(rsc)/./node_modules/pdfmake/src/svgMeasure.js\");\r\nvar textDecorator = __webpack_require__(/*! ./textDecorator */ \"(rsc)/./node_modules/pdfmake/src/textDecorator.js\");\r\nvar TextTools = __webpack_require__(/*! ./textTools */ \"(rsc)/./node_modules/pdfmake/src/textTools.js\");\r\nvar isFunction = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isFunction);\r\nvar isString = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isString);\r\nvar isNumber = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isNumber);\r\nvar isBoolean = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isBoolean);\r\nvar isArray = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isArray);\r\nvar isUndefined = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isUndefined);\r\nvar isPattern = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isPattern);\r\nvar getPattern = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").getPattern);\r\nvar SVGtoPDF = __webpack_require__(/*! ./3rd-party/svg-to-pdfkit */ \"(rsc)/./node_modules/pdfmake/src/3rd-party/svg-to-pdfkit.js\");\r\n\r\nvar findFont = function (fonts, requiredFonts, defaultFont) {\r\n\tfor (var i = 0; i < requiredFonts.length; i++) {\r\n\t\tvar requiredFont = requiredFonts[i].toLowerCase();\r\n\r\n\t\tfor (var font in fonts) {\r\n\t\t\tif (font.toLowerCase() === requiredFont) {\r\n\t\t\t\treturn font;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn defaultFont;\r\n};\r\n\r\n////////////////////////////////////////\r\n// PdfPrinter\r\n\r\n/**\r\n * @class Creates an instance of a PdfPrinter which turns document definition into a pdf\r\n *\r\n * @param {Object} fontDescriptors font definition dictionary\r\n *\r\n * @example\r\n * var fontDescriptors = {\r\n *\tRoboto: {\r\n *\t\tnormal: 'fonts/Roboto-Regular.ttf',\r\n *\t\tbold: 'fonts/Roboto-Medium.ttf',\r\n *\t\titalics: 'fonts/Roboto-Italic.ttf',\r\n *\t\tbolditalics: 'fonts/Roboto-MediumItalic.ttf'\r\n *\t}\r\n * };\r\n *\r\n * var printer = new PdfPrinter(fontDescriptors);\r\n */\r\nfunction PdfPrinter(fontDescriptors) {\r\n\tthis.fontDescriptors = fontDescriptors;\r\n}\r\n\r\n/**\r\n * Executes layout engine for the specified document and renders it into a pdfkit document\r\n * ready to be saved.\r\n *\r\n * @param {Object} docDefinition document definition\r\n * @param {Object} docDefinition.content an array describing the pdf structure (for more information take a look at the examples in the /examples folder)\r\n * @param {Object} [docDefinition.defaultStyle] default (implicit) style definition\r\n * @param {Object} [docDefinition.styles] dictionary defining all styles which can be used in the document\r\n * @param {Object} [docDefinition.pageSize] page size (pdfkit units, A4 dimensions by default)\r\n * @param {Number} docDefinition.pageSize.width width\r\n * @param {Number} docDefinition.pageSize.height height\r\n * @param {Object} [docDefinition.pageMargins] page margins (pdfkit units)\r\n * @param {Number} docDefinition.maxPagesNumber maximum number of pages to render\r\n *\r\n * @example\r\n *\r\n * var docDefinition = {\r\n * \tinfo: {\r\n *\t\ttitle: 'awesome Document',\r\n *\t\tauthor: 'john doe',\r\n *\t\tsubject: 'subject of document',\r\n *\t\tkeywords: 'keywords for document',\r\n * \t},\r\n *\tcontent: [\r\n *\t\t'First paragraph',\r\n *\t\t'Second paragraph, this time a little bit longer',\r\n *\t\t{ text: 'Third paragraph, slightly bigger font size', fontSize: 20 },\r\n *\t\t{ text: 'Another paragraph using a named style', style: 'header' },\r\n *\t\t{ text: ['playing with ', 'inlines' ] },\r\n *\t\t{ text: ['and ', { text: 'restyling ', bold: true }, 'them'] },\r\n *\t],\r\n *\tstyles: {\r\n *\t\theader: { fontSize: 30, bold: true }\r\n *\t},\r\n *\tpatterns: {\r\n *\t\tstripe45d: {\r\n *\t\t\tboundingBox: [1, 1, 4, 4],\r\n *\t\t\txStep: 3,\r\n *\t\t\tyStep: 3,\r\n *\t\t\tpattern: '1 w 0 1 m 4 5 l s 2 0 m 5 3 l s'\r\n *\t\t}\r\n *\t}\r\n * };\r\n *\r\n * var pdfKitDoc = printer.createPdfKitDocument(docDefinition);\r\n *\r\n * pdfKitDoc.pipe(fs.createWriteStream('sample.pdf'));\r\n * pdfKitDoc.end();\r\n *\r\n * @return {Object} a pdfKit document object which can be saved or encode to data-url\r\n */\r\nPdfPrinter.prototype.createPdfKitDocument = function (docDefinition, options) {\r\n\toptions = options || {};\r\n\r\n\tdocDefinition.version = docDefinition.version || '1.3';\r\n\tdocDefinition.subset = docDefinition.subset || undefined;\r\n\tdocDefinition.tagged = typeof docDefinition.tagged === 'boolean' ? docDefinition.tagged : false;\r\n\tdocDefinition.displayTitle = typeof docDefinition.displayTitle === 'boolean' ? docDefinition.displayTitle : false;\r\n\tdocDefinition.compress = isBoolean(docDefinition.compress) ? docDefinition.compress : true;\r\n\tdocDefinition.images = docDefinition.images || {};\r\n\tdocDefinition.pageMargins = ((docDefinition.pageMargins !== undefined) && (docDefinition.pageMargins !== null)) ? docDefinition.pageMargins : 40;\r\n\r\n\tvar pageSize = fixPageSize(docDefinition.pageSize, docDefinition.pageOrientation);\r\n\r\n\tvar pdfOptions = {\r\n\t\tsize: [pageSize.width, pageSize.height],\r\n\t\tpdfVersion: docDefinition.version,\r\n\t\tsubset: docDefinition.subset,\r\n\t\ttagged: docDefinition.tagged,\r\n\t\tdisplayTitle: docDefinition.displayTitle,\r\n\t\tcompress: docDefinition.compress,\r\n\t\tuserPassword: docDefinition.userPassword,\r\n\t\townerPassword: docDefinition.ownerPassword,\r\n\t\tpermissions: docDefinition.permissions,\r\n\t\tlang: docDefinition.language,\r\n\t\tfontLayoutCache: isBoolean(options.fontLayoutCache) ? options.fontLayoutCache : true,\r\n\t\tbufferPages: options.bufferPages || false,\r\n\t\tautoFirstPage: false,\r\n\t\tinfo: createMetadata(docDefinition),\r\n\t\tfont: null\r\n\t};\r\n\r\n\tthis.pdfKitDoc = PdfKitEngine.createPdfDocument(pdfOptions);\r\n\r\n\tthis.fontProvider = new FontProvider(this.fontDescriptors, this.pdfKitDoc);\r\n\r\n\tvar builder = new LayoutBuilder(pageSize, fixPageMargins(docDefinition.pageMargins), new ImageMeasure(this.pdfKitDoc, docDefinition.images), new SVGMeasure());\r\n\r\n\tregisterDefaultTableLayouts(builder);\r\n\tif (options.tableLayouts) {\r\n\t\tbuilder.registerTableLayouts(options.tableLayouts);\r\n\t}\r\n\r\n\tvar pages = builder.layoutDocument(docDefinition.content, this.fontProvider, docDefinition.styles || {}, docDefinition.defaultStyle || {\r\n\t\tfontSize: 12,\r\n\t\tfont: 'Roboto'\r\n\t}, docDefinition.background, docDefinition.header, docDefinition.footer, docDefinition.images, docDefinition.watermark, docDefinition.pageBreakBefore);\r\n\tvar maxNumberPages = docDefinition.maxPagesNumber || -1;\r\n\tif (isNumber(maxNumberPages) && maxNumberPages > -1) {\r\n\t\tpages = pages.slice(0, maxNumberPages);\r\n\t}\r\n\r\n\t// if pageSize.height is set to Infinity, calculate the actual height of the page that\r\n\t// was laid out using the height of each of the items in the page.\r\n\tif (pageSize.height === Infinity) {\r\n\t\tvar pageHeight = calculatePageHeight(pages, docDefinition.pageMargins);\r\n\t\tthis.pdfKitDoc.options.size = [pageSize.width, pageHeight];\r\n\t}\r\n\r\n\tvar patterns = createPatterns(docDefinition.patterns || {}, this.pdfKitDoc);\r\n\r\n\trenderPages(pages, this.fontProvider, this.pdfKitDoc, patterns, options.progressCallback);\r\n\r\n\tif (options.autoPrint) {\r\n\t\tvar printActionRef = this.pdfKitDoc.ref({\r\n\t\t\tType: 'Action',\r\n\t\t\tS: 'Named',\r\n\t\t\tN: 'Print'\r\n\t\t});\r\n\t\tthis.pdfKitDoc._root.data.OpenAction = printActionRef;\r\n\t\tprintActionRef.end();\r\n\t}\r\n\treturn this.pdfKitDoc;\r\n};\r\n\r\nfunction createMetadata(docDefinition) {\r\n\t// PDF standard has these properties reserved: Title, Author, Subject, Keywords,\r\n\t// Creator, Producer, CreationDate, ModDate, Trapped.\r\n\t// To keep the pdfmake api consistent, the info field are defined lowercase.\r\n\t// Custom properties don't contain a space.\r\n\tfunction standardizePropertyKey(key) {\r\n\t\tvar standardProperties = ['Title', 'Author', 'Subject', 'Keywords',\r\n\t\t\t'Creator', 'Producer', 'CreationDate', 'ModDate', 'Trapped'];\r\n\t\tvar standardizedKey = key.charAt(0).toUpperCase() + key.slice(1);\r\n\t\tif (standardProperties.indexOf(standardizedKey) !== -1) {\r\n\t\t\treturn standardizedKey;\r\n\t\t}\r\n\r\n\t\treturn key.replace(/\\s+/g, '');\r\n\t}\r\n\r\n\tvar info = {\r\n\t\tProducer: 'pdfmake',\r\n\t\tCreator: 'pdfmake'\r\n\t};\r\n\r\n\tif (docDefinition.info) {\r\n\t\tfor (var key in docDefinition.info) {\r\n\t\t\tvar value = docDefinition.info[key];\r\n\t\t\tif (value) {\r\n\t\t\t\tkey = standardizePropertyKey(key);\r\n\t\t\t\tinfo[key] = value;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn info;\r\n}\r\n\r\nfunction calculatePageHeight(pages, margins) {\r\n\tfunction getItemHeight(item) {\r\n\t\tif (isFunction(item.item.getHeight)) {\r\n\t\t\treturn item.item.getHeight();\r\n\t\t} else if (item.item._height) {\r\n\t\t\treturn item.item._height;\r\n\t\t} else if (item.type === 'vector') {\r\n\t\t\tif (typeof item.item.y1 !== 'undefined') {\r\n\t\t\t\treturn item.item.y1 > item.item.y2 ? item.item.y1 : item.item.y2;\r\n\t\t\t} else {\r\n\t\t\t\treturn item.item.h;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// TODO: add support for next item types\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getBottomPosition(item) {\r\n\t\tvar top = item.item.y || 0;\r\n\t\tvar height = getItemHeight(item);\r\n\t\treturn top + height;\r\n\t}\r\n\r\n\tvar fixedMargins = fixPageMargins(margins || 40);\r\n\tvar height = fixedMargins.top;\r\n\r\n\tpages.forEach(function (page) {\r\n\t\tpage.items.forEach(function (item) {\r\n\t\t\tvar bottomPosition = getBottomPosition(item);\r\n\t\t\tif (bottomPosition > height) {\r\n\t\t\t\theight = bottomPosition;\r\n\t\t\t}\r\n\t\t});\r\n\t});\r\n\r\n\theight += fixedMargins.bottom;\r\n\r\n\treturn height;\r\n}\r\n\r\nfunction fixPageSize(pageSize, pageOrientation) {\r\n\tfunction isNeedSwapPageSizes(pageOrientation) {\r\n\t\tif (isString(pageOrientation)) {\r\n\t\t\tpageOrientation = pageOrientation.toLowerCase();\r\n\t\t\treturn ((pageOrientation === 'portrait') && (size.width > size.height)) ||\r\n\t\t\t\t((pageOrientation === 'landscape') && (size.width < size.height));\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// if pageSize.height is set to auto, set the height to infinity so there are no page breaks.\r\n\tif (pageSize && pageSize.height === 'auto') {\r\n\t\tpageSize.height = Infinity;\r\n\t}\r\n\r\n\tvar size = pageSize2widthAndHeight(pageSize || 'A4');\r\n\tif (isNeedSwapPageSizes(pageOrientation)) { // swap page sizes\r\n\t\tsize = { width: size.height, height: size.width };\r\n\t}\r\n\tsize.orientation = size.width > size.height ? 'landscape' : 'portrait';\r\n\treturn size;\r\n}\r\n\r\nfunction fixPageMargins(margin) {\r\n\tif (isNumber(margin)) {\r\n\t\tmargin = { left: margin, right: margin, top: margin, bottom: margin };\r\n\t} else if (isArray(margin)) {\r\n\t\tif (margin.length === 2) {\r\n\t\t\tmargin = { left: margin[0], top: margin[1], right: margin[0], bottom: margin[1] };\r\n\t\t} else if (margin.length === 4) {\r\n\t\t\tmargin = { left: margin[0], top: margin[1], right: margin[2], bottom: margin[3] };\r\n\t\t} else {\r\n\t\t\tthrow 'Invalid pageMargins definition';\r\n\t\t}\r\n\t}\r\n\r\n\treturn margin;\r\n}\r\n\r\nfunction registerDefaultTableLayouts(layoutBuilder) {\r\n\tlayoutBuilder.registerTableLayouts({\r\n\t\tnoBorders: {\r\n\t\t\thLineWidth: function (i) {\r\n\t\t\t\treturn 0;\r\n\t\t\t},\r\n\t\t\tvLineWidth: function (i) {\r\n\t\t\t\treturn 0;\r\n\t\t\t},\r\n\t\t\tpaddingLeft: function (i) {\r\n\t\t\t\treturn i && 4 || 0;\r\n\t\t\t},\r\n\t\t\tpaddingRight: function (i, node) {\r\n\t\t\t\treturn (i < node.table.widths.length - 1) ? 4 : 0;\r\n\t\t\t}\r\n\t\t},\r\n\t\theaderLineOnly: {\r\n\t\t\thLineWidth: function (i, node) {\r\n\t\t\t\tif (i === 0 || i === node.table.body.length) {\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t\t\treturn (i === node.table.headerRows) ? 2 : 0;\r\n\t\t\t},\r\n\t\t\tvLineWidth: function (i) {\r\n\t\t\t\treturn 0;\r\n\t\t\t},\r\n\t\t\tpaddingLeft: function (i) {\r\n\t\t\t\treturn i === 0 ? 0 : 8;\r\n\t\t\t},\r\n\t\t\tpaddingRight: function (i, node) {\r\n\t\t\t\treturn (i === node.table.widths.length - 1) ? 0 : 8;\r\n\t\t\t}\r\n\t\t},\r\n\t\tlightHorizontalLines: {\r\n\t\t\thLineWidth: function (i, node) {\r\n\t\t\t\tif (i === 0 || i === node.table.body.length) {\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\t\t\t\treturn (i === node.table.headerRows) ? 2 : 1;\r\n\t\t\t},\r\n\t\t\tvLineWidth: function (i) {\r\n\t\t\t\treturn 0;\r\n\t\t\t},\r\n\t\t\thLineColor: function (i) {\r\n\t\t\t\treturn i === 1 ? 'black' : '#aaa';\r\n\t\t\t},\r\n\t\t\tpaddingLeft: function (i) {\r\n\t\t\t\treturn i === 0 ? 0 : 8;\r\n\t\t\t},\r\n\t\t\tpaddingRight: function (i, node) {\r\n\t\t\t\treturn (i === node.table.widths.length - 1) ? 0 : 8;\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\n\r\nfunction pageSize2widthAndHeight(pageSize) {\r\n\tif (isString(pageSize)) {\r\n\t\tvar size = sizes[pageSize.toUpperCase()];\r\n\t\tif (!size) {\r\n\t\t\tthrow 'Page size ' + pageSize + ' not recognized';\r\n\t\t}\r\n\t\treturn { width: size[0], height: size[1] };\r\n\t}\r\n\r\n\treturn pageSize;\r\n}\r\n\r\nfunction updatePageOrientationInOptions(currentPage, pdfKitDoc) {\r\n\tvar previousPageOrientation = pdfKitDoc.options.size[0] > pdfKitDoc.options.size[1] ? 'landscape' : 'portrait';\r\n\r\n\tif (currentPage.pageSize.orientation !== previousPageOrientation) {\r\n\t\tvar width = pdfKitDoc.options.size[0];\r\n\t\tvar height = pdfKitDoc.options.size[1];\r\n\t\tpdfKitDoc.options.size = [height, width];\r\n\t}\r\n}\r\n\r\nfunction renderPages(pages, fontProvider, pdfKitDoc, patterns, progressCallback) {\r\n\tpdfKitDoc._pdfMakePages = pages;\r\n\tpdfKitDoc.addPage();\r\n\r\n\tvar totalItems = 0;\r\n\tif (progressCallback) {\r\n\t\tpages.forEach(function (page) {\r\n\t\t\ttotalItems += page.items.length;\r\n\t\t});\r\n\t}\r\n\r\n\tvar renderedItems = 0;\r\n\tprogressCallback = progressCallback || function () {\r\n\t};\r\n\r\n\tfor (var i = 0; i < pages.length; i++) {\r\n\t\tif (i > 0) {\r\n\t\t\tupdatePageOrientationInOptions(pages[i], pdfKitDoc);\r\n\t\t\tpdfKitDoc.addPage(pdfKitDoc.options);\r\n\t\t}\r\n\r\n\t\tvar page = pages[i];\r\n\t\tfor (var ii = 0, il = page.items.length; ii < il; ii++) {\r\n\t\t\tvar item = page.items[ii];\r\n\t\t\tswitch (item.type) {\r\n\t\t\t\tcase 'vector':\r\n\t\t\t\t\trenderVector(item.item, patterns, pdfKitDoc);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'line':\r\n\t\t\t\t\trenderLine(item.item, item.item.x, item.item.y, patterns, pdfKitDoc);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'image':\r\n\t\t\t\t\trenderImage(item.item, item.item.x, item.item.y, pdfKitDoc);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'svg':\r\n\t\t\t\t\trenderSVG(item.item, item.item.x, item.item.y, pdfKitDoc, fontProvider);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'beginClip':\r\n\t\t\t\t\tbeginClip(item.item, pdfKitDoc);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'endClip':\r\n\t\t\t\t\tendClip(pdfKitDoc);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\trenderedItems++;\r\n\t\t\tprogressCallback(renderedItems / totalItems);\r\n\t\t}\r\n\t\tif (page.watermark) {\r\n\t\t\trenderWatermark(page, pdfKitDoc);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Shift the \"y\" height of the text baseline up or down (superscript or subscript,\r\n * respectively). The exact shift can / should be changed according to standard\r\n * conventions.\r\n *\r\n * @param {number} y\r\n * @param {any} inline\r\n */\r\nfunction offsetText(y, inline) {\r\n\tvar newY = y;\r\n\tif (inline.sup) {\r\n\t\tnewY -= inline.fontSize * 0.75;\r\n\t}\r\n\tif (inline.sub) {\r\n\t\tnewY += inline.fontSize * 0.35;\r\n\t}\r\n\treturn newY;\r\n}\r\n\r\nfunction renderLine(line, x, y, patterns, pdfKitDoc) {\r\n\tfunction preparePageNodeRefLine(_pageNodeRef, inline) {\r\n\t\tvar newWidth;\r\n\t\tvar diffWidth;\r\n\t\tvar textTools = new TextTools(null);\r\n\r\n\t\tif (isUndefined(_pageNodeRef.positions)) {\r\n\t\t\tthrow 'Page reference id not found';\r\n\t\t}\r\n\r\n\t\tvar pageNumber = _pageNodeRef.positions[0].pageNumber.toString();\r\n\r\n\t\tinline.text = pageNumber;\r\n\t\tnewWidth = textTools.widthOfString(inline.text, inline.font, inline.fontSize, inline.characterSpacing, inline.fontFeatures);\r\n\t\tdiffWidth = inline.width - newWidth;\r\n\t\tinline.width = newWidth;\r\n\r\n\t\tswitch (inline.alignment) {\r\n\t\t\tcase 'right':\r\n\t\t\t\tinline.x += diffWidth;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 'center':\r\n\t\t\t\tinline.x += diffWidth / 2;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif (line._pageNodeRef) {\r\n\t\tpreparePageNodeRefLine(line._pageNodeRef, line.inlines[0]);\r\n\t}\r\n\r\n\tx = x || 0;\r\n\ty = y || 0;\r\n\r\n\tvar lineHeight = line.getHeight();\r\n\tvar ascenderHeight = line.getAscenderHeight();\r\n\tvar descent = lineHeight - ascenderHeight;\r\n\r\n\ttextDecorator.drawBackground(line, x, y, patterns, pdfKitDoc);\r\n\r\n\t//TODO: line.optimizeInlines();\r\n\tfor (var i = 0, l = line.inlines.length; i < l; i++) {\r\n\t\tvar inline = line.inlines[i];\r\n\t\tvar shiftToBaseline = lineHeight - ((inline.font.ascender / 1000) * inline.fontSize) - descent;\r\n\r\n\t\tif (inline._pageNodeRef) {\r\n\t\t\tpreparePageNodeRefLine(inline._pageNodeRef, inline);\r\n\t\t}\r\n\r\n\t\tvar options = {\r\n\t\t\tlineBreak: false,\r\n\t\t\ttextWidth: inline.width,\r\n\t\t\tcharacterSpacing: inline.characterSpacing,\r\n\t\t\twordCount: 1,\r\n\t\t\tlink: inline.link\r\n\t\t};\r\n\r\n\t\tif (inline.linkToDestination) {\r\n\t\t\toptions.goTo = inline.linkToDestination;\r\n\t\t}\r\n\r\n\t\tif (line.id && i === 0) {\r\n\t\t\toptions.destination = line.id;\r\n\t\t}\r\n\r\n\t\tif (inline.fontFeatures) {\r\n\t\t\toptions.features = inline.fontFeatures;\r\n\t\t}\r\n\r\n\t\tvar opacity = isNumber(inline.opacity) ? inline.opacity : 1;\r\n\t\tpdfKitDoc.opacity(opacity);\r\n\t\tpdfKitDoc.fill(inline.color || 'black');\r\n\r\n\t\tpdfKitDoc._font = inline.font;\r\n\t\tpdfKitDoc.fontSize(inline.fontSize);\r\n\r\n\t\tvar shiftedY = offsetText(y + shiftToBaseline, inline);\r\n\t\tpdfKitDoc.text(inline.text, x + inline.x, shiftedY, options);\r\n\r\n\t\tif (inline.linkToPage) {\r\n\t\t\tvar _ref = pdfKitDoc.ref({ Type: 'Action', S: 'GoTo', D: [inline.linkToPage, 0, 0] }).end();\r\n\t\t\tpdfKitDoc.annotate(x + inline.x, shiftedY, inline.width, inline.height, {\r\n\t\t\t\tSubtype: 'Link',\r\n\t\t\t\tDest: [inline.linkToPage - 1, 'XYZ', null, null, null]\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t}\r\n\t// Decorations won't draw correctly for superscript\r\n\ttextDecorator.drawDecorations(line, x, y, pdfKitDoc);\r\n}\r\n\r\nfunction renderWatermark(page, pdfKitDoc) {\r\n\tvar watermark = page.watermark;\r\n\r\n\tpdfKitDoc.fill(watermark.color);\r\n\tpdfKitDoc.opacity(watermark.opacity);\r\n\r\n\tpdfKitDoc.save();\r\n\r\n\tpdfKitDoc.rotate(watermark.angle, { origin: [pdfKitDoc.page.width / 2, pdfKitDoc.page.height / 2] });\r\n\r\n\tvar x = pdfKitDoc.page.width / 2 - watermark._size.size.width / 2;\r\n\tvar y = pdfKitDoc.page.height / 2 - watermark._size.size.height / 2;\r\n\r\n\tpdfKitDoc._font = watermark.font;\r\n\tpdfKitDoc.fontSize(watermark.fontSize);\r\n\tpdfKitDoc.text(watermark.text, x, y, { lineBreak: false });\r\n\r\n\tpdfKitDoc.restore();\r\n}\r\n\r\nfunction renderVector(vector, patterns, pdfKitDoc) {\r\n\t//TODO: pdf optimization (there's no need to write all properties everytime)\r\n\tpdfKitDoc.lineWidth(vector.lineWidth || 1);\r\n\tif (vector.dash) {\r\n\t\tpdfKitDoc.dash(vector.dash.length, { space: vector.dash.space || vector.dash.length, phase: vector.dash.phase || 0 });\r\n\t} else {\r\n\t\tpdfKitDoc.undash();\r\n\t}\r\n\tpdfKitDoc.lineJoin(vector.lineJoin || 'miter');\r\n\tpdfKitDoc.lineCap(vector.lineCap || 'butt');\r\n\r\n\t//TODO: clipping\r\n\r\n\tvar gradient = null;\r\n\r\n\tswitch (vector.type) {\r\n\t\tcase 'ellipse':\r\n\t\t\tpdfKitDoc.ellipse(vector.x, vector.y, vector.r1, vector.r2);\r\n\r\n\t\t\tif (vector.linearGradient) {\r\n\t\t\t\tgradient = pdfKitDoc.linearGradient(vector.x - vector.r1, vector.y, vector.x + vector.r1, vector.y);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 'rect':\r\n\t\t\tif (vector.r) {\r\n\t\t\t\tpdfKitDoc.roundedRect(vector.x, vector.y, vector.w, vector.h, vector.r);\r\n\t\t\t} else {\r\n\t\t\t\tpdfKitDoc.rect(vector.x, vector.y, vector.w, vector.h);\r\n\t\t\t}\r\n\r\n\t\t\tif (vector.linearGradient) {\r\n\t\t\t\tgradient = pdfKitDoc.linearGradient(vector.x, vector.y, vector.x + vector.w, vector.y);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 'line':\r\n\t\t\tpdfKitDoc.moveTo(vector.x1, vector.y1);\r\n\t\t\tpdfKitDoc.lineTo(vector.x2, vector.y2);\r\n\t\t\tbreak;\r\n\t\tcase 'polyline':\r\n\t\t\tif (vector.points.length === 0) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tpdfKitDoc.moveTo(vector.points[0].x, vector.points[0].y);\r\n\t\t\tfor (var i = 1, l = vector.points.length; i < l; i++) {\r\n\t\t\t\tpdfKitDoc.lineTo(vector.points[i].x, vector.points[i].y);\r\n\t\t\t}\r\n\r\n\t\t\tif (vector.points.length > 1) {\r\n\t\t\t\tvar p1 = vector.points[0];\r\n\t\t\t\tvar pn = vector.points[vector.points.length - 1];\r\n\r\n\t\t\t\tif (vector.closePath || p1.x === pn.x && p1.y === pn.y) {\r\n\t\t\t\t\tpdfKitDoc.closePath();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 'path':\r\n\t\t\tpdfKitDoc.path(vector.d);\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\tif (vector.linearGradient && gradient) {\r\n\t\tvar step = 1 / (vector.linearGradient.length - 1);\r\n\r\n\t\tfor (var i = 0; i < vector.linearGradient.length; i++) {\r\n\t\t\tgradient.stop(i * step, vector.linearGradient[i]);\r\n\t\t}\r\n\r\n\t\tvector.color = gradient;\r\n\t}\r\n\r\n\tif (isPattern(vector.color)) {\r\n\t\tvector.color = getPattern(vector.color, patterns);\r\n\t}\r\n\r\n\tvar fillOpacity = isNumber(vector.fillOpacity) ? vector.fillOpacity : 1;\r\n\tvar strokeOpacity = isNumber(vector.strokeOpacity) ? vector.strokeOpacity : 1;\r\n\r\n\tif (vector.color && vector.lineColor) {\r\n\t\tpdfKitDoc.fillColor(vector.color, fillOpacity);\r\n\t\tpdfKitDoc.strokeColor(vector.lineColor, strokeOpacity);\r\n\t\tpdfKitDoc.fillAndStroke();\r\n\t} else if (vector.color) {\r\n\t\tpdfKitDoc.fillColor(vector.color, fillOpacity);\r\n\t\tpdfKitDoc.fill();\r\n\t} else {\r\n\t\tpdfKitDoc.strokeColor(vector.lineColor || 'black', strokeOpacity);\r\n\t\tpdfKitDoc.stroke();\r\n\t}\r\n}\r\n\r\nfunction renderImage(image, x, y, pdfKitDoc) {\r\n\tvar opacity = isNumber(image.opacity) ? image.opacity : 1;\r\n\tpdfKitDoc.opacity(opacity);\r\n\tif (image.cover) {\r\n\t\tvar align = image.cover.align || 'center';\r\n\t\tvar valign = image.cover.valign || 'center';\r\n\t\tvar width = image.cover.width ? image.cover.width : image.width;\r\n\t\tvar height = image.cover.height ? image.cover.height : image.height;\r\n\t\tpdfKitDoc.save();\r\n\t\tpdfKitDoc.rect(image.x, image.y, width, height).clip();\r\n\t\tpdfKitDoc.image(image.image, image.x, image.y, { cover: [width, height], align: align, valign: valign });\r\n\t\tpdfKitDoc.restore();\r\n\t} else {\r\n\t\tpdfKitDoc.image(image.image, image.x, image.y, { width: image._width, height: image._height });\r\n\t}\r\n\tif (image.link) {\r\n\t\tpdfKitDoc.link(image.x, image.y, image._width, image._height, image.link);\r\n\t}\r\n\tif (image.linkToPage) {\r\n\t\tpdfKitDoc.ref({ Type: 'Action', S: 'GoTo', D: [image.linkToPage, 0, 0] }).end();\r\n\t\tpdfKitDoc.annotate(image.x, image.y, image._width, image._height, { Subtype: 'Link', Dest: [image.linkToPage - 1, 'XYZ', null, null, null] });\r\n\t}\r\n\tif (image.linkToDestination) {\r\n\t\tpdfKitDoc.goTo(image.x, image.y, image._width, image._height, image.linkToDestination);\r\n\t}\r\n}\r\n\r\nfunction renderSVG(svg, x, y, pdfKitDoc, fontProvider) {\r\n\tvar options = Object.assign({ width: svg._width, height: svg._height, assumePt: true }, svg.options);\r\n\toptions.fontCallback = function (family, bold, italic) {\r\n\t\tvar fontsFamily = family.split(',').map(function (f) { return f.trim().replace(/('|\")/g, ''); });\r\n\t\tvar font = findFont(fontProvider.fonts, fontsFamily, svg.font || 'Roboto');\r\n\r\n\t\tvar fontFile = fontProvider.getFontFile(font, bold, italic);\r\n\t\tif (fontFile === null) {\r\n\t\t\tvar type = fontProvider.getFontType(bold, italic);\r\n\t\t\tthrow new Error('Font \\'' + font + '\\' in style \\'' + type + '\\' is not defined in the font section of the document definition.');\r\n\t\t}\r\n\r\n\t\treturn fontFile;\r\n\t};\r\n\r\n\tSVGtoPDF(pdfKitDoc, svg.svg, svg.x, svg.y, options);\r\n\r\n\tif (svg.link) {\r\n\t\tpdfKitDoc.link(svg.x, svg.y, svg._width, svg._height, svg.link);\r\n\t}\r\n\tif (svg.linkToPage) {\r\n\t\tpdfKitDoc.ref({Type: 'Action', S: 'GoTo', D: [svg.linkToPage, 0, 0]}).end();\r\n\t\tpdfKitDoc.annotate(svg.x, svg.y, svg._width, svg._height, { Subtype: 'Link', Dest: [svg.linkToPage - 1, 'XYZ', null, null, null] });\r\n\t}\r\n\tif (svg.linkToDestination) {\r\n\t\tpdfKitDoc.goTo(svg.x, svg.y, svg._width, svg._height, svg.linkToDestination);\r\n\t}\r\n}\r\n\r\nfunction beginClip(rect, pdfKitDoc) {\r\n\tpdfKitDoc.save();\r\n\tpdfKitDoc.addContent('' + rect.x + ' ' + rect.y + ' ' + rect.width + ' ' + rect.height + ' re');\r\n\tpdfKitDoc.clip();\r\n}\r\n\r\nfunction endClip(pdfKitDoc) {\r\n\tpdfKitDoc.restore();\r\n}\r\n\r\nfunction createPatterns(patternDefinitions, pdfKitDoc) {\r\n\tvar patterns = {};\r\n\tObject.keys(patternDefinitions).forEach(function (p) {\r\n\t\tvar pattern = patternDefinitions[p];\r\n\t\tpatterns[p] = pdfKitDoc.pattern(pattern.boundingBox, pattern.xStep, pattern.yStep, pattern.pattern, pattern.colored);\r\n\t});\r\n\treturn patterns;\r\n}\r\n\r\nmodule.exports = PdfPrinter;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvcHJpbnRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxvQ0FBb0MsZUFBZTtBQUN0QztBQUNiO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWdCO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFnQjtBQUMzQyxvQkFBb0IsbUJBQU8sQ0FBQywwRUFBaUI7QUFDN0MsWUFBWSxtQkFBTyxDQUFDLGtGQUFxQjtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBZ0I7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsb0VBQWM7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMsMEVBQWlCO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLGtFQUFhO0FBQ3JDLGlCQUFpQixnR0FBK0I7QUFDaEQsZUFBZSw4RkFBNkI7QUFDNUMsZUFBZSw4RkFBNkI7QUFDNUMsZ0JBQWdCLCtGQUE4QjtBQUM5QyxjQUFjLDZGQUE0QjtBQUMxQyxrQkFBa0IsaUdBQWdDO0FBQ2xELGdCQUFnQiwrRkFBOEI7QUFDOUMsaUJBQWlCLGdHQUErQjtBQUNoRCxlQUFlLG1CQUFPLENBQUMsOEZBQTJCO0FBQ2xEO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRUFBa0U7QUFDeEUsTUFBTSxnRUFBZ0U7QUFDdEUsTUFBTSxxQ0FBcUM7QUFDM0MsTUFBTSxpQkFBaUIsZ0NBQWdDLFdBQVc7QUFDbEU7QUFDQTtBQUNBLGNBQWM7QUFDZCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHO0FBQ3hHO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0g7QUFDQSxjQUFjO0FBQ2QsSUFBSTtBQUNKLGNBQWM7QUFDZCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlEQUF5RDtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLCtEQUErRDtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsK0VBQStFO0FBQ3RILEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHNEQUFzRDtBQUN6RztBQUNBLEdBQUc7QUFDSCxtREFBbUQsNENBQTRDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQXdEO0FBQzFFLHNFQUFzRSx3RUFBd0U7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0RBQXdEO0FBQ3ZGO0FBQ0EseURBQXlELHdDQUF3QztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFxRDtBQUN0RSw4REFBOEQsc0VBQXNFO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvZ2FzY2F0L3ByaXNtYXF1YW50L3ByaXNtYS1xdWFudHVtL25vZGVfbW9kdWxlcy9wZGZtYWtlL3NyYy9wcmludGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7XCJhcmdzXCI6IFwibm9uZVwifV0qL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgUGRmS2l0RW5naW5lID0gcmVxdWlyZSgnLi9wZGZLaXRFbmdpbmUnKTtcclxudmFyIEZvbnRQcm92aWRlciA9IHJlcXVpcmUoJy4vZm9udFByb3ZpZGVyJyk7XHJcbnZhciBMYXlvdXRCdWlsZGVyID0gcmVxdWlyZSgnLi9sYXlvdXRCdWlsZGVyJyk7XHJcbnZhciBzaXplcyA9IHJlcXVpcmUoJy4vc3RhbmRhcmRQYWdlU2l6ZXMnKTtcclxudmFyIEltYWdlTWVhc3VyZSA9IHJlcXVpcmUoJy4vaW1hZ2VNZWFzdXJlJyk7XHJcbnZhciBTVkdNZWFzdXJlID0gcmVxdWlyZSgnLi9zdmdNZWFzdXJlJyk7XHJcbnZhciB0ZXh0RGVjb3JhdG9yID0gcmVxdWlyZSgnLi90ZXh0RGVjb3JhdG9yJyk7XHJcbnZhciBUZXh0VG9vbHMgPSByZXF1aXJlKCcuL3RleHRUb29scycpO1xyXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaGVscGVycycpLmlzRnVuY3Rpb247XHJcbnZhciBpc1N0cmluZyA9IHJlcXVpcmUoJy4vaGVscGVycycpLmlzU3RyaW5nO1xyXG52YXIgaXNOdW1iZXIgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc051bWJlcjtcclxudmFyIGlzQm9vbGVhbiA9IHJlcXVpcmUoJy4vaGVscGVycycpLmlzQm9vbGVhbjtcclxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc0FycmF5O1xyXG52YXIgaXNVbmRlZmluZWQgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc1VuZGVmaW5lZDtcclxudmFyIGlzUGF0dGVybiA9IHJlcXVpcmUoJy4vaGVscGVycycpLmlzUGF0dGVybjtcclxudmFyIGdldFBhdHRlcm4gPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5nZXRQYXR0ZXJuO1xyXG52YXIgU1ZHdG9QREYgPSByZXF1aXJlKCcuLzNyZC1wYXJ0eS9zdmctdG8tcGRma2l0Jyk7XHJcblxyXG52YXIgZmluZEZvbnQgPSBmdW5jdGlvbiAoZm9udHMsIHJlcXVpcmVkRm9udHMsIGRlZmF1bHRGb250KSB7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCByZXF1aXJlZEZvbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgcmVxdWlyZWRGb250ID0gcmVxdWlyZWRGb250c1tpXS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHRcdGZvciAodmFyIGZvbnQgaW4gZm9udHMpIHtcclxuXHRcdFx0aWYgKGZvbnQudG9Mb3dlckNhc2UoKSA9PT0gcmVxdWlyZWRGb250KSB7XHJcblx0XHRcdFx0cmV0dXJuIGZvbnQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBkZWZhdWx0Rm9udDtcclxufTtcclxuXHJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuLy8gUGRmUHJpbnRlclxyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGEgUGRmUHJpbnRlciB3aGljaCB0dXJucyBkb2N1bWVudCBkZWZpbml0aW9uIGludG8gYSBwZGZcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGZvbnREZXNjcmlwdG9ycyBmb250IGRlZmluaXRpb24gZGljdGlvbmFyeVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgZm9udERlc2NyaXB0b3JzID0ge1xyXG4gKlx0Um9ib3RvOiB7XHJcbiAqXHRcdG5vcm1hbDogJ2ZvbnRzL1JvYm90by1SZWd1bGFyLnR0ZicsXHJcbiAqXHRcdGJvbGQ6ICdmb250cy9Sb2JvdG8tTWVkaXVtLnR0ZicsXHJcbiAqXHRcdGl0YWxpY3M6ICdmb250cy9Sb2JvdG8tSXRhbGljLnR0ZicsXHJcbiAqXHRcdGJvbGRpdGFsaWNzOiAnZm9udHMvUm9ib3RvLU1lZGl1bUl0YWxpYy50dGYnXHJcbiAqXHR9XHJcbiAqIH07XHJcbiAqXHJcbiAqIHZhciBwcmludGVyID0gbmV3IFBkZlByaW50ZXIoZm9udERlc2NyaXB0b3JzKTtcclxuICovXHJcbmZ1bmN0aW9uIFBkZlByaW50ZXIoZm9udERlc2NyaXB0b3JzKSB7XHJcblx0dGhpcy5mb250RGVzY3JpcHRvcnMgPSBmb250RGVzY3JpcHRvcnM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeGVjdXRlcyBsYXlvdXQgZW5naW5lIGZvciB0aGUgc3BlY2lmaWVkIGRvY3VtZW50IGFuZCByZW5kZXJzIGl0IGludG8gYSBwZGZraXQgZG9jdW1lbnRcclxuICogcmVhZHkgdG8gYmUgc2F2ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NEZWZpbml0aW9uIGRvY3VtZW50IGRlZmluaXRpb25cclxuICogQHBhcmFtIHtPYmplY3R9IGRvY0RlZmluaXRpb24uY29udGVudCBhbiBhcnJheSBkZXNjcmliaW5nIHRoZSBwZGYgc3RydWN0dXJlIChmb3IgbW9yZSBpbmZvcm1hdGlvbiB0YWtlIGEgbG9vayBhdCB0aGUgZXhhbXBsZXMgaW4gdGhlIC9leGFtcGxlcyBmb2xkZXIpXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZG9jRGVmaW5pdGlvbi5kZWZhdWx0U3R5bGVdIGRlZmF1bHQgKGltcGxpY2l0KSBzdHlsZSBkZWZpbml0aW9uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZG9jRGVmaW5pdGlvbi5zdHlsZXNdIGRpY3Rpb25hcnkgZGVmaW5pbmcgYWxsIHN0eWxlcyB3aGljaCBjYW4gYmUgdXNlZCBpbiB0aGUgZG9jdW1lbnRcclxuICogQHBhcmFtIHtPYmplY3R9IFtkb2NEZWZpbml0aW9uLnBhZ2VTaXplXSBwYWdlIHNpemUgKHBkZmtpdCB1bml0cywgQTQgZGltZW5zaW9ucyBieSBkZWZhdWx0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gZG9jRGVmaW5pdGlvbi5wYWdlU2l6ZS53aWR0aCB3aWR0aFxyXG4gKiBAcGFyYW0ge051bWJlcn0gZG9jRGVmaW5pdGlvbi5wYWdlU2l6ZS5oZWlnaHQgaGVpZ2h0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZG9jRGVmaW5pdGlvbi5wYWdlTWFyZ2luc10gcGFnZSBtYXJnaW5zIChwZGZraXQgdW5pdHMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBkb2NEZWZpbml0aW9uLm1heFBhZ2VzTnVtYmVyIG1heGltdW0gbnVtYmVyIG9mIHBhZ2VzIHRvIHJlbmRlclxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiB2YXIgZG9jRGVmaW5pdGlvbiA9IHtcclxuICogXHRpbmZvOiB7XHJcbiAqXHRcdHRpdGxlOiAnYXdlc29tZSBEb2N1bWVudCcsXHJcbiAqXHRcdGF1dGhvcjogJ2pvaG4gZG9lJyxcclxuICpcdFx0c3ViamVjdDogJ3N1YmplY3Qgb2YgZG9jdW1lbnQnLFxyXG4gKlx0XHRrZXl3b3JkczogJ2tleXdvcmRzIGZvciBkb2N1bWVudCcsXHJcbiAqIFx0fSxcclxuICpcdGNvbnRlbnQ6IFtcclxuICpcdFx0J0ZpcnN0IHBhcmFncmFwaCcsXHJcbiAqXHRcdCdTZWNvbmQgcGFyYWdyYXBoLCB0aGlzIHRpbWUgYSBsaXR0bGUgYml0IGxvbmdlcicsXHJcbiAqXHRcdHsgdGV4dDogJ1RoaXJkIHBhcmFncmFwaCwgc2xpZ2h0bHkgYmlnZ2VyIGZvbnQgc2l6ZScsIGZvbnRTaXplOiAyMCB9LFxyXG4gKlx0XHR7IHRleHQ6ICdBbm90aGVyIHBhcmFncmFwaCB1c2luZyBhIG5hbWVkIHN0eWxlJywgc3R5bGU6ICdoZWFkZXInIH0sXHJcbiAqXHRcdHsgdGV4dDogWydwbGF5aW5nIHdpdGggJywgJ2lubGluZXMnIF0gfSxcclxuICpcdFx0eyB0ZXh0OiBbJ2FuZCAnLCB7IHRleHQ6ICdyZXN0eWxpbmcgJywgYm9sZDogdHJ1ZSB9LCAndGhlbSddIH0sXHJcbiAqXHRdLFxyXG4gKlx0c3R5bGVzOiB7XHJcbiAqXHRcdGhlYWRlcjogeyBmb250U2l6ZTogMzAsIGJvbGQ6IHRydWUgfVxyXG4gKlx0fSxcclxuICpcdHBhdHRlcm5zOiB7XHJcbiAqXHRcdHN0cmlwZTQ1ZDoge1xyXG4gKlx0XHRcdGJvdW5kaW5nQm94OiBbMSwgMSwgNCwgNF0sXHJcbiAqXHRcdFx0eFN0ZXA6IDMsXHJcbiAqXHRcdFx0eVN0ZXA6IDMsXHJcbiAqXHRcdFx0cGF0dGVybjogJzEgdyAwIDEgbSA0IDUgbCBzIDIgMCBtIDUgMyBsIHMnXHJcbiAqXHRcdH1cclxuICpcdH1cclxuICogfTtcclxuICpcclxuICogdmFyIHBkZktpdERvYyA9IHByaW50ZXIuY3JlYXRlUGRmS2l0RG9jdW1lbnQoZG9jRGVmaW5pdGlvbik7XHJcbiAqXHJcbiAqIHBkZktpdERvYy5waXBlKGZzLmNyZWF0ZVdyaXRlU3RyZWFtKCdzYW1wbGUucGRmJykpO1xyXG4gKiBwZGZLaXREb2MuZW5kKCk7XHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gYSBwZGZLaXQgZG9jdW1lbnQgb2JqZWN0IHdoaWNoIGNhbiBiZSBzYXZlZCBvciBlbmNvZGUgdG8gZGF0YS11cmxcclxuICovXHJcblBkZlByaW50ZXIucHJvdG90eXBlLmNyZWF0ZVBkZktpdERvY3VtZW50ID0gZnVuY3Rpb24gKGRvY0RlZmluaXRpb24sIG9wdGlvbnMpIHtcclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0ZG9jRGVmaW5pdGlvbi52ZXJzaW9uID0gZG9jRGVmaW5pdGlvbi52ZXJzaW9uIHx8ICcxLjMnO1xyXG5cdGRvY0RlZmluaXRpb24uc3Vic2V0ID0gZG9jRGVmaW5pdGlvbi5zdWJzZXQgfHwgdW5kZWZpbmVkO1xyXG5cdGRvY0RlZmluaXRpb24udGFnZ2VkID0gdHlwZW9mIGRvY0RlZmluaXRpb24udGFnZ2VkID09PSAnYm9vbGVhbicgPyBkb2NEZWZpbml0aW9uLnRhZ2dlZCA6IGZhbHNlO1xyXG5cdGRvY0RlZmluaXRpb24uZGlzcGxheVRpdGxlID0gdHlwZW9mIGRvY0RlZmluaXRpb24uZGlzcGxheVRpdGxlID09PSAnYm9vbGVhbicgPyBkb2NEZWZpbml0aW9uLmRpc3BsYXlUaXRsZSA6IGZhbHNlO1xyXG5cdGRvY0RlZmluaXRpb24uY29tcHJlc3MgPSBpc0Jvb2xlYW4oZG9jRGVmaW5pdGlvbi5jb21wcmVzcykgPyBkb2NEZWZpbml0aW9uLmNvbXByZXNzIDogdHJ1ZTtcclxuXHRkb2NEZWZpbml0aW9uLmltYWdlcyA9IGRvY0RlZmluaXRpb24uaW1hZ2VzIHx8IHt9O1xyXG5cdGRvY0RlZmluaXRpb24ucGFnZU1hcmdpbnMgPSAoKGRvY0RlZmluaXRpb24ucGFnZU1hcmdpbnMgIT09IHVuZGVmaW5lZCkgJiYgKGRvY0RlZmluaXRpb24ucGFnZU1hcmdpbnMgIT09IG51bGwpKSA/IGRvY0RlZmluaXRpb24ucGFnZU1hcmdpbnMgOiA0MDtcclxuXHJcblx0dmFyIHBhZ2VTaXplID0gZml4UGFnZVNpemUoZG9jRGVmaW5pdGlvbi5wYWdlU2l6ZSwgZG9jRGVmaW5pdGlvbi5wYWdlT3JpZW50YXRpb24pO1xyXG5cclxuXHR2YXIgcGRmT3B0aW9ucyA9IHtcclxuXHRcdHNpemU6IFtwYWdlU2l6ZS53aWR0aCwgcGFnZVNpemUuaGVpZ2h0XSxcclxuXHRcdHBkZlZlcnNpb246IGRvY0RlZmluaXRpb24udmVyc2lvbixcclxuXHRcdHN1YnNldDogZG9jRGVmaW5pdGlvbi5zdWJzZXQsXHJcblx0XHR0YWdnZWQ6IGRvY0RlZmluaXRpb24udGFnZ2VkLFxyXG5cdFx0ZGlzcGxheVRpdGxlOiBkb2NEZWZpbml0aW9uLmRpc3BsYXlUaXRsZSxcclxuXHRcdGNvbXByZXNzOiBkb2NEZWZpbml0aW9uLmNvbXByZXNzLFxyXG5cdFx0dXNlclBhc3N3b3JkOiBkb2NEZWZpbml0aW9uLnVzZXJQYXNzd29yZCxcclxuXHRcdG93bmVyUGFzc3dvcmQ6IGRvY0RlZmluaXRpb24ub3duZXJQYXNzd29yZCxcclxuXHRcdHBlcm1pc3Npb25zOiBkb2NEZWZpbml0aW9uLnBlcm1pc3Npb25zLFxyXG5cdFx0bGFuZzogZG9jRGVmaW5pdGlvbi5sYW5ndWFnZSxcclxuXHRcdGZvbnRMYXlvdXRDYWNoZTogaXNCb29sZWFuKG9wdGlvbnMuZm9udExheW91dENhY2hlKSA/IG9wdGlvbnMuZm9udExheW91dENhY2hlIDogdHJ1ZSxcclxuXHRcdGJ1ZmZlclBhZ2VzOiBvcHRpb25zLmJ1ZmZlclBhZ2VzIHx8IGZhbHNlLFxyXG5cdFx0YXV0b0ZpcnN0UGFnZTogZmFsc2UsXHJcblx0XHRpbmZvOiBjcmVhdGVNZXRhZGF0YShkb2NEZWZpbml0aW9uKSxcclxuXHRcdGZvbnQ6IG51bGxcclxuXHR9O1xyXG5cclxuXHR0aGlzLnBkZktpdERvYyA9IFBkZktpdEVuZ2luZS5jcmVhdGVQZGZEb2N1bWVudChwZGZPcHRpb25zKTtcclxuXHJcblx0dGhpcy5mb250UHJvdmlkZXIgPSBuZXcgRm9udFByb3ZpZGVyKHRoaXMuZm9udERlc2NyaXB0b3JzLCB0aGlzLnBkZktpdERvYyk7XHJcblxyXG5cdHZhciBidWlsZGVyID0gbmV3IExheW91dEJ1aWxkZXIocGFnZVNpemUsIGZpeFBhZ2VNYXJnaW5zKGRvY0RlZmluaXRpb24ucGFnZU1hcmdpbnMpLCBuZXcgSW1hZ2VNZWFzdXJlKHRoaXMucGRmS2l0RG9jLCBkb2NEZWZpbml0aW9uLmltYWdlcyksIG5ldyBTVkdNZWFzdXJlKCkpO1xyXG5cclxuXHRyZWdpc3RlckRlZmF1bHRUYWJsZUxheW91dHMoYnVpbGRlcik7XHJcblx0aWYgKG9wdGlvbnMudGFibGVMYXlvdXRzKSB7XHJcblx0XHRidWlsZGVyLnJlZ2lzdGVyVGFibGVMYXlvdXRzKG9wdGlvbnMudGFibGVMYXlvdXRzKTtcclxuXHR9XHJcblxyXG5cdHZhciBwYWdlcyA9IGJ1aWxkZXIubGF5b3V0RG9jdW1lbnQoZG9jRGVmaW5pdGlvbi5jb250ZW50LCB0aGlzLmZvbnRQcm92aWRlciwgZG9jRGVmaW5pdGlvbi5zdHlsZXMgfHwge30sIGRvY0RlZmluaXRpb24uZGVmYXVsdFN0eWxlIHx8IHtcclxuXHRcdGZvbnRTaXplOiAxMixcclxuXHRcdGZvbnQ6ICdSb2JvdG8nXHJcblx0fSwgZG9jRGVmaW5pdGlvbi5iYWNrZ3JvdW5kLCBkb2NEZWZpbml0aW9uLmhlYWRlciwgZG9jRGVmaW5pdGlvbi5mb290ZXIsIGRvY0RlZmluaXRpb24uaW1hZ2VzLCBkb2NEZWZpbml0aW9uLndhdGVybWFyaywgZG9jRGVmaW5pdGlvbi5wYWdlQnJlYWtCZWZvcmUpO1xyXG5cdHZhciBtYXhOdW1iZXJQYWdlcyA9IGRvY0RlZmluaXRpb24ubWF4UGFnZXNOdW1iZXIgfHwgLTE7XHJcblx0aWYgKGlzTnVtYmVyKG1heE51bWJlclBhZ2VzKSAmJiBtYXhOdW1iZXJQYWdlcyA+IC0xKSB7XHJcblx0XHRwYWdlcyA9IHBhZ2VzLnNsaWNlKDAsIG1heE51bWJlclBhZ2VzKTtcclxuXHR9XHJcblxyXG5cdC8vIGlmIHBhZ2VTaXplLmhlaWdodCBpcyBzZXQgdG8gSW5maW5pdHksIGNhbGN1bGF0ZSB0aGUgYWN0dWFsIGhlaWdodCBvZiB0aGUgcGFnZSB0aGF0XHJcblx0Ly8gd2FzIGxhaWQgb3V0IHVzaW5nIHRoZSBoZWlnaHQgb2YgZWFjaCBvZiB0aGUgaXRlbXMgaW4gdGhlIHBhZ2UuXHJcblx0aWYgKHBhZ2VTaXplLmhlaWdodCA9PT0gSW5maW5pdHkpIHtcclxuXHRcdHZhciBwYWdlSGVpZ2h0ID0gY2FsY3VsYXRlUGFnZUhlaWdodChwYWdlcywgZG9jRGVmaW5pdGlvbi5wYWdlTWFyZ2lucyk7XHJcblx0XHR0aGlzLnBkZktpdERvYy5vcHRpb25zLnNpemUgPSBbcGFnZVNpemUud2lkdGgsIHBhZ2VIZWlnaHRdO1xyXG5cdH1cclxuXHJcblx0dmFyIHBhdHRlcm5zID0gY3JlYXRlUGF0dGVybnMoZG9jRGVmaW5pdGlvbi5wYXR0ZXJucyB8fCB7fSwgdGhpcy5wZGZLaXREb2MpO1xyXG5cclxuXHRyZW5kZXJQYWdlcyhwYWdlcywgdGhpcy5mb250UHJvdmlkZXIsIHRoaXMucGRmS2l0RG9jLCBwYXR0ZXJucywgb3B0aW9ucy5wcm9ncmVzc0NhbGxiYWNrKTtcclxuXHJcblx0aWYgKG9wdGlvbnMuYXV0b1ByaW50KSB7XHJcblx0XHR2YXIgcHJpbnRBY3Rpb25SZWYgPSB0aGlzLnBkZktpdERvYy5yZWYoe1xyXG5cdFx0XHRUeXBlOiAnQWN0aW9uJyxcclxuXHRcdFx0UzogJ05hbWVkJyxcclxuXHRcdFx0TjogJ1ByaW50J1xyXG5cdFx0fSk7XHJcblx0XHR0aGlzLnBkZktpdERvYy5fcm9vdC5kYXRhLk9wZW5BY3Rpb24gPSBwcmludEFjdGlvblJlZjtcclxuXHRcdHByaW50QWN0aW9uUmVmLmVuZCgpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5wZGZLaXREb2M7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVNZXRhZGF0YShkb2NEZWZpbml0aW9uKSB7XHJcblx0Ly8gUERGIHN0YW5kYXJkIGhhcyB0aGVzZSBwcm9wZXJ0aWVzIHJlc2VydmVkOiBUaXRsZSwgQXV0aG9yLCBTdWJqZWN0LCBLZXl3b3JkcyxcclxuXHQvLyBDcmVhdG9yLCBQcm9kdWNlciwgQ3JlYXRpb25EYXRlLCBNb2REYXRlLCBUcmFwcGVkLlxyXG5cdC8vIFRvIGtlZXAgdGhlIHBkZm1ha2UgYXBpIGNvbnNpc3RlbnQsIHRoZSBpbmZvIGZpZWxkIGFyZSBkZWZpbmVkIGxvd2VyY2FzZS5cclxuXHQvLyBDdXN0b20gcHJvcGVydGllcyBkb24ndCBjb250YWluIGEgc3BhY2UuXHJcblx0ZnVuY3Rpb24gc3RhbmRhcmRpemVQcm9wZXJ0eUtleShrZXkpIHtcclxuXHRcdHZhciBzdGFuZGFyZFByb3BlcnRpZXMgPSBbJ1RpdGxlJywgJ0F1dGhvcicsICdTdWJqZWN0JywgJ0tleXdvcmRzJyxcclxuXHRcdFx0J0NyZWF0b3InLCAnUHJvZHVjZXInLCAnQ3JlYXRpb25EYXRlJywgJ01vZERhdGUnLCAnVHJhcHBlZCddO1xyXG5cdFx0dmFyIHN0YW5kYXJkaXplZEtleSA9IGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKTtcclxuXHRcdGlmIChzdGFuZGFyZFByb3BlcnRpZXMuaW5kZXhPZihzdGFuZGFyZGl6ZWRLZXkpICE9PSAtMSkge1xyXG5cdFx0XHRyZXR1cm4gc3RhbmRhcmRpemVkS2V5O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBrZXkucmVwbGFjZSgvXFxzKy9nLCAnJyk7XHJcblx0fVxyXG5cclxuXHR2YXIgaW5mbyA9IHtcclxuXHRcdFByb2R1Y2VyOiAncGRmbWFrZScsXHJcblx0XHRDcmVhdG9yOiAncGRmbWFrZSdcclxuXHR9O1xyXG5cclxuXHRpZiAoZG9jRGVmaW5pdGlvbi5pbmZvKSB7XHJcblx0XHRmb3IgKHZhciBrZXkgaW4gZG9jRGVmaW5pdGlvbi5pbmZvKSB7XHJcblx0XHRcdHZhciB2YWx1ZSA9IGRvY0RlZmluaXRpb24uaW5mb1trZXldO1xyXG5cdFx0XHRpZiAodmFsdWUpIHtcclxuXHRcdFx0XHRrZXkgPSBzdGFuZGFyZGl6ZVByb3BlcnR5S2V5KGtleSk7XHJcblx0XHRcdFx0aW5mb1trZXldID0gdmFsdWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGluZm87XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNhbGN1bGF0ZVBhZ2VIZWlnaHQocGFnZXMsIG1hcmdpbnMpIHtcclxuXHRmdW5jdGlvbiBnZXRJdGVtSGVpZ2h0KGl0ZW0pIHtcclxuXHRcdGlmIChpc0Z1bmN0aW9uKGl0ZW0uaXRlbS5nZXRIZWlnaHQpKSB7XHJcblx0XHRcdHJldHVybiBpdGVtLml0ZW0uZ2V0SGVpZ2h0KCk7XHJcblx0XHR9IGVsc2UgaWYgKGl0ZW0uaXRlbS5faGVpZ2h0KSB7XHJcblx0XHRcdHJldHVybiBpdGVtLml0ZW0uX2hlaWdodDtcclxuXHRcdH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSAndmVjdG9yJykge1xyXG5cdFx0XHRpZiAodHlwZW9mIGl0ZW0uaXRlbS55MSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRyZXR1cm4gaXRlbS5pdGVtLnkxID4gaXRlbS5pdGVtLnkyID8gaXRlbS5pdGVtLnkxIDogaXRlbS5pdGVtLnkyO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBpdGVtLml0ZW0uaDtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIG5leHQgaXRlbSB0eXBlc1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldEJvdHRvbVBvc2l0aW9uKGl0ZW0pIHtcclxuXHRcdHZhciB0b3AgPSBpdGVtLml0ZW0ueSB8fCAwO1xyXG5cdFx0dmFyIGhlaWdodCA9IGdldEl0ZW1IZWlnaHQoaXRlbSk7XHJcblx0XHRyZXR1cm4gdG9wICsgaGVpZ2h0O1xyXG5cdH1cclxuXHJcblx0dmFyIGZpeGVkTWFyZ2lucyA9IGZpeFBhZ2VNYXJnaW5zKG1hcmdpbnMgfHwgNDApO1xyXG5cdHZhciBoZWlnaHQgPSBmaXhlZE1hcmdpbnMudG9wO1xyXG5cclxuXHRwYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYWdlKSB7XHJcblx0XHRwYWdlLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuXHRcdFx0dmFyIGJvdHRvbVBvc2l0aW9uID0gZ2V0Qm90dG9tUG9zaXRpb24oaXRlbSk7XHJcblx0XHRcdGlmIChib3R0b21Qb3NpdGlvbiA+IGhlaWdodCkge1xyXG5cdFx0XHRcdGhlaWdodCA9IGJvdHRvbVBvc2l0aW9uO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHJcblx0aGVpZ2h0ICs9IGZpeGVkTWFyZ2lucy5ib3R0b207XHJcblxyXG5cdHJldHVybiBoZWlnaHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpeFBhZ2VTaXplKHBhZ2VTaXplLCBwYWdlT3JpZW50YXRpb24pIHtcclxuXHRmdW5jdGlvbiBpc05lZWRTd2FwUGFnZVNpemVzKHBhZ2VPcmllbnRhdGlvbikge1xyXG5cdFx0aWYgKGlzU3RyaW5nKHBhZ2VPcmllbnRhdGlvbikpIHtcclxuXHRcdFx0cGFnZU9yaWVudGF0aW9uID0gcGFnZU9yaWVudGF0aW9uLnRvTG93ZXJDYXNlKCk7XHJcblx0XHRcdHJldHVybiAoKHBhZ2VPcmllbnRhdGlvbiA9PT0gJ3BvcnRyYWl0JykgJiYgKHNpemUud2lkdGggPiBzaXplLmhlaWdodCkpIHx8XHJcblx0XHRcdFx0KChwYWdlT3JpZW50YXRpb24gPT09ICdsYW5kc2NhcGUnKSAmJiAoc2l6ZS53aWR0aCA8IHNpemUuaGVpZ2h0KSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvLyBpZiBwYWdlU2l6ZS5oZWlnaHQgaXMgc2V0IHRvIGF1dG8sIHNldCB0aGUgaGVpZ2h0IHRvIGluZmluaXR5IHNvIHRoZXJlIGFyZSBubyBwYWdlIGJyZWFrcy5cclxuXHRpZiAocGFnZVNpemUgJiYgcGFnZVNpemUuaGVpZ2h0ID09PSAnYXV0bycpIHtcclxuXHRcdHBhZ2VTaXplLmhlaWdodCA9IEluZmluaXR5O1xyXG5cdH1cclxuXHJcblx0dmFyIHNpemUgPSBwYWdlU2l6ZTJ3aWR0aEFuZEhlaWdodChwYWdlU2l6ZSB8fCAnQTQnKTtcclxuXHRpZiAoaXNOZWVkU3dhcFBhZ2VTaXplcyhwYWdlT3JpZW50YXRpb24pKSB7IC8vIHN3YXAgcGFnZSBzaXplc1xyXG5cdFx0c2l6ZSA9IHsgd2lkdGg6IHNpemUuaGVpZ2h0LCBoZWlnaHQ6IHNpemUud2lkdGggfTtcclxuXHR9XHJcblx0c2l6ZS5vcmllbnRhdGlvbiA9IHNpemUud2lkdGggPiBzaXplLmhlaWdodCA/ICdsYW5kc2NhcGUnIDogJ3BvcnRyYWl0JztcclxuXHRyZXR1cm4gc2l6ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZml4UGFnZU1hcmdpbnMobWFyZ2luKSB7XHJcblx0aWYgKGlzTnVtYmVyKG1hcmdpbikpIHtcclxuXHRcdG1hcmdpbiA9IHsgbGVmdDogbWFyZ2luLCByaWdodDogbWFyZ2luLCB0b3A6IG1hcmdpbiwgYm90dG9tOiBtYXJnaW4gfTtcclxuXHR9IGVsc2UgaWYgKGlzQXJyYXkobWFyZ2luKSkge1xyXG5cdFx0aWYgKG1hcmdpbi5sZW5ndGggPT09IDIpIHtcclxuXHRcdFx0bWFyZ2luID0geyBsZWZ0OiBtYXJnaW5bMF0sIHRvcDogbWFyZ2luWzFdLCByaWdodDogbWFyZ2luWzBdLCBib3R0b206IG1hcmdpblsxXSB9O1xyXG5cdFx0fSBlbHNlIGlmIChtYXJnaW4ubGVuZ3RoID09PSA0KSB7XHJcblx0XHRcdG1hcmdpbiA9IHsgbGVmdDogbWFyZ2luWzBdLCB0b3A6IG1hcmdpblsxXSwgcmlnaHQ6IG1hcmdpblsyXSwgYm90dG9tOiBtYXJnaW5bM10gfTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRocm93ICdJbnZhbGlkIHBhZ2VNYXJnaW5zIGRlZmluaXRpb24nO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG1hcmdpbjtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0VGFibGVMYXlvdXRzKGxheW91dEJ1aWxkZXIpIHtcclxuXHRsYXlvdXRCdWlsZGVyLnJlZ2lzdGVyVGFibGVMYXlvdXRzKHtcclxuXHRcdG5vQm9yZGVyczoge1xyXG5cdFx0XHRoTGluZVdpZHRoOiBmdW5jdGlvbiAoaSkge1xyXG5cdFx0XHRcdHJldHVybiAwO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHR2TGluZVdpZHRoOiBmdW5jdGlvbiAoaSkge1xyXG5cdFx0XHRcdHJldHVybiAwO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRwYWRkaW5nTGVmdDogZnVuY3Rpb24gKGkpIHtcclxuXHRcdFx0XHRyZXR1cm4gaSAmJiA0IHx8IDA7XHJcblx0XHRcdH0sXHJcblx0XHRcdHBhZGRpbmdSaWdodDogZnVuY3Rpb24gKGksIG5vZGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gKGkgPCBub2RlLnRhYmxlLndpZHRocy5sZW5ndGggLSAxKSA/IDQgOiAwO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0aGVhZGVyTGluZU9ubHk6IHtcclxuXHRcdFx0aExpbmVXaWR0aDogZnVuY3Rpb24gKGksIG5vZGUpIHtcclxuXHRcdFx0XHRpZiAoaSA9PT0gMCB8fCBpID09PSBub2RlLnRhYmxlLmJvZHkubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gMDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIChpID09PSBub2RlLnRhYmxlLmhlYWRlclJvd3MpID8gMiA6IDA7XHJcblx0XHRcdH0sXHJcblx0XHRcdHZMaW5lV2lkdGg6IGZ1bmN0aW9uIChpKSB7XHJcblx0XHRcdFx0cmV0dXJuIDA7XHJcblx0XHRcdH0sXHJcblx0XHRcdHBhZGRpbmdMZWZ0OiBmdW5jdGlvbiAoaSkge1xyXG5cdFx0XHRcdHJldHVybiBpID09PSAwID8gMCA6IDg7XHJcblx0XHRcdH0sXHJcblx0XHRcdHBhZGRpbmdSaWdodDogZnVuY3Rpb24gKGksIG5vZGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gKGkgPT09IG5vZGUudGFibGUud2lkdGhzLmxlbmd0aCAtIDEpID8gMCA6IDg7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRsaWdodEhvcml6b250YWxMaW5lczoge1xyXG5cdFx0XHRoTGluZVdpZHRoOiBmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG5cdFx0XHRcdGlmIChpID09PSAwIHx8IGkgPT09IG5vZGUudGFibGUuYm9keS5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdHJldHVybiAwO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gKGkgPT09IG5vZGUudGFibGUuaGVhZGVyUm93cykgPyAyIDogMTtcclxuXHRcdFx0fSxcclxuXHRcdFx0dkxpbmVXaWR0aDogZnVuY3Rpb24gKGkpIHtcclxuXHRcdFx0XHRyZXR1cm4gMDtcclxuXHRcdFx0fSxcclxuXHRcdFx0aExpbmVDb2xvcjogZnVuY3Rpb24gKGkpIHtcclxuXHRcdFx0XHRyZXR1cm4gaSA9PT0gMSA/ICdibGFjaycgOiAnI2FhYSc7XHJcblx0XHRcdH0sXHJcblx0XHRcdHBhZGRpbmdMZWZ0OiBmdW5jdGlvbiAoaSkge1xyXG5cdFx0XHRcdHJldHVybiBpID09PSAwID8gMCA6IDg7XHJcblx0XHRcdH0sXHJcblx0XHRcdHBhZGRpbmdSaWdodDogZnVuY3Rpb24gKGksIG5vZGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gKGkgPT09IG5vZGUudGFibGUud2lkdGhzLmxlbmd0aCAtIDEpID8gMCA6IDg7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGFnZVNpemUyd2lkdGhBbmRIZWlnaHQocGFnZVNpemUpIHtcclxuXHRpZiAoaXNTdHJpbmcocGFnZVNpemUpKSB7XHJcblx0XHR2YXIgc2l6ZSA9IHNpemVzW3BhZ2VTaXplLnRvVXBwZXJDYXNlKCldO1xyXG5cdFx0aWYgKCFzaXplKSB7XHJcblx0XHRcdHRocm93ICdQYWdlIHNpemUgJyArIHBhZ2VTaXplICsgJyBub3QgcmVjb2duaXplZCc7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4geyB3aWR0aDogc2l6ZVswXSwgaGVpZ2h0OiBzaXplWzFdIH07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcGFnZVNpemU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZVBhZ2VPcmllbnRhdGlvbkluT3B0aW9ucyhjdXJyZW50UGFnZSwgcGRmS2l0RG9jKSB7XHJcblx0dmFyIHByZXZpb3VzUGFnZU9yaWVudGF0aW9uID0gcGRmS2l0RG9jLm9wdGlvbnMuc2l6ZVswXSA+IHBkZktpdERvYy5vcHRpb25zLnNpemVbMV0gPyAnbGFuZHNjYXBlJyA6ICdwb3J0cmFpdCc7XHJcblxyXG5cdGlmIChjdXJyZW50UGFnZS5wYWdlU2l6ZS5vcmllbnRhdGlvbiAhPT0gcHJldmlvdXNQYWdlT3JpZW50YXRpb24pIHtcclxuXHRcdHZhciB3aWR0aCA9IHBkZktpdERvYy5vcHRpb25zLnNpemVbMF07XHJcblx0XHR2YXIgaGVpZ2h0ID0gcGRmS2l0RG9jLm9wdGlvbnMuc2l6ZVsxXTtcclxuXHRcdHBkZktpdERvYy5vcHRpb25zLnNpemUgPSBbaGVpZ2h0LCB3aWR0aF07XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW5kZXJQYWdlcyhwYWdlcywgZm9udFByb3ZpZGVyLCBwZGZLaXREb2MsIHBhdHRlcm5zLCBwcm9ncmVzc0NhbGxiYWNrKSB7XHJcblx0cGRmS2l0RG9jLl9wZGZNYWtlUGFnZXMgPSBwYWdlcztcclxuXHRwZGZLaXREb2MuYWRkUGFnZSgpO1xyXG5cclxuXHR2YXIgdG90YWxJdGVtcyA9IDA7XHJcblx0aWYgKHByb2dyZXNzQ2FsbGJhY2spIHtcclxuXHRcdHBhZ2VzLmZvckVhY2goZnVuY3Rpb24gKHBhZ2UpIHtcclxuXHRcdFx0dG90YWxJdGVtcyArPSBwYWdlLml0ZW1zLmxlbmd0aDtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0dmFyIHJlbmRlcmVkSXRlbXMgPSAwO1xyXG5cdHByb2dyZXNzQ2FsbGJhY2sgPSBwcm9ncmVzc0NhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHtcclxuXHR9O1xyXG5cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHBhZ2VzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAoaSA+IDApIHtcclxuXHRcdFx0dXBkYXRlUGFnZU9yaWVudGF0aW9uSW5PcHRpb25zKHBhZ2VzW2ldLCBwZGZLaXREb2MpO1xyXG5cdFx0XHRwZGZLaXREb2MuYWRkUGFnZShwZGZLaXREb2Mub3B0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHBhZ2UgPSBwYWdlc1tpXTtcclxuXHRcdGZvciAodmFyIGlpID0gMCwgaWwgPSBwYWdlLml0ZW1zLmxlbmd0aDsgaWkgPCBpbDsgaWkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHBhZ2UuaXRlbXNbaWldO1xyXG5cdFx0XHRzd2l0Y2ggKGl0ZW0udHlwZSkge1xyXG5cdFx0XHRcdGNhc2UgJ3ZlY3Rvcic6XHJcblx0XHRcdFx0XHRyZW5kZXJWZWN0b3IoaXRlbS5pdGVtLCBwYXR0ZXJucywgcGRmS2l0RG9jKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgJ2xpbmUnOlxyXG5cdFx0XHRcdFx0cmVuZGVyTGluZShpdGVtLml0ZW0sIGl0ZW0uaXRlbS54LCBpdGVtLml0ZW0ueSwgcGF0dGVybnMsIHBkZktpdERvYyk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlICdpbWFnZSc6XHJcblx0XHRcdFx0XHRyZW5kZXJJbWFnZShpdGVtLml0ZW0sIGl0ZW0uaXRlbS54LCBpdGVtLml0ZW0ueSwgcGRmS2l0RG9jKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgJ3N2Zyc6XHJcblx0XHRcdFx0XHRyZW5kZXJTVkcoaXRlbS5pdGVtLCBpdGVtLml0ZW0ueCwgaXRlbS5pdGVtLnksIHBkZktpdERvYywgZm9udFByb3ZpZGVyKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgJ2JlZ2luQ2xpcCc6XHJcblx0XHRcdFx0XHRiZWdpbkNsaXAoaXRlbS5pdGVtLCBwZGZLaXREb2MpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAnZW5kQ2xpcCc6XHJcblx0XHRcdFx0XHRlbmRDbGlwKHBkZktpdERvYyk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRyZW5kZXJlZEl0ZW1zKys7XHJcblx0XHRcdHByb2dyZXNzQ2FsbGJhY2socmVuZGVyZWRJdGVtcyAvIHRvdGFsSXRlbXMpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHBhZ2Uud2F0ZXJtYXJrKSB7XHJcblx0XHRcdHJlbmRlcldhdGVybWFyayhwYWdlLCBwZGZLaXREb2MpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNoaWZ0IHRoZSBcInlcIiBoZWlnaHQgb2YgdGhlIHRleHQgYmFzZWxpbmUgdXAgb3IgZG93biAoc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0LFxyXG4gKiByZXNwZWN0aXZlbHkpLiBUaGUgZXhhY3Qgc2hpZnQgY2FuIC8gc2hvdWxkIGJlIGNoYW5nZWQgYWNjb3JkaW5nIHRvIHN0YW5kYXJkXHJcbiAqIGNvbnZlbnRpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0geVxyXG4gKiBAcGFyYW0ge2FueX0gaW5saW5lXHJcbiAqL1xyXG5mdW5jdGlvbiBvZmZzZXRUZXh0KHksIGlubGluZSkge1xyXG5cdHZhciBuZXdZID0geTtcclxuXHRpZiAoaW5saW5lLnN1cCkge1xyXG5cdFx0bmV3WSAtPSBpbmxpbmUuZm9udFNpemUgKiAwLjc1O1xyXG5cdH1cclxuXHRpZiAoaW5saW5lLnN1Yikge1xyXG5cdFx0bmV3WSArPSBpbmxpbmUuZm9udFNpemUgKiAwLjM1O1xyXG5cdH1cclxuXHRyZXR1cm4gbmV3WTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVuZGVyTGluZShsaW5lLCB4LCB5LCBwYXR0ZXJucywgcGRmS2l0RG9jKSB7XHJcblx0ZnVuY3Rpb24gcHJlcGFyZVBhZ2VOb2RlUmVmTGluZShfcGFnZU5vZGVSZWYsIGlubGluZSkge1xyXG5cdFx0dmFyIG5ld1dpZHRoO1xyXG5cdFx0dmFyIGRpZmZXaWR0aDtcclxuXHRcdHZhciB0ZXh0VG9vbHMgPSBuZXcgVGV4dFRvb2xzKG51bGwpO1xyXG5cclxuXHRcdGlmIChpc1VuZGVmaW5lZChfcGFnZU5vZGVSZWYucG9zaXRpb25zKSkge1xyXG5cdFx0XHR0aHJvdyAnUGFnZSByZWZlcmVuY2UgaWQgbm90IGZvdW5kJztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcGFnZU51bWJlciA9IF9wYWdlTm9kZVJlZi5wb3NpdGlvbnNbMF0ucGFnZU51bWJlci50b1N0cmluZygpO1xyXG5cclxuXHRcdGlubGluZS50ZXh0ID0gcGFnZU51bWJlcjtcclxuXHRcdG5ld1dpZHRoID0gdGV4dFRvb2xzLndpZHRoT2ZTdHJpbmcoaW5saW5lLnRleHQsIGlubGluZS5mb250LCBpbmxpbmUuZm9udFNpemUsIGlubGluZS5jaGFyYWN0ZXJTcGFjaW5nLCBpbmxpbmUuZm9udEZlYXR1cmVzKTtcclxuXHRcdGRpZmZXaWR0aCA9IGlubGluZS53aWR0aCAtIG5ld1dpZHRoO1xyXG5cdFx0aW5saW5lLndpZHRoID0gbmV3V2lkdGg7XHJcblxyXG5cdFx0c3dpdGNoIChpbmxpbmUuYWxpZ25tZW50KSB7XHJcblx0XHRcdGNhc2UgJ3JpZ2h0JzpcclxuXHRcdFx0XHRpbmxpbmUueCArPSBkaWZmV2lkdGg7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgJ2NlbnRlcic6XHJcblx0XHRcdFx0aW5saW5lLnggKz0gZGlmZldpZHRoIC8gMjtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGlmIChsaW5lLl9wYWdlTm9kZVJlZikge1xyXG5cdFx0cHJlcGFyZVBhZ2VOb2RlUmVmTGluZShsaW5lLl9wYWdlTm9kZVJlZiwgbGluZS5pbmxpbmVzWzBdKTtcclxuXHR9XHJcblxyXG5cdHggPSB4IHx8IDA7XHJcblx0eSA9IHkgfHwgMDtcclxuXHJcblx0dmFyIGxpbmVIZWlnaHQgPSBsaW5lLmdldEhlaWdodCgpO1xyXG5cdHZhciBhc2NlbmRlckhlaWdodCA9IGxpbmUuZ2V0QXNjZW5kZXJIZWlnaHQoKTtcclxuXHR2YXIgZGVzY2VudCA9IGxpbmVIZWlnaHQgLSBhc2NlbmRlckhlaWdodDtcclxuXHJcblx0dGV4dERlY29yYXRvci5kcmF3QmFja2dyb3VuZChsaW5lLCB4LCB5LCBwYXR0ZXJucywgcGRmS2l0RG9jKTtcclxuXHJcblx0Ly9UT0RPOiBsaW5lLm9wdGltaXplSW5saW5lcygpO1xyXG5cdGZvciAodmFyIGkgPSAwLCBsID0gbGluZS5pbmxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0dmFyIGlubGluZSA9IGxpbmUuaW5saW5lc1tpXTtcclxuXHRcdHZhciBzaGlmdFRvQmFzZWxpbmUgPSBsaW5lSGVpZ2h0IC0gKChpbmxpbmUuZm9udC5hc2NlbmRlciAvIDEwMDApICogaW5saW5lLmZvbnRTaXplKSAtIGRlc2NlbnQ7XHJcblxyXG5cdFx0aWYgKGlubGluZS5fcGFnZU5vZGVSZWYpIHtcclxuXHRcdFx0cHJlcGFyZVBhZ2VOb2RlUmVmTGluZShpbmxpbmUuX3BhZ2VOb2RlUmVmLCBpbmxpbmUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvcHRpb25zID0ge1xyXG5cdFx0XHRsaW5lQnJlYWs6IGZhbHNlLFxyXG5cdFx0XHR0ZXh0V2lkdGg6IGlubGluZS53aWR0aCxcclxuXHRcdFx0Y2hhcmFjdGVyU3BhY2luZzogaW5saW5lLmNoYXJhY3RlclNwYWNpbmcsXHJcblx0XHRcdHdvcmRDb3VudDogMSxcclxuXHRcdFx0bGluazogaW5saW5lLmxpbmtcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKGlubGluZS5saW5rVG9EZXN0aW5hdGlvbikge1xyXG5cdFx0XHRvcHRpb25zLmdvVG8gPSBpbmxpbmUubGlua1RvRGVzdGluYXRpb247XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGxpbmUuaWQgJiYgaSA9PT0gMCkge1xyXG5cdFx0XHRvcHRpb25zLmRlc3RpbmF0aW9uID0gbGluZS5pZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaW5saW5lLmZvbnRGZWF0dXJlcykge1xyXG5cdFx0XHRvcHRpb25zLmZlYXR1cmVzID0gaW5saW5lLmZvbnRGZWF0dXJlcztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgb3BhY2l0eSA9IGlzTnVtYmVyKGlubGluZS5vcGFjaXR5KSA/IGlubGluZS5vcGFjaXR5IDogMTtcclxuXHRcdHBkZktpdERvYy5vcGFjaXR5KG9wYWNpdHkpO1xyXG5cdFx0cGRmS2l0RG9jLmZpbGwoaW5saW5lLmNvbG9yIHx8ICdibGFjaycpO1xyXG5cclxuXHRcdHBkZktpdERvYy5fZm9udCA9IGlubGluZS5mb250O1xyXG5cdFx0cGRmS2l0RG9jLmZvbnRTaXplKGlubGluZS5mb250U2l6ZSk7XHJcblxyXG5cdFx0dmFyIHNoaWZ0ZWRZID0gb2Zmc2V0VGV4dCh5ICsgc2hpZnRUb0Jhc2VsaW5lLCBpbmxpbmUpO1xyXG5cdFx0cGRmS2l0RG9jLnRleHQoaW5saW5lLnRleHQsIHggKyBpbmxpbmUueCwgc2hpZnRlZFksIG9wdGlvbnMpO1xyXG5cclxuXHRcdGlmIChpbmxpbmUubGlua1RvUGFnZSkge1xyXG5cdFx0XHR2YXIgX3JlZiA9IHBkZktpdERvYy5yZWYoeyBUeXBlOiAnQWN0aW9uJywgUzogJ0dvVG8nLCBEOiBbaW5saW5lLmxpbmtUb1BhZ2UsIDAsIDBdIH0pLmVuZCgpO1xyXG5cdFx0XHRwZGZLaXREb2MuYW5ub3RhdGUoeCArIGlubGluZS54LCBzaGlmdGVkWSwgaW5saW5lLndpZHRoLCBpbmxpbmUuaGVpZ2h0LCB7XHJcblx0XHRcdFx0U3VidHlwZTogJ0xpbmsnLFxyXG5cdFx0XHRcdERlc3Q6IFtpbmxpbmUubGlua1RvUGFnZSAtIDEsICdYWVonLCBudWxsLCBudWxsLCBudWxsXVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0fVxyXG5cdC8vIERlY29yYXRpb25zIHdvbid0IGRyYXcgY29ycmVjdGx5IGZvciBzdXBlcnNjcmlwdFxyXG5cdHRleHREZWNvcmF0b3IuZHJhd0RlY29yYXRpb25zKGxpbmUsIHgsIHksIHBkZktpdERvYyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbmRlcldhdGVybWFyayhwYWdlLCBwZGZLaXREb2MpIHtcclxuXHR2YXIgd2F0ZXJtYXJrID0gcGFnZS53YXRlcm1hcms7XHJcblxyXG5cdHBkZktpdERvYy5maWxsKHdhdGVybWFyay5jb2xvcik7XHJcblx0cGRmS2l0RG9jLm9wYWNpdHkod2F0ZXJtYXJrLm9wYWNpdHkpO1xyXG5cclxuXHRwZGZLaXREb2Muc2F2ZSgpO1xyXG5cclxuXHRwZGZLaXREb2Mucm90YXRlKHdhdGVybWFyay5hbmdsZSwgeyBvcmlnaW46IFtwZGZLaXREb2MucGFnZS53aWR0aCAvIDIsIHBkZktpdERvYy5wYWdlLmhlaWdodCAvIDJdIH0pO1xyXG5cclxuXHR2YXIgeCA9IHBkZktpdERvYy5wYWdlLndpZHRoIC8gMiAtIHdhdGVybWFyay5fc2l6ZS5zaXplLndpZHRoIC8gMjtcclxuXHR2YXIgeSA9IHBkZktpdERvYy5wYWdlLmhlaWdodCAvIDIgLSB3YXRlcm1hcmsuX3NpemUuc2l6ZS5oZWlnaHQgLyAyO1xyXG5cclxuXHRwZGZLaXREb2MuX2ZvbnQgPSB3YXRlcm1hcmsuZm9udDtcclxuXHRwZGZLaXREb2MuZm9udFNpemUod2F0ZXJtYXJrLmZvbnRTaXplKTtcclxuXHRwZGZLaXREb2MudGV4dCh3YXRlcm1hcmsudGV4dCwgeCwgeSwgeyBsaW5lQnJlYWs6IGZhbHNlIH0pO1xyXG5cclxuXHRwZGZLaXREb2MucmVzdG9yZSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW5kZXJWZWN0b3IodmVjdG9yLCBwYXR0ZXJucywgcGRmS2l0RG9jKSB7XHJcblx0Ly9UT0RPOiBwZGYgb3B0aW1pemF0aW9uICh0aGVyZSdzIG5vIG5lZWQgdG8gd3JpdGUgYWxsIHByb3BlcnRpZXMgZXZlcnl0aW1lKVxyXG5cdHBkZktpdERvYy5saW5lV2lkdGgodmVjdG9yLmxpbmVXaWR0aCB8fCAxKTtcclxuXHRpZiAodmVjdG9yLmRhc2gpIHtcclxuXHRcdHBkZktpdERvYy5kYXNoKHZlY3Rvci5kYXNoLmxlbmd0aCwgeyBzcGFjZTogdmVjdG9yLmRhc2guc3BhY2UgfHwgdmVjdG9yLmRhc2gubGVuZ3RoLCBwaGFzZTogdmVjdG9yLmRhc2gucGhhc2UgfHwgMCB9KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cGRmS2l0RG9jLnVuZGFzaCgpO1xyXG5cdH1cclxuXHRwZGZLaXREb2MubGluZUpvaW4odmVjdG9yLmxpbmVKb2luIHx8ICdtaXRlcicpO1xyXG5cdHBkZktpdERvYy5saW5lQ2FwKHZlY3Rvci5saW5lQ2FwIHx8ICdidXR0Jyk7XHJcblxyXG5cdC8vVE9ETzogY2xpcHBpbmdcclxuXHJcblx0dmFyIGdyYWRpZW50ID0gbnVsbDtcclxuXHJcblx0c3dpdGNoICh2ZWN0b3IudHlwZSkge1xyXG5cdFx0Y2FzZSAnZWxsaXBzZSc6XHJcblx0XHRcdHBkZktpdERvYy5lbGxpcHNlKHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnIxLCB2ZWN0b3IucjIpO1xyXG5cclxuXHRcdFx0aWYgKHZlY3Rvci5saW5lYXJHcmFkaWVudCkge1xyXG5cdFx0XHRcdGdyYWRpZW50ID0gcGRmS2l0RG9jLmxpbmVhckdyYWRpZW50KHZlY3Rvci54IC0gdmVjdG9yLnIxLCB2ZWN0b3IueSwgdmVjdG9yLnggKyB2ZWN0b3IucjEsIHZlY3Rvci55KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ3JlY3QnOlxyXG5cdFx0XHRpZiAodmVjdG9yLnIpIHtcclxuXHRcdFx0XHRwZGZLaXREb2Mucm91bmRlZFJlY3QodmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IudywgdmVjdG9yLmgsIHZlY3Rvci5yKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRwZGZLaXREb2MucmVjdCh2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci53LCB2ZWN0b3IuaCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh2ZWN0b3IubGluZWFyR3JhZGllbnQpIHtcclxuXHRcdFx0XHRncmFkaWVudCA9IHBkZktpdERvYy5saW5lYXJHcmFkaWVudCh2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci54ICsgdmVjdG9yLncsIHZlY3Rvci55KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ2xpbmUnOlxyXG5cdFx0XHRwZGZLaXREb2MubW92ZVRvKHZlY3Rvci54MSwgdmVjdG9yLnkxKTtcclxuXHRcdFx0cGRmS2l0RG9jLmxpbmVUbyh2ZWN0b3IueDIsIHZlY3Rvci55Mik7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSAncG9seWxpbmUnOlxyXG5cdFx0XHRpZiAodmVjdG9yLnBvaW50cy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cGRmS2l0RG9jLm1vdmVUbyh2ZWN0b3IucG9pbnRzWzBdLngsIHZlY3Rvci5wb2ludHNbMF0ueSk7XHJcblx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gdmVjdG9yLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0XHRwZGZLaXREb2MubGluZVRvKHZlY3Rvci5wb2ludHNbaV0ueCwgdmVjdG9yLnBvaW50c1tpXS55KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHZlY3Rvci5wb2ludHMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHRcdHZhciBwMSA9IHZlY3Rvci5wb2ludHNbMF07XHJcblx0XHRcdFx0dmFyIHBuID0gdmVjdG9yLnBvaW50c1t2ZWN0b3IucG9pbnRzLmxlbmd0aCAtIDFdO1xyXG5cclxuXHRcdFx0XHRpZiAodmVjdG9yLmNsb3NlUGF0aCB8fCBwMS54ID09PSBwbi54ICYmIHAxLnkgPT09IHBuLnkpIHtcclxuXHRcdFx0XHRcdHBkZktpdERvYy5jbG9zZVBhdGgoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlICdwYXRoJzpcclxuXHRcdFx0cGRmS2l0RG9jLnBhdGgodmVjdG9yLmQpO1xyXG5cdFx0XHRicmVhaztcclxuXHR9XHJcblxyXG5cdGlmICh2ZWN0b3IubGluZWFyR3JhZGllbnQgJiYgZ3JhZGllbnQpIHtcclxuXHRcdHZhciBzdGVwID0gMSAvICh2ZWN0b3IubGluZWFyR3JhZGllbnQubGVuZ3RoIC0gMSk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2ZWN0b3IubGluZWFyR3JhZGllbnQubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0Z3JhZGllbnQuc3RvcChpICogc3RlcCwgdmVjdG9yLmxpbmVhckdyYWRpZW50W2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHR2ZWN0b3IuY29sb3IgPSBncmFkaWVudDtcclxuXHR9XHJcblxyXG5cdGlmIChpc1BhdHRlcm4odmVjdG9yLmNvbG9yKSkge1xyXG5cdFx0dmVjdG9yLmNvbG9yID0gZ2V0UGF0dGVybih2ZWN0b3IuY29sb3IsIHBhdHRlcm5zKTtcclxuXHR9XHJcblxyXG5cdHZhciBmaWxsT3BhY2l0eSA9IGlzTnVtYmVyKHZlY3Rvci5maWxsT3BhY2l0eSkgPyB2ZWN0b3IuZmlsbE9wYWNpdHkgOiAxO1xyXG5cdHZhciBzdHJva2VPcGFjaXR5ID0gaXNOdW1iZXIodmVjdG9yLnN0cm9rZU9wYWNpdHkpID8gdmVjdG9yLnN0cm9rZU9wYWNpdHkgOiAxO1xyXG5cclxuXHRpZiAodmVjdG9yLmNvbG9yICYmIHZlY3Rvci5saW5lQ29sb3IpIHtcclxuXHRcdHBkZktpdERvYy5maWxsQ29sb3IodmVjdG9yLmNvbG9yLCBmaWxsT3BhY2l0eSk7XHJcblx0XHRwZGZLaXREb2Muc3Ryb2tlQ29sb3IodmVjdG9yLmxpbmVDb2xvciwgc3Ryb2tlT3BhY2l0eSk7XHJcblx0XHRwZGZLaXREb2MuZmlsbEFuZFN0cm9rZSgpO1xyXG5cdH0gZWxzZSBpZiAodmVjdG9yLmNvbG9yKSB7XHJcblx0XHRwZGZLaXREb2MuZmlsbENvbG9yKHZlY3Rvci5jb2xvciwgZmlsbE9wYWNpdHkpO1xyXG5cdFx0cGRmS2l0RG9jLmZpbGwoKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cGRmS2l0RG9jLnN0cm9rZUNvbG9yKHZlY3Rvci5saW5lQ29sb3IgfHwgJ2JsYWNrJywgc3Ryb2tlT3BhY2l0eSk7XHJcblx0XHRwZGZLaXREb2Muc3Ryb2tlKCk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiByZW5kZXJJbWFnZShpbWFnZSwgeCwgeSwgcGRmS2l0RG9jKSB7XHJcblx0dmFyIG9wYWNpdHkgPSBpc051bWJlcihpbWFnZS5vcGFjaXR5KSA/IGltYWdlLm9wYWNpdHkgOiAxO1xyXG5cdHBkZktpdERvYy5vcGFjaXR5KG9wYWNpdHkpO1xyXG5cdGlmIChpbWFnZS5jb3Zlcikge1xyXG5cdFx0dmFyIGFsaWduID0gaW1hZ2UuY292ZXIuYWxpZ24gfHwgJ2NlbnRlcic7XHJcblx0XHR2YXIgdmFsaWduID0gaW1hZ2UuY292ZXIudmFsaWduIHx8ICdjZW50ZXInO1xyXG5cdFx0dmFyIHdpZHRoID0gaW1hZ2UuY292ZXIud2lkdGggPyBpbWFnZS5jb3Zlci53aWR0aCA6IGltYWdlLndpZHRoO1xyXG5cdFx0dmFyIGhlaWdodCA9IGltYWdlLmNvdmVyLmhlaWdodCA/IGltYWdlLmNvdmVyLmhlaWdodCA6IGltYWdlLmhlaWdodDtcclxuXHRcdHBkZktpdERvYy5zYXZlKCk7XHJcblx0XHRwZGZLaXREb2MucmVjdChpbWFnZS54LCBpbWFnZS55LCB3aWR0aCwgaGVpZ2h0KS5jbGlwKCk7XHJcblx0XHRwZGZLaXREb2MuaW1hZ2UoaW1hZ2UuaW1hZ2UsIGltYWdlLngsIGltYWdlLnksIHsgY292ZXI6IFt3aWR0aCwgaGVpZ2h0XSwgYWxpZ246IGFsaWduLCB2YWxpZ246IHZhbGlnbiB9KTtcclxuXHRcdHBkZktpdERvYy5yZXN0b3JlKCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHBkZktpdERvYy5pbWFnZShpbWFnZS5pbWFnZSwgaW1hZ2UueCwgaW1hZ2UueSwgeyB3aWR0aDogaW1hZ2UuX3dpZHRoLCBoZWlnaHQ6IGltYWdlLl9oZWlnaHQgfSk7XHJcblx0fVxyXG5cdGlmIChpbWFnZS5saW5rKSB7XHJcblx0XHRwZGZLaXREb2MubGluayhpbWFnZS54LCBpbWFnZS55LCBpbWFnZS5fd2lkdGgsIGltYWdlLl9oZWlnaHQsIGltYWdlLmxpbmspO1xyXG5cdH1cclxuXHRpZiAoaW1hZ2UubGlua1RvUGFnZSkge1xyXG5cdFx0cGRmS2l0RG9jLnJlZih7IFR5cGU6ICdBY3Rpb24nLCBTOiAnR29UbycsIEQ6IFtpbWFnZS5saW5rVG9QYWdlLCAwLCAwXSB9KS5lbmQoKTtcclxuXHRcdHBkZktpdERvYy5hbm5vdGF0ZShpbWFnZS54LCBpbWFnZS55LCBpbWFnZS5fd2lkdGgsIGltYWdlLl9oZWlnaHQsIHsgU3VidHlwZTogJ0xpbmsnLCBEZXN0OiBbaW1hZ2UubGlua1RvUGFnZSAtIDEsICdYWVonLCBudWxsLCBudWxsLCBudWxsXSB9KTtcclxuXHR9XHJcblx0aWYgKGltYWdlLmxpbmtUb0Rlc3RpbmF0aW9uKSB7XHJcblx0XHRwZGZLaXREb2MuZ29UbyhpbWFnZS54LCBpbWFnZS55LCBpbWFnZS5fd2lkdGgsIGltYWdlLl9oZWlnaHQsIGltYWdlLmxpbmtUb0Rlc3RpbmF0aW9uKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbmRlclNWRyhzdmcsIHgsIHksIHBkZktpdERvYywgZm9udFByb3ZpZGVyKSB7XHJcblx0dmFyIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgd2lkdGg6IHN2Zy5fd2lkdGgsIGhlaWdodDogc3ZnLl9oZWlnaHQsIGFzc3VtZVB0OiB0cnVlIH0sIHN2Zy5vcHRpb25zKTtcclxuXHRvcHRpb25zLmZvbnRDYWxsYmFjayA9IGZ1bmN0aW9uIChmYW1pbHksIGJvbGQsIGl0YWxpYykge1xyXG5cdFx0dmFyIGZvbnRzRmFtaWx5ID0gZmFtaWx5LnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLnRyaW0oKS5yZXBsYWNlKC8oJ3xcIikvZywgJycpOyB9KTtcclxuXHRcdHZhciBmb250ID0gZmluZEZvbnQoZm9udFByb3ZpZGVyLmZvbnRzLCBmb250c0ZhbWlseSwgc3ZnLmZvbnQgfHwgJ1JvYm90bycpO1xyXG5cclxuXHRcdHZhciBmb250RmlsZSA9IGZvbnRQcm92aWRlci5nZXRGb250RmlsZShmb250LCBib2xkLCBpdGFsaWMpO1xyXG5cdFx0aWYgKGZvbnRGaWxlID09PSBudWxsKSB7XHJcblx0XHRcdHZhciB0eXBlID0gZm9udFByb3ZpZGVyLmdldEZvbnRUeXBlKGJvbGQsIGl0YWxpYyk7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignRm9udCBcXCcnICsgZm9udCArICdcXCcgaW4gc3R5bGUgXFwnJyArIHR5cGUgKyAnXFwnIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBmb250IHNlY3Rpb24gb2YgdGhlIGRvY3VtZW50IGRlZmluaXRpb24uJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZvbnRGaWxlO1xyXG5cdH07XHJcblxyXG5cdFNWR3RvUERGKHBkZktpdERvYywgc3ZnLnN2Zywgc3ZnLngsIHN2Zy55LCBvcHRpb25zKTtcclxuXHJcblx0aWYgKHN2Zy5saW5rKSB7XHJcblx0XHRwZGZLaXREb2MubGluayhzdmcueCwgc3ZnLnksIHN2Zy5fd2lkdGgsIHN2Zy5faGVpZ2h0LCBzdmcubGluayk7XHJcblx0fVxyXG5cdGlmIChzdmcubGlua1RvUGFnZSkge1xyXG5cdFx0cGRmS2l0RG9jLnJlZih7VHlwZTogJ0FjdGlvbicsIFM6ICdHb1RvJywgRDogW3N2Zy5saW5rVG9QYWdlLCAwLCAwXX0pLmVuZCgpO1xyXG5cdFx0cGRmS2l0RG9jLmFubm90YXRlKHN2Zy54LCBzdmcueSwgc3ZnLl93aWR0aCwgc3ZnLl9oZWlnaHQsIHsgU3VidHlwZTogJ0xpbmsnLCBEZXN0OiBbc3ZnLmxpbmtUb1BhZ2UgLSAxLCAnWFlaJywgbnVsbCwgbnVsbCwgbnVsbF0gfSk7XHJcblx0fVxyXG5cdGlmIChzdmcubGlua1RvRGVzdGluYXRpb24pIHtcclxuXHRcdHBkZktpdERvYy5nb1RvKHN2Zy54LCBzdmcueSwgc3ZnLl93aWR0aCwgc3ZnLl9oZWlnaHQsIHN2Zy5saW5rVG9EZXN0aW5hdGlvbik7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBiZWdpbkNsaXAocmVjdCwgcGRmS2l0RG9jKSB7XHJcblx0cGRmS2l0RG9jLnNhdmUoKTtcclxuXHRwZGZLaXREb2MuYWRkQ29udGVudCgnJyArIHJlY3QueCArICcgJyArIHJlY3QueSArICcgJyArIHJlY3Qud2lkdGggKyAnICcgKyByZWN0LmhlaWdodCArICcgcmUnKTtcclxuXHRwZGZLaXREb2MuY2xpcCgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbmRDbGlwKHBkZktpdERvYykge1xyXG5cdHBkZktpdERvYy5yZXN0b3JlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVBhdHRlcm5zKHBhdHRlcm5EZWZpbml0aW9ucywgcGRmS2l0RG9jKSB7XHJcblx0dmFyIHBhdHRlcm5zID0ge307XHJcblx0T2JqZWN0LmtleXMocGF0dGVybkRlZmluaXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XHJcblx0XHR2YXIgcGF0dGVybiA9IHBhdHRlcm5EZWZpbml0aW9uc1twXTtcclxuXHRcdHBhdHRlcm5zW3BdID0gcGRmS2l0RG9jLnBhdHRlcm4ocGF0dGVybi5ib3VuZGluZ0JveCwgcGF0dGVybi54U3RlcCwgcGF0dGVybi55U3RlcCwgcGF0dGVybi5wYXR0ZXJuLCBwYXR0ZXJuLmNvbG9yZWQpO1xyXG5cdH0pO1xyXG5cdHJldHVybiBwYXR0ZXJucztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBQZGZQcmludGVyO1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/printer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/qrEnc.js":
/*!*******************************************!*\
  !*** ./node_modules/pdfmake/src/qrEnc.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
eval("/*eslint no-unused-vars: [\"error\", {\"args\": \"none\"}]*/\r\n/*eslint no-redeclare: \"off\"*/\r\n\r\n\r\n/* qr.js -- QR code generator in Javascript (revision 2011-01-19)\r\n * Written by Kang Seonghoon <public+qrjs@mearie.org>.\r\n *\r\n * This source code is in the public domain; if your jurisdiction does not\r\n * recognize the public domain the terms of Creative Commons CC0 license\r\n * apply. In the other words, you can always do what you want.\r\n */\r\n\r\n\r\n// per-version information (cf. JIS X 0510:2004 pp. 30--36, 71)\r\n//\r\n// [0]: the degree of generator polynomial by ECC levels\r\n// [1]: # of code blocks by ECC levels\r\n// [2]: left-top positions of alignment patterns\r\n//\r\n// the number in this table (in particular, [0]) does not exactly match with\r\n// the numbers in the specficiation. see augumenteccs below for the reason.\r\nvar VERSIONS = [\r\n\tnull,\r\n\t[[10, 7, 17, 13], [1, 1, 1, 1], []],\r\n\t[[16, 10, 28, 22], [1, 1, 1, 1], [4, 16]],\r\n\t[[26, 15, 22, 18], [1, 1, 2, 2], [4, 20]],\r\n\t[[18, 20, 16, 26], [2, 1, 4, 2], [4, 24]],\r\n\t[[24, 26, 22, 18], [2, 1, 4, 4], [4, 28]],\r\n\t[[16, 18, 28, 24], [4, 2, 4, 4], [4, 32]],\r\n\t[[18, 20, 26, 18], [4, 2, 5, 6], [4, 20, 36]],\r\n\t[[22, 24, 26, 22], [4, 2, 6, 6], [4, 22, 40]],\r\n\t[[22, 30, 24, 20], [5, 2, 8, 8], [4, 24, 44]],\r\n\t[[26, 18, 28, 24], [5, 4, 8, 8], [4, 26, 48]],\r\n\t[[30, 20, 24, 28], [5, 4, 11, 8], [4, 28, 52]],\r\n\t[[22, 24, 28, 26], [8, 4, 11, 10], [4, 30, 56]],\r\n\t[[22, 26, 22, 24], [9, 4, 16, 12], [4, 32, 60]],\r\n\t[[24, 30, 24, 20], [9, 4, 16, 16], [4, 24, 44, 64]],\r\n\t[[24, 22, 24, 30], [10, 6, 18, 12], [4, 24, 46, 68]],\r\n\t[[28, 24, 30, 24], [10, 6, 16, 17], [4, 24, 48, 72]],\r\n\t[[28, 28, 28, 28], [11, 6, 19, 16], [4, 28, 52, 76]],\r\n\t[[26, 30, 28, 28], [13, 6, 21, 18], [4, 28, 54, 80]],\r\n\t[[26, 28, 26, 26], [14, 7, 25, 21], [4, 28, 56, 84]],\r\n\t[[26, 28, 28, 30], [16, 8, 25, 20], [4, 32, 60, 88]],\r\n\t[[26, 28, 30, 28], [17, 8, 25, 23], [4, 26, 48, 70, 92]],\r\n\t[[28, 28, 24, 30], [17, 9, 34, 23], [4, 24, 48, 72, 96]],\r\n\t[[28, 30, 30, 30], [18, 9, 30, 25], [4, 28, 52, 76, 100]],\r\n\t[[28, 30, 30, 30], [20, 10, 32, 27], [4, 26, 52, 78, 104]],\r\n\t[[28, 26, 30, 30], [21, 12, 35, 29], [4, 30, 56, 82, 108]],\r\n\t[[28, 28, 30, 28], [23, 12, 37, 34], [4, 28, 56, 84, 112]],\r\n\t[[28, 30, 30, 30], [25, 12, 40, 34], [4, 32, 60, 88, 116]],\r\n\t[[28, 30, 30, 30], [26, 13, 42, 35], [4, 24, 48, 72, 96, 120]],\r\n\t[[28, 30, 30, 30], [28, 14, 45, 38], [4, 28, 52, 76, 100, 124]],\r\n\t[[28, 30, 30, 30], [29, 15, 48, 40], [4, 24, 50, 76, 102, 128]],\r\n\t[[28, 30, 30, 30], [31, 16, 51, 43], [4, 28, 54, 80, 106, 132]],\r\n\t[[28, 30, 30, 30], [33, 17, 54, 45], [4, 32, 58, 84, 110, 136]],\r\n\t[[28, 30, 30, 30], [35, 18, 57, 48], [4, 28, 56, 84, 112, 140]],\r\n\t[[28, 30, 30, 30], [37, 19, 60, 51], [4, 32, 60, 88, 116, 144]],\r\n\t[[28, 30, 30, 30], [38, 19, 63, 53], [4, 28, 52, 76, 100, 124, 148]],\r\n\t[[28, 30, 30, 30], [40, 20, 66, 56], [4, 22, 48, 74, 100, 126, 152]],\r\n\t[[28, 30, 30, 30], [43, 21, 70, 59], [4, 26, 52, 78, 104, 130, 156]],\r\n\t[[28, 30, 30, 30], [45, 22, 74, 62], [4, 30, 56, 82, 108, 134, 160]],\r\n\t[[28, 30, 30, 30], [47, 24, 77, 65], [4, 24, 52, 80, 108, 136, 164]],\r\n\t[[28, 30, 30, 30], [49, 25, 81, 68], [4, 28, 56, 84, 112, 140, 168]]];\r\n\r\n// mode constants (cf. Table 2 in JIS X 0510:2004 p. 16)\r\nvar MODE_TERMINATOR = 0;\r\nvar MODE_NUMERIC = 1, MODE_ALPHANUMERIC = 2, MODE_OCTET = 4, MODE_KANJI = 8;\r\n\r\n// validation regexps\r\nvar NUMERIC_REGEXP = /^\\d*$/;\r\nvar ALPHANUMERIC_REGEXP = /^[A-Za-z0-9 $%*+\\-./:]*$/;\r\nvar ALPHANUMERIC_OUT_REGEXP = /^[A-Z0-9 $%*+\\-./:]*$/;\r\n\r\n// ECC levels (cf. Table 22 in JIS X 0510:2004 p. 45)\r\nvar ECCLEVEL_L = 1, ECCLEVEL_M = 0, ECCLEVEL_Q = 3, ECCLEVEL_H = 2;\r\n\r\n// GF(2^8)-to-integer mapping with a reducing polynomial x^8+x^4+x^3+x^2+1\r\n// invariant: GF256_MAP[GF256_INVMAP[i]] == i for all i in [1,256)\r\nvar GF256_MAP = [], GF256_INVMAP = [-1];\r\nfor (var i = 0, v = 1; i < 255; ++i) {\r\n\tGF256_MAP.push(v);\r\n\tGF256_INVMAP[v] = i;\r\n\tv = (v * 2) ^ (v >= 128 ? 0x11d : 0);\r\n}\r\n\r\n// generator polynomials up to degree 30\r\n// (should match with polynomials in JIS X 0510:2004 Appendix A)\r\n//\r\n// generator polynomial of degree K is product of (x-\\alpha^0), (x-\\alpha^1),\r\n// ..., (x-\\alpha^(K-1)). by convention, we omit the K-th coefficient (always 1)\r\n// from the result; also other coefficients are written in terms of the exponent\r\n// to \\alpha to avoid the redundant calculation. (see also calculateecc below.)\r\nvar GF256_GENPOLY = [[]];\r\nfor (var i = 0; i < 30; ++i) {\r\n\tvar prevpoly = GF256_GENPOLY[i], poly = [];\r\n\tfor (var j = 0; j <= i; ++j) {\r\n\t\tvar a = (j < i ? GF256_MAP[prevpoly[j]] : 0);\r\n\t\tvar b = GF256_MAP[(i + (prevpoly[j - 1] || 0)) % 255];\r\n\t\tpoly.push(GF256_INVMAP[a ^ b]);\r\n\t}\r\n\tGF256_GENPOLY.push(poly);\r\n}\r\n\r\n// alphanumeric character mapping (cf. Table 5 in JIS X 0510:2004 p. 19)\r\nvar ALPHANUMERIC_MAP = {};\r\nfor (var i = 0; i < 45; ++i) {\r\n\tALPHANUMERIC_MAP['0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:'.charAt(i)] = i;\r\n}\r\n\r\n// mask functions in terms of row # and column #\r\n// (cf. Table 20 in JIS X 0510:2004 p. 42)\r\n/*jshint unused: false */\r\nvar MASKFUNCS = [\r\n\tfunction (i, j) {\r\n\t\treturn (i + j) % 2 === 0;\r\n\t},\r\n\tfunction (i, j) {\r\n\t\treturn i % 2 === 0;\r\n\t},\r\n\tfunction (i, j) {\r\n\t\treturn j % 3 === 0;\r\n\t},\r\n\tfunction (i, j) {\r\n\t\treturn (i + j) % 3 === 0;\r\n\t},\r\n\tfunction (i, j) {\r\n\t\treturn (((i / 2) | 0) + ((j / 3) | 0)) % 2 === 0;\r\n\t},\r\n\tfunction (i, j) {\r\n\t\treturn (i * j) % 2 + (i * j) % 3 === 0;\r\n\t},\r\n\tfunction (i, j) {\r\n\t\treturn ((i * j) % 2 + (i * j) % 3) % 2 === 0;\r\n\t},\r\n\tfunction (i, j) {\r\n\t\treturn ((i + j) % 2 + (i * j) % 3) % 2 === 0;\r\n\t}];\r\n\r\n// returns true when the version information has to be embeded.\r\nvar needsverinfo = function (ver) {\r\n\treturn ver > 6;\r\n};\r\n\r\n// returns the size of entire QR code for given version.\r\nvar getsizebyver = function (ver) {\r\n\treturn 4 * ver + 17;\r\n};\r\n\r\n// returns the number of bits available for code words in this version.\r\nvar nfullbits = function (ver) {\r\n\t/*\r\n\t * |<--------------- n --------------->|\r\n\t * |        |<----- n-17 ---->|        |\r\n\t * +-------+                ///+-------+ ----\r\n\t * |       |                ///|       |    ^\r\n\t * |  9x9  |       @@@@@    ///|  9x8  |    |\r\n\t * |       | # # # @5x5@ # # # |       |    |\r\n\t * +-------+       @@@@@       +-------+    |\r\n\t *       #                               ---|\r\n\t *                                        ^ |\r\n\t *       #                                |\r\n\t *     @@@@@       @@@@@       @@@@@      | n\r\n\t *     @5x5@       @5x5@       @5x5@   n-17\r\n\t *     @@@@@       @@@@@       @@@@@      | |\r\n\t *       #                                | |\r\n\t * //////                                 v |\r\n\t * //////#                               ---|\r\n\t * +-------+       @@@@@       @@@@@        |\r\n\t * |       |       @5x5@       @5x5@        |\r\n\t * |  8x9  |       @@@@@       @@@@@        |\r\n\t * |       |                                v\r\n\t * +-------+                             ----\r\n\t *\r\n\t * when the entire code has n^2 modules and there are m^2-3 alignment\r\n\t * patterns, we have:\r\n\t * - 225 (= 9x9 + 9x8 + 8x9) modules for finder patterns and\r\n\t *   format information;\r\n\t * - 2n-34 (= 2(n-17)) modules for timing patterns;\r\n\t * - 36 (= 3x6 + 6x3) modules for version information, if any;\r\n\t * - 25m^2-75 (= (m^2-3)(5x5)) modules for alignment patterns\r\n\t *   if any, but 10m-20 (= 2(m-2)x5) of them overlaps with\r\n\t *   timing patterns.\r\n\t */\r\n\tvar v = VERSIONS[ver];\r\n\tvar nbits = 16 * ver * ver + 128 * ver + 64; // finder, timing and format info.\r\n\tif (needsverinfo(ver))\r\n\t\tnbits -= 36; // version information\r\n\tif (v[2].length) { // alignment patterns\r\n\t\tnbits -= 25 * v[2].length * v[2].length - 10 * v[2].length - 55;\r\n\t}\r\n\treturn nbits;\r\n};\r\n\r\n// returns the number of bits available for data portions (i.e. excludes ECC\r\n// bits but includes mode and length bits) in this version and ECC level.\r\nvar ndatabits = function (ver, ecclevel) {\r\n\tvar nbits = nfullbits(ver) & ~7; // no sub-octet code words\r\n\tvar v = VERSIONS[ver];\r\n\tnbits -= 8 * v[0][ecclevel] * v[1][ecclevel]; // ecc bits\r\n\treturn nbits;\r\n};\r\n\r\n// returns the number of bits required for the length of data.\r\n// (cf. Table 3 in JIS X 0510:2004 p. 16)\r\nvar ndatalenbits = function (ver, mode) {\r\n\tswitch (mode) {\r\n\t\tcase MODE_NUMERIC:\r\n\t\t\treturn (ver < 10 ? 10 : ver < 27 ? 12 : 14);\r\n\t\tcase MODE_ALPHANUMERIC:\r\n\t\t\treturn (ver < 10 ? 9 : ver < 27 ? 11 : 13);\r\n\t\tcase MODE_OCTET:\r\n\t\t\treturn (ver < 10 ? 8 : 16);\r\n\t\tcase MODE_KANJI:\r\n\t\t\treturn (ver < 10 ? 8 : ver < 27 ? 10 : 12);\r\n\t}\r\n};\r\n\r\n// returns the maximum length of data possible in given configuration.\r\nvar getmaxdatalen = function (ver, mode, ecclevel) {\r\n\tvar nbits = ndatabits(ver, ecclevel) - 4 - ndatalenbits(ver, mode); // 4 for mode bits\r\n\tswitch (mode) {\r\n\t\tcase MODE_NUMERIC:\r\n\t\t\treturn ((nbits / 10) | 0) * 3 + (nbits % 10 < 4 ? 0 : nbits % 10 < 7 ? 1 : 2);\r\n\t\tcase MODE_ALPHANUMERIC:\r\n\t\t\treturn ((nbits / 11) | 0) * 2 + (nbits % 11 < 6 ? 0 : 1);\r\n\t\tcase MODE_OCTET:\r\n\t\t\treturn (nbits / 8) | 0;\r\n\t\tcase MODE_KANJI:\r\n\t\t\treturn (nbits / 13) | 0;\r\n\t}\r\n};\r\n\r\n// checks if the given data can be encoded in given mode, and returns\r\n// the converted data for the further processing if possible. otherwise\r\n// returns null.\r\n//\r\n// this function does not check the length of data; it is a duty of\r\n// encode function below (as it depends on the version and ECC level too).\r\nvar validatedata = function (mode, data) {\r\n\tswitch (mode) {\r\n\t\tcase MODE_NUMERIC:\r\n\t\t\tif (!data.match(NUMERIC_REGEXP))\r\n\t\t\t\treturn null;\r\n\t\t\treturn data;\r\n\r\n\t\tcase MODE_ALPHANUMERIC:\r\n\t\t\tif (!data.match(ALPHANUMERIC_REGEXP))\r\n\t\t\t\treturn null;\r\n\t\t\treturn data.toUpperCase();\r\n\r\n\t\tcase MODE_OCTET:\r\n\t\t\tif (typeof data === 'string') { // encode as utf-8 string\r\n\t\t\t\tvar newdata = [];\r\n\t\t\t\tfor (var i = 0; i < data.length; ++i) {\r\n\t\t\t\t\tvar ch = data.charCodeAt(i);\r\n\t\t\t\t\tif (ch < 0x80) {\r\n\t\t\t\t\t\tnewdata.push(ch);\r\n\t\t\t\t\t} else if (ch < 0x800) {\r\n\t\t\t\t\t\tnewdata.push(0xc0 | (ch >> 6),\r\n\t\t\t\t\t\t\t0x80 | (ch & 0x3f));\r\n\t\t\t\t\t} else if (ch < 0x10000) {\r\n\t\t\t\t\t\tnewdata.push(0xe0 | (ch >> 12),\r\n\t\t\t\t\t\t\t0x80 | ((ch >> 6) & 0x3f),\r\n\t\t\t\t\t\t\t0x80 | (ch & 0x3f));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnewdata.push(0xf0 | (ch >> 18),\r\n\t\t\t\t\t\t\t0x80 | ((ch >> 12) & 0x3f),\r\n\t\t\t\t\t\t\t0x80 | ((ch >> 6) & 0x3f),\r\n\t\t\t\t\t\t\t0x80 | (ch & 0x3f));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn newdata;\r\n\t\t\t} else {\r\n\t\t\t\treturn data;\r\n\t\t\t}\r\n\t}\r\n};\r\n\r\n// returns the code words (sans ECC bits) for given data and configurations.\r\n// requires data to be preprocessed by validatedata. no length check is\r\n// performed, and everything has to be checked before calling this function.\r\nvar encode = function (ver, mode, data, maxbuflen) {\r\n\tvar buf = [];\r\n\tvar bits = 0, remaining = 8;\r\n\tvar datalen = data.length;\r\n\r\n\t// this function is intentionally no-op when n=0.\r\n\tvar pack = function (x, n) {\r\n\t\tif (n >= remaining) {\r\n\t\t\tbuf.push(bits | (x >> (n -= remaining)));\r\n\t\t\twhile (n >= 8)\r\n\t\t\t\tbuf.push((x >> (n -= 8)) & 255);\r\n\t\t\tbits = 0;\r\n\t\t\tremaining = 8;\r\n\t\t}\r\n\t\tif (n > 0)\r\n\t\t\tbits |= (x & ((1 << n) - 1)) << (remaining -= n);\r\n\t};\r\n\r\n\tvar nlenbits = ndatalenbits(ver, mode);\r\n\tpack(mode, 4);\r\n\tpack(datalen, nlenbits);\r\n\r\n\tswitch (mode) {\r\n\t\tcase MODE_NUMERIC:\r\n\t\t\tfor (var i = 2; i < datalen; i += 3) {\r\n\t\t\t\tpack(parseInt(data.substring(i - 2, i + 1), 10), 10);\r\n\t\t\t}\r\n\t\t\tpack(parseInt(data.substring(i - 2), 10), [0, 4, 7][datalen % 3]);\r\n\t\t\tbreak;\r\n\r\n\t\tcase MODE_ALPHANUMERIC:\r\n\t\t\tfor (var i = 1; i < datalen; i += 2) {\r\n\t\t\t\tpack(ALPHANUMERIC_MAP[data.charAt(i - 1)] * 45 +\r\n\t\t\t\t\tALPHANUMERIC_MAP[data.charAt(i)], 11);\r\n\t\t\t}\r\n\t\t\tif (datalen % 2 == 1) {\r\n\t\t\t\tpack(ALPHANUMERIC_MAP[data.charAt(i - 1)], 6);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\r\n\t\tcase MODE_OCTET:\r\n\t\t\tfor (var i = 0; i < datalen; ++i) {\r\n\t\t\t\tpack(data[i], 8);\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\t// final bits. it is possible that adding terminator causes the buffer\r\n\t// to overflow, but then the buffer truncated to the maximum size will\r\n\t// be valid as the truncated terminator mode bits and padding is\r\n\t// identical in appearance (cf. JIS X 0510:2004 sec 8.4.8).\r\n\tpack(MODE_TERMINATOR, 4);\r\n\tif (remaining < 8)\r\n\t\tbuf.push(bits);\r\n\r\n\t// the padding to fill up the remaining space. we should not add any\r\n\t// words when the overflow already occurred.\r\n\twhile (buf.length + 1 < maxbuflen)\r\n\t\tbuf.push(0xec, 0x11);\r\n\tif (buf.length < maxbuflen)\r\n\t\tbuf.push(0xec);\r\n\treturn buf;\r\n};\r\n\r\n// calculates ECC code words for given code words and generator polynomial.\r\n//\r\n// this is quite similar to CRC calculation as both Reed-Solomon and CRC use\r\n// the certain kind of cyclic codes, which is effectively the division of\r\n// zero-augumented polynomial by the generator polynomial. the only difference\r\n// is that Reed-Solomon uses GF(2^8), instead of CRC's GF(2), and Reed-Solomon\r\n// uses the different generator polynomial than CRC's.\r\nvar calculateecc = function (poly, genpoly) {\r\n\tvar modulus = poly.slice(0);\r\n\tvar polylen = poly.length, genpolylen = genpoly.length;\r\n\tfor (var i = 0; i < genpolylen; ++i)\r\n\t\tmodulus.push(0);\r\n\tfor (var i = 0; i < polylen; ) {\r\n\t\tvar quotient = GF256_INVMAP[modulus[i++]];\r\n\t\tif (quotient >= 0) {\r\n\t\t\tfor (var j = 0; j < genpolylen; ++j) {\r\n\t\t\t\tmodulus[i + j] ^= GF256_MAP[(quotient + genpoly[j]) % 255];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn modulus.slice(polylen);\r\n};\r\n\r\n// auguments ECC code words to given code words. the resulting words are\r\n// ready to be encoded in the matrix.\r\n//\r\n// the much of actual augumenting procedure follows JIS X 0510:2004 sec 8.7.\r\n// the code is simplified using the fact that the size of each code & ECC\r\n// blocks is almost same; for example, when we have 4 blocks and 46 data words\r\n// the number of code words in those blocks are 11, 11, 12, 12 respectively.\r\nvar augumenteccs = function (poly, nblocks, genpoly) {\r\n\tvar subsizes = [];\r\n\tvar subsize = (poly.length / nblocks) | 0, subsize0 = 0;\r\n\tvar pivot = nblocks - poly.length % nblocks;\r\n\tfor (var i = 0; i < pivot; ++i) {\r\n\t\tsubsizes.push(subsize0);\r\n\t\tsubsize0 += subsize;\r\n\t}\r\n\tfor (var i = pivot; i < nblocks; ++i) {\r\n\t\tsubsizes.push(subsize0);\r\n\t\tsubsize0 += subsize + 1;\r\n\t}\r\n\tsubsizes.push(subsize0);\r\n\r\n\tvar eccs = [];\r\n\tfor (var i = 0; i < nblocks; ++i) {\r\n\t\teccs.push(calculateecc(poly.slice(subsizes[i], subsizes[i + 1]), genpoly));\r\n\t}\r\n\r\n\tvar result = [];\r\n\tvar nitemsperblock = (poly.length / nblocks) | 0;\r\n\tfor (var i = 0; i < nitemsperblock; ++i) {\r\n\t\tfor (var j = 0; j < nblocks; ++j) {\r\n\t\t\tresult.push(poly[subsizes[j] + i]);\r\n\t\t}\r\n\t}\r\n\tfor (var j = pivot; j < nblocks; ++j) {\r\n\t\tresult.push(poly[subsizes[j + 1] - 1]);\r\n\t}\r\n\tfor (var i = 0; i < genpoly.length; ++i) {\r\n\t\tfor (var j = 0; j < nblocks; ++j) {\r\n\t\t\tresult.push(eccs[j][i]);\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n};\r\n\r\n// auguments BCH(p+q,q) code to the polynomial over GF(2), given the proper\r\n// genpoly. the both input and output are in binary numbers, and unlike\r\n// calculateecc genpoly should include the 1 bit for the highest degree.\r\n//\r\n// actual polynomials used for this procedure are as follows:\r\n// - p=10, q=5, genpoly=x^10+x^8+x^5+x^4+x^2+x+1 (JIS X 0510:2004 Appendix C)\r\n// - p=18, q=6, genpoly=x^12+x^11+x^10+x^9+x^8+x^5+x^2+1 (ibid. Appendix D)\r\nvar augumentbch = function (poly, p, genpoly, q) {\r\n\tvar modulus = poly << q;\r\n\tfor (var i = p - 1; i >= 0; --i) {\r\n\t\tif ((modulus >> (q + i)) & 1)\r\n\t\t\tmodulus ^= genpoly << i;\r\n\t}\r\n\treturn (poly << q) | modulus;\r\n};\r\n\r\n// creates the base matrix for given version. it returns two matrices, one of\r\n// them is the actual one and the another represents the \"reserved\" portion\r\n// (e.g. finder and timing patterns) of the matrix.\r\n//\r\n// some entries in the matrix may be undefined, rather than 0 or 1. this is\r\n// intentional (no initialization needed!), and putdata below will fill\r\n// the remaining ones.\r\nvar makebasematrix = function (ver) {\r\n\tvar v = VERSIONS[ver], n = getsizebyver(ver);\r\n\tvar matrix = [], reserved = [];\r\n\tfor (var i = 0; i < n; ++i) {\r\n\t\tmatrix.push([]);\r\n\t\treserved.push([]);\r\n\t}\r\n\r\n\tvar blit = function (y, x, h, w, bits) {\r\n\t\tfor (var i = 0; i < h; ++i) {\r\n\t\t\tfor (var j = 0; j < w; ++j) {\r\n\t\t\t\tmatrix[y + i][x + j] = (bits[i] >> j) & 1;\r\n\t\t\t\treserved[y + i][x + j] = 1;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// finder patterns and a part of timing patterns\r\n\t// will also mark the format information area (not yet written) as reserved.\r\n\tblit(0, 0, 9, 9, [0x7f, 0x41, 0x5d, 0x5d, 0x5d, 0x41, 0x17f, 0x00, 0x40]);\r\n\tblit(n - 8, 0, 8, 9, [0x100, 0x7f, 0x41, 0x5d, 0x5d, 0x5d, 0x41, 0x7f]);\r\n\tblit(0, n - 8, 9, 8, [0xfe, 0x82, 0xba, 0xba, 0xba, 0x82, 0xfe, 0x00, 0x00]);\r\n\r\n\t// the rest of timing patterns\r\n\tfor (var i = 9; i < n - 8; ++i) {\r\n\t\tmatrix[6][i] = matrix[i][6] = ~i & 1;\r\n\t\treserved[6][i] = reserved[i][6] = 1;\r\n\t}\r\n\r\n\t// alignment patterns\r\n\tvar aligns = v[2], m = aligns.length;\r\n\tfor (var i = 0; i < m; ++i) {\r\n\t\tvar minj = (i === 0 || i === m - 1 ? 1 : 0), maxj = (i === 0 ? m - 1 : m);\r\n\t\tfor (var j = minj; j < maxj; ++j) {\r\n\t\t\tblit(aligns[i], aligns[j], 5, 5, [0x1f, 0x11, 0x15, 0x11, 0x1f]);\r\n\t\t}\r\n\t}\r\n\r\n\t// version information\r\n\tif (needsverinfo(ver)) {\r\n\t\tvar code = augumentbch(ver, 6, 0x1f25, 12);\r\n\t\tvar k = 0;\r\n\t\tfor (var i = 0; i < 6; ++i) {\r\n\t\t\tfor (var j = 0; j < 3; ++j) {\r\n\t\t\t\tmatrix[i][(n - 11) + j] = matrix[(n - 11) + j][i] = (code >> k++) & 1;\r\n\t\t\t\treserved[i][(n - 11) + j] = reserved[(n - 11) + j][i] = 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn {matrix: matrix, reserved: reserved};\r\n};\r\n\r\n// fills the data portion (i.e. unmarked in reserved) of the matrix with given\r\n// code words. the size of code words should be no more than available bits,\r\n// and remaining bits are padded to 0 (cf. JIS X 0510:2004 sec 8.7.3).\r\nvar putdata = function (matrix, reserved, buf) {\r\n\tvar n = matrix.length;\r\n\tvar k = 0, dir = -1;\r\n\tfor (var i = n - 1; i >= 0; i -= 2) {\r\n\t\tif (i == 6)\r\n\t\t\t--i; // skip the entire timing pattern column\r\n\t\tvar jj = (dir < 0 ? n - 1 : 0);\r\n\t\tfor (var j = 0; j < n; ++j) {\r\n\t\t\tfor (var ii = i; ii > i - 2; --ii) {\r\n\t\t\t\tif (!reserved[jj][ii]) {\r\n\t\t\t\t\t// may overflow, but (undefined >> x)\r\n\t\t\t\t\t// is 0 so it will auto-pad to zero.\r\n\t\t\t\t\tmatrix[jj][ii] = (buf[k >> 3] >> (~k & 7)) & 1;\r\n\t\t\t\t\t++k;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tjj += dir;\r\n\t\t}\r\n\t\tdir = -dir;\r\n\t}\r\n\treturn matrix;\r\n};\r\n\r\n// XOR-masks the data portion of the matrix. repeating the call with the same\r\n// arguments will revert the prior call (convenient in the matrix evaluation).\r\nvar maskdata = function (matrix, reserved, mask) {\r\n\tvar maskf = MASKFUNCS[mask];\r\n\tvar n = matrix.length;\r\n\tfor (var i = 0; i < n; ++i) {\r\n\t\tfor (var j = 0; j < n; ++j) {\r\n\t\t\tif (!reserved[i][j])\r\n\t\t\t\tmatrix[i][j] ^= maskf(i, j);\r\n\t\t}\r\n\t}\r\n\treturn matrix;\r\n};\r\n\r\n// puts the format information.\r\nvar putformatinfo = function (matrix, reserved, ecclevel, mask) {\r\n\tvar n = matrix.length;\r\n\tvar code = augumentbch((ecclevel << 3) | mask, 5, 0x537, 10) ^ 0x5412;\r\n\tfor (var i = 0; i < 15; ++i) {\r\n\t\tvar r = [0, 1, 2, 3, 4, 5, 7, 8, n - 7, n - 6, n - 5, n - 4, n - 3, n - 2, n - 1][i];\r\n\t\tvar c = [n - 1, n - 2, n - 3, n - 4, n - 5, n - 6, n - 7, n - 8, 7, 5, 4, 3, 2, 1, 0][i];\r\n\t\tmatrix[r][8] = matrix[8][c] = (code >> i) & 1;\r\n\t\t// we don't have to mark those bits reserved; always done\r\n\t\t// in makebasematrix above.\r\n\t}\r\n\treturn matrix;\r\n};\r\n\r\n// evaluates the resulting matrix and returns the score (lower is better).\r\n// (cf. JIS X 0510:2004 sec 8.8.2)\r\n//\r\n// the evaluation procedure tries to avoid the problematic patterns naturally\r\n// occuring from the original matrix. for example, it penaltizes the patterns\r\n// which just look like the finder pattern which will confuse the decoder.\r\n// we choose the mask which results in the lowest score among 8 possible ones.\r\n//\r\n// note: zxing seems to use the same procedure and in many cases its choice\r\n// agrees to ours, but sometimes it does not. practically it doesn't matter.\r\nvar evaluatematrix = function (matrix) {\r\n\t// N1+(k-5) points for each consecutive row of k same-colored modules,\r\n\t// where k >= 5. no overlapping row counts.\r\n\tvar PENALTY_CONSECUTIVE = 3;\r\n\t// N2 points for each 2x2 block of same-colored modules.\r\n\t// overlapping block does count.\r\n\tvar PENALTY_TWOBYTWO = 3;\r\n\t// N3 points for each pattern with >4W:1B:1W:3B:1W:1B or\r\n\t// 1B:1W:3B:1W:1B:>4W, or their multiples (e.g. highly unlikely,\r\n\t// but 13W:3B:3W:9B:3W:3B counts).\r\n\tvar PENALTY_FINDERLIKE = 40;\r\n\t// N4*k points for every (5*k)% deviation from 50% black density.\r\n\t// i.e. k=1 for 55~60% and 40~45%, k=2 for 60~65% and 35~40%, etc.\r\n\tvar PENALTY_DENSITY = 10;\r\n\r\n\tvar evaluategroup = function (groups) { // assumes [W,B,W,B,W,...,B,W]\r\n\t\tvar score = 0;\r\n\t\tfor (var i = 0; i < groups.length; ++i) {\r\n\t\t\tif (groups[i] >= 5)\r\n\t\t\t\tscore += PENALTY_CONSECUTIVE + (groups[i] - 5);\r\n\t\t}\r\n\t\tfor (var i = 5; i < groups.length; i += 2) {\r\n\t\t\tvar p = groups[i];\r\n\t\t\tif (groups[i - 1] == p && groups[i - 2] == 3 * p && groups[i - 3] == p &&\r\n\t\t\t\tgroups[i - 4] == p && (groups[i - 5] >= 4 * p || groups[i + 1] >= 4 * p)) {\r\n\t\t\t\t// this part differs from zxing...\r\n\t\t\t\tscore += PENALTY_FINDERLIKE;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn score;\r\n\t};\r\n\r\n\tvar n = matrix.length;\r\n\tvar score = 0, nblacks = 0;\r\n\tfor (var i = 0; i < n; ++i) {\r\n\t\tvar row = matrix[i];\r\n\t\tvar groups;\r\n\r\n\t\t// evaluate the current row\r\n\t\tgroups = [0]; // the first empty group of white\r\n\t\tfor (var j = 0; j < n; ) {\r\n\t\t\tvar k;\r\n\t\t\tfor (k = 0; j < n && row[j]; ++k)\r\n\t\t\t\t++j;\r\n\t\t\tgroups.push(k);\r\n\t\t\tfor (k = 0; j < n && !row[j]; ++k)\r\n\t\t\t\t++j;\r\n\t\t\tgroups.push(k);\r\n\t\t}\r\n\t\tscore += evaluategroup(groups);\r\n\r\n\t\t// evaluate the current column\r\n\t\tgroups = [0];\r\n\t\tfor (var j = 0; j < n; ) {\r\n\t\t\tvar k;\r\n\t\t\tfor (k = 0; j < n && matrix[j][i]; ++k)\r\n\t\t\t\t++j;\r\n\t\t\tgroups.push(k);\r\n\t\t\tfor (k = 0; j < n && !matrix[j][i]; ++k)\r\n\t\t\t\t++j;\r\n\t\t\tgroups.push(k);\r\n\t\t}\r\n\t\tscore += evaluategroup(groups);\r\n\r\n\t\t// check the 2x2 box and calculate the density\r\n\t\tvar nextrow = matrix[i + 1] || [];\r\n\t\tnblacks += row[0];\r\n\t\tfor (var j = 1; j < n; ++j) {\r\n\t\t\tvar p = row[j];\r\n\t\t\tnblacks += p;\r\n\t\t\t// at least comparison with next row should be strict...\r\n\t\t\tif (row[j - 1] == p && nextrow[j] === p && nextrow[j - 1] === p) {\r\n\t\t\t\tscore += PENALTY_TWOBYTWO;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tscore += PENALTY_DENSITY * ((Math.abs(nblacks / n / n - 0.5) / 0.05) | 0);\r\n\treturn score;\r\n};\r\n\r\n// returns the fully encoded QR code matrix which contains given data.\r\n// it also chooses the best mask automatically when mask is -1.\r\nvar generate = function (data, ver, mode, ecclevel, mask) {\r\n\tvar v = VERSIONS[ver];\r\n\tvar buf = encode(ver, mode, data, ndatabits(ver, ecclevel) >> 3);\r\n\tbuf = augumenteccs(buf, v[1][ecclevel], GF256_GENPOLY[v[0][ecclevel]]);\r\n\r\n\tvar result = makebasematrix(ver);\r\n\tvar matrix = result.matrix, reserved = result.reserved;\r\n\tputdata(matrix, reserved, buf);\r\n\r\n\tif (mask < 0) {\r\n\t\t// find the best mask\r\n\t\tmaskdata(matrix, reserved, 0);\r\n\t\tputformatinfo(matrix, reserved, ecclevel, 0);\r\n\t\tvar bestmask = 0, bestscore = evaluatematrix(matrix);\r\n\t\tmaskdata(matrix, reserved, 0);\r\n\t\tfor (mask = 1; mask < 8; ++mask) {\r\n\t\t\tmaskdata(matrix, reserved, mask);\r\n\t\t\tputformatinfo(matrix, reserved, ecclevel, mask);\r\n\t\t\tvar score = evaluatematrix(matrix);\r\n\t\t\tif (bestscore > score) {\r\n\t\t\t\tbestscore = score;\r\n\t\t\t\tbestmask = mask;\r\n\t\t\t}\r\n\t\t\tmaskdata(matrix, reserved, mask);\r\n\t\t}\r\n\t\tmask = bestmask;\r\n\t}\r\n\r\n\tmaskdata(matrix, reserved, mask);\r\n\tputformatinfo(matrix, reserved, ecclevel, mask);\r\n\treturn matrix;\r\n};\r\n\r\n// the public interface is trivial; the options available are as follows:\r\n//\r\n// - version: an integer in [1,40]. when omitted (or -1) the smallest possible\r\n//   version is chosen.\r\n// - mode: one of 'numeric', 'alphanumeric', 'octet'. when omitted the smallest\r\n//   possible mode is chosen.\r\n// - eccLevel: one of 'L', 'M', 'Q', 'H'. defaults to 'L'.\r\n// - mask: an integer in [0,7]. when omitted (or -1) the best mask is chosen.\r\n//\r\n\r\nfunction generateFrame(data, options) {\r\n\tvar MODES = {'numeric': MODE_NUMERIC, 'alphanumeric': MODE_ALPHANUMERIC,\r\n\t\t'octet': MODE_OCTET};\r\n\tvar ECCLEVELS = {'L': ECCLEVEL_L, 'M': ECCLEVEL_M, 'Q': ECCLEVEL_Q,\r\n\t\t'H': ECCLEVEL_H};\r\n\r\n\toptions = options || {};\r\n\tvar ver = options.version || -1;\r\n\tvar ecclevel = ECCLEVELS[(options.eccLevel || 'L').toUpperCase()];\r\n\tvar mode = options.mode ? MODES[options.mode.toLowerCase()] : -1;\r\n\tvar mask = 'mask' in options ? options.mask : -1;\r\n\r\n\tif (mode < 0) {\r\n\t\tif (typeof data === 'string') {\r\n\t\t\tif (data.match(NUMERIC_REGEXP)) {\r\n\t\t\t\tmode = MODE_NUMERIC;\r\n\t\t\t} else if (data.match(ALPHANUMERIC_OUT_REGEXP)) {\r\n\t\t\t\t// while encode supports case-insensitive encoding, we restrict the data to be uppercased when auto-selecting the mode.\r\n\t\t\t\tmode = MODE_ALPHANUMERIC;\r\n\t\t\t} else {\r\n\t\t\t\tmode = MODE_OCTET;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tmode = MODE_OCTET;\r\n\t\t}\r\n\t} else if (!(mode == MODE_NUMERIC || mode == MODE_ALPHANUMERIC ||\r\n\t\tmode == MODE_OCTET)) {\r\n\t\tthrow 'invalid or unsupported mode';\r\n\t}\r\n\r\n\tdata = validatedata(mode, data);\r\n\tif (data === null)\r\n\t\tthrow 'invalid data format';\r\n\r\n\tif (ecclevel < 0 || ecclevel > 3)\r\n\t\tthrow 'invalid ECC level';\r\n\r\n\tif (ver < 0) {\r\n\t\tfor (ver = 1; ver <= 40; ++ver) {\r\n\t\t\tif (data.length <= getmaxdatalen(ver, mode, ecclevel))\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tif (ver > 40)\r\n\t\t\tthrow 'too large data for the Qr format';\r\n\t} else if (ver < 1 || ver > 40) {\r\n\t\tthrow 'invalid Qr version! should be between 1 and 40';\r\n\t}\r\n\r\n\tif (mask != -1 && (mask < 0 || mask > 8))\r\n\t\tthrow 'invalid mask';\r\n\t//console.log('version:', ver, 'mode:', mode, 'ECC:', ecclevel, 'mask:', mask )\r\n\treturn generate(data, ver, mode, ecclevel, mask);\r\n}\r\n\r\n\r\n// options\r\n// - modulesize: a number. this is a size of each modules in pixels, and\r\n//   defaults to 5px.\r\n// - margin: a number. this is a size of margin in *modules*, and defaults to\r\n//   4 (white modules). the specficiation mandates the margin no less than 4\r\n//   modules, so it is better not to alter this value unless you know what\r\n//   you're doing.\r\nfunction buildCanvas(data, options) {\r\n\r\n\tvar canvas = [];\r\n\tvar background = options.background || '#fff';\r\n\tvar foreground = options.foreground || '#000';\r\n\tvar padding = options.padding || 0;\r\n\t//var margin = options.margin || 4;\r\n\tvar matrix = generateFrame(data, options);\r\n\tvar n = matrix.length;\r\n\tvar modSize = Math.floor(options.fit ? options.fit / n : 5);\r\n\tvar size = (n * modSize) + (modSize * padding * 2);\r\n\tvar paddingXY = modSize * padding;\r\n\r\n\tcanvas.push({\r\n\t\ttype: 'rect',\r\n\t\tx: 0, y: 0, w: size, h: size, lineWidth: 0, color: background\r\n\t});\r\n\r\n\tfor (var i = 0; i < n; ++i) {\r\n\t\tfor (var j = 0; j < n; ++j) {\r\n\t\t\tif (matrix[i][j]) {\r\n\t\t\t\tcanvas.push({\r\n\t\t\t\t\ttype: 'rect',\r\n\t\t\t\t\tx: modSize * j + paddingXY,\r\n\t\t\t\t\ty: modSize * i + paddingXY,\r\n\t\t\t\t\tw: modSize,\r\n\t\t\t\t\th: modSize,\r\n\t\t\t\t\tlineWidth: 0,\r\n\t\t\t\t\tcolor: foreground\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcanvas: canvas,\r\n\t\tsize: size\r\n\t};\r\n\r\n}\r\n\r\nfunction measure(node) {\r\n\tvar cd = buildCanvas(node.qr, node);\r\n\tnode._canvas = cd.canvas;\r\n\tnode._width = node._height = node._minWidth = node._maxWidth = node._minHeight = node._maxHeight = cd.size;\r\n\treturn node;\r\n}\r\n\r\nmodule.exports = {\r\n\tmeasure: measure\r\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvcXJFbmMuanMiLCJtYXBwaW5ncyI6IkFBQUEsb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsZUFBZTtBQUNmLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckMsa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckMsa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixrQkFBa0IsT0FBTztBQUN6QjtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2dhc2NhdC9wcmlzbWFxdWFudC9wcmlzbWEtcXVhbnR1bS9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvcXJFbmMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyplc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSovXHJcbi8qZXNsaW50IG5vLXJlZGVjbGFyZTogXCJvZmZcIiovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcbi8qIHFyLmpzIC0tIFFSIGNvZGUgZ2VuZXJhdG9yIGluIEphdmFzY3JpcHQgKHJldmlzaW9uIDIwMTEtMDEtMTkpXHJcbiAqIFdyaXR0ZW4gYnkgS2FuZyBTZW9uZ2hvb24gPHB1YmxpYytxcmpzQG1lYXJpZS5vcmc+LlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGluIHRoZSBwdWJsaWMgZG9tYWluOyBpZiB5b3VyIGp1cmlzZGljdGlvbiBkb2VzIG5vdFxyXG4gKiByZWNvZ25pemUgdGhlIHB1YmxpYyBkb21haW4gdGhlIHRlcm1zIG9mIENyZWF0aXZlIENvbW1vbnMgQ0MwIGxpY2Vuc2VcclxuICogYXBwbHkuIEluIHRoZSBvdGhlciB3b3JkcywgeW91IGNhbiBhbHdheXMgZG8gd2hhdCB5b3Ugd2FudC5cclxuICovXHJcblxyXG5cclxuLy8gcGVyLXZlcnNpb24gaW5mb3JtYXRpb24gKGNmLiBKSVMgWCAwNTEwOjIwMDQgcHAuIDMwLS0zNiwgNzEpXHJcbi8vXHJcbi8vIFswXTogdGhlIGRlZ3JlZSBvZiBnZW5lcmF0b3IgcG9seW5vbWlhbCBieSBFQ0MgbGV2ZWxzXHJcbi8vIFsxXTogIyBvZiBjb2RlIGJsb2NrcyBieSBFQ0MgbGV2ZWxzXHJcbi8vIFsyXTogbGVmdC10b3AgcG9zaXRpb25zIG9mIGFsaWdubWVudCBwYXR0ZXJuc1xyXG4vL1xyXG4vLyB0aGUgbnVtYmVyIGluIHRoaXMgdGFibGUgKGluIHBhcnRpY3VsYXIsIFswXSkgZG9lcyBub3QgZXhhY3RseSBtYXRjaCB3aXRoXHJcbi8vIHRoZSBudW1iZXJzIGluIHRoZSBzcGVjZmljaWF0aW9uLiBzZWUgYXVndW1lbnRlY2NzIGJlbG93IGZvciB0aGUgcmVhc29uLlxyXG52YXIgVkVSU0lPTlMgPSBbXHJcblx0bnVsbCxcclxuXHRbWzEwLCA3LCAxNywgMTNdLCBbMSwgMSwgMSwgMV0sIFtdXSxcclxuXHRbWzE2LCAxMCwgMjgsIDIyXSwgWzEsIDEsIDEsIDFdLCBbNCwgMTZdXSxcclxuXHRbWzI2LCAxNSwgMjIsIDE4XSwgWzEsIDEsIDIsIDJdLCBbNCwgMjBdXSxcclxuXHRbWzE4LCAyMCwgMTYsIDI2XSwgWzIsIDEsIDQsIDJdLCBbNCwgMjRdXSxcclxuXHRbWzI0LCAyNiwgMjIsIDE4XSwgWzIsIDEsIDQsIDRdLCBbNCwgMjhdXSxcclxuXHRbWzE2LCAxOCwgMjgsIDI0XSwgWzQsIDIsIDQsIDRdLCBbNCwgMzJdXSxcclxuXHRbWzE4LCAyMCwgMjYsIDE4XSwgWzQsIDIsIDUsIDZdLCBbNCwgMjAsIDM2XV0sXHJcblx0W1syMiwgMjQsIDI2LCAyMl0sIFs0LCAyLCA2LCA2XSwgWzQsIDIyLCA0MF1dLFxyXG5cdFtbMjIsIDMwLCAyNCwgMjBdLCBbNSwgMiwgOCwgOF0sIFs0LCAyNCwgNDRdXSxcclxuXHRbWzI2LCAxOCwgMjgsIDI0XSwgWzUsIDQsIDgsIDhdLCBbNCwgMjYsIDQ4XV0sXHJcblx0W1szMCwgMjAsIDI0LCAyOF0sIFs1LCA0LCAxMSwgOF0sIFs0LCAyOCwgNTJdXSxcclxuXHRbWzIyLCAyNCwgMjgsIDI2XSwgWzgsIDQsIDExLCAxMF0sIFs0LCAzMCwgNTZdXSxcclxuXHRbWzIyLCAyNiwgMjIsIDI0XSwgWzksIDQsIDE2LCAxMl0sIFs0LCAzMiwgNjBdXSxcclxuXHRbWzI0LCAzMCwgMjQsIDIwXSwgWzksIDQsIDE2LCAxNl0sIFs0LCAyNCwgNDQsIDY0XV0sXHJcblx0W1syNCwgMjIsIDI0LCAzMF0sIFsxMCwgNiwgMTgsIDEyXSwgWzQsIDI0LCA0NiwgNjhdXSxcclxuXHRbWzI4LCAyNCwgMzAsIDI0XSwgWzEwLCA2LCAxNiwgMTddLCBbNCwgMjQsIDQ4LCA3Ml1dLFxyXG5cdFtbMjgsIDI4LCAyOCwgMjhdLCBbMTEsIDYsIDE5LCAxNl0sIFs0LCAyOCwgNTIsIDc2XV0sXHJcblx0W1syNiwgMzAsIDI4LCAyOF0sIFsxMywgNiwgMjEsIDE4XSwgWzQsIDI4LCA1NCwgODBdXSxcclxuXHRbWzI2LCAyOCwgMjYsIDI2XSwgWzE0LCA3LCAyNSwgMjFdLCBbNCwgMjgsIDU2LCA4NF1dLFxyXG5cdFtbMjYsIDI4LCAyOCwgMzBdLCBbMTYsIDgsIDI1LCAyMF0sIFs0LCAzMiwgNjAsIDg4XV0sXHJcblx0W1syNiwgMjgsIDMwLCAyOF0sIFsxNywgOCwgMjUsIDIzXSwgWzQsIDI2LCA0OCwgNzAsIDkyXV0sXHJcblx0W1syOCwgMjgsIDI0LCAzMF0sIFsxNywgOSwgMzQsIDIzXSwgWzQsIDI0LCA0OCwgNzIsIDk2XV0sXHJcblx0W1syOCwgMzAsIDMwLCAzMF0sIFsxOCwgOSwgMzAsIDI1XSwgWzQsIDI4LCA1MiwgNzYsIDEwMF1dLFxyXG5cdFtbMjgsIDMwLCAzMCwgMzBdLCBbMjAsIDEwLCAzMiwgMjddLCBbNCwgMjYsIDUyLCA3OCwgMTA0XV0sXHJcblx0W1syOCwgMjYsIDMwLCAzMF0sIFsyMSwgMTIsIDM1LCAyOV0sIFs0LCAzMCwgNTYsIDgyLCAxMDhdXSxcclxuXHRbWzI4LCAyOCwgMzAsIDI4XSwgWzIzLCAxMiwgMzcsIDM0XSwgWzQsIDI4LCA1NiwgODQsIDExMl1dLFxyXG5cdFtbMjgsIDMwLCAzMCwgMzBdLCBbMjUsIDEyLCA0MCwgMzRdLCBbNCwgMzIsIDYwLCA4OCwgMTE2XV0sXHJcblx0W1syOCwgMzAsIDMwLCAzMF0sIFsyNiwgMTMsIDQyLCAzNV0sIFs0LCAyNCwgNDgsIDcyLCA5NiwgMTIwXV0sXHJcblx0W1syOCwgMzAsIDMwLCAzMF0sIFsyOCwgMTQsIDQ1LCAzOF0sIFs0LCAyOCwgNTIsIDc2LCAxMDAsIDEyNF1dLFxyXG5cdFtbMjgsIDMwLCAzMCwgMzBdLCBbMjksIDE1LCA0OCwgNDBdLCBbNCwgMjQsIDUwLCA3NiwgMTAyLCAxMjhdXSxcclxuXHRbWzI4LCAzMCwgMzAsIDMwXSwgWzMxLCAxNiwgNTEsIDQzXSwgWzQsIDI4LCA1NCwgODAsIDEwNiwgMTMyXV0sXHJcblx0W1syOCwgMzAsIDMwLCAzMF0sIFszMywgMTcsIDU0LCA0NV0sIFs0LCAzMiwgNTgsIDg0LCAxMTAsIDEzNl1dLFxyXG5cdFtbMjgsIDMwLCAzMCwgMzBdLCBbMzUsIDE4LCA1NywgNDhdLCBbNCwgMjgsIDU2LCA4NCwgMTEyLCAxNDBdXSxcclxuXHRbWzI4LCAzMCwgMzAsIDMwXSwgWzM3LCAxOSwgNjAsIDUxXSwgWzQsIDMyLCA2MCwgODgsIDExNiwgMTQ0XV0sXHJcblx0W1syOCwgMzAsIDMwLCAzMF0sIFszOCwgMTksIDYzLCA1M10sIFs0LCAyOCwgNTIsIDc2LCAxMDAsIDEyNCwgMTQ4XV0sXHJcblx0W1syOCwgMzAsIDMwLCAzMF0sIFs0MCwgMjAsIDY2LCA1Nl0sIFs0LCAyMiwgNDgsIDc0LCAxMDAsIDEyNiwgMTUyXV0sXHJcblx0W1syOCwgMzAsIDMwLCAzMF0sIFs0MywgMjEsIDcwLCA1OV0sIFs0LCAyNiwgNTIsIDc4LCAxMDQsIDEzMCwgMTU2XV0sXHJcblx0W1syOCwgMzAsIDMwLCAzMF0sIFs0NSwgMjIsIDc0LCA2Ml0sIFs0LCAzMCwgNTYsIDgyLCAxMDgsIDEzNCwgMTYwXV0sXHJcblx0W1syOCwgMzAsIDMwLCAzMF0sIFs0NywgMjQsIDc3LCA2NV0sIFs0LCAyNCwgNTIsIDgwLCAxMDgsIDEzNiwgMTY0XV0sXHJcblx0W1syOCwgMzAsIDMwLCAzMF0sIFs0OSwgMjUsIDgxLCA2OF0sIFs0LCAyOCwgNTYsIDg0LCAxMTIsIDE0MCwgMTY4XV1dO1xyXG5cclxuLy8gbW9kZSBjb25zdGFudHMgKGNmLiBUYWJsZSAyIGluIEpJUyBYIDA1MTA6MjAwNCBwLiAxNilcclxudmFyIE1PREVfVEVSTUlOQVRPUiA9IDA7XHJcbnZhciBNT0RFX05VTUVSSUMgPSAxLCBNT0RFX0FMUEhBTlVNRVJJQyA9IDIsIE1PREVfT0NURVQgPSA0LCBNT0RFX0tBTkpJID0gODtcclxuXHJcbi8vIHZhbGlkYXRpb24gcmVnZXhwc1xyXG52YXIgTlVNRVJJQ19SRUdFWFAgPSAvXlxcZCokLztcclxudmFyIEFMUEhBTlVNRVJJQ19SRUdFWFAgPSAvXltBLVphLXowLTkgJCUqK1xcLS4vOl0qJC87XHJcbnZhciBBTFBIQU5VTUVSSUNfT1VUX1JFR0VYUCA9IC9eW0EtWjAtOSAkJSorXFwtLi86XSokLztcclxuXHJcbi8vIEVDQyBsZXZlbHMgKGNmLiBUYWJsZSAyMiBpbiBKSVMgWCAwNTEwOjIwMDQgcC4gNDUpXHJcbnZhciBFQ0NMRVZFTF9MID0gMSwgRUNDTEVWRUxfTSA9IDAsIEVDQ0xFVkVMX1EgPSAzLCBFQ0NMRVZFTF9IID0gMjtcclxuXHJcbi8vIEdGKDJeOCktdG8taW50ZWdlciBtYXBwaW5nIHdpdGggYSByZWR1Y2luZyBwb2x5bm9taWFsIHheOCt4XjQreF4zK3heMisxXHJcbi8vIGludmFyaWFudDogR0YyNTZfTUFQW0dGMjU2X0lOVk1BUFtpXV0gPT0gaSBmb3IgYWxsIGkgaW4gWzEsMjU2KVxyXG52YXIgR0YyNTZfTUFQID0gW10sIEdGMjU2X0lOVk1BUCA9IFstMV07XHJcbmZvciAodmFyIGkgPSAwLCB2ID0gMTsgaSA8IDI1NTsgKytpKSB7XHJcblx0R0YyNTZfTUFQLnB1c2godik7XHJcblx0R0YyNTZfSU5WTUFQW3ZdID0gaTtcclxuXHR2ID0gKHYgKiAyKSBeICh2ID49IDEyOCA/IDB4MTFkIDogMCk7XHJcbn1cclxuXHJcbi8vIGdlbmVyYXRvciBwb2x5bm9taWFscyB1cCB0byBkZWdyZWUgMzBcclxuLy8gKHNob3VsZCBtYXRjaCB3aXRoIHBvbHlub21pYWxzIGluIEpJUyBYIDA1MTA6MjAwNCBBcHBlbmRpeCBBKVxyXG4vL1xyXG4vLyBnZW5lcmF0b3IgcG9seW5vbWlhbCBvZiBkZWdyZWUgSyBpcyBwcm9kdWN0IG9mICh4LVxcYWxwaGFeMCksICh4LVxcYWxwaGFeMSksXHJcbi8vIC4uLiwgKHgtXFxhbHBoYV4oSy0xKSkuIGJ5IGNvbnZlbnRpb24sIHdlIG9taXQgdGhlIEstdGggY29lZmZpY2llbnQgKGFsd2F5cyAxKVxyXG4vLyBmcm9tIHRoZSByZXN1bHQ7IGFsc28gb3RoZXIgY29lZmZpY2llbnRzIGFyZSB3cml0dGVuIGluIHRlcm1zIG9mIHRoZSBleHBvbmVudFxyXG4vLyB0byBcXGFscGhhIHRvIGF2b2lkIHRoZSByZWR1bmRhbnQgY2FsY3VsYXRpb24uIChzZWUgYWxzbyBjYWxjdWxhdGVlY2MgYmVsb3cuKVxyXG52YXIgR0YyNTZfR0VOUE9MWSA9IFtbXV07XHJcbmZvciAodmFyIGkgPSAwOyBpIDwgMzA7ICsraSkge1xyXG5cdHZhciBwcmV2cG9seSA9IEdGMjU2X0dFTlBPTFlbaV0sIHBvbHkgPSBbXTtcclxuXHRmb3IgKHZhciBqID0gMDsgaiA8PSBpOyArK2opIHtcclxuXHRcdHZhciBhID0gKGogPCBpID8gR0YyNTZfTUFQW3ByZXZwb2x5W2pdXSA6IDApO1xyXG5cdFx0dmFyIGIgPSBHRjI1Nl9NQVBbKGkgKyAocHJldnBvbHlbaiAtIDFdIHx8IDApKSAlIDI1NV07XHJcblx0XHRwb2x5LnB1c2goR0YyNTZfSU5WTUFQW2EgXiBiXSk7XHJcblx0fVxyXG5cdEdGMjU2X0dFTlBPTFkucHVzaChwb2x5KTtcclxufVxyXG5cclxuLy8gYWxwaGFudW1lcmljIGNoYXJhY3RlciBtYXBwaW5nIChjZi4gVGFibGUgNSBpbiBKSVMgWCAwNTEwOjIwMDQgcC4gMTkpXHJcbnZhciBBTFBIQU5VTUVSSUNfTUFQID0ge307XHJcbmZvciAodmFyIGkgPSAwOyBpIDwgNDU7ICsraSkge1xyXG5cdEFMUEhBTlVNRVJJQ19NQVBbJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiAkJSorLS4vOicuY2hhckF0KGkpXSA9IGk7XHJcbn1cclxuXHJcbi8vIG1hc2sgZnVuY3Rpb25zIGluIHRlcm1zIG9mIHJvdyAjIGFuZCBjb2x1bW4gI1xyXG4vLyAoY2YuIFRhYmxlIDIwIGluIEpJUyBYIDA1MTA6MjAwNCBwLiA0MilcclxuLypqc2hpbnQgdW51c2VkOiBmYWxzZSAqL1xyXG52YXIgTUFTS0ZVTkNTID0gW1xyXG5cdGZ1bmN0aW9uIChpLCBqKSB7XHJcblx0XHRyZXR1cm4gKGkgKyBqKSAlIDIgPT09IDA7XHJcblx0fSxcclxuXHRmdW5jdGlvbiAoaSwgaikge1xyXG5cdFx0cmV0dXJuIGkgJSAyID09PSAwO1xyXG5cdH0sXHJcblx0ZnVuY3Rpb24gKGksIGopIHtcclxuXHRcdHJldHVybiBqICUgMyA9PT0gMDtcclxuXHR9LFxyXG5cdGZ1bmN0aW9uIChpLCBqKSB7XHJcblx0XHRyZXR1cm4gKGkgKyBqKSAlIDMgPT09IDA7XHJcblx0fSxcclxuXHRmdW5jdGlvbiAoaSwgaikge1xyXG5cdFx0cmV0dXJuICgoKGkgLyAyKSB8IDApICsgKChqIC8gMykgfCAwKSkgJSAyID09PSAwO1xyXG5cdH0sXHJcblx0ZnVuY3Rpb24gKGksIGopIHtcclxuXHRcdHJldHVybiAoaSAqIGopICUgMiArIChpICogaikgJSAzID09PSAwO1xyXG5cdH0sXHJcblx0ZnVuY3Rpb24gKGksIGopIHtcclxuXHRcdHJldHVybiAoKGkgKiBqKSAlIDIgKyAoaSAqIGopICUgMykgJSAyID09PSAwO1xyXG5cdH0sXHJcblx0ZnVuY3Rpb24gKGksIGopIHtcclxuXHRcdHJldHVybiAoKGkgKyBqKSAlIDIgKyAoaSAqIGopICUgMykgJSAyID09PSAwO1xyXG5cdH1dO1xyXG5cclxuLy8gcmV0dXJucyB0cnVlIHdoZW4gdGhlIHZlcnNpb24gaW5mb3JtYXRpb24gaGFzIHRvIGJlIGVtYmVkZWQuXHJcbnZhciBuZWVkc3ZlcmluZm8gPSBmdW5jdGlvbiAodmVyKSB7XHJcblx0cmV0dXJuIHZlciA+IDY7XHJcbn07XHJcblxyXG4vLyByZXR1cm5zIHRoZSBzaXplIG9mIGVudGlyZSBRUiBjb2RlIGZvciBnaXZlbiB2ZXJzaW9uLlxyXG52YXIgZ2V0c2l6ZWJ5dmVyID0gZnVuY3Rpb24gKHZlcikge1xyXG5cdHJldHVybiA0ICogdmVyICsgMTc7XHJcbn07XHJcblxyXG4vLyByZXR1cm5zIHRoZSBudW1iZXIgb2YgYml0cyBhdmFpbGFibGUgZm9yIGNvZGUgd29yZHMgaW4gdGhpcyB2ZXJzaW9uLlxyXG52YXIgbmZ1bGxiaXRzID0gZnVuY3Rpb24gKHZlcikge1xyXG5cdC8qXHJcblx0ICogfDwtLS0tLS0tLS0tLS0tLS0gbiAtLS0tLS0tLS0tLS0tLS0+fFxyXG5cdCAqIHwgICAgICAgIHw8LS0tLS0gbi0xNyAtLS0tPnwgICAgICAgIHxcclxuXHQgKiArLS0tLS0tLSsgICAgICAgICAgICAgICAgLy8vKy0tLS0tLS0rIC0tLS1cclxuXHQgKiB8ICAgICAgIHwgICAgICAgICAgICAgICAgLy8vfCAgICAgICB8ICAgIF5cclxuXHQgKiB8ICA5eDkgIHwgICAgICAgQEBAQEAgICAgLy8vfCAgOXg4ICB8ICAgIHxcclxuXHQgKiB8ICAgICAgIHwgIyAjICMgQDV4NUAgIyAjICMgfCAgICAgICB8ICAgIHxcclxuXHQgKiArLS0tLS0tLSsgICAgICAgQEBAQEAgICAgICAgKy0tLS0tLS0rICAgIHxcclxuXHQgKiAgICAgICAjICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tLXxcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeIHxcclxuXHQgKiAgICAgICAjICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcblx0ICogICAgIEBAQEBAICAgICAgIEBAQEBAICAgICAgIEBAQEBAICAgICAgfCBuXHJcblx0ICogICAgIEA1eDVAICAgICAgIEA1eDVAICAgICAgIEA1eDVAICAgbi0xN1xyXG5cdCAqICAgICBAQEBAQCAgICAgICBAQEBAQCAgICAgICBAQEBAQCAgICAgIHwgfFxyXG5cdCAqICAgICAgICMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgfFxyXG5cdCAqIC8vLy8vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgfFxyXG5cdCAqIC8vLy8vLyMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0tfFxyXG5cdCAqICstLS0tLS0tKyAgICAgICBAQEBAQCAgICAgICBAQEBAQCAgICAgICAgfFxyXG5cdCAqIHwgICAgICAgfCAgICAgICBANXg1QCAgICAgICBANXg1QCAgICAgICAgfFxyXG5cdCAqIHwgIDh4OSAgfCAgICAgICBAQEBAQCAgICAgICBAQEBAQCAgICAgICAgfFxyXG5cdCAqIHwgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdlxyXG5cdCAqICstLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0tLVxyXG5cdCAqXHJcblx0ICogd2hlbiB0aGUgZW50aXJlIGNvZGUgaGFzIG5eMiBtb2R1bGVzIGFuZCB0aGVyZSBhcmUgbV4yLTMgYWxpZ25tZW50XHJcblx0ICogcGF0dGVybnMsIHdlIGhhdmU6XHJcblx0ICogLSAyMjUgKD0gOXg5ICsgOXg4ICsgOHg5KSBtb2R1bGVzIGZvciBmaW5kZXIgcGF0dGVybnMgYW5kXHJcblx0ICogICBmb3JtYXQgaW5mb3JtYXRpb247XHJcblx0ICogLSAybi0zNCAoPSAyKG4tMTcpKSBtb2R1bGVzIGZvciB0aW1pbmcgcGF0dGVybnM7XHJcblx0ICogLSAzNiAoPSAzeDYgKyA2eDMpIG1vZHVsZXMgZm9yIHZlcnNpb24gaW5mb3JtYXRpb24sIGlmIGFueTtcclxuXHQgKiAtIDI1bV4yLTc1ICg9IChtXjItMykoNXg1KSkgbW9kdWxlcyBmb3IgYWxpZ25tZW50IHBhdHRlcm5zXHJcblx0ICogICBpZiBhbnksIGJ1dCAxMG0tMjAgKD0gMihtLTIpeDUpIG9mIHRoZW0gb3ZlcmxhcHMgd2l0aFxyXG5cdCAqICAgdGltaW5nIHBhdHRlcm5zLlxyXG5cdCAqL1xyXG5cdHZhciB2ID0gVkVSU0lPTlNbdmVyXTtcclxuXHR2YXIgbmJpdHMgPSAxNiAqIHZlciAqIHZlciArIDEyOCAqIHZlciArIDY0OyAvLyBmaW5kZXIsIHRpbWluZyBhbmQgZm9ybWF0IGluZm8uXHJcblx0aWYgKG5lZWRzdmVyaW5mbyh2ZXIpKVxyXG5cdFx0bmJpdHMgLT0gMzY7IC8vIHZlcnNpb24gaW5mb3JtYXRpb25cclxuXHRpZiAodlsyXS5sZW5ndGgpIHsgLy8gYWxpZ25tZW50IHBhdHRlcm5zXHJcblx0XHRuYml0cyAtPSAyNSAqIHZbMl0ubGVuZ3RoICogdlsyXS5sZW5ndGggLSAxMCAqIHZbMl0ubGVuZ3RoIC0gNTU7XHJcblx0fVxyXG5cdHJldHVybiBuYml0cztcclxufTtcclxuXHJcbi8vIHJldHVybnMgdGhlIG51bWJlciBvZiBiaXRzIGF2YWlsYWJsZSBmb3IgZGF0YSBwb3J0aW9ucyAoaS5lLiBleGNsdWRlcyBFQ0NcclxuLy8gYml0cyBidXQgaW5jbHVkZXMgbW9kZSBhbmQgbGVuZ3RoIGJpdHMpIGluIHRoaXMgdmVyc2lvbiBhbmQgRUNDIGxldmVsLlxyXG52YXIgbmRhdGFiaXRzID0gZnVuY3Rpb24gKHZlciwgZWNjbGV2ZWwpIHtcclxuXHR2YXIgbmJpdHMgPSBuZnVsbGJpdHModmVyKSAmIH43OyAvLyBubyBzdWItb2N0ZXQgY29kZSB3b3Jkc1xyXG5cdHZhciB2ID0gVkVSU0lPTlNbdmVyXTtcclxuXHRuYml0cyAtPSA4ICogdlswXVtlY2NsZXZlbF0gKiB2WzFdW2VjY2xldmVsXTsgLy8gZWNjIGJpdHNcclxuXHRyZXR1cm4gbmJpdHM7XHJcbn07XHJcblxyXG4vLyByZXR1cm5zIHRoZSBudW1iZXIgb2YgYml0cyByZXF1aXJlZCBmb3IgdGhlIGxlbmd0aCBvZiBkYXRhLlxyXG4vLyAoY2YuIFRhYmxlIDMgaW4gSklTIFggMDUxMDoyMDA0IHAuIDE2KVxyXG52YXIgbmRhdGFsZW5iaXRzID0gZnVuY3Rpb24gKHZlciwgbW9kZSkge1xyXG5cdHN3aXRjaCAobW9kZSkge1xyXG5cdFx0Y2FzZSBNT0RFX05VTUVSSUM6XHJcblx0XHRcdHJldHVybiAodmVyIDwgMTAgPyAxMCA6IHZlciA8IDI3ID8gMTIgOiAxNCk7XHJcblx0XHRjYXNlIE1PREVfQUxQSEFOVU1FUklDOlxyXG5cdFx0XHRyZXR1cm4gKHZlciA8IDEwID8gOSA6IHZlciA8IDI3ID8gMTEgOiAxMyk7XHJcblx0XHRjYXNlIE1PREVfT0NURVQ6XHJcblx0XHRcdHJldHVybiAodmVyIDwgMTAgPyA4IDogMTYpO1xyXG5cdFx0Y2FzZSBNT0RFX0tBTkpJOlxyXG5cdFx0XHRyZXR1cm4gKHZlciA8IDEwID8gOCA6IHZlciA8IDI3ID8gMTAgOiAxMik7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gcmV0dXJucyB0aGUgbWF4aW11bSBsZW5ndGggb2YgZGF0YSBwb3NzaWJsZSBpbiBnaXZlbiBjb25maWd1cmF0aW9uLlxyXG52YXIgZ2V0bWF4ZGF0YWxlbiA9IGZ1bmN0aW9uICh2ZXIsIG1vZGUsIGVjY2xldmVsKSB7XHJcblx0dmFyIG5iaXRzID0gbmRhdGFiaXRzKHZlciwgZWNjbGV2ZWwpIC0gNCAtIG5kYXRhbGVuYml0cyh2ZXIsIG1vZGUpOyAvLyA0IGZvciBtb2RlIGJpdHNcclxuXHRzd2l0Y2ggKG1vZGUpIHtcclxuXHRcdGNhc2UgTU9ERV9OVU1FUklDOlxyXG5cdFx0XHRyZXR1cm4gKChuYml0cyAvIDEwKSB8IDApICogMyArIChuYml0cyAlIDEwIDwgNCA/IDAgOiBuYml0cyAlIDEwIDwgNyA/IDEgOiAyKTtcclxuXHRcdGNhc2UgTU9ERV9BTFBIQU5VTUVSSUM6XHJcblx0XHRcdHJldHVybiAoKG5iaXRzIC8gMTEpIHwgMCkgKiAyICsgKG5iaXRzICUgMTEgPCA2ID8gMCA6IDEpO1xyXG5cdFx0Y2FzZSBNT0RFX09DVEVUOlxyXG5cdFx0XHRyZXR1cm4gKG5iaXRzIC8gOCkgfCAwO1xyXG5cdFx0Y2FzZSBNT0RFX0tBTkpJOlxyXG5cdFx0XHRyZXR1cm4gKG5iaXRzIC8gMTMpIHwgMDtcclxuXHR9XHJcbn07XHJcblxyXG4vLyBjaGVja3MgaWYgdGhlIGdpdmVuIGRhdGEgY2FuIGJlIGVuY29kZWQgaW4gZ2l2ZW4gbW9kZSwgYW5kIHJldHVybnNcclxuLy8gdGhlIGNvbnZlcnRlZCBkYXRhIGZvciB0aGUgZnVydGhlciBwcm9jZXNzaW5nIGlmIHBvc3NpYmxlLiBvdGhlcndpc2VcclxuLy8gcmV0dXJucyBudWxsLlxyXG4vL1xyXG4vLyB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNoZWNrIHRoZSBsZW5ndGggb2YgZGF0YTsgaXQgaXMgYSBkdXR5IG9mXHJcbi8vIGVuY29kZSBmdW5jdGlvbiBiZWxvdyAoYXMgaXQgZGVwZW5kcyBvbiB0aGUgdmVyc2lvbiBhbmQgRUNDIGxldmVsIHRvbykuXHJcbnZhciB2YWxpZGF0ZWRhdGEgPSBmdW5jdGlvbiAobW9kZSwgZGF0YSkge1xyXG5cdHN3aXRjaCAobW9kZSkge1xyXG5cdFx0Y2FzZSBNT0RFX05VTUVSSUM6XHJcblx0XHRcdGlmICghZGF0YS5tYXRjaChOVU1FUklDX1JFR0VYUCkpXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdHJldHVybiBkYXRhO1xyXG5cclxuXHRcdGNhc2UgTU9ERV9BTFBIQU5VTUVSSUM6XHJcblx0XHRcdGlmICghZGF0YS5tYXRjaChBTFBIQU5VTUVSSUNfUkVHRVhQKSlcclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0cmV0dXJuIGRhdGEudG9VcHBlckNhc2UoKTtcclxuXHJcblx0XHRjYXNlIE1PREVfT0NURVQ6XHJcblx0XHRcdGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHsgLy8gZW5jb2RlIGFzIHV0Zi04IHN0cmluZ1xyXG5cdFx0XHRcdHZhciBuZXdkYXRhID0gW107XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdFx0XHR2YXIgY2ggPSBkYXRhLmNoYXJDb2RlQXQoaSk7XHJcblx0XHRcdFx0XHRpZiAoY2ggPCAweDgwKSB7XHJcblx0XHRcdFx0XHRcdG5ld2RhdGEucHVzaChjaCk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGNoIDwgMHg4MDApIHtcclxuXHRcdFx0XHRcdFx0bmV3ZGF0YS5wdXNoKDB4YzAgfCAoY2ggPj4gNiksXHJcblx0XHRcdFx0XHRcdFx0MHg4MCB8IChjaCAmIDB4M2YpKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY2ggPCAweDEwMDAwKSB7XHJcblx0XHRcdFx0XHRcdG5ld2RhdGEucHVzaCgweGUwIHwgKGNoID4+IDEyKSxcclxuXHRcdFx0XHRcdFx0XHQweDgwIHwgKChjaCA+PiA2KSAmIDB4M2YpLFxyXG5cdFx0XHRcdFx0XHRcdDB4ODAgfCAoY2ggJiAweDNmKSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRuZXdkYXRhLnB1c2goMHhmMCB8IChjaCA+PiAxOCksXHJcblx0XHRcdFx0XHRcdFx0MHg4MCB8ICgoY2ggPj4gMTIpICYgMHgzZiksXHJcblx0XHRcdFx0XHRcdFx0MHg4MCB8ICgoY2ggPj4gNikgJiAweDNmKSxcclxuXHRcdFx0XHRcdFx0XHQweDgwIHwgKGNoICYgMHgzZikpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gbmV3ZGF0YTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcclxuXHRcdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbi8vIHJldHVybnMgdGhlIGNvZGUgd29yZHMgKHNhbnMgRUNDIGJpdHMpIGZvciBnaXZlbiBkYXRhIGFuZCBjb25maWd1cmF0aW9ucy5cclxuLy8gcmVxdWlyZXMgZGF0YSB0byBiZSBwcmVwcm9jZXNzZWQgYnkgdmFsaWRhdGVkYXRhLiBubyBsZW5ndGggY2hlY2sgaXNcclxuLy8gcGVyZm9ybWVkLCBhbmQgZXZlcnl0aGluZyBoYXMgdG8gYmUgY2hlY2tlZCBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxyXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gKHZlciwgbW9kZSwgZGF0YSwgbWF4YnVmbGVuKSB7XHJcblx0dmFyIGJ1ZiA9IFtdO1xyXG5cdHZhciBiaXRzID0gMCwgcmVtYWluaW5nID0gODtcclxuXHR2YXIgZGF0YWxlbiA9IGRhdGEubGVuZ3RoO1xyXG5cclxuXHQvLyB0aGlzIGZ1bmN0aW9uIGlzIGludGVudGlvbmFsbHkgbm8tb3Agd2hlbiBuPTAuXHJcblx0dmFyIHBhY2sgPSBmdW5jdGlvbiAoeCwgbikge1xyXG5cdFx0aWYgKG4gPj0gcmVtYWluaW5nKSB7XHJcblx0XHRcdGJ1Zi5wdXNoKGJpdHMgfCAoeCA+PiAobiAtPSByZW1haW5pbmcpKSk7XHJcblx0XHRcdHdoaWxlIChuID49IDgpXHJcblx0XHRcdFx0YnVmLnB1c2goKHggPj4gKG4gLT0gOCkpICYgMjU1KTtcclxuXHRcdFx0Yml0cyA9IDA7XHJcblx0XHRcdHJlbWFpbmluZyA9IDg7XHJcblx0XHR9XHJcblx0XHRpZiAobiA+IDApXHJcblx0XHRcdGJpdHMgfD0gKHggJiAoKDEgPDwgbikgLSAxKSkgPDwgKHJlbWFpbmluZyAtPSBuKTtcclxuXHR9O1xyXG5cclxuXHR2YXIgbmxlbmJpdHMgPSBuZGF0YWxlbmJpdHModmVyLCBtb2RlKTtcclxuXHRwYWNrKG1vZGUsIDQpO1xyXG5cdHBhY2soZGF0YWxlbiwgbmxlbmJpdHMpO1xyXG5cclxuXHRzd2l0Y2ggKG1vZGUpIHtcclxuXHRcdGNhc2UgTU9ERV9OVU1FUklDOlxyXG5cdFx0XHRmb3IgKHZhciBpID0gMjsgaSA8IGRhdGFsZW47IGkgKz0gMykge1xyXG5cdFx0XHRcdHBhY2socGFyc2VJbnQoZGF0YS5zdWJzdHJpbmcoaSAtIDIsIGkgKyAxKSwgMTApLCAxMCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cGFjayhwYXJzZUludChkYXRhLnN1YnN0cmluZyhpIC0gMiksIDEwKSwgWzAsIDQsIDddW2RhdGFsZW4gJSAzXSk7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgTU9ERV9BTFBIQU5VTUVSSUM6XHJcblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgZGF0YWxlbjsgaSArPSAyKSB7XHJcblx0XHRcdFx0cGFjayhBTFBIQU5VTUVSSUNfTUFQW2RhdGEuY2hhckF0KGkgLSAxKV0gKiA0NSArXHJcblx0XHRcdFx0XHRBTFBIQU5VTUVSSUNfTUFQW2RhdGEuY2hhckF0KGkpXSwgMTEpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChkYXRhbGVuICUgMiA9PSAxKSB7XHJcblx0XHRcdFx0cGFjayhBTFBIQU5VTUVSSUNfTUFQW2RhdGEuY2hhckF0KGkgLSAxKV0sIDYpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgTU9ERV9PQ1RFVDpcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhbGVuOyArK2kpIHtcclxuXHRcdFx0XHRwYWNrKGRhdGFbaV0sIDgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJyZWFrO1xyXG5cdH1cclxuXHJcblx0Ly8gZmluYWwgYml0cy4gaXQgaXMgcG9zc2libGUgdGhhdCBhZGRpbmcgdGVybWluYXRvciBjYXVzZXMgdGhlIGJ1ZmZlclxyXG5cdC8vIHRvIG92ZXJmbG93LCBidXQgdGhlbiB0aGUgYnVmZmVyIHRydW5jYXRlZCB0byB0aGUgbWF4aW11bSBzaXplIHdpbGxcclxuXHQvLyBiZSB2YWxpZCBhcyB0aGUgdHJ1bmNhdGVkIHRlcm1pbmF0b3IgbW9kZSBiaXRzIGFuZCBwYWRkaW5nIGlzXHJcblx0Ly8gaWRlbnRpY2FsIGluIGFwcGVhcmFuY2UgKGNmLiBKSVMgWCAwNTEwOjIwMDQgc2VjIDguNC44KS5cclxuXHRwYWNrKE1PREVfVEVSTUlOQVRPUiwgNCk7XHJcblx0aWYgKHJlbWFpbmluZyA8IDgpXHJcblx0XHRidWYucHVzaChiaXRzKTtcclxuXHJcblx0Ly8gdGhlIHBhZGRpbmcgdG8gZmlsbCB1cCB0aGUgcmVtYWluaW5nIHNwYWNlLiB3ZSBzaG91bGQgbm90IGFkZCBhbnlcclxuXHQvLyB3b3JkcyB3aGVuIHRoZSBvdmVyZmxvdyBhbHJlYWR5IG9jY3VycmVkLlxyXG5cdHdoaWxlIChidWYubGVuZ3RoICsgMSA8IG1heGJ1ZmxlbilcclxuXHRcdGJ1Zi5wdXNoKDB4ZWMsIDB4MTEpO1xyXG5cdGlmIChidWYubGVuZ3RoIDwgbWF4YnVmbGVuKVxyXG5cdFx0YnVmLnB1c2goMHhlYyk7XHJcblx0cmV0dXJuIGJ1ZjtcclxufTtcclxuXHJcbi8vIGNhbGN1bGF0ZXMgRUNDIGNvZGUgd29yZHMgZm9yIGdpdmVuIGNvZGUgd29yZHMgYW5kIGdlbmVyYXRvciBwb2x5bm9taWFsLlxyXG4vL1xyXG4vLyB0aGlzIGlzIHF1aXRlIHNpbWlsYXIgdG8gQ1JDIGNhbGN1bGF0aW9uIGFzIGJvdGggUmVlZC1Tb2xvbW9uIGFuZCBDUkMgdXNlXHJcbi8vIHRoZSBjZXJ0YWluIGtpbmQgb2YgY3ljbGljIGNvZGVzLCB3aGljaCBpcyBlZmZlY3RpdmVseSB0aGUgZGl2aXNpb24gb2ZcclxuLy8gemVyby1hdWd1bWVudGVkIHBvbHlub21pYWwgYnkgdGhlIGdlbmVyYXRvciBwb2x5bm9taWFsLiB0aGUgb25seSBkaWZmZXJlbmNlXHJcbi8vIGlzIHRoYXQgUmVlZC1Tb2xvbW9uIHVzZXMgR0YoMl44KSwgaW5zdGVhZCBvZiBDUkMncyBHRigyKSwgYW5kIFJlZWQtU29sb21vblxyXG4vLyB1c2VzIHRoZSBkaWZmZXJlbnQgZ2VuZXJhdG9yIHBvbHlub21pYWwgdGhhbiBDUkMncy5cclxudmFyIGNhbGN1bGF0ZWVjYyA9IGZ1bmN0aW9uIChwb2x5LCBnZW5wb2x5KSB7XHJcblx0dmFyIG1vZHVsdXMgPSBwb2x5LnNsaWNlKDApO1xyXG5cdHZhciBwb2x5bGVuID0gcG9seS5sZW5ndGgsIGdlbnBvbHlsZW4gPSBnZW5wb2x5Lmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGdlbnBvbHlsZW47ICsraSlcclxuXHRcdG1vZHVsdXMucHVzaCgwKTtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlsZW47ICkge1xyXG5cdFx0dmFyIHF1b3RpZW50ID0gR0YyNTZfSU5WTUFQW21vZHVsdXNbaSsrXV07XHJcblx0XHRpZiAocXVvdGllbnQgPj0gMCkge1xyXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGdlbnBvbHlsZW47ICsraikge1xyXG5cdFx0XHRcdG1vZHVsdXNbaSArIGpdIF49IEdGMjU2X01BUFsocXVvdGllbnQgKyBnZW5wb2x5W2pdKSAlIDI1NV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsdXMuc2xpY2UocG9seWxlbik7XHJcbn07XHJcblxyXG4vLyBhdWd1bWVudHMgRUNDIGNvZGUgd29yZHMgdG8gZ2l2ZW4gY29kZSB3b3Jkcy4gdGhlIHJlc3VsdGluZyB3b3JkcyBhcmVcclxuLy8gcmVhZHkgdG8gYmUgZW5jb2RlZCBpbiB0aGUgbWF0cml4LlxyXG4vL1xyXG4vLyB0aGUgbXVjaCBvZiBhY3R1YWwgYXVndW1lbnRpbmcgcHJvY2VkdXJlIGZvbGxvd3MgSklTIFggMDUxMDoyMDA0IHNlYyA4LjcuXHJcbi8vIHRoZSBjb2RlIGlzIHNpbXBsaWZpZWQgdXNpbmcgdGhlIGZhY3QgdGhhdCB0aGUgc2l6ZSBvZiBlYWNoIGNvZGUgJiBFQ0NcclxuLy8gYmxvY2tzIGlzIGFsbW9zdCBzYW1lOyBmb3IgZXhhbXBsZSwgd2hlbiB3ZSBoYXZlIDQgYmxvY2tzIGFuZCA0NiBkYXRhIHdvcmRzXHJcbi8vIHRoZSBudW1iZXIgb2YgY29kZSB3b3JkcyBpbiB0aG9zZSBibG9ja3MgYXJlIDExLCAxMSwgMTIsIDEyIHJlc3BlY3RpdmVseS5cclxudmFyIGF1Z3VtZW50ZWNjcyA9IGZ1bmN0aW9uIChwb2x5LCBuYmxvY2tzLCBnZW5wb2x5KSB7XHJcblx0dmFyIHN1YnNpemVzID0gW107XHJcblx0dmFyIHN1YnNpemUgPSAocG9seS5sZW5ndGggLyBuYmxvY2tzKSB8IDAsIHN1YnNpemUwID0gMDtcclxuXHR2YXIgcGl2b3QgPSBuYmxvY2tzIC0gcG9seS5sZW5ndGggJSBuYmxvY2tzO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcGl2b3Q7ICsraSkge1xyXG5cdFx0c3Vic2l6ZXMucHVzaChzdWJzaXplMCk7XHJcblx0XHRzdWJzaXplMCArPSBzdWJzaXplO1xyXG5cdH1cclxuXHRmb3IgKHZhciBpID0gcGl2b3Q7IGkgPCBuYmxvY2tzOyArK2kpIHtcclxuXHRcdHN1YnNpemVzLnB1c2goc3Vic2l6ZTApO1xyXG5cdFx0c3Vic2l6ZTAgKz0gc3Vic2l6ZSArIDE7XHJcblx0fVxyXG5cdHN1YnNpemVzLnB1c2goc3Vic2l6ZTApO1xyXG5cclxuXHR2YXIgZWNjcyA9IFtdO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbmJsb2NrczsgKytpKSB7XHJcblx0XHRlY2NzLnB1c2goY2FsY3VsYXRlZWNjKHBvbHkuc2xpY2Uoc3Vic2l6ZXNbaV0sIHN1YnNpemVzW2kgKyAxXSksIGdlbnBvbHkpKTtcclxuXHR9XHJcblxyXG5cdHZhciByZXN1bHQgPSBbXTtcclxuXHR2YXIgbml0ZW1zcGVyYmxvY2sgPSAocG9seS5sZW5ndGggLyBuYmxvY2tzKSB8IDA7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuaXRlbXNwZXJibG9jazsgKytpKSB7XHJcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG5ibG9ja3M7ICsraikge1xyXG5cdFx0XHRyZXN1bHQucHVzaChwb2x5W3N1YnNpemVzW2pdICsgaV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRmb3IgKHZhciBqID0gcGl2b3Q7IGogPCBuYmxvY2tzOyArK2opIHtcclxuXHRcdHJlc3VsdC5wdXNoKHBvbHlbc3Vic2l6ZXNbaiArIDFdIC0gMV0pO1xyXG5cdH1cclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGdlbnBvbHkubGVuZ3RoOyArK2kpIHtcclxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgbmJsb2NrczsgKytqKSB7XHJcblx0XHRcdHJlc3VsdC5wdXNoKGVjY3Nbal1baV0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuLy8gYXVndW1lbnRzIEJDSChwK3EscSkgY29kZSB0byB0aGUgcG9seW5vbWlhbCBvdmVyIEdGKDIpLCBnaXZlbiB0aGUgcHJvcGVyXHJcbi8vIGdlbnBvbHkuIHRoZSBib3RoIGlucHV0IGFuZCBvdXRwdXQgYXJlIGluIGJpbmFyeSBudW1iZXJzLCBhbmQgdW5saWtlXHJcbi8vIGNhbGN1bGF0ZWVjYyBnZW5wb2x5IHNob3VsZCBpbmNsdWRlIHRoZSAxIGJpdCBmb3IgdGhlIGhpZ2hlc3QgZGVncmVlLlxyXG4vL1xyXG4vLyBhY3R1YWwgcG9seW5vbWlhbHMgdXNlZCBmb3IgdGhpcyBwcm9jZWR1cmUgYXJlIGFzIGZvbGxvd3M6XHJcbi8vIC0gcD0xMCwgcT01LCBnZW5wb2x5PXheMTAreF44K3heNSt4XjQreF4yK3grMSAoSklTIFggMDUxMDoyMDA0IEFwcGVuZGl4IEMpXHJcbi8vIC0gcD0xOCwgcT02LCBnZW5wb2x5PXheMTIreF4xMSt4XjEwK3heOSt4XjgreF41K3heMisxIChpYmlkLiBBcHBlbmRpeCBEKVxyXG52YXIgYXVndW1lbnRiY2ggPSBmdW5jdGlvbiAocG9seSwgcCwgZ2VucG9seSwgcSkge1xyXG5cdHZhciBtb2R1bHVzID0gcG9seSA8PCBxO1xyXG5cdGZvciAodmFyIGkgPSBwIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuXHRcdGlmICgobW9kdWx1cyA+PiAocSArIGkpKSAmIDEpXHJcblx0XHRcdG1vZHVsdXMgXj0gZ2VucG9seSA8PCBpO1xyXG5cdH1cclxuXHRyZXR1cm4gKHBvbHkgPDwgcSkgfCBtb2R1bHVzO1xyXG59O1xyXG5cclxuLy8gY3JlYXRlcyB0aGUgYmFzZSBtYXRyaXggZm9yIGdpdmVuIHZlcnNpb24uIGl0IHJldHVybnMgdHdvIG1hdHJpY2VzLCBvbmUgb2ZcclxuLy8gdGhlbSBpcyB0aGUgYWN0dWFsIG9uZSBhbmQgdGhlIGFub3RoZXIgcmVwcmVzZW50cyB0aGUgXCJyZXNlcnZlZFwiIHBvcnRpb25cclxuLy8gKGUuZy4gZmluZGVyIGFuZCB0aW1pbmcgcGF0dGVybnMpIG9mIHRoZSBtYXRyaXguXHJcbi8vXHJcbi8vIHNvbWUgZW50cmllcyBpbiB0aGUgbWF0cml4IG1heSBiZSB1bmRlZmluZWQsIHJhdGhlciB0aGFuIDAgb3IgMS4gdGhpcyBpc1xyXG4vLyBpbnRlbnRpb25hbCAobm8gaW5pdGlhbGl6YXRpb24gbmVlZGVkISksIGFuZCBwdXRkYXRhIGJlbG93IHdpbGwgZmlsbFxyXG4vLyB0aGUgcmVtYWluaW5nIG9uZXMuXHJcbnZhciBtYWtlYmFzZW1hdHJpeCA9IGZ1bmN0aW9uICh2ZXIpIHtcclxuXHR2YXIgdiA9IFZFUlNJT05TW3Zlcl0sIG4gPSBnZXRzaXplYnl2ZXIodmVyKTtcclxuXHR2YXIgbWF0cml4ID0gW10sIHJlc2VydmVkID0gW107XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcclxuXHRcdG1hdHJpeC5wdXNoKFtdKTtcclxuXHRcdHJlc2VydmVkLnB1c2goW10pO1xyXG5cdH1cclxuXHJcblx0dmFyIGJsaXQgPSBmdW5jdGlvbiAoeSwgeCwgaCwgdywgYml0cykge1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBoOyArK2kpIHtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCB3OyArK2opIHtcclxuXHRcdFx0XHRtYXRyaXhbeSArIGldW3ggKyBqXSA9IChiaXRzW2ldID4+IGopICYgMTtcclxuXHRcdFx0XHRyZXNlcnZlZFt5ICsgaV1beCArIGpdID0gMTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIGZpbmRlciBwYXR0ZXJucyBhbmQgYSBwYXJ0IG9mIHRpbWluZyBwYXR0ZXJuc1xyXG5cdC8vIHdpbGwgYWxzbyBtYXJrIHRoZSBmb3JtYXQgaW5mb3JtYXRpb24gYXJlYSAobm90IHlldCB3cml0dGVuKSBhcyByZXNlcnZlZC5cclxuXHRibGl0KDAsIDAsIDksIDksIFsweDdmLCAweDQxLCAweDVkLCAweDVkLCAweDVkLCAweDQxLCAweDE3ZiwgMHgwMCwgMHg0MF0pO1xyXG5cdGJsaXQobiAtIDgsIDAsIDgsIDksIFsweDEwMCwgMHg3ZiwgMHg0MSwgMHg1ZCwgMHg1ZCwgMHg1ZCwgMHg0MSwgMHg3Zl0pO1xyXG5cdGJsaXQoMCwgbiAtIDgsIDksIDgsIFsweGZlLCAweDgyLCAweGJhLCAweGJhLCAweGJhLCAweDgyLCAweGZlLCAweDAwLCAweDAwXSk7XHJcblxyXG5cdC8vIHRoZSByZXN0IG9mIHRpbWluZyBwYXR0ZXJuc1xyXG5cdGZvciAodmFyIGkgPSA5OyBpIDwgbiAtIDg7ICsraSkge1xyXG5cdFx0bWF0cml4WzZdW2ldID0gbWF0cml4W2ldWzZdID0gfmkgJiAxO1xyXG5cdFx0cmVzZXJ2ZWRbNl1baV0gPSByZXNlcnZlZFtpXVs2XSA9IDE7XHJcblx0fVxyXG5cclxuXHQvLyBhbGlnbm1lbnQgcGF0dGVybnNcclxuXHR2YXIgYWxpZ25zID0gdlsyXSwgbSA9IGFsaWducy5sZW5ndGg7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtOyArK2kpIHtcclxuXHRcdHZhciBtaW5qID0gKGkgPT09IDAgfHwgaSA9PT0gbSAtIDEgPyAxIDogMCksIG1heGogPSAoaSA9PT0gMCA/IG0gLSAxIDogbSk7XHJcblx0XHRmb3IgKHZhciBqID0gbWluajsgaiA8IG1heGo7ICsraikge1xyXG5cdFx0XHRibGl0KGFsaWduc1tpXSwgYWxpZ25zW2pdLCA1LCA1LCBbMHgxZiwgMHgxMSwgMHgxNSwgMHgxMSwgMHgxZl0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gdmVyc2lvbiBpbmZvcm1hdGlvblxyXG5cdGlmIChuZWVkc3ZlcmluZm8odmVyKSkge1xyXG5cdFx0dmFyIGNvZGUgPSBhdWd1bWVudGJjaCh2ZXIsIDYsIDB4MWYyNSwgMTIpO1xyXG5cdFx0dmFyIGsgPSAwO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA2OyArK2kpIHtcclxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCAzOyArK2opIHtcclxuXHRcdFx0XHRtYXRyaXhbaV1bKG4gLSAxMSkgKyBqXSA9IG1hdHJpeFsobiAtIDExKSArIGpdW2ldID0gKGNvZGUgPj4gaysrKSAmIDE7XHJcblx0XHRcdFx0cmVzZXJ2ZWRbaV1bKG4gLSAxMSkgKyBqXSA9IHJlc2VydmVkWyhuIC0gMTEpICsgal1baV0gPSAxO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge21hdHJpeDogbWF0cml4LCByZXNlcnZlZDogcmVzZXJ2ZWR9O1xyXG59O1xyXG5cclxuLy8gZmlsbHMgdGhlIGRhdGEgcG9ydGlvbiAoaS5lLiB1bm1hcmtlZCBpbiByZXNlcnZlZCkgb2YgdGhlIG1hdHJpeCB3aXRoIGdpdmVuXHJcbi8vIGNvZGUgd29yZHMuIHRoZSBzaXplIG9mIGNvZGUgd29yZHMgc2hvdWxkIGJlIG5vIG1vcmUgdGhhbiBhdmFpbGFibGUgYml0cyxcclxuLy8gYW5kIHJlbWFpbmluZyBiaXRzIGFyZSBwYWRkZWQgdG8gMCAoY2YuIEpJUyBYIDA1MTA6MjAwNCBzZWMgOC43LjMpLlxyXG52YXIgcHV0ZGF0YSA9IGZ1bmN0aW9uIChtYXRyaXgsIHJlc2VydmVkLCBidWYpIHtcclxuXHR2YXIgbiA9IG1hdHJpeC5sZW5ndGg7XHJcblx0dmFyIGsgPSAwLCBkaXIgPSAtMTtcclxuXHRmb3IgKHZhciBpID0gbiAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XHJcblx0XHRpZiAoaSA9PSA2KVxyXG5cdFx0XHQtLWk7IC8vIHNraXAgdGhlIGVudGlyZSB0aW1pbmcgcGF0dGVybiBjb2x1bW5cclxuXHRcdHZhciBqaiA9IChkaXIgPCAwID8gbiAtIDEgOiAwKTtcclxuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgbjsgKytqKSB7XHJcblx0XHRcdGZvciAodmFyIGlpID0gaTsgaWkgPiBpIC0gMjsgLS1paSkge1xyXG5cdFx0XHRcdGlmICghcmVzZXJ2ZWRbampdW2lpXSkge1xyXG5cdFx0XHRcdFx0Ly8gbWF5IG92ZXJmbG93LCBidXQgKHVuZGVmaW5lZCA+PiB4KVxyXG5cdFx0XHRcdFx0Ly8gaXMgMCBzbyBpdCB3aWxsIGF1dG8tcGFkIHRvIHplcm8uXHJcblx0XHRcdFx0XHRtYXRyaXhbampdW2lpXSA9IChidWZbayA+PiAzXSA+PiAofmsgJiA3KSkgJiAxO1xyXG5cdFx0XHRcdFx0KytrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRqaiArPSBkaXI7XHJcblx0XHR9XHJcblx0XHRkaXIgPSAtZGlyO1xyXG5cdH1cclxuXHRyZXR1cm4gbWF0cml4O1xyXG59O1xyXG5cclxuLy8gWE9SLW1hc2tzIHRoZSBkYXRhIHBvcnRpb24gb2YgdGhlIG1hdHJpeC4gcmVwZWF0aW5nIHRoZSBjYWxsIHdpdGggdGhlIHNhbWVcclxuLy8gYXJndW1lbnRzIHdpbGwgcmV2ZXJ0IHRoZSBwcmlvciBjYWxsIChjb252ZW5pZW50IGluIHRoZSBtYXRyaXggZXZhbHVhdGlvbikuXHJcbnZhciBtYXNrZGF0YSA9IGZ1bmN0aW9uIChtYXRyaXgsIHJlc2VydmVkLCBtYXNrKSB7XHJcblx0dmFyIG1hc2tmID0gTUFTS0ZVTkNTW21hc2tdO1xyXG5cdHZhciBuID0gbWF0cml4Lmxlbmd0aDtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xyXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBuOyArK2opIHtcclxuXHRcdFx0aWYgKCFyZXNlcnZlZFtpXVtqXSlcclxuXHRcdFx0XHRtYXRyaXhbaV1bal0gXj0gbWFza2YoaSwgaik7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBtYXRyaXg7XHJcbn07XHJcblxyXG4vLyBwdXRzIHRoZSBmb3JtYXQgaW5mb3JtYXRpb24uXHJcbnZhciBwdXRmb3JtYXRpbmZvID0gZnVuY3Rpb24gKG1hdHJpeCwgcmVzZXJ2ZWQsIGVjY2xldmVsLCBtYXNrKSB7XHJcblx0dmFyIG4gPSBtYXRyaXgubGVuZ3RoO1xyXG5cdHZhciBjb2RlID0gYXVndW1lbnRiY2goKGVjY2xldmVsIDw8IDMpIHwgbWFzaywgNSwgMHg1MzcsIDEwKSBeIDB4NTQxMjtcclxuXHRmb3IgKHZhciBpID0gMDsgaSA8IDE1OyArK2kpIHtcclxuXHRcdHZhciByID0gWzAsIDEsIDIsIDMsIDQsIDUsIDcsIDgsIG4gLSA3LCBuIC0gNiwgbiAtIDUsIG4gLSA0LCBuIC0gMywgbiAtIDIsIG4gLSAxXVtpXTtcclxuXHRcdHZhciBjID0gW24gLSAxLCBuIC0gMiwgbiAtIDMsIG4gLSA0LCBuIC0gNSwgbiAtIDYsIG4gLSA3LCBuIC0gOCwgNywgNSwgNCwgMywgMiwgMSwgMF1baV07XHJcblx0XHRtYXRyaXhbcl1bOF0gPSBtYXRyaXhbOF1bY10gPSAoY29kZSA+PiBpKSAmIDE7XHJcblx0XHQvLyB3ZSBkb24ndCBoYXZlIHRvIG1hcmsgdGhvc2UgYml0cyByZXNlcnZlZDsgYWx3YXlzIGRvbmVcclxuXHRcdC8vIGluIG1ha2ViYXNlbWF0cml4IGFib3ZlLlxyXG5cdH1cclxuXHRyZXR1cm4gbWF0cml4O1xyXG59O1xyXG5cclxuLy8gZXZhbHVhdGVzIHRoZSByZXN1bHRpbmcgbWF0cml4IGFuZCByZXR1cm5zIHRoZSBzY29yZSAobG93ZXIgaXMgYmV0dGVyKS5cclxuLy8gKGNmLiBKSVMgWCAwNTEwOjIwMDQgc2VjIDguOC4yKVxyXG4vL1xyXG4vLyB0aGUgZXZhbHVhdGlvbiBwcm9jZWR1cmUgdHJpZXMgdG8gYXZvaWQgdGhlIHByb2JsZW1hdGljIHBhdHRlcm5zIG5hdHVyYWxseVxyXG4vLyBvY2N1cmluZyBmcm9tIHRoZSBvcmlnaW5hbCBtYXRyaXguIGZvciBleGFtcGxlLCBpdCBwZW5hbHRpemVzIHRoZSBwYXR0ZXJuc1xyXG4vLyB3aGljaCBqdXN0IGxvb2sgbGlrZSB0aGUgZmluZGVyIHBhdHRlcm4gd2hpY2ggd2lsbCBjb25mdXNlIHRoZSBkZWNvZGVyLlxyXG4vLyB3ZSBjaG9vc2UgdGhlIG1hc2sgd2hpY2ggcmVzdWx0cyBpbiB0aGUgbG93ZXN0IHNjb3JlIGFtb25nIDggcG9zc2libGUgb25lcy5cclxuLy9cclxuLy8gbm90ZTogenhpbmcgc2VlbXMgdG8gdXNlIHRoZSBzYW1lIHByb2NlZHVyZSBhbmQgaW4gbWFueSBjYXNlcyBpdHMgY2hvaWNlXHJcbi8vIGFncmVlcyB0byBvdXJzLCBidXQgc29tZXRpbWVzIGl0IGRvZXMgbm90LiBwcmFjdGljYWxseSBpdCBkb2Vzbid0IG1hdHRlci5cclxudmFyIGV2YWx1YXRlbWF0cml4ID0gZnVuY3Rpb24gKG1hdHJpeCkge1xyXG5cdC8vIE4xKyhrLTUpIHBvaW50cyBmb3IgZWFjaCBjb25zZWN1dGl2ZSByb3cgb2YgayBzYW1lLWNvbG9yZWQgbW9kdWxlcyxcclxuXHQvLyB3aGVyZSBrID49IDUuIG5vIG92ZXJsYXBwaW5nIHJvdyBjb3VudHMuXHJcblx0dmFyIFBFTkFMVFlfQ09OU0VDVVRJVkUgPSAzO1xyXG5cdC8vIE4yIHBvaW50cyBmb3IgZWFjaCAyeDIgYmxvY2sgb2Ygc2FtZS1jb2xvcmVkIG1vZHVsZXMuXHJcblx0Ly8gb3ZlcmxhcHBpbmcgYmxvY2sgZG9lcyBjb3VudC5cclxuXHR2YXIgUEVOQUxUWV9UV09CWVRXTyA9IDM7XHJcblx0Ly8gTjMgcG9pbnRzIGZvciBlYWNoIHBhdHRlcm4gd2l0aCA+NFc6MUI6MVc6M0I6MVc6MUIgb3JcclxuXHQvLyAxQjoxVzozQjoxVzoxQjo+NFcsIG9yIHRoZWlyIG11bHRpcGxlcyAoZS5nLiBoaWdobHkgdW5saWtlbHksXHJcblx0Ly8gYnV0IDEzVzozQjozVzo5QjozVzozQiBjb3VudHMpLlxyXG5cdHZhciBQRU5BTFRZX0ZJTkRFUkxJS0UgPSA0MDtcclxuXHQvLyBONCprIHBvaW50cyBmb3IgZXZlcnkgKDUqayklIGRldmlhdGlvbiBmcm9tIDUwJSBibGFjayBkZW5zaXR5LlxyXG5cdC8vIGkuZS4gaz0xIGZvciA1NX42MCUgYW5kIDQwfjQ1JSwgaz0yIGZvciA2MH42NSUgYW5kIDM1fjQwJSwgZXRjLlxyXG5cdHZhciBQRU5BTFRZX0RFTlNJVFkgPSAxMDtcclxuXHJcblx0dmFyIGV2YWx1YXRlZ3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXBzKSB7IC8vIGFzc3VtZXMgW1csQixXLEIsVywuLi4sQixXXVxyXG5cdFx0dmFyIHNjb3JlID0gMDtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgKytpKSB7XHJcblx0XHRcdGlmIChncm91cHNbaV0gPj0gNSlcclxuXHRcdFx0XHRzY29yZSArPSBQRU5BTFRZX0NPTlNFQ1VUSVZFICsgKGdyb3Vwc1tpXSAtIDUpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yICh2YXIgaSA9IDU7IGkgPCBncm91cHMubGVuZ3RoOyBpICs9IDIpIHtcclxuXHRcdFx0dmFyIHAgPSBncm91cHNbaV07XHJcblx0XHRcdGlmIChncm91cHNbaSAtIDFdID09IHAgJiYgZ3JvdXBzW2kgLSAyXSA9PSAzICogcCAmJiBncm91cHNbaSAtIDNdID09IHAgJiZcclxuXHRcdFx0XHRncm91cHNbaSAtIDRdID09IHAgJiYgKGdyb3Vwc1tpIC0gNV0gPj0gNCAqIHAgfHwgZ3JvdXBzW2kgKyAxXSA+PSA0ICogcCkpIHtcclxuXHRcdFx0XHQvLyB0aGlzIHBhcnQgZGlmZmVycyBmcm9tIHp4aW5nLi4uXHJcblx0XHRcdFx0c2NvcmUgKz0gUEVOQUxUWV9GSU5ERVJMSUtFO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc2NvcmU7XHJcblx0fTtcclxuXHJcblx0dmFyIG4gPSBtYXRyaXgubGVuZ3RoO1xyXG5cdHZhciBzY29yZSA9IDAsIG5ibGFja3MgPSAwO1xyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcblx0XHR2YXIgcm93ID0gbWF0cml4W2ldO1xyXG5cdFx0dmFyIGdyb3VwcztcclxuXHJcblx0XHQvLyBldmFsdWF0ZSB0aGUgY3VycmVudCByb3dcclxuXHRcdGdyb3VwcyA9IFswXTsgLy8gdGhlIGZpcnN0IGVtcHR5IGdyb3VwIG9mIHdoaXRlXHJcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG47ICkge1xyXG5cdFx0XHR2YXIgaztcclxuXHRcdFx0Zm9yIChrID0gMDsgaiA8IG4gJiYgcm93W2pdOyArK2spXHJcblx0XHRcdFx0KytqO1xyXG5cdFx0XHRncm91cHMucHVzaChrKTtcclxuXHRcdFx0Zm9yIChrID0gMDsgaiA8IG4gJiYgIXJvd1tqXTsgKytrKVxyXG5cdFx0XHRcdCsrajtcclxuXHRcdFx0Z3JvdXBzLnB1c2goayk7XHJcblx0XHR9XHJcblx0XHRzY29yZSArPSBldmFsdWF0ZWdyb3VwKGdyb3Vwcyk7XHJcblxyXG5cdFx0Ly8gZXZhbHVhdGUgdGhlIGN1cnJlbnQgY29sdW1uXHJcblx0XHRncm91cHMgPSBbMF07XHJcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG47ICkge1xyXG5cdFx0XHR2YXIgaztcclxuXHRcdFx0Zm9yIChrID0gMDsgaiA8IG4gJiYgbWF0cml4W2pdW2ldOyArK2spXHJcblx0XHRcdFx0KytqO1xyXG5cdFx0XHRncm91cHMucHVzaChrKTtcclxuXHRcdFx0Zm9yIChrID0gMDsgaiA8IG4gJiYgIW1hdHJpeFtqXVtpXTsgKytrKVxyXG5cdFx0XHRcdCsrajtcclxuXHRcdFx0Z3JvdXBzLnB1c2goayk7XHJcblx0XHR9XHJcblx0XHRzY29yZSArPSBldmFsdWF0ZWdyb3VwKGdyb3Vwcyk7XHJcblxyXG5cdFx0Ly8gY2hlY2sgdGhlIDJ4MiBib3ggYW5kIGNhbGN1bGF0ZSB0aGUgZGVuc2l0eVxyXG5cdFx0dmFyIG5leHRyb3cgPSBtYXRyaXhbaSArIDFdIHx8IFtdO1xyXG5cdFx0bmJsYWNrcyArPSByb3dbMF07XHJcblx0XHRmb3IgKHZhciBqID0gMTsgaiA8IG47ICsraikge1xyXG5cdFx0XHR2YXIgcCA9IHJvd1tqXTtcclxuXHRcdFx0bmJsYWNrcyArPSBwO1xyXG5cdFx0XHQvLyBhdCBsZWFzdCBjb21wYXJpc29uIHdpdGggbmV4dCByb3cgc2hvdWxkIGJlIHN0cmljdC4uLlxyXG5cdFx0XHRpZiAocm93W2ogLSAxXSA9PSBwICYmIG5leHRyb3dbal0gPT09IHAgJiYgbmV4dHJvd1tqIC0gMV0gPT09IHApIHtcclxuXHRcdFx0XHRzY29yZSArPSBQRU5BTFRZX1RXT0JZVFdPO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRzY29yZSArPSBQRU5BTFRZX0RFTlNJVFkgKiAoKE1hdGguYWJzKG5ibGFja3MgLyBuIC8gbiAtIDAuNSkgLyAwLjA1KSB8IDApO1xyXG5cdHJldHVybiBzY29yZTtcclxufTtcclxuXHJcbi8vIHJldHVybnMgdGhlIGZ1bGx5IGVuY29kZWQgUVIgY29kZSBtYXRyaXggd2hpY2ggY29udGFpbnMgZ2l2ZW4gZGF0YS5cclxuLy8gaXQgYWxzbyBjaG9vc2VzIHRoZSBiZXN0IG1hc2sgYXV0b21hdGljYWxseSB3aGVuIG1hc2sgaXMgLTEuXHJcbnZhciBnZW5lcmF0ZSA9IGZ1bmN0aW9uIChkYXRhLCB2ZXIsIG1vZGUsIGVjY2xldmVsLCBtYXNrKSB7XHJcblx0dmFyIHYgPSBWRVJTSU9OU1t2ZXJdO1xyXG5cdHZhciBidWYgPSBlbmNvZGUodmVyLCBtb2RlLCBkYXRhLCBuZGF0YWJpdHModmVyLCBlY2NsZXZlbCkgPj4gMyk7XHJcblx0YnVmID0gYXVndW1lbnRlY2NzKGJ1ZiwgdlsxXVtlY2NsZXZlbF0sIEdGMjU2X0dFTlBPTFlbdlswXVtlY2NsZXZlbF1dKTtcclxuXHJcblx0dmFyIHJlc3VsdCA9IG1ha2ViYXNlbWF0cml4KHZlcik7XHJcblx0dmFyIG1hdHJpeCA9IHJlc3VsdC5tYXRyaXgsIHJlc2VydmVkID0gcmVzdWx0LnJlc2VydmVkO1xyXG5cdHB1dGRhdGEobWF0cml4LCByZXNlcnZlZCwgYnVmKTtcclxuXHJcblx0aWYgKG1hc2sgPCAwKSB7XHJcblx0XHQvLyBmaW5kIHRoZSBiZXN0IG1hc2tcclxuXHRcdG1hc2tkYXRhKG1hdHJpeCwgcmVzZXJ2ZWQsIDApO1xyXG5cdFx0cHV0Zm9ybWF0aW5mbyhtYXRyaXgsIHJlc2VydmVkLCBlY2NsZXZlbCwgMCk7XHJcblx0XHR2YXIgYmVzdG1hc2sgPSAwLCBiZXN0c2NvcmUgPSBldmFsdWF0ZW1hdHJpeChtYXRyaXgpO1xyXG5cdFx0bWFza2RhdGEobWF0cml4LCByZXNlcnZlZCwgMCk7XHJcblx0XHRmb3IgKG1hc2sgPSAxOyBtYXNrIDwgODsgKyttYXNrKSB7XHJcblx0XHRcdG1hc2tkYXRhKG1hdHJpeCwgcmVzZXJ2ZWQsIG1hc2spO1xyXG5cdFx0XHRwdXRmb3JtYXRpbmZvKG1hdHJpeCwgcmVzZXJ2ZWQsIGVjY2xldmVsLCBtYXNrKTtcclxuXHRcdFx0dmFyIHNjb3JlID0gZXZhbHVhdGVtYXRyaXgobWF0cml4KTtcclxuXHRcdFx0aWYgKGJlc3RzY29yZSA+IHNjb3JlKSB7XHJcblx0XHRcdFx0YmVzdHNjb3JlID0gc2NvcmU7XHJcblx0XHRcdFx0YmVzdG1hc2sgPSBtYXNrO1xyXG5cdFx0XHR9XHJcblx0XHRcdG1hc2tkYXRhKG1hdHJpeCwgcmVzZXJ2ZWQsIG1hc2spO1xyXG5cdFx0fVxyXG5cdFx0bWFzayA9IGJlc3RtYXNrO1xyXG5cdH1cclxuXHJcblx0bWFza2RhdGEobWF0cml4LCByZXNlcnZlZCwgbWFzayk7XHJcblx0cHV0Zm9ybWF0aW5mbyhtYXRyaXgsIHJlc2VydmVkLCBlY2NsZXZlbCwgbWFzayk7XHJcblx0cmV0dXJuIG1hdHJpeDtcclxufTtcclxuXHJcbi8vIHRoZSBwdWJsaWMgaW50ZXJmYWNlIGlzIHRyaXZpYWw7IHRoZSBvcHRpb25zIGF2YWlsYWJsZSBhcmUgYXMgZm9sbG93czpcclxuLy9cclxuLy8gLSB2ZXJzaW9uOiBhbiBpbnRlZ2VyIGluIFsxLDQwXS4gd2hlbiBvbWl0dGVkIChvciAtMSkgdGhlIHNtYWxsZXN0IHBvc3NpYmxlXHJcbi8vICAgdmVyc2lvbiBpcyBjaG9zZW4uXHJcbi8vIC0gbW9kZTogb25lIG9mICdudW1lcmljJywgJ2FscGhhbnVtZXJpYycsICdvY3RldCcuIHdoZW4gb21pdHRlZCB0aGUgc21hbGxlc3RcclxuLy8gICBwb3NzaWJsZSBtb2RlIGlzIGNob3Nlbi5cclxuLy8gLSBlY2NMZXZlbDogb25lIG9mICdMJywgJ00nLCAnUScsICdIJy4gZGVmYXVsdHMgdG8gJ0wnLlxyXG4vLyAtIG1hc2s6IGFuIGludGVnZXIgaW4gWzAsN10uIHdoZW4gb21pdHRlZCAob3IgLTEpIHRoZSBiZXN0IG1hc2sgaXMgY2hvc2VuLlxyXG4vL1xyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVGcmFtZShkYXRhLCBvcHRpb25zKSB7XHJcblx0dmFyIE1PREVTID0geydudW1lcmljJzogTU9ERV9OVU1FUklDLCAnYWxwaGFudW1lcmljJzogTU9ERV9BTFBIQU5VTUVSSUMsXHJcblx0XHQnb2N0ZXQnOiBNT0RFX09DVEVUfTtcclxuXHR2YXIgRUNDTEVWRUxTID0geydMJzogRUNDTEVWRUxfTCwgJ00nOiBFQ0NMRVZFTF9NLCAnUSc6IEVDQ0xFVkVMX1EsXHJcblx0XHQnSCc6IEVDQ0xFVkVMX0h9O1xyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHR2YXIgdmVyID0gb3B0aW9ucy52ZXJzaW9uIHx8IC0xO1xyXG5cdHZhciBlY2NsZXZlbCA9IEVDQ0xFVkVMU1sob3B0aW9ucy5lY2NMZXZlbCB8fCAnTCcpLnRvVXBwZXJDYXNlKCldO1xyXG5cdHZhciBtb2RlID0gb3B0aW9ucy5tb2RlID8gTU9ERVNbb3B0aW9ucy5tb2RlLnRvTG93ZXJDYXNlKCldIDogLTE7XHJcblx0dmFyIG1hc2sgPSAnbWFzaycgaW4gb3B0aW9ucyA/IG9wdGlvbnMubWFzayA6IC0xO1xyXG5cclxuXHRpZiAobW9kZSA8IDApIHtcclxuXHRcdGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0aWYgKGRhdGEubWF0Y2goTlVNRVJJQ19SRUdFWFApKSB7XHJcblx0XHRcdFx0bW9kZSA9IE1PREVfTlVNRVJJQztcclxuXHRcdFx0fSBlbHNlIGlmIChkYXRhLm1hdGNoKEFMUEhBTlVNRVJJQ19PVVRfUkVHRVhQKSkge1xyXG5cdFx0XHRcdC8vIHdoaWxlIGVuY29kZSBzdXBwb3J0cyBjYXNlLWluc2Vuc2l0aXZlIGVuY29kaW5nLCB3ZSByZXN0cmljdCB0aGUgZGF0YSB0byBiZSB1cHBlcmNhc2VkIHdoZW4gYXV0by1zZWxlY3RpbmcgdGhlIG1vZGUuXHJcblx0XHRcdFx0bW9kZSA9IE1PREVfQUxQSEFOVU1FUklDO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG1vZGUgPSBNT0RFX09DVEVUO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtb2RlID0gTU9ERV9PQ1RFVDtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYgKCEobW9kZSA9PSBNT0RFX05VTUVSSUMgfHwgbW9kZSA9PSBNT0RFX0FMUEhBTlVNRVJJQyB8fFxyXG5cdFx0bW9kZSA9PSBNT0RFX09DVEVUKSkge1xyXG5cdFx0dGhyb3cgJ2ludmFsaWQgb3IgdW5zdXBwb3J0ZWQgbW9kZSc7XHJcblx0fVxyXG5cclxuXHRkYXRhID0gdmFsaWRhdGVkYXRhKG1vZGUsIGRhdGEpO1xyXG5cdGlmIChkYXRhID09PSBudWxsKVxyXG5cdFx0dGhyb3cgJ2ludmFsaWQgZGF0YSBmb3JtYXQnO1xyXG5cclxuXHRpZiAoZWNjbGV2ZWwgPCAwIHx8IGVjY2xldmVsID4gMylcclxuXHRcdHRocm93ICdpbnZhbGlkIEVDQyBsZXZlbCc7XHJcblxyXG5cdGlmICh2ZXIgPCAwKSB7XHJcblx0XHRmb3IgKHZlciA9IDE7IHZlciA8PSA0MDsgKyt2ZXIpIHtcclxuXHRcdFx0aWYgKGRhdGEubGVuZ3RoIDw9IGdldG1heGRhdGFsZW4odmVyLCBtb2RlLCBlY2NsZXZlbCkpXHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0XHRpZiAodmVyID4gNDApXHJcblx0XHRcdHRocm93ICd0b28gbGFyZ2UgZGF0YSBmb3IgdGhlIFFyIGZvcm1hdCc7XHJcblx0fSBlbHNlIGlmICh2ZXIgPCAxIHx8IHZlciA+IDQwKSB7XHJcblx0XHR0aHJvdyAnaW52YWxpZCBRciB2ZXJzaW9uISBzaG91bGQgYmUgYmV0d2VlbiAxIGFuZCA0MCc7XHJcblx0fVxyXG5cclxuXHRpZiAobWFzayAhPSAtMSAmJiAobWFzayA8IDAgfHwgbWFzayA+IDgpKVxyXG5cdFx0dGhyb3cgJ2ludmFsaWQgbWFzayc7XHJcblx0Ly9jb25zb2xlLmxvZygndmVyc2lvbjonLCB2ZXIsICdtb2RlOicsIG1vZGUsICdFQ0M6JywgZWNjbGV2ZWwsICdtYXNrOicsIG1hc2sgKVxyXG5cdHJldHVybiBnZW5lcmF0ZShkYXRhLCB2ZXIsIG1vZGUsIGVjY2xldmVsLCBtYXNrKTtcclxufVxyXG5cclxuXHJcbi8vIG9wdGlvbnNcclxuLy8gLSBtb2R1bGVzaXplOiBhIG51bWJlci4gdGhpcyBpcyBhIHNpemUgb2YgZWFjaCBtb2R1bGVzIGluIHBpeGVscywgYW5kXHJcbi8vICAgZGVmYXVsdHMgdG8gNXB4LlxyXG4vLyAtIG1hcmdpbjogYSBudW1iZXIuIHRoaXMgaXMgYSBzaXplIG9mIG1hcmdpbiBpbiAqbW9kdWxlcyosIGFuZCBkZWZhdWx0cyB0b1xyXG4vLyAgIDQgKHdoaXRlIG1vZHVsZXMpLiB0aGUgc3BlY2ZpY2lhdGlvbiBtYW5kYXRlcyB0aGUgbWFyZ2luIG5vIGxlc3MgdGhhbiA0XHJcbi8vICAgbW9kdWxlcywgc28gaXQgaXMgYmV0dGVyIG5vdCB0byBhbHRlciB0aGlzIHZhbHVlIHVubGVzcyB5b3Uga25vdyB3aGF0XHJcbi8vICAgeW91J3JlIGRvaW5nLlxyXG5mdW5jdGlvbiBidWlsZENhbnZhcyhkYXRhLCBvcHRpb25zKSB7XHJcblxyXG5cdHZhciBjYW52YXMgPSBbXTtcclxuXHR2YXIgYmFja2dyb3VuZCA9IG9wdGlvbnMuYmFja2dyb3VuZCB8fCAnI2ZmZic7XHJcblx0dmFyIGZvcmVncm91bmQgPSBvcHRpb25zLmZvcmVncm91bmQgfHwgJyMwMDAnO1xyXG5cdHZhciBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nIHx8IDA7XHJcblx0Ly92YXIgbWFyZ2luID0gb3B0aW9ucy5tYXJnaW4gfHwgNDtcclxuXHR2YXIgbWF0cml4ID0gZ2VuZXJhdGVGcmFtZShkYXRhLCBvcHRpb25zKTtcclxuXHR2YXIgbiA9IG1hdHJpeC5sZW5ndGg7XHJcblx0dmFyIG1vZFNpemUgPSBNYXRoLmZsb29yKG9wdGlvbnMuZml0ID8gb3B0aW9ucy5maXQgLyBuIDogNSk7XHJcblx0dmFyIHNpemUgPSAobiAqIG1vZFNpemUpICsgKG1vZFNpemUgKiBwYWRkaW5nICogMik7XHJcblx0dmFyIHBhZGRpbmdYWSA9IG1vZFNpemUgKiBwYWRkaW5nO1xyXG5cclxuXHRjYW52YXMucHVzaCh7XHJcblx0XHR0eXBlOiAncmVjdCcsXHJcblx0XHR4OiAwLCB5OiAwLCB3OiBzaXplLCBoOiBzaXplLCBsaW5lV2lkdGg6IDAsIGNvbG9yOiBiYWNrZ3JvdW5kXHJcblx0fSk7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IG47ICsraikge1xyXG5cdFx0XHRpZiAobWF0cml4W2ldW2pdKSB7XHJcblx0XHRcdFx0Y2FudmFzLnB1c2goe1xyXG5cdFx0XHRcdFx0dHlwZTogJ3JlY3QnLFxyXG5cdFx0XHRcdFx0eDogbW9kU2l6ZSAqIGogKyBwYWRkaW5nWFksXHJcblx0XHRcdFx0XHR5OiBtb2RTaXplICogaSArIHBhZGRpbmdYWSxcclxuXHRcdFx0XHRcdHc6IG1vZFNpemUsXHJcblx0XHRcdFx0XHRoOiBtb2RTaXplLFxyXG5cdFx0XHRcdFx0bGluZVdpZHRoOiAwLFxyXG5cdFx0XHRcdFx0Y29sb3I6IGZvcmVncm91bmRcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGNhbnZhczogY2FudmFzLFxyXG5cdFx0c2l6ZTogc2l6ZVxyXG5cdH07XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBtZWFzdXJlKG5vZGUpIHtcclxuXHR2YXIgY2QgPSBidWlsZENhbnZhcyhub2RlLnFyLCBub2RlKTtcclxuXHRub2RlLl9jYW52YXMgPSBjZC5jYW52YXM7XHJcblx0bm9kZS5fd2lkdGggPSBub2RlLl9oZWlnaHQgPSBub2RlLl9taW5XaWR0aCA9IG5vZGUuX21heFdpZHRoID0gbm9kZS5fbWluSGVpZ2h0ID0gbm9kZS5fbWF4SGVpZ2h0ID0gY2Quc2l6ZTtcclxuXHRyZXR1cm4gbm9kZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0bWVhc3VyZTogbWVhc3VyZVxyXG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/qrEnc.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/standardPageSizes.js":
/*!*******************************************************!*\
  !*** ./node_modules/pdfmake/src/standardPageSizes.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\nmodule.exports = {\r\n\t'4A0': [4767.87, 6740.79],\r\n\t'2A0': [3370.39, 4767.87],\r\n\tA0: [2383.94, 3370.39],\r\n\tA1: [1683.78, 2383.94],\r\n\tA2: [1190.55, 1683.78],\r\n\tA3: [841.89, 1190.55],\r\n\tA4: [595.28, 841.89],\r\n\tA5: [419.53, 595.28],\r\n\tA6: [297.64, 419.53],\r\n\tA7: [209.76, 297.64],\r\n\tA8: [147.40, 209.76],\r\n\tA9: [104.88, 147.40],\r\n\tA10: [73.70, 104.88],\r\n\tB0: [2834.65, 4008.19],\r\n\tB1: [2004.09, 2834.65],\r\n\tB2: [1417.32, 2004.09],\r\n\tB3: [1000.63, 1417.32],\r\n\tB4: [708.66, 1000.63],\r\n\tB5: [498.90, 708.66],\r\n\tB6: [354.33, 498.90],\r\n\tB7: [249.45, 354.33],\r\n\tB8: [175.75, 249.45],\r\n\tB9: [124.72, 175.75],\r\n\tB10: [87.87, 124.72],\r\n\tC0: [2599.37, 3676.54],\r\n\tC1: [1836.85, 2599.37],\r\n\tC2: [1298.27, 1836.85],\r\n\tC3: [918.43, 1298.27],\r\n\tC4: [649.13, 918.43],\r\n\tC5: [459.21, 649.13],\r\n\tC6: [323.15, 459.21],\r\n\tC7: [229.61, 323.15],\r\n\tC8: [161.57, 229.61],\r\n\tC9: [113.39, 161.57],\r\n\tC10: [79.37, 113.39],\r\n\tRA0: [2437.80, 3458.27],\r\n\tRA1: [1729.13, 2437.80],\r\n\tRA2: [1218.90, 1729.13],\r\n\tRA3: [864.57, 1218.90],\r\n\tRA4: [609.45, 864.57],\r\n\tSRA0: [2551.18, 3628.35],\r\n\tSRA1: [1814.17, 2551.18],\r\n\tSRA2: [1275.59, 1814.17],\r\n\tSRA3: [907.09, 1275.59],\r\n\tSRA4: [637.80, 907.09],\r\n\tEXECUTIVE: [521.86, 756.00],\r\n\tFOLIO: [612.00, 936.00],\r\n\tLEGAL: [612.00, 1008.00],\r\n\tLETTER: [612.00, 792.00],\r\n\tTABLOID: [792.00, 1224.00]\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvc3RhbmRhcmRQYWdlU2l6ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9nYXNjYXQvcHJpc21hcXVhbnQvcHJpc21hLXF1YW50dW0vbm9kZV9tb2R1bGVzL3BkZm1ha2Uvc3JjL3N0YW5kYXJkUGFnZVNpemVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCc0QTAnOiBbNDc2Ny44NywgNjc0MC43OV0sXHJcblx0JzJBMCc6IFszMzcwLjM5LCA0NzY3Ljg3XSxcclxuXHRBMDogWzIzODMuOTQsIDMzNzAuMzldLFxyXG5cdEExOiBbMTY4My43OCwgMjM4My45NF0sXHJcblx0QTI6IFsxMTkwLjU1LCAxNjgzLjc4XSxcclxuXHRBMzogWzg0MS44OSwgMTE5MC41NV0sXHJcblx0QTQ6IFs1OTUuMjgsIDg0MS44OV0sXHJcblx0QTU6IFs0MTkuNTMsIDU5NS4yOF0sXHJcblx0QTY6IFsyOTcuNjQsIDQxOS41M10sXHJcblx0QTc6IFsyMDkuNzYsIDI5Ny42NF0sXHJcblx0QTg6IFsxNDcuNDAsIDIwOS43Nl0sXHJcblx0QTk6IFsxMDQuODgsIDE0Ny40MF0sXHJcblx0QTEwOiBbNzMuNzAsIDEwNC44OF0sXHJcblx0QjA6IFsyODM0LjY1LCA0MDA4LjE5XSxcclxuXHRCMTogWzIwMDQuMDksIDI4MzQuNjVdLFxyXG5cdEIyOiBbMTQxNy4zMiwgMjAwNC4wOV0sXHJcblx0QjM6IFsxMDAwLjYzLCAxNDE3LjMyXSxcclxuXHRCNDogWzcwOC42NiwgMTAwMC42M10sXHJcblx0QjU6IFs0OTguOTAsIDcwOC42Nl0sXHJcblx0QjY6IFszNTQuMzMsIDQ5OC45MF0sXHJcblx0Qjc6IFsyNDkuNDUsIDM1NC4zM10sXHJcblx0Qjg6IFsxNzUuNzUsIDI0OS40NV0sXHJcblx0Qjk6IFsxMjQuNzIsIDE3NS43NV0sXHJcblx0QjEwOiBbODcuODcsIDEyNC43Ml0sXHJcblx0QzA6IFsyNTk5LjM3LCAzNjc2LjU0XSxcclxuXHRDMTogWzE4MzYuODUsIDI1OTkuMzddLFxyXG5cdEMyOiBbMTI5OC4yNywgMTgzNi44NV0sXHJcblx0QzM6IFs5MTguNDMsIDEyOTguMjddLFxyXG5cdEM0OiBbNjQ5LjEzLCA5MTguNDNdLFxyXG5cdEM1OiBbNDU5LjIxLCA2NDkuMTNdLFxyXG5cdEM2OiBbMzIzLjE1LCA0NTkuMjFdLFxyXG5cdEM3OiBbMjI5LjYxLCAzMjMuMTVdLFxyXG5cdEM4OiBbMTYxLjU3LCAyMjkuNjFdLFxyXG5cdEM5OiBbMTEzLjM5LCAxNjEuNTddLFxyXG5cdEMxMDogWzc5LjM3LCAxMTMuMzldLFxyXG5cdFJBMDogWzI0MzcuODAsIDM0NTguMjddLFxyXG5cdFJBMTogWzE3MjkuMTMsIDI0MzcuODBdLFxyXG5cdFJBMjogWzEyMTguOTAsIDE3MjkuMTNdLFxyXG5cdFJBMzogWzg2NC41NywgMTIxOC45MF0sXHJcblx0UkE0OiBbNjA5LjQ1LCA4NjQuNTddLFxyXG5cdFNSQTA6IFsyNTUxLjE4LCAzNjI4LjM1XSxcclxuXHRTUkExOiBbMTgxNC4xNywgMjU1MS4xOF0sXHJcblx0U1JBMjogWzEyNzUuNTksIDE4MTQuMTddLFxyXG5cdFNSQTM6IFs5MDcuMDksIDEyNzUuNTldLFxyXG5cdFNSQTQ6IFs2MzcuODAsIDkwNy4wOV0sXHJcblx0RVhFQ1VUSVZFOiBbNTIxLjg2LCA3NTYuMDBdLFxyXG5cdEZPTElPOiBbNjEyLjAwLCA5MzYuMDBdLFxyXG5cdExFR0FMOiBbNjEyLjAwLCAxMDA4LjAwXSxcclxuXHRMRVRURVI6IFs2MTIuMDAsIDc5Mi4wMF0sXHJcblx0VEFCTE9JRDogWzc5Mi4wMCwgMTIyNC4wMF1cclxufTtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/standardPageSizes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/styleContextStack.js":
/*!*******************************************************!*\
  !*** ./node_modules/pdfmake/src/styleContextStack.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar isString = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isString);\r\nvar isArray = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isArray);\r\nvar isUndefined = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isUndefined);\r\nvar isNull = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isNull);\r\n\r\n/**\r\n * Creates an instance of StyleContextStack used for style inheritance and style overrides\r\n *\r\n * @constructor\r\n * @this {StyleContextStack}\r\n * @param {Object} named styles dictionary\r\n * @param {Object} optional default style definition\r\n */\r\nfunction StyleContextStack(styleDictionary, defaultStyle) {\r\n\tthis.defaultStyle = defaultStyle || {};\r\n\tthis.styleDictionary = styleDictionary;\r\n\tthis.styleOverrides = [];\r\n}\r\n\r\n/**\r\n * Creates cloned version of current stack\r\n * @return {StyleContextStack} current stack snapshot\r\n */\r\nStyleContextStack.prototype.clone = function () {\r\n\tvar stack = new StyleContextStack(this.styleDictionary, this.defaultStyle);\r\n\r\n\tthis.styleOverrides.forEach(function (item) {\r\n\t\tstack.styleOverrides.push(item);\r\n\t});\r\n\r\n\treturn stack;\r\n};\r\n\r\n/**\r\n * Pushes style-name or style-overrides-object onto the stack for future evaluation\r\n *\r\n * @param {String|Object} styleNameOrOverride style-name (referring to styleDictionary) or\r\n *                                            a new dictionary defining overriding properties\r\n */\r\nStyleContextStack.prototype.push = function (styleNameOrOverride) {\r\n\tthis.styleOverrides.push(styleNameOrOverride);\r\n};\r\n\r\n/**\r\n * Removes last style-name or style-overrides-object from the stack\r\n *\r\n * @param {Number} howMany - optional number of elements to be popped (if not specified,\r\n *                           one element will be removed from the stack)\r\n */\r\nStyleContextStack.prototype.pop = function (howMany) {\r\n\thowMany = howMany || 1;\r\n\r\n\twhile (howMany-- > 0) {\r\n\t\tthis.styleOverrides.pop();\r\n\t}\r\n};\r\n\r\n/**\r\n * Creates a set of named styles or/and a style-overrides-object based on the item,\r\n * pushes those elements onto the stack for future evaluation and returns the number\r\n * of elements pushed, so they can be easily poped then.\r\n *\r\n * @param {Object} item - an object with optional style property and/or style overrides\r\n * @return the number of items pushed onto the stack\r\n */\r\nStyleContextStack.prototype.autopush = function (item) {\r\n\tif (isString(item)) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tvar styleNames = [];\r\n\r\n\tif (item.style) {\r\n\t\tif (isArray(item.style)) {\r\n\t\t\tstyleNames = item.style;\r\n\t\t} else {\r\n\t\t\tstyleNames = [item.style];\r\n\t\t}\r\n\t}\r\n\r\n\tfor (var i = 0, l = styleNames.length; i < l; i++) {\r\n\t\tthis.push(styleNames[i]);\r\n\t}\r\n\r\n\t// rather than spend significant time making a styleOverrideObject, just add item\r\n\tthis.push(item);\r\n\treturn styleNames.length + 1;\r\n};\r\n\r\n/**\r\n * Automatically pushes elements onto the stack, using autopush based on item,\r\n * executes callback and then pops elements back. Returns value returned by callback\r\n *\r\n * @param  {Object}   item - an object with optional style property and/or style overrides\r\n * @param  {Function} function to be called between autopush and pop\r\n * @return {Object} value returned by callback\r\n */\r\nStyleContextStack.prototype.auto = function (item, callback) {\r\n\tvar pushedItems = this.autopush(item);\r\n\tvar result = callback();\r\n\r\n\tif (pushedItems > 0) {\r\n\t\tthis.pop(pushedItems);\r\n\t}\r\n\r\n\treturn result;\r\n};\r\n\r\n/**\r\n * Evaluates stack and returns value of a named property\r\n *\r\n * @param {String} property - property name\r\n * @return property value or null if not found\r\n */\r\nStyleContextStack.prototype.getProperty = function (property) {\r\n\tif (this.styleOverrides) {\r\n\t\tfor (var i = this.styleOverrides.length - 1; i >= 0; i--) {\r\n\t\t\tvar item = this.styleOverrides[i];\r\n\r\n\t\t\tif (isString(item)) {\r\n\t\t\t\t// named-style-override\r\n\t\t\t\tvar style = this.styleDictionary[item];\r\n\t\t\t\tif (style && !isUndefined(style[property]) && !isNull(style[property])) {\r\n\t\t\t\t\treturn style[property];\r\n\t\t\t\t}\r\n\t\t\t} else if (!isUndefined(item[property]) && !isNull(item[property])) {\r\n\t\t\t\t// style-overrides-object\r\n\t\t\t\treturn item[property];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn this.defaultStyle && this.defaultStyle[property];\r\n};\r\n\r\nmodule.exports = StyleContextStack;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvc3R5bGVDb250ZXh0U3RhY2suanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLGVBQWUsOEZBQTZCO0FBQzVDLGNBQWMsNkZBQTRCO0FBQzFDLGtCQUFrQixpR0FBZ0M7QUFDbEQsYUFBYSw0RkFBMkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2dhc2NhdC9wcmlzbWFxdWFudC9wcmlzbWEtcXVhbnR1bS9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvc3R5bGVDb250ZXh0U3RhY2suanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuaXNTdHJpbmc7XHJcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuaXNBcnJheTtcclxudmFyIGlzVW5kZWZpbmVkID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuaXNVbmRlZmluZWQ7XHJcbnZhciBpc051bGwgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc051bGw7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBTdHlsZUNvbnRleHRTdGFjayB1c2VkIGZvciBzdHlsZSBpbmhlcml0YW5jZSBhbmQgc3R5bGUgb3ZlcnJpZGVzXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAdGhpcyB7U3R5bGVDb250ZXh0U3RhY2t9XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBuYW1lZCBzdHlsZXMgZGljdGlvbmFyeVxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uYWwgZGVmYXVsdCBzdHlsZSBkZWZpbml0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBTdHlsZUNvbnRleHRTdGFjayhzdHlsZURpY3Rpb25hcnksIGRlZmF1bHRTdHlsZSkge1xyXG5cdHRoaXMuZGVmYXVsdFN0eWxlID0gZGVmYXVsdFN0eWxlIHx8IHt9O1xyXG5cdHRoaXMuc3R5bGVEaWN0aW9uYXJ5ID0gc3R5bGVEaWN0aW9uYXJ5O1xyXG5cdHRoaXMuc3R5bGVPdmVycmlkZXMgPSBbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgY2xvbmVkIHZlcnNpb24gb2YgY3VycmVudCBzdGFja1xyXG4gKiBAcmV0dXJuIHtTdHlsZUNvbnRleHRTdGFja30gY3VycmVudCBzdGFjayBzbmFwc2hvdFxyXG4gKi9cclxuU3R5bGVDb250ZXh0U3RhY2sucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cdHZhciBzdGFjayA9IG5ldyBTdHlsZUNvbnRleHRTdGFjayh0aGlzLnN0eWxlRGljdGlvbmFyeSwgdGhpcy5kZWZhdWx0U3R5bGUpO1xyXG5cclxuXHR0aGlzLnN0eWxlT3ZlcnJpZGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuXHRcdHN0YWNrLnN0eWxlT3ZlcnJpZGVzLnB1c2goaXRlbSk7XHJcblx0fSk7XHJcblxyXG5cdHJldHVybiBzdGFjaztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQdXNoZXMgc3R5bGUtbmFtZSBvciBzdHlsZS1vdmVycmlkZXMtb2JqZWN0IG9udG8gdGhlIHN0YWNrIGZvciBmdXR1cmUgZXZhbHVhdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHN0eWxlTmFtZU9yT3ZlcnJpZGUgc3R5bGUtbmFtZSAocmVmZXJyaW5nIHRvIHN0eWxlRGljdGlvbmFyeSkgb3JcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgbmV3IGRpY3Rpb25hcnkgZGVmaW5pbmcgb3ZlcnJpZGluZyBwcm9wZXJ0aWVzXHJcbiAqL1xyXG5TdHlsZUNvbnRleHRTdGFjay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChzdHlsZU5hbWVPck92ZXJyaWRlKSB7XHJcblx0dGhpcy5zdHlsZU92ZXJyaWRlcy5wdXNoKHN0eWxlTmFtZU9yT3ZlcnJpZGUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgbGFzdCBzdHlsZS1uYW1lIG9yIHN0eWxlLW92ZXJyaWRlcy1vYmplY3QgZnJvbSB0aGUgc3RhY2tcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGhvd01hbnkgLSBvcHRpb25hbCBudW1iZXIgb2YgZWxlbWVudHMgdG8gYmUgcG9wcGVkIChpZiBub3Qgc3BlY2lmaWVkLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZSBlbGVtZW50IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBzdGFjaylcclxuICovXHJcblN0eWxlQ29udGV4dFN0YWNrLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoaG93TWFueSkge1xyXG5cdGhvd01hbnkgPSBob3dNYW55IHx8IDE7XHJcblxyXG5cdHdoaWxlIChob3dNYW55LS0gPiAwKSB7XHJcblx0XHR0aGlzLnN0eWxlT3ZlcnJpZGVzLnBvcCgpO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2V0IG9mIG5hbWVkIHN0eWxlcyBvci9hbmQgYSBzdHlsZS1vdmVycmlkZXMtb2JqZWN0IGJhc2VkIG9uIHRoZSBpdGVtLFxyXG4gKiBwdXNoZXMgdGhvc2UgZWxlbWVudHMgb250byB0aGUgc3RhY2sgZm9yIGZ1dHVyZSBldmFsdWF0aW9uIGFuZCByZXR1cm5zIHRoZSBudW1iZXJcclxuICogb2YgZWxlbWVudHMgcHVzaGVkLCBzbyB0aGV5IGNhbiBiZSBlYXNpbHkgcG9wZWQgdGhlbi5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gLSBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdHlsZSBwcm9wZXJ0eSBhbmQvb3Igc3R5bGUgb3ZlcnJpZGVzXHJcbiAqIEByZXR1cm4gdGhlIG51bWJlciBvZiBpdGVtcyBwdXNoZWQgb250byB0aGUgc3RhY2tcclxuICovXHJcblN0eWxlQ29udGV4dFN0YWNrLnByb3RvdHlwZS5hdXRvcHVzaCA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcblx0aWYgKGlzU3RyaW5nKGl0ZW0pKSB7XHJcblx0XHRyZXR1cm4gMDtcclxuXHR9XHJcblxyXG5cdHZhciBzdHlsZU5hbWVzID0gW107XHJcblxyXG5cdGlmIChpdGVtLnN0eWxlKSB7XHJcblx0XHRpZiAoaXNBcnJheShpdGVtLnN0eWxlKSkge1xyXG5cdFx0XHRzdHlsZU5hbWVzID0gaXRlbS5zdHlsZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN0eWxlTmFtZXMgPSBbaXRlbS5zdHlsZV07XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbCA9IHN0eWxlTmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHR0aGlzLnB1c2goc3R5bGVOYW1lc1tpXSk7XHJcblx0fVxyXG5cclxuXHQvLyByYXRoZXIgdGhhbiBzcGVuZCBzaWduaWZpY2FudCB0aW1lIG1ha2luZyBhIHN0eWxlT3ZlcnJpZGVPYmplY3QsIGp1c3QgYWRkIGl0ZW1cclxuXHR0aGlzLnB1c2goaXRlbSk7XHJcblx0cmV0dXJuIHN0eWxlTmFtZXMubGVuZ3RoICsgMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBdXRvbWF0aWNhbGx5IHB1c2hlcyBlbGVtZW50cyBvbnRvIHRoZSBzdGFjaywgdXNpbmcgYXV0b3B1c2ggYmFzZWQgb24gaXRlbSxcclxuICogZXhlY3V0ZXMgY2FsbGJhY2sgYW5kIHRoZW4gcG9wcyBlbGVtZW50cyBiYWNrLiBSZXR1cm5zIHZhbHVlIHJldHVybmVkIGJ5IGNhbGxiYWNrXHJcbiAqXHJcbiAqIEBwYXJhbSAge09iamVjdH0gICBpdGVtIC0gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3R5bGUgcHJvcGVydHkgYW5kL29yIHN0eWxlIG92ZXJyaWRlc1xyXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGJldHdlZW4gYXV0b3B1c2ggYW5kIHBvcFxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHZhbHVlIHJldHVybmVkIGJ5IGNhbGxiYWNrXHJcbiAqL1xyXG5TdHlsZUNvbnRleHRTdGFjay5wcm90b3R5cGUuYXV0byA9IGZ1bmN0aW9uIChpdGVtLCBjYWxsYmFjaykge1xyXG5cdHZhciBwdXNoZWRJdGVtcyA9IHRoaXMuYXV0b3B1c2goaXRlbSk7XHJcblx0dmFyIHJlc3VsdCA9IGNhbGxiYWNrKCk7XHJcblxyXG5cdGlmIChwdXNoZWRJdGVtcyA+IDApIHtcclxuXHRcdHRoaXMucG9wKHB1c2hlZEl0ZW1zKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG4vKipcclxuICogRXZhbHVhdGVzIHN0YWNrIGFuZCByZXR1cm5zIHZhbHVlIG9mIGEgbmFtZWQgcHJvcGVydHlcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gcHJvcGVydHkgbmFtZVxyXG4gKiBAcmV0dXJuIHByb3BlcnR5IHZhbHVlIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAqL1xyXG5TdHlsZUNvbnRleHRTdGFjay5wcm90b3R5cGUuZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcclxuXHRpZiAodGhpcy5zdHlsZU92ZXJyaWRlcykge1xyXG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMuc3R5bGVPdmVycmlkZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzLnN0eWxlT3ZlcnJpZGVzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGlzU3RyaW5nKGl0ZW0pKSB7XHJcblx0XHRcdFx0Ly8gbmFtZWQtc3R5bGUtb3ZlcnJpZGVcclxuXHRcdFx0XHR2YXIgc3R5bGUgPSB0aGlzLnN0eWxlRGljdGlvbmFyeVtpdGVtXTtcclxuXHRcdFx0XHRpZiAoc3R5bGUgJiYgIWlzVW5kZWZpbmVkKHN0eWxlW3Byb3BlcnR5XSkgJiYgIWlzTnVsbChzdHlsZVtwcm9wZXJ0eV0pKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gc3R5bGVbcHJvcGVydHldO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmICghaXNVbmRlZmluZWQoaXRlbVtwcm9wZXJ0eV0pICYmICFpc051bGwoaXRlbVtwcm9wZXJ0eV0pKSB7XHJcblx0XHRcdFx0Ly8gc3R5bGUtb3ZlcnJpZGVzLW9iamVjdFxyXG5cdFx0XHRcdHJldHVybiBpdGVtW3Byb3BlcnR5XTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXMuZGVmYXVsdFN0eWxlICYmIHRoaXMuZGVmYXVsdFN0eWxlW3Byb3BlcnR5XTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3R5bGVDb250ZXh0U3RhY2s7XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/styleContextStack.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/svgMeasure.js":
/*!************************************************!*\
  !*** ./node_modules/pdfmake/src/svgMeasure.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar xmldoc = __webpack_require__(/*! xmldoc */ \"(rsc)/./node_modules/xmldoc/lib/xmldoc.js\");\r\n\r\n/** Strip unit postfix, parse number, but return undefined instead of NaN for bad input */\r\nfunction stripUnits(textVal) {\r\n\tvar n = parseFloat(textVal);\r\n\tif (typeof n !== 'number' || isNaN(n)) {\r\n\t\treturn undefined;\r\n\t}\r\n\treturn n;\r\n}\r\n\r\n/** Make sure it's valid XML and the root tage is <svg/>, returns xmldoc DOM */\r\nfunction parseSVG(svgString) {\r\n\tvar doc;\r\n\r\n\ttry {\r\n\t\tdoc = new xmldoc.XmlDocument(svgString);\r\n\t} catch (err) {\r\n\t\tthrow new Error('SVGMeasure: ' + err);\r\n\t}\r\n\r\n\tif (doc.name !== \"svg\") {\r\n\t\tthrow new Error('SVGMeasure: expected <svg> document');\r\n\t}\r\n\r\n\treturn doc;\r\n}\r\n\r\nfunction SVGMeasure() {\r\n}\r\n\r\nSVGMeasure.prototype.measureSVG = function (svgString) {\r\n\r\n\tvar doc = parseSVG(svgString);\r\n\r\n\tvar docWidth = stripUnits(doc.attr.width);\r\n\tvar docHeight = stripUnits(doc.attr.height);\r\n\r\n\tif ((docWidth == undefined || docHeight == undefined) && typeof doc.attr.viewBox == 'string') {\r\n\t\tvar viewBoxParts = doc.attr.viewBox.split(/[,\\s]+/);\r\n\t\tif (viewBoxParts.length !== 4) {\r\n\t\t\tthrow new Error(\"Unexpected svg viewbox format, should have 4 entries but found: '\" + doc.attr.viewBox + \"'\");\r\n\t\t}\r\n\t\tif (docWidth == undefined) {\r\n\t\t\tdocWidth = stripUnits(viewBoxParts[2]);\r\n\t\t}\r\n\t\tif (docHeight == undefined) {\r\n\t\t\tdocHeight = stripUnits(viewBoxParts[3]);\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\twidth: docWidth,\r\n\t\theight: docHeight\r\n\t};\r\n};\r\n\r\nSVGMeasure.prototype.writeDimensions = function (svgString, dimensions) {\r\n\r\n\tvar doc = parseSVG(svgString);\r\n\r\n\tdoc.attr.width = \"\" + dimensions.width;\r\n\tdoc.attr.height = \"\" + dimensions.height;\r\n\r\n\treturn doc.toString();\r\n};\r\n\r\nmodule.exports = SVGMeasure;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvc3ZnTWVhc3VyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLHlEQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2dhc2NhdC9wcmlzbWFxdWFudC9wcmlzbWEtcXVhbnR1bS9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvc3ZnTWVhc3VyZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG52YXIgeG1sZG9jID0gcmVxdWlyZSgneG1sZG9jJyk7XHJcblxyXG4vKiogU3RyaXAgdW5pdCBwb3N0Zml4LCBwYXJzZSBudW1iZXIsIGJ1dCByZXR1cm4gdW5kZWZpbmVkIGluc3RlYWQgb2YgTmFOIGZvciBiYWQgaW5wdXQgKi9cclxuZnVuY3Rpb24gc3RyaXBVbml0cyh0ZXh0VmFsKSB7XHJcblx0dmFyIG4gPSBwYXJzZUZsb2F0KHRleHRWYWwpO1xyXG5cdGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgaXNOYU4obikpIHtcclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG5cdHJldHVybiBuO1xyXG59XHJcblxyXG4vKiogTWFrZSBzdXJlIGl0J3MgdmFsaWQgWE1MIGFuZCB0aGUgcm9vdCB0YWdlIGlzIDxzdmcvPiwgcmV0dXJucyB4bWxkb2MgRE9NICovXHJcbmZ1bmN0aW9uIHBhcnNlU1ZHKHN2Z1N0cmluZykge1xyXG5cdHZhciBkb2M7XHJcblxyXG5cdHRyeSB7XHJcblx0XHRkb2MgPSBuZXcgeG1sZG9jLlhtbERvY3VtZW50KHN2Z1N0cmluZyk7XHJcblx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NWR01lYXN1cmU6ICcgKyBlcnIpO1xyXG5cdH1cclxuXHJcblx0aWYgKGRvYy5uYW1lICE9PSBcInN2Z1wiKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NWR01lYXN1cmU6IGV4cGVjdGVkIDxzdmc+IGRvY3VtZW50Jyk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZG9jO1xyXG59XHJcblxyXG5mdW5jdGlvbiBTVkdNZWFzdXJlKCkge1xyXG59XHJcblxyXG5TVkdNZWFzdXJlLnByb3RvdHlwZS5tZWFzdXJlU1ZHID0gZnVuY3Rpb24gKHN2Z1N0cmluZykge1xyXG5cclxuXHR2YXIgZG9jID0gcGFyc2VTVkcoc3ZnU3RyaW5nKTtcclxuXHJcblx0dmFyIGRvY1dpZHRoID0gc3RyaXBVbml0cyhkb2MuYXR0ci53aWR0aCk7XHJcblx0dmFyIGRvY0hlaWdodCA9IHN0cmlwVW5pdHMoZG9jLmF0dHIuaGVpZ2h0KTtcclxuXHJcblx0aWYgKChkb2NXaWR0aCA9PSB1bmRlZmluZWQgfHwgZG9jSGVpZ2h0ID09IHVuZGVmaW5lZCkgJiYgdHlwZW9mIGRvYy5hdHRyLnZpZXdCb3ggPT0gJ3N0cmluZycpIHtcclxuXHRcdHZhciB2aWV3Qm94UGFydHMgPSBkb2MuYXR0ci52aWV3Qm94LnNwbGl0KC9bLFxcc10rLyk7XHJcblx0XHRpZiAodmlld0JveFBhcnRzLmxlbmd0aCAhPT0gNCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHN2ZyB2aWV3Ym94IGZvcm1hdCwgc2hvdWxkIGhhdmUgNCBlbnRyaWVzIGJ1dCBmb3VuZDogJ1wiICsgZG9jLmF0dHIudmlld0JveCArIFwiJ1wiKTtcclxuXHRcdH1cclxuXHRcdGlmIChkb2NXaWR0aCA9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0ZG9jV2lkdGggPSBzdHJpcFVuaXRzKHZpZXdCb3hQYXJ0c1syXSk7XHJcblx0XHR9XHJcblx0XHRpZiAoZG9jSGVpZ2h0ID09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRkb2NIZWlnaHQgPSBzdHJpcFVuaXRzKHZpZXdCb3hQYXJ0c1szXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0d2lkdGg6IGRvY1dpZHRoLFxyXG5cdFx0aGVpZ2h0OiBkb2NIZWlnaHRcclxuXHR9O1xyXG59O1xyXG5cclxuU1ZHTWVhc3VyZS5wcm90b3R5cGUud3JpdGVEaW1lbnNpb25zID0gZnVuY3Rpb24gKHN2Z1N0cmluZywgZGltZW5zaW9ucykge1xyXG5cclxuXHR2YXIgZG9jID0gcGFyc2VTVkcoc3ZnU3RyaW5nKTtcclxuXHJcblx0ZG9jLmF0dHIud2lkdGggPSBcIlwiICsgZGltZW5zaW9ucy53aWR0aDtcclxuXHRkb2MuYXR0ci5oZWlnaHQgPSBcIlwiICsgZGltZW5zaW9ucy5oZWlnaHQ7XHJcblxyXG5cdHJldHVybiBkb2MudG9TdHJpbmcoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU1ZHTWVhc3VyZTtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/svgMeasure.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/tableProcessor.js":
/*!****************************************************!*\
  !*** ./node_modules/pdfmake/src/tableProcessor.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar ColumnCalculator = __webpack_require__(/*! ./columnCalculator */ \"(rsc)/./node_modules/pdfmake/src/columnCalculator.js\");\r\nvar isFunction = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isFunction);\r\nvar isNumber = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isNumber);\r\nvar isPositiveInteger = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isPositiveInteger);\r\n\r\nfunction TableProcessor(tableNode) {\r\n\tthis.tableNode = tableNode;\r\n}\r\n\r\nTableProcessor.prototype.beginTable = function (writer) {\r\n\tvar tableNode;\r\n\tvar availableWidth;\r\n\tvar self = this;\r\n\r\n\ttableNode = this.tableNode;\r\n\tthis.offsets = tableNode._offsets;\r\n\tthis.layout = tableNode._layout;\r\n\r\n\tavailableWidth = writer.context().availableWidth - this.offsets.total;\r\n\tColumnCalculator.buildColumnWidths(tableNode.table.widths, availableWidth, this.offsets.total, tableNode);\r\n\r\n\tthis.tableWidth = tableNode._offsets.total + getTableInnerContentWidth();\r\n\tthis.rowSpanData = prepareRowSpanData();\r\n\tthis.cleanUpRepeatables = false;\r\n\r\n\t// headersRows and rowsWithoutPageBreak (headerRows + keepWithHeaderRows)\r\n\tthis.headerRows = 0;\r\n\tthis.rowsWithoutPageBreak = 0;\r\n\r\n\tvar headerRows = tableNode.table.headerRows;\r\n\r\n\tif (isPositiveInteger(headerRows)) {\r\n\t\tthis.headerRows = headerRows;\r\n\r\n\t\tif (this.headerRows > tableNode.table.body.length) {\r\n\t\t\tthrow new Error(`Too few rows in the table. Property headerRows requires at least ${this.headerRows}, contains only ${tableNode.table.body.length}`);\r\n\t\t}\r\n\r\n\t\tthis.rowsWithoutPageBreak = this.headerRows;\r\n\r\n\t\tconst keepWithHeaderRows = tableNode.table.keepWithHeaderRows;\r\n\r\n\t\tif (isPositiveInteger(keepWithHeaderRows)) {\r\n\t\t\tthis.rowsWithoutPageBreak += keepWithHeaderRows;\r\n\t\t}\r\n\t}\r\n\r\n\tthis.dontBreakRows = tableNode.table.dontBreakRows || false;\r\n\r\n\tif (this.rowsWithoutPageBreak || this.dontBreakRows) {\r\n\t\twriter.beginUnbreakableBlock();\r\n\t\t// Draw the top border of the table\r\n\t\tthis.drawHorizontalLine(0, writer);\r\n\t\tif (this.rowsWithoutPageBreak && this.dontBreakRows) {\r\n\t\t\t// We just increase the value of transactionLevel\r\n\t\t\twriter.beginUnbreakableBlock();\r\n\t\t}\r\n\t}\r\n\r\n\t// update the border properties of all cells before drawing any lines\r\n\tprepareCellBorders(this.tableNode.table.body);\r\n\r\n\tfunction getTableInnerContentWidth() {\r\n\t\tvar width = 0;\r\n\r\n\t\ttableNode.table.widths.forEach(function (w) {\r\n\t\t\twidth += w._calcWidth;\r\n\t\t});\r\n\r\n\t\treturn width;\r\n\t}\r\n\r\n\tfunction prepareRowSpanData() {\r\n\t\tvar rsd = [];\r\n\t\tvar x = 0;\r\n\t\tvar lastWidth = 0;\r\n\r\n\t\trsd.push({ left: 0, rowSpan: 0 });\r\n\r\n\t\tfor (var i = 0, l = self.tableNode.table.body[0].length; i < l; i++) {\r\n\t\t\tvar paddings = self.layout.paddingLeft(i, self.tableNode) + self.layout.paddingRight(i, self.tableNode);\r\n\t\t\tvar lBorder = self.layout.vLineWidth(i, self.tableNode);\r\n\t\t\tlastWidth = paddings + lBorder + self.tableNode.table.widths[i]._calcWidth;\r\n\t\t\trsd[rsd.length - 1].width = lastWidth;\r\n\t\t\tx += lastWidth;\r\n\t\t\trsd.push({ left: x, rowSpan: 0, width: 0 });\r\n\t\t}\r\n\r\n\t\treturn rsd;\r\n\t}\r\n\r\n\t// Iterate through all cells. If the current cell is the start of a\r\n\t// rowSpan/colSpan, update the border property of the cells on its\r\n\t// bottom/right accordingly. This is needed since each iteration of the\r\n\t// line-drawing loops draws lines for a single cell, not for an entire\r\n\t// rowSpan/colSpan.\r\n\tfunction prepareCellBorders(body) {\r\n\t\tfor (var rowIndex = 0; rowIndex < body.length; rowIndex++) {\r\n\t\t\tvar row = body[rowIndex];\r\n\r\n\t\t\tfor (var colIndex = 0; colIndex < row.length; colIndex++) {\r\n\t\t\t\tvar cell = row[colIndex];\r\n\r\n\t\t\t\tif (cell.border) {\r\n\t\t\t\t\tvar rowSpan = cell.rowSpan || 1;\r\n\t\t\t\t\tvar colSpan = cell.colSpan || 1;\r\n\r\n\t\t\t\t\tfor (var rowOffset = 0; rowOffset < rowSpan; rowOffset++) {\r\n\t\t\t\t\t\t// set left border\r\n\t\t\t\t\t\tif (cell.border[0] !== undefined && rowOffset > 0) {\r\n\t\t\t\t\t\t\tsetBorder(rowIndex + rowOffset, colIndex, 0, cell.border[0]);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// set right border\r\n\t\t\t\t\t\tif (cell.border[2] !== undefined) {\r\n\t\t\t\t\t\t\tsetBorder(rowIndex + rowOffset, colIndex + colSpan - 1, 2, cell.border[2]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor (var colOffset = 0; colOffset < colSpan; colOffset++) {\r\n\t\t\t\t\t\t// set top border\r\n\t\t\t\t\t\tif (cell.border[1] !== undefined && colOffset > 0) {\r\n\t\t\t\t\t\t\tsetBorder(rowIndex, colIndex + colOffset, 1, cell.border[1]);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// set bottom border\r\n\t\t\t\t\t\tif (cell.border[3] !== undefined) {\r\n\t\t\t\t\t\t\tsetBorder(rowIndex + rowSpan - 1, colIndex + colOffset, 3, cell.border[3]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// helper function to set the border for a given cell\r\n\t\tfunction setBorder(rowIndex, colIndex, borderIndex, borderValue) {\r\n\t\t\tvar cell = body[rowIndex][colIndex];\r\n\t\t\tcell.border = cell.border || {};\r\n\t\t\tcell.border[borderIndex] = borderValue;\r\n\t\t}\r\n\t}\r\n};\r\n\r\nTableProcessor.prototype.onRowBreak = function (rowIndex, writer) {\r\n\tvar self = this;\r\n\treturn function () {\r\n\t\tvar offset = self.rowPaddingTop + (!self.headerRows ? self.topLineWidth : 0);\r\n\t\twriter.context().availableHeight -= self.reservedAtBottom;\r\n\t\twriter.context().moveDown(offset);\r\n\t};\r\n};\r\n\r\nTableProcessor.prototype.beginRow = function (rowIndex, writer) {\r\n\tthis.topLineWidth = this.layout.hLineWidth(rowIndex, this.tableNode);\r\n\tthis.rowPaddingTop = this.layout.paddingTop(rowIndex, this.tableNode);\r\n\tthis.bottomLineWidth = this.layout.hLineWidth(rowIndex + 1, this.tableNode);\r\n\tthis.rowPaddingBottom = this.layout.paddingBottom(rowIndex, this.tableNode);\r\n\r\n\tthis.rowCallback = this.onRowBreak(rowIndex, writer);\r\n\twriter.tracker.startTracking('pageChanged', this.rowCallback);\r\n\tif (rowIndex == 0 && !this.dontBreakRows && !this.rowsWithoutPageBreak) {\r\n\t\t// We store the 'y' to draw later and if necessary the top border of the table\r\n\t\tthis._tableTopBorderY = writer.context().y;\r\n\t\twriter.context().moveDown(this.topLineWidth);\r\n\t}\r\n\tif (this.dontBreakRows && rowIndex > 0) {\r\n\t\twriter.beginUnbreakableBlock();\r\n\t}\r\n\tthis.rowTopY = writer.context().y;\r\n\tthis.reservedAtBottom = this.bottomLineWidth + this.rowPaddingBottom;\r\n\r\n\twriter.context().availableHeight -= this.reservedAtBottom;\r\n\r\n\twriter.context().moveDown(this.rowPaddingTop);\r\n};\r\n\r\nTableProcessor.prototype.drawHorizontalLine = function (lineIndex, writer, overrideY, moveDown = true, forcePage) {\r\n\tvar lineWidth = this.layout.hLineWidth(lineIndex, this.tableNode);\r\n\tif (lineWidth) {\r\n\t\tvar style = this.layout.hLineStyle(lineIndex, this.tableNode);\r\n\t\tvar dash;\r\n\t\tif (style && style.dash) {\r\n\t\t\tdash = style.dash;\r\n\t\t}\r\n\r\n\t\tvar offset = lineWidth / 2;\r\n\t\tvar currentLine = null;\r\n\t\tvar body = this.tableNode.table.body;\r\n\t\tvar cellAbove;\r\n\t\tvar currentCell;\r\n\t\tvar rowCellAbove;\r\n\r\n\t\tfor (var i = 0, l = this.rowSpanData.length; i < l; i++) {\r\n\t\t\tvar data = this.rowSpanData[i];\r\n\t\t\tvar shouldDrawLine = !data.rowSpan;\r\n\t\t\tvar borderColor = null;\r\n\r\n\t\t\t// draw only if the current cell requires a top border or the cell in the\r\n\t\t\t// row above requires a bottom border\r\n\t\t\tif (shouldDrawLine && i < l - 1) {\r\n\t\t\t\tvar topBorder = false, bottomBorder = false, rowBottomBorder = false;\r\n\r\n\t\t\t\t// the cell in the row above\r\n\t\t\t\tif (lineIndex > 0) {\r\n\t\t\t\t\tcellAbove = body[lineIndex - 1][i];\r\n\t\t\t\t\tbottomBorder = cellAbove.border ? cellAbove.border[3] : this.layout.defaultBorder;\r\n\t\t\t\t\tif (bottomBorder && cellAbove.borderColor) {\r\n\t\t\t\t\t\tborderColor = cellAbove.borderColor[3];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// the current cell\r\n\t\t\t\tif (lineIndex < body.length) {\r\n\t\t\t\t\tcurrentCell = body[lineIndex][i];\r\n\t\t\t\t\ttopBorder = currentCell.border ? currentCell.border[1] : this.layout.defaultBorder;\r\n\t\t\t\t\tif (topBorder && borderColor == null && currentCell.borderColor) {\r\n\t\t\t\t\t\tborderColor = currentCell.borderColor[1];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tshouldDrawLine = topBorder || bottomBorder;\r\n\t\t\t}\r\n\r\n\t\t\tif (cellAbove && cellAbove._rowSpanCurrentOffset) {\r\n\t\t\t\trowCellAbove = body[lineIndex - 1 - cellAbove._rowSpanCurrentOffset][i];\r\n\t\t\t\trowBottomBorder = rowCellAbove && rowCellAbove.border ? rowCellAbove.border[3] : this.layout.defaultBorder;\r\n\t\t\t\tif (rowBottomBorder && rowCellAbove && rowCellAbove.borderColor) {\r\n\t\t\t\t\tborderColor = rowCellAbove.borderColor[3];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (borderColor == null) {\r\n\t\t\t\tborderColor = isFunction(this.layout.hLineColor) ? this.layout.hLineColor(lineIndex, this.tableNode, i) : this.layout.hLineColor;\r\n\t\t\t}\r\n\r\n\t\t\tif (!currentLine && shouldDrawLine) {\r\n\t\t\t\tcurrentLine = { left: data.left, width: 0 };\r\n\t\t\t}\r\n\r\n\t\t\tif (shouldDrawLine) {\r\n\t\t\t\tvar colSpanIndex = 0;\r\n\t\t\t\tif (rowCellAbove && rowCellAbove.colSpan && rowBottomBorder) {\r\n\t\t\t\t\twhile (rowCellAbove.colSpan > colSpanIndex) {\r\n\t\t\t\t\t\tcurrentLine.width += (this.rowSpanData[i + colSpanIndex++].width || 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti += colSpanIndex - 1;\r\n\t\t\t\t} else if (cellAbove && cellAbove.colSpan && bottomBorder) {\r\n\t\t\t\t\twhile (cellAbove.colSpan > colSpanIndex) {\r\n\t\t\t\t\t\tcurrentLine.width += (this.rowSpanData[i + colSpanIndex++].width || 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti += colSpanIndex - 1;\r\n\t\t\t\t} else if (currentCell && currentCell.colSpan && topBorder) {\r\n\t\t\t\t\twhile (currentCell.colSpan > colSpanIndex) {\r\n\t\t\t\t\t\tcurrentLine.width += (this.rowSpanData[i + colSpanIndex++].width || 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\ti += colSpanIndex - 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentLine.width += (this.rowSpanData[i].width || 0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar y = (overrideY || 0) + offset;\r\n\r\n\r\n\t\t\tif (shouldDrawLine) {\r\n\t\t\t\tif (currentLine && currentLine.width) {\r\n\t\t\t\t\twriter.addVector({\r\n\t\t\t\t\t\ttype: 'line',\r\n\t\t\t\t\t\tx1: currentLine.left,\r\n\t\t\t\t\t\tx2: currentLine.left + currentLine.width,\r\n\t\t\t\t\t\ty1: y,\r\n\t\t\t\t\t\ty2: y,\r\n\t\t\t\t\t\tlineWidth: lineWidth,\r\n\t\t\t\t\t\tdash: dash,\r\n\t\t\t\t\t\tlineColor: borderColor\r\n\t\t\t\t\t}, false, isNumber(overrideY), null, forcePage);\r\n\t\t\t\t\tcurrentLine = null;\r\n\t\t\t\t\tborderColor = null;\r\n\t\t\t\t\tcellAbove = null;\r\n\t\t\t\t\tcurrentCell = null;\r\n\t\t\t\t\trowCellAbove = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (moveDown) {\r\n\t\t\twriter.context().moveDown(lineWidth);\r\n\t\t}\r\n\t}\r\n};\r\n\r\nTableProcessor.prototype.drawVerticalLine = function (x, y0, y1, vLineColIndex, writer, vLineRowIndex, beforeVLineColIndex) {\r\n\tvar width = this.layout.vLineWidth(vLineColIndex, this.tableNode);\r\n\tif (width === 0) {\r\n\t\treturn;\r\n\t}\r\n\tvar style = this.layout.vLineStyle(vLineColIndex, this.tableNode);\r\n\tvar dash;\r\n\tif (style && style.dash) {\r\n\t\tdash = style.dash;\r\n\t}\r\n\r\n\tvar body = this.tableNode.table.body;\r\n\tvar cellBefore;\r\n\tvar currentCell;\r\n\tvar borderColor;\r\n\r\n\t// the cell in the col before\r\n\tif (vLineColIndex > 0) {\r\n\t\tcellBefore = body[vLineRowIndex][beforeVLineColIndex];\r\n\t\tif (cellBefore && cellBefore.borderColor) {\r\n\t\t\tif (cellBefore.border ? cellBefore.border[2] : this.layout.defaultBorder) {\r\n\t\t\t\tborderColor = cellBefore.borderColor[2];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// the current cell\r\n\tif (borderColor == null && vLineColIndex < body.length) {\r\n\t\tcurrentCell = body[vLineRowIndex][vLineColIndex];\r\n\t\tif (currentCell && currentCell.borderColor) {\r\n\t\t\tif (currentCell.border ? currentCell.border[0] : this.layout.defaultBorder) {\r\n\t\t\t\tborderColor = currentCell.borderColor[0];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (borderColor == null && cellBefore && cellBefore._rowSpanCurrentOffset) {\r\n\t\tvar rowCellBeforeAbove = body[vLineRowIndex - cellBefore._rowSpanCurrentOffset][beforeVLineColIndex];\r\n\t\tif (rowCellBeforeAbove.borderColor) {\r\n\t\t\tif (rowCellBeforeAbove.border ? rowCellBeforeAbove.border[2] : this.layout.defaultBorder) {\r\n\t\t\t\tborderColor = rowCellBeforeAbove.borderColor[2];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (borderColor == null && currentCell && currentCell._rowSpanCurrentOffset) {\r\n\t\tvar rowCurrentCellAbove = body[vLineRowIndex - currentCell._rowSpanCurrentOffset][vLineColIndex];\r\n\t\tif (rowCurrentCellAbove.borderColor) {\r\n\t\t\tif (rowCurrentCellAbove.border ? rowCurrentCellAbove.border[2] : this.layout.defaultBorder) {\r\n\t\t\t\tborderColor = rowCurrentCellAbove.borderColor[2];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (borderColor == null) {\r\n\t\tborderColor = isFunction(this.layout.vLineColor) ? this.layout.vLineColor(vLineColIndex, this.tableNode, vLineRowIndex) : this.layout.vLineColor;\r\n\t}\r\n\twriter.addVector({\r\n\t\ttype: 'line',\r\n\t\tx1: x + width / 2,\r\n\t\tx2: x + width / 2,\r\n\t\ty1: y0,\r\n\t\ty2: y1,\r\n\t\tlineWidth: width,\r\n\t\tdash: dash,\r\n\t\tlineColor: borderColor\r\n\t}, false, true);\r\n\tcellBefore = null;\r\n\tcurrentCell = null;\r\n\tborderColor = null;\r\n};\r\n\r\nTableProcessor.prototype.endTable = function (writer) {\r\n\tif (this.cleanUpRepeatables) {\r\n\t\twriter.popFromRepeatables();\r\n\t}\r\n};\r\n\r\nTableProcessor.prototype.endRow = function (rowIndex, writer, pageBreaks) {\r\n\tvar l, i;\r\n\tvar self = this;\r\n\twriter.tracker.stopTracking('pageChanged', this.rowCallback);\r\n\twriter.context().moveDown(this.layout.paddingBottom(rowIndex, this.tableNode));\r\n\twriter.context().availableHeight += this.reservedAtBottom;\r\n\r\n\tvar endingPage = writer.context().page;\r\n\tvar endingY = writer.context().y;\r\n\r\n\tvar xs = getLineXs();\r\n\r\n\tvar ys = [];\r\n\r\n\tvar hasBreaks = pageBreaks && pageBreaks.length > 0;\r\n\tvar body = this.tableNode.table.body;\r\n\r\n\tys.push({\r\n\t\ty0: this.rowTopY,\r\n\t\tpage: hasBreaks ? pageBreaks[0].prevPage : endingPage\r\n\t});\r\n\r\n\tif (hasBreaks) {\r\n\t\tfor (i = 0, l = pageBreaks.length; i < l; i++) {\r\n\t\t\tvar pageBreak = pageBreaks[i];\r\n\t\t\tys[ys.length - 1].y1 = pageBreak.prevY;\r\n\r\n\t\t\tys.push({ y0: pageBreak.y, page: pageBreak.prevPage + 1 });\r\n\t\t}\r\n\t}\r\n\r\n\tys[ys.length - 1].y1 = endingY;\r\n\r\n\tvar skipOrphanePadding = (ys[0].y1 - ys[0].y0 === this.rowPaddingTop);\r\n\tif (rowIndex === 0 && !skipOrphanePadding && !this.rowsWithoutPageBreak && !this.dontBreakRows) {\r\n\t\t// Draw the top border of the table\r\n\t\tvar pageTableStartedAt = null;\r\n\t\tif (pageBreaks && pageBreaks.length > 0) {\r\n\t\t\t// Get the page where table started at\r\n\t\t\tpageTableStartedAt = pageBreaks[0].prevPage;\r\n\t\t}\r\n\t\tthis.drawHorizontalLine(0, writer, this._tableTopBorderY, false, pageTableStartedAt);\r\n\t}\r\n\tfor (var yi = (skipOrphanePadding ? 1 : 0), yl = ys.length; yi < yl; yi++) {\r\n\t\tvar willBreak = yi < ys.length - 1;\r\n\t\tvar rowBreakWithoutHeader = (yi > 0 && !this.headerRows);\r\n\t\tvar hzLineOffset = rowBreakWithoutHeader ? 0 : this.topLineWidth;\r\n\t\tvar y1 = ys[yi].y0;\r\n\t\tvar y2 = ys[yi].y1;\r\n\r\n\t\tif (willBreak) {\r\n\t\t\ty2 = y2 + this.rowPaddingBottom;\r\n\t\t}\r\n\r\n\t\tif (writer.context().page != ys[yi].page) {\r\n\t\t\twriter.context().page = ys[yi].page;\r\n\r\n\t\t\t//TODO: buggy, availableHeight should be updated on every pageChanged event\r\n\t\t\t// TableProcessor should be pageChanged listener, instead of processRow\r\n\t\t\tthis.reservedAtBottom = 0;\r\n\t\t}\r\n\r\n\t\t// Draw horizontal lines before the vertical lines so they are not overridden\r\n\t\tif (willBreak && this.layout.hLineWhenBroken !== false) {\r\n\t\t\tthis.drawHorizontalLine(rowIndex + 1, writer, y2);\r\n\t\t}\r\n\t\tif (rowBreakWithoutHeader && this.layout.hLineWhenBroken !== false) {\r\n\t\t\tthis.drawHorizontalLine(rowIndex, writer, y1);\r\n\t\t}\r\n\r\n\t\tfor (i = 0, l = xs.length; i < l; i++) {\r\n\t\t\tvar leftCellBorder = false;\r\n\t\t\tvar rightCellBorder = false;\r\n\t\t\tvar colIndex = xs[i].index;\r\n\r\n\t\t\t// current cell\r\n\t\t\tif (colIndex < body[rowIndex].length) {\r\n\t\t\t\tvar cell = body[rowIndex][colIndex];\r\n\t\t\t\tleftCellBorder = cell.border ? cell.border[0] : this.layout.defaultBorder;\r\n\t\t\t\trightCellBorder = cell.border ? cell.border[2] : this.layout.defaultBorder;\r\n\t\t\t}\r\n\r\n\t\t\t// before cell\r\n\t\t\tif (colIndex > 0 && !leftCellBorder) {\r\n\t\t\t\tvar cell = body[rowIndex][colIndex - 1];\r\n\t\t\t\tleftCellBorder = cell.border ? cell.border[2] : this.layout.defaultBorder;\r\n\t\t\t}\r\n\r\n\t\t\t// after cell\r\n\t\t\tif (colIndex + 1 < body[rowIndex].length && !rightCellBorder) {\r\n\t\t\t\tvar cell = body[rowIndex][colIndex + 1];\r\n\t\t\t\trightCellBorder = cell.border ? cell.border[0] : this.layout.defaultBorder;\r\n\t\t\t}\r\n\r\n\t\t\tif (leftCellBorder) {\r\n\t\t\t\tthis.drawVerticalLine(xs[i].x, y1 - hzLineOffset, y2 + this.bottomLineWidth, xs[i].index, writer, rowIndex, xs[i - 1] ? xs[i - 1].index : null);\r\n\t\t\t}\r\n\r\n\t\t\tif (i < l - 1) {\r\n\t\t\t\tvar fillColor = body[rowIndex][colIndex].fillColor;\r\n\t\t\t\tvar fillOpacity = body[rowIndex][colIndex].fillOpacity;\r\n\t\t\t\tif (!fillColor) {\r\n\t\t\t\t\tfillColor = isFunction(this.layout.fillColor) ? this.layout.fillColor(rowIndex, this.tableNode, colIndex) : this.layout.fillColor;\r\n\t\t\t\t}\r\n\t\t\t\tif (!isNumber(fillOpacity)) {\r\n\t\t\t\t\tfillOpacity = isFunction(this.layout.fillOpacity) ? this.layout.fillOpacity(rowIndex, this.tableNode, colIndex) : this.layout.fillOpacity;\r\n\t\t\t\t}\r\n\t\t\t\tvar overlayPattern = body[rowIndex][colIndex].overlayPattern;\r\n\t\t\t\tvar overlayOpacity = body[rowIndex][colIndex].overlayOpacity;\r\n\t\t\t\tif (fillColor || overlayPattern) {\r\n\t\t\t\t\tvar widthLeftBorder = leftCellBorder ? this.layout.vLineWidth(colIndex, this.tableNode) : 0;\r\n\t\t\t\t\tvar widthRightBorder;\r\n\t\t\t\t\tif ((colIndex === 0 || colIndex + 1 == body[rowIndex].length) && !rightCellBorder) {\r\n\t\t\t\t\t\twidthRightBorder = this.layout.vLineWidth(colIndex + 1, this.tableNode);\r\n\t\t\t\t\t} else if (rightCellBorder) {\r\n\t\t\t\t\t\twidthRightBorder = this.layout.vLineWidth(colIndex + 1, this.tableNode) / 2;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twidthRightBorder = 0;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar x1f = this.dontBreakRows ? xs[i].x + widthLeftBorder : xs[i].x + (widthLeftBorder / 2);\r\n\t\t\t\t\tvar y1f = this.dontBreakRows ? y1 : y1 - (hzLineOffset / 2);\r\n\t\t\t\t\tvar x2f = xs[i + 1].x + widthRightBorder;\r\n\t\t\t\t\tvar y2f = this.dontBreakRows ? y2 + this.bottomLineWidth : y2 + (this.bottomLineWidth / 2);\r\n\t\t\t\t\tvar bgWidth = x2f - x1f;\r\n\t\t\t\t\tvar bgHeight = y2f - y1f;\r\n\t\t\t\t\tif (fillColor) {\r\n\t\t\t\t\t\twriter.addVector({\r\n\t\t\t\t\t\t\ttype: 'rect',\r\n\t\t\t\t\t\t\tx: x1f,\r\n\t\t\t\t\t\t\ty: y1f,\r\n\t\t\t\t\t\t\tw: bgWidth,\r\n\t\t\t\t\t\t\th: bgHeight,\r\n\t\t\t\t\t\t\tlineWidth: 0,\r\n\t\t\t\t\t\t\tcolor: fillColor,\r\n\t\t\t\t\t\t\tfillOpacity: fillOpacity,\r\n\t\t\t\t\t\t\t// mark if we are in an unbreakable block\r\n\t\t\t\t\t\t\t_isFillColorFromUnbreakable: !!writer.transactionLevel\r\n\t\t\t\t\t\t}, false, true, writer.context().backgroundLength[writer.context().page]);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (overlayPattern) {\r\n\t\t\t\t\t\twriter.addVector({\r\n\t\t\t\t\t\t\ttype: 'rect',\r\n\t\t\t\t\t\t\tx: x1f,\r\n\t\t\t\t\t\t\ty: y1f,\r\n\t\t\t\t\t\t\tw: bgWidth,\r\n\t\t\t\t\t\t\th: bgHeight,\r\n\t\t\t\t\t\t\tlineWidth: 0,\r\n\t\t\t\t\t\t\tcolor: overlayPattern,\r\n\t\t\t\t\t\t\tfillOpacity: overlayOpacity\r\n\t\t\t\t\t\t}, false, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\twriter.context().page = endingPage;\r\n\twriter.context().y = endingY;\r\n\r\n\tvar row = this.tableNode.table.body[rowIndex];\r\n\tfor (i = 0, l = row.length; i < l; i++) {\r\n\t\tif (row[i].rowSpan) {\r\n\t\t\tthis.rowSpanData[i].rowSpan = row[i].rowSpan;\r\n\r\n\t\t\t// fix colSpans\r\n\t\t\tif (row[i].colSpan && row[i].colSpan > 1) {\r\n\t\t\t\tfor (var j = 1; j < row[i].rowSpan; j++) {\r\n\t\t\t\t\tthis.tableNode.table.body[rowIndex + j][i]._colSpan = row[i].colSpan;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// fix rowSpans\r\n\t\t\tif (row[i].rowSpan && row[i].rowSpan > 1) {\r\n\t\t\t\tfor (var j = 1; j < row[i].rowSpan; j++) {\r\n\t\t\t\t\tthis.tableNode.table.body[rowIndex + j][i]._rowSpanCurrentOffset = j;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.rowSpanData[i].rowSpan > 0) {\r\n\t\t\tthis.rowSpanData[i].rowSpan--;\r\n\t\t}\r\n\t}\r\n\r\n\tthis.drawHorizontalLine(rowIndex + 1, writer);\r\n\r\n\tif (this.headerRows && rowIndex === this.headerRows - 1) {\r\n\t\tthis.headerRepeatable = writer.currentBlockToRepeatable();\r\n\t}\r\n\r\n\tif (this.dontBreakRows) {\r\n\t\twriter.tracker.auto('pageChanged',\r\n\t\t\tfunction () {\r\n\t\t\t\tif (rowIndex > 0 && !self.headerRows && self.layout.hLineWhenBroken !== false) {\r\n\t\t\t\t\t// Draw the top border of the row after a page break\r\n\t\t\t\t\tself.drawHorizontalLine(rowIndex, writer);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tfunction () {\r\n\t\t\t\twriter.commitUnbreakableBlock();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tif (this.headerRepeatable && (rowIndex === (this.rowsWithoutPageBreak - 1) || rowIndex === this.tableNode.table.body.length - 1)) {\r\n\t\twriter.commitUnbreakableBlock();\r\n\t\twriter.pushToRepeatables(this.headerRepeatable);\r\n\t\tthis.cleanUpRepeatables = true;\r\n\t\tthis.headerRepeatable = null;\r\n\t}\r\n\r\n\tfunction getLineXs() {\r\n\t\tvar result = [];\r\n\t\tvar cols = 0;\r\n\r\n\t\tfor (var i = 0, l = self.tableNode.table.body[rowIndex].length; i < l; i++) {\r\n\t\t\tif (!cols) {\r\n\t\t\t\tresult.push({ x: self.rowSpanData[i].left, index: i });\r\n\r\n\t\t\t\tvar item = self.tableNode.table.body[rowIndex][i];\r\n\t\t\t\tcols = (item._colSpan || item.colSpan || 0);\r\n\t\t\t}\r\n\t\t\tif (cols > 0) {\r\n\t\t\t\tcols--;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tresult.push({ x: self.rowSpanData[self.rowSpanData.length - 1].left, index: self.rowSpanData.length - 1 });\r\n\r\n\t\treturn result;\r\n\t}\r\n};\r\n\r\nmodule.exports = TableProcessor;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvdGFibGVQcm9jZXNzb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLGdGQUFvQjtBQUNuRCxpQkFBaUIsZ0dBQStCO0FBQ2hELGVBQWUsOEZBQTZCO0FBQzVDLHdCQUF3Qix1R0FBc0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsZ0JBQWdCLGtCQUFrQiw0QkFBNEI7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQSwyREFBMkQsT0FBTztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQkFBK0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3QkFBd0I7QUFDakQ7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQ0FBK0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFNBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsT0FBTztBQUN6RTtBQUNBLGtCQUFrQix1Q0FBdUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJGQUEyRjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2dhc2NhdC9wcmlzbWFxdWFudC9wcmlzbWEtcXVhbnR1bS9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvdGFibGVQcm9jZXNzb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIENvbHVtbkNhbGN1bGF0b3IgPSByZXF1aXJlKCcuL2NvbHVtbkNhbGN1bGF0b3InKTtcclxudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc0Z1bmN0aW9uO1xyXG52YXIgaXNOdW1iZXIgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc051bWJlcjtcclxudmFyIGlzUG9zaXRpdmVJbnRlZ2VyID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuaXNQb3NpdGl2ZUludGVnZXI7XHJcblxyXG5mdW5jdGlvbiBUYWJsZVByb2Nlc3Nvcih0YWJsZU5vZGUpIHtcclxuXHR0aGlzLnRhYmxlTm9kZSA9IHRhYmxlTm9kZTtcclxufVxyXG5cclxuVGFibGVQcm9jZXNzb3IucHJvdG90eXBlLmJlZ2luVGFibGUgPSBmdW5jdGlvbiAod3JpdGVyKSB7XHJcblx0dmFyIHRhYmxlTm9kZTtcclxuXHR2YXIgYXZhaWxhYmxlV2lkdGg7XHJcblx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuXHR0YWJsZU5vZGUgPSB0aGlzLnRhYmxlTm9kZTtcclxuXHR0aGlzLm9mZnNldHMgPSB0YWJsZU5vZGUuX29mZnNldHM7XHJcblx0dGhpcy5sYXlvdXQgPSB0YWJsZU5vZGUuX2xheW91dDtcclxuXHJcblx0YXZhaWxhYmxlV2lkdGggPSB3cml0ZXIuY29udGV4dCgpLmF2YWlsYWJsZVdpZHRoIC0gdGhpcy5vZmZzZXRzLnRvdGFsO1xyXG5cdENvbHVtbkNhbGN1bGF0b3IuYnVpbGRDb2x1bW5XaWR0aHModGFibGVOb2RlLnRhYmxlLndpZHRocywgYXZhaWxhYmxlV2lkdGgsIHRoaXMub2Zmc2V0cy50b3RhbCwgdGFibGVOb2RlKTtcclxuXHJcblx0dGhpcy50YWJsZVdpZHRoID0gdGFibGVOb2RlLl9vZmZzZXRzLnRvdGFsICsgZ2V0VGFibGVJbm5lckNvbnRlbnRXaWR0aCgpO1xyXG5cdHRoaXMucm93U3BhbkRhdGEgPSBwcmVwYXJlUm93U3BhbkRhdGEoKTtcclxuXHR0aGlzLmNsZWFuVXBSZXBlYXRhYmxlcyA9IGZhbHNlO1xyXG5cclxuXHQvLyBoZWFkZXJzUm93cyBhbmQgcm93c1dpdGhvdXRQYWdlQnJlYWsgKGhlYWRlclJvd3MgKyBrZWVwV2l0aEhlYWRlclJvd3MpXHJcblx0dGhpcy5oZWFkZXJSb3dzID0gMDtcclxuXHR0aGlzLnJvd3NXaXRob3V0UGFnZUJyZWFrID0gMDtcclxuXHJcblx0dmFyIGhlYWRlclJvd3MgPSB0YWJsZU5vZGUudGFibGUuaGVhZGVyUm93cztcclxuXHJcblx0aWYgKGlzUG9zaXRpdmVJbnRlZ2VyKGhlYWRlclJvd3MpKSB7XHJcblx0XHR0aGlzLmhlYWRlclJvd3MgPSBoZWFkZXJSb3dzO1xyXG5cclxuXHRcdGlmICh0aGlzLmhlYWRlclJvd3MgPiB0YWJsZU5vZGUudGFibGUuYm9keS5sZW5ndGgpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBUb28gZmV3IHJvd3MgaW4gdGhlIHRhYmxlLiBQcm9wZXJ0eSBoZWFkZXJSb3dzIHJlcXVpcmVzIGF0IGxlYXN0ICR7dGhpcy5oZWFkZXJSb3dzfSwgY29udGFpbnMgb25seSAke3RhYmxlTm9kZS50YWJsZS5ib2R5Lmxlbmd0aH1gKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnJvd3NXaXRob3V0UGFnZUJyZWFrID0gdGhpcy5oZWFkZXJSb3dzO1xyXG5cclxuXHRcdGNvbnN0IGtlZXBXaXRoSGVhZGVyUm93cyA9IHRhYmxlTm9kZS50YWJsZS5rZWVwV2l0aEhlYWRlclJvd3M7XHJcblxyXG5cdFx0aWYgKGlzUG9zaXRpdmVJbnRlZ2VyKGtlZXBXaXRoSGVhZGVyUm93cykpIHtcclxuXHRcdFx0dGhpcy5yb3dzV2l0aG91dFBhZ2VCcmVhayArPSBrZWVwV2l0aEhlYWRlclJvd3M7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR0aGlzLmRvbnRCcmVha1Jvd3MgPSB0YWJsZU5vZGUudGFibGUuZG9udEJyZWFrUm93cyB8fCBmYWxzZTtcclxuXHJcblx0aWYgKHRoaXMucm93c1dpdGhvdXRQYWdlQnJlYWsgfHwgdGhpcy5kb250QnJlYWtSb3dzKSB7XHJcblx0XHR3cml0ZXIuYmVnaW5VbmJyZWFrYWJsZUJsb2NrKCk7XHJcblx0XHQvLyBEcmF3IHRoZSB0b3AgYm9yZGVyIG9mIHRoZSB0YWJsZVxyXG5cdFx0dGhpcy5kcmF3SG9yaXpvbnRhbExpbmUoMCwgd3JpdGVyKTtcclxuXHRcdGlmICh0aGlzLnJvd3NXaXRob3V0UGFnZUJyZWFrICYmIHRoaXMuZG9udEJyZWFrUm93cykge1xyXG5cdFx0XHQvLyBXZSBqdXN0IGluY3JlYXNlIHRoZSB2YWx1ZSBvZiB0cmFuc2FjdGlvbkxldmVsXHJcblx0XHRcdHdyaXRlci5iZWdpblVuYnJlYWthYmxlQmxvY2soKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIHVwZGF0ZSB0aGUgYm9yZGVyIHByb3BlcnRpZXMgb2YgYWxsIGNlbGxzIGJlZm9yZSBkcmF3aW5nIGFueSBsaW5lc1xyXG5cdHByZXBhcmVDZWxsQm9yZGVycyh0aGlzLnRhYmxlTm9kZS50YWJsZS5ib2R5KTtcclxuXHJcblx0ZnVuY3Rpb24gZ2V0VGFibGVJbm5lckNvbnRlbnRXaWR0aCgpIHtcclxuXHRcdHZhciB3aWR0aCA9IDA7XHJcblxyXG5cdFx0dGFibGVOb2RlLnRhYmxlLndpZHRocy5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7XHJcblx0XHRcdHdpZHRoICs9IHcuX2NhbGNXaWR0aDtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiB3aWR0aDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByZXBhcmVSb3dTcGFuRGF0YSgpIHtcclxuXHRcdHZhciByc2QgPSBbXTtcclxuXHRcdHZhciB4ID0gMDtcclxuXHRcdHZhciBsYXN0V2lkdGggPSAwO1xyXG5cclxuXHRcdHJzZC5wdXNoKHsgbGVmdDogMCwgcm93U3BhbjogMCB9KTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlbGYudGFibGVOb2RlLnRhYmxlLmJvZHlbMF0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRcdHZhciBwYWRkaW5ncyA9IHNlbGYubGF5b3V0LnBhZGRpbmdMZWZ0KGksIHNlbGYudGFibGVOb2RlKSArIHNlbGYubGF5b3V0LnBhZGRpbmdSaWdodChpLCBzZWxmLnRhYmxlTm9kZSk7XHJcblx0XHRcdHZhciBsQm9yZGVyID0gc2VsZi5sYXlvdXQudkxpbmVXaWR0aChpLCBzZWxmLnRhYmxlTm9kZSk7XHJcblx0XHRcdGxhc3RXaWR0aCA9IHBhZGRpbmdzICsgbEJvcmRlciArIHNlbGYudGFibGVOb2RlLnRhYmxlLndpZHRoc1tpXS5fY2FsY1dpZHRoO1xyXG5cdFx0XHRyc2RbcnNkLmxlbmd0aCAtIDFdLndpZHRoID0gbGFzdFdpZHRoO1xyXG5cdFx0XHR4ICs9IGxhc3RXaWR0aDtcclxuXHRcdFx0cnNkLnB1c2goeyBsZWZ0OiB4LCByb3dTcGFuOiAwLCB3aWR0aDogMCB9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcnNkO1xyXG5cdH1cclxuXHJcblx0Ly8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBjZWxscy4gSWYgdGhlIGN1cnJlbnQgY2VsbCBpcyB0aGUgc3RhcnQgb2YgYVxyXG5cdC8vIHJvd1NwYW4vY29sU3BhbiwgdXBkYXRlIHRoZSBib3JkZXIgcHJvcGVydHkgb2YgdGhlIGNlbGxzIG9uIGl0c1xyXG5cdC8vIGJvdHRvbS9yaWdodCBhY2NvcmRpbmdseS4gVGhpcyBpcyBuZWVkZWQgc2luY2UgZWFjaCBpdGVyYXRpb24gb2YgdGhlXHJcblx0Ly8gbGluZS1kcmF3aW5nIGxvb3BzIGRyYXdzIGxpbmVzIGZvciBhIHNpbmdsZSBjZWxsLCBub3QgZm9yIGFuIGVudGlyZVxyXG5cdC8vIHJvd1NwYW4vY29sU3Bhbi5cclxuXHRmdW5jdGlvbiBwcmVwYXJlQ2VsbEJvcmRlcnMoYm9keSkge1xyXG5cdFx0Zm9yICh2YXIgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IGJvZHkubGVuZ3RoOyByb3dJbmRleCsrKSB7XHJcblx0XHRcdHZhciByb3cgPSBib2R5W3Jvd0luZGV4XTtcclxuXHJcblx0XHRcdGZvciAodmFyIGNvbEluZGV4ID0gMDsgY29sSW5kZXggPCByb3cubGVuZ3RoOyBjb2xJbmRleCsrKSB7XHJcblx0XHRcdFx0dmFyIGNlbGwgPSByb3dbY29sSW5kZXhdO1xyXG5cclxuXHRcdFx0XHRpZiAoY2VsbC5ib3JkZXIpIHtcclxuXHRcdFx0XHRcdHZhciByb3dTcGFuID0gY2VsbC5yb3dTcGFuIHx8IDE7XHJcblx0XHRcdFx0XHR2YXIgY29sU3BhbiA9IGNlbGwuY29sU3BhbiB8fCAxO1xyXG5cclxuXHRcdFx0XHRcdGZvciAodmFyIHJvd09mZnNldCA9IDA7IHJvd09mZnNldCA8IHJvd1NwYW47IHJvd09mZnNldCsrKSB7XHJcblx0XHRcdFx0XHRcdC8vIHNldCBsZWZ0IGJvcmRlclxyXG5cdFx0XHRcdFx0XHRpZiAoY2VsbC5ib3JkZXJbMF0gIT09IHVuZGVmaW5lZCAmJiByb3dPZmZzZXQgPiAwKSB7XHJcblx0XHRcdFx0XHRcdFx0c2V0Qm9yZGVyKHJvd0luZGV4ICsgcm93T2Zmc2V0LCBjb2xJbmRleCwgMCwgY2VsbC5ib3JkZXJbMF0pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBzZXQgcmlnaHQgYm9yZGVyXHJcblx0XHRcdFx0XHRcdGlmIChjZWxsLmJvcmRlclsyXSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdFx0c2V0Qm9yZGVyKHJvd0luZGV4ICsgcm93T2Zmc2V0LCBjb2xJbmRleCArIGNvbFNwYW4gLSAxLCAyLCBjZWxsLmJvcmRlclsyXSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRmb3IgKHZhciBjb2xPZmZzZXQgPSAwOyBjb2xPZmZzZXQgPCBjb2xTcGFuOyBjb2xPZmZzZXQrKykge1xyXG5cdFx0XHRcdFx0XHQvLyBzZXQgdG9wIGJvcmRlclxyXG5cdFx0XHRcdFx0XHRpZiAoY2VsbC5ib3JkZXJbMV0gIT09IHVuZGVmaW5lZCAmJiBjb2xPZmZzZXQgPiAwKSB7XHJcblx0XHRcdFx0XHRcdFx0c2V0Qm9yZGVyKHJvd0luZGV4LCBjb2xJbmRleCArIGNvbE9mZnNldCwgMSwgY2VsbC5ib3JkZXJbMV0pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBzZXQgYm90dG9tIGJvcmRlclxyXG5cdFx0XHRcdFx0XHRpZiAoY2VsbC5ib3JkZXJbM10gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdHNldEJvcmRlcihyb3dJbmRleCArIHJvd1NwYW4gLSAxLCBjb2xJbmRleCArIGNvbE9mZnNldCwgMywgY2VsbC5ib3JkZXJbM10pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaGVscGVyIGZ1bmN0aW9uIHRvIHNldCB0aGUgYm9yZGVyIGZvciBhIGdpdmVuIGNlbGxcclxuXHRcdGZ1bmN0aW9uIHNldEJvcmRlcihyb3dJbmRleCwgY29sSW5kZXgsIGJvcmRlckluZGV4LCBib3JkZXJWYWx1ZSkge1xyXG5cdFx0XHR2YXIgY2VsbCA9IGJvZHlbcm93SW5kZXhdW2NvbEluZGV4XTtcclxuXHRcdFx0Y2VsbC5ib3JkZXIgPSBjZWxsLmJvcmRlciB8fCB7fTtcclxuXHRcdFx0Y2VsbC5ib3JkZXJbYm9yZGVySW5kZXhdID0gYm9yZGVyVmFsdWU7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuVGFibGVQcm9jZXNzb3IucHJvdG90eXBlLm9uUm93QnJlYWsgPSBmdW5jdGlvbiAocm93SW5kZXgsIHdyaXRlcikge1xyXG5cdHZhciBzZWxmID0gdGhpcztcclxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG9mZnNldCA9IHNlbGYucm93UGFkZGluZ1RvcCArICghc2VsZi5oZWFkZXJSb3dzID8gc2VsZi50b3BMaW5lV2lkdGggOiAwKTtcclxuXHRcdHdyaXRlci5jb250ZXh0KCkuYXZhaWxhYmxlSGVpZ2h0IC09IHNlbGYucmVzZXJ2ZWRBdEJvdHRvbTtcclxuXHRcdHdyaXRlci5jb250ZXh0KCkubW92ZURvd24ob2Zmc2V0KTtcclxuXHR9O1xyXG59O1xyXG5cclxuVGFibGVQcm9jZXNzb3IucHJvdG90eXBlLmJlZ2luUm93ID0gZnVuY3Rpb24gKHJvd0luZGV4LCB3cml0ZXIpIHtcclxuXHR0aGlzLnRvcExpbmVXaWR0aCA9IHRoaXMubGF5b3V0LmhMaW5lV2lkdGgocm93SW5kZXgsIHRoaXMudGFibGVOb2RlKTtcclxuXHR0aGlzLnJvd1BhZGRpbmdUb3AgPSB0aGlzLmxheW91dC5wYWRkaW5nVG9wKHJvd0luZGV4LCB0aGlzLnRhYmxlTm9kZSk7XHJcblx0dGhpcy5ib3R0b21MaW5lV2lkdGggPSB0aGlzLmxheW91dC5oTGluZVdpZHRoKHJvd0luZGV4ICsgMSwgdGhpcy50YWJsZU5vZGUpO1xyXG5cdHRoaXMucm93UGFkZGluZ0JvdHRvbSA9IHRoaXMubGF5b3V0LnBhZGRpbmdCb3R0b20ocm93SW5kZXgsIHRoaXMudGFibGVOb2RlKTtcclxuXHJcblx0dGhpcy5yb3dDYWxsYmFjayA9IHRoaXMub25Sb3dCcmVhayhyb3dJbmRleCwgd3JpdGVyKTtcclxuXHR3cml0ZXIudHJhY2tlci5zdGFydFRyYWNraW5nKCdwYWdlQ2hhbmdlZCcsIHRoaXMucm93Q2FsbGJhY2spO1xyXG5cdGlmIChyb3dJbmRleCA9PSAwICYmICF0aGlzLmRvbnRCcmVha1Jvd3MgJiYgIXRoaXMucm93c1dpdGhvdXRQYWdlQnJlYWspIHtcclxuXHRcdC8vIFdlIHN0b3JlIHRoZSAneScgdG8gZHJhdyBsYXRlciBhbmQgaWYgbmVjZXNzYXJ5IHRoZSB0b3AgYm9yZGVyIG9mIHRoZSB0YWJsZVxyXG5cdFx0dGhpcy5fdGFibGVUb3BCb3JkZXJZID0gd3JpdGVyLmNvbnRleHQoKS55O1xyXG5cdFx0d3JpdGVyLmNvbnRleHQoKS5tb3ZlRG93bih0aGlzLnRvcExpbmVXaWR0aCk7XHJcblx0fVxyXG5cdGlmICh0aGlzLmRvbnRCcmVha1Jvd3MgJiYgcm93SW5kZXggPiAwKSB7XHJcblx0XHR3cml0ZXIuYmVnaW5VbmJyZWFrYWJsZUJsb2NrKCk7XHJcblx0fVxyXG5cdHRoaXMucm93VG9wWSA9IHdyaXRlci5jb250ZXh0KCkueTtcclxuXHR0aGlzLnJlc2VydmVkQXRCb3R0b20gPSB0aGlzLmJvdHRvbUxpbmVXaWR0aCArIHRoaXMucm93UGFkZGluZ0JvdHRvbTtcclxuXHJcblx0d3JpdGVyLmNvbnRleHQoKS5hdmFpbGFibGVIZWlnaHQgLT0gdGhpcy5yZXNlcnZlZEF0Qm90dG9tO1xyXG5cclxuXHR3cml0ZXIuY29udGV4dCgpLm1vdmVEb3duKHRoaXMucm93UGFkZGluZ1RvcCk7XHJcbn07XHJcblxyXG5UYWJsZVByb2Nlc3Nvci5wcm90b3R5cGUuZHJhd0hvcml6b250YWxMaW5lID0gZnVuY3Rpb24gKGxpbmVJbmRleCwgd3JpdGVyLCBvdmVycmlkZVksIG1vdmVEb3duID0gdHJ1ZSwgZm9yY2VQYWdlKSB7XHJcblx0dmFyIGxpbmVXaWR0aCA9IHRoaXMubGF5b3V0LmhMaW5lV2lkdGgobGluZUluZGV4LCB0aGlzLnRhYmxlTm9kZSk7XHJcblx0aWYgKGxpbmVXaWR0aCkge1xyXG5cdFx0dmFyIHN0eWxlID0gdGhpcy5sYXlvdXQuaExpbmVTdHlsZShsaW5lSW5kZXgsIHRoaXMudGFibGVOb2RlKTtcclxuXHRcdHZhciBkYXNoO1xyXG5cdFx0aWYgKHN0eWxlICYmIHN0eWxlLmRhc2gpIHtcclxuXHRcdFx0ZGFzaCA9IHN0eWxlLmRhc2g7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG9mZnNldCA9IGxpbmVXaWR0aCAvIDI7XHJcblx0XHR2YXIgY3VycmVudExpbmUgPSBudWxsO1xyXG5cdFx0dmFyIGJvZHkgPSB0aGlzLnRhYmxlTm9kZS50YWJsZS5ib2R5O1xyXG5cdFx0dmFyIGNlbGxBYm92ZTtcclxuXHRcdHZhciBjdXJyZW50Q2VsbDtcclxuXHRcdHZhciByb3dDZWxsQWJvdmU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnJvd1NwYW5EYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHR2YXIgZGF0YSA9IHRoaXMucm93U3BhbkRhdGFbaV07XHJcblx0XHRcdHZhciBzaG91bGREcmF3TGluZSA9ICFkYXRhLnJvd1NwYW47XHJcblx0XHRcdHZhciBib3JkZXJDb2xvciA9IG51bGw7XHJcblxyXG5cdFx0XHQvLyBkcmF3IG9ubHkgaWYgdGhlIGN1cnJlbnQgY2VsbCByZXF1aXJlcyBhIHRvcCBib3JkZXIgb3IgdGhlIGNlbGwgaW4gdGhlXHJcblx0XHRcdC8vIHJvdyBhYm92ZSByZXF1aXJlcyBhIGJvdHRvbSBib3JkZXJcclxuXHRcdFx0aWYgKHNob3VsZERyYXdMaW5lICYmIGkgPCBsIC0gMSkge1xyXG5cdFx0XHRcdHZhciB0b3BCb3JkZXIgPSBmYWxzZSwgYm90dG9tQm9yZGVyID0gZmFsc2UsIHJvd0JvdHRvbUJvcmRlciA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHQvLyB0aGUgY2VsbCBpbiB0aGUgcm93IGFib3ZlXHJcblx0XHRcdFx0aWYgKGxpbmVJbmRleCA+IDApIHtcclxuXHRcdFx0XHRcdGNlbGxBYm92ZSA9IGJvZHlbbGluZUluZGV4IC0gMV1baV07XHJcblx0XHRcdFx0XHRib3R0b21Cb3JkZXIgPSBjZWxsQWJvdmUuYm9yZGVyID8gY2VsbEFib3ZlLmJvcmRlclszXSA6IHRoaXMubGF5b3V0LmRlZmF1bHRCb3JkZXI7XHJcblx0XHRcdFx0XHRpZiAoYm90dG9tQm9yZGVyICYmIGNlbGxBYm92ZS5ib3JkZXJDb2xvcikge1xyXG5cdFx0XHRcdFx0XHRib3JkZXJDb2xvciA9IGNlbGxBYm92ZS5ib3JkZXJDb2xvclszXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHRoZSBjdXJyZW50IGNlbGxcclxuXHRcdFx0XHRpZiAobGluZUluZGV4IDwgYm9keS5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdGN1cnJlbnRDZWxsID0gYm9keVtsaW5lSW5kZXhdW2ldO1xyXG5cdFx0XHRcdFx0dG9wQm9yZGVyID0gY3VycmVudENlbGwuYm9yZGVyID8gY3VycmVudENlbGwuYm9yZGVyWzFdIDogdGhpcy5sYXlvdXQuZGVmYXVsdEJvcmRlcjtcclxuXHRcdFx0XHRcdGlmICh0b3BCb3JkZXIgJiYgYm9yZGVyQ29sb3IgPT0gbnVsbCAmJiBjdXJyZW50Q2VsbC5ib3JkZXJDb2xvcikge1xyXG5cdFx0XHRcdFx0XHRib3JkZXJDb2xvciA9IGN1cnJlbnRDZWxsLmJvcmRlckNvbG9yWzFdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c2hvdWxkRHJhd0xpbmUgPSB0b3BCb3JkZXIgfHwgYm90dG9tQm9yZGVyO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoY2VsbEFib3ZlICYmIGNlbGxBYm92ZS5fcm93U3BhbkN1cnJlbnRPZmZzZXQpIHtcclxuXHRcdFx0XHRyb3dDZWxsQWJvdmUgPSBib2R5W2xpbmVJbmRleCAtIDEgLSBjZWxsQWJvdmUuX3Jvd1NwYW5DdXJyZW50T2Zmc2V0XVtpXTtcclxuXHRcdFx0XHRyb3dCb3R0b21Cb3JkZXIgPSByb3dDZWxsQWJvdmUgJiYgcm93Q2VsbEFib3ZlLmJvcmRlciA/IHJvd0NlbGxBYm92ZS5ib3JkZXJbM10gOiB0aGlzLmxheW91dC5kZWZhdWx0Qm9yZGVyO1xyXG5cdFx0XHRcdGlmIChyb3dCb3R0b21Cb3JkZXIgJiYgcm93Q2VsbEFib3ZlICYmIHJvd0NlbGxBYm92ZS5ib3JkZXJDb2xvcikge1xyXG5cdFx0XHRcdFx0Ym9yZGVyQ29sb3IgPSByb3dDZWxsQWJvdmUuYm9yZGVyQ29sb3JbM107XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoYm9yZGVyQ29sb3IgPT0gbnVsbCkge1xyXG5cdFx0XHRcdGJvcmRlckNvbG9yID0gaXNGdW5jdGlvbih0aGlzLmxheW91dC5oTGluZUNvbG9yKSA/IHRoaXMubGF5b3V0LmhMaW5lQ29sb3IobGluZUluZGV4LCB0aGlzLnRhYmxlTm9kZSwgaSkgOiB0aGlzLmxheW91dC5oTGluZUNvbG9yO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIWN1cnJlbnRMaW5lICYmIHNob3VsZERyYXdMaW5lKSB7XHJcblx0XHRcdFx0Y3VycmVudExpbmUgPSB7IGxlZnQ6IGRhdGEubGVmdCwgd2lkdGg6IDAgfTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHNob3VsZERyYXdMaW5lKSB7XHJcblx0XHRcdFx0dmFyIGNvbFNwYW5JbmRleCA9IDA7XHJcblx0XHRcdFx0aWYgKHJvd0NlbGxBYm92ZSAmJiByb3dDZWxsQWJvdmUuY29sU3BhbiAmJiByb3dCb3R0b21Cb3JkZXIpIHtcclxuXHRcdFx0XHRcdHdoaWxlIChyb3dDZWxsQWJvdmUuY29sU3BhbiA+IGNvbFNwYW5JbmRleCkge1xyXG5cdFx0XHRcdFx0XHRjdXJyZW50TGluZS53aWR0aCArPSAodGhpcy5yb3dTcGFuRGF0YVtpICsgY29sU3BhbkluZGV4KytdLndpZHRoIHx8IDApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aSArPSBjb2xTcGFuSW5kZXggLSAxO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoY2VsbEFib3ZlICYmIGNlbGxBYm92ZS5jb2xTcGFuICYmIGJvdHRvbUJvcmRlcikge1xyXG5cdFx0XHRcdFx0d2hpbGUgKGNlbGxBYm92ZS5jb2xTcGFuID4gY29sU3BhbkluZGV4KSB7XHJcblx0XHRcdFx0XHRcdGN1cnJlbnRMaW5lLndpZHRoICs9ICh0aGlzLnJvd1NwYW5EYXRhW2kgKyBjb2xTcGFuSW5kZXgrK10ud2lkdGggfHwgMCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpICs9IGNvbFNwYW5JbmRleCAtIDE7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChjdXJyZW50Q2VsbCAmJiBjdXJyZW50Q2VsbC5jb2xTcGFuICYmIHRvcEJvcmRlcikge1xyXG5cdFx0XHRcdFx0d2hpbGUgKGN1cnJlbnRDZWxsLmNvbFNwYW4gPiBjb2xTcGFuSW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0Y3VycmVudExpbmUud2lkdGggKz0gKHRoaXMucm93U3BhbkRhdGFbaSArIGNvbFNwYW5JbmRleCsrXS53aWR0aCB8fCAwKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGkgKz0gY29sU3BhbkluZGV4IC0gMTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Y3VycmVudExpbmUud2lkdGggKz0gKHRoaXMucm93U3BhbkRhdGFbaV0ud2lkdGggfHwgMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgeSA9IChvdmVycmlkZVkgfHwgMCkgKyBvZmZzZXQ7XHJcblxyXG5cclxuXHRcdFx0aWYgKHNob3VsZERyYXdMaW5lKSB7XHJcblx0XHRcdFx0aWYgKGN1cnJlbnRMaW5lICYmIGN1cnJlbnRMaW5lLndpZHRoKSB7XHJcblx0XHRcdFx0XHR3cml0ZXIuYWRkVmVjdG9yKHtcclxuXHRcdFx0XHRcdFx0dHlwZTogJ2xpbmUnLFxyXG5cdFx0XHRcdFx0XHR4MTogY3VycmVudExpbmUubGVmdCxcclxuXHRcdFx0XHRcdFx0eDI6IGN1cnJlbnRMaW5lLmxlZnQgKyBjdXJyZW50TGluZS53aWR0aCxcclxuXHRcdFx0XHRcdFx0eTE6IHksXHJcblx0XHRcdFx0XHRcdHkyOiB5LFxyXG5cdFx0XHRcdFx0XHRsaW5lV2lkdGg6IGxpbmVXaWR0aCxcclxuXHRcdFx0XHRcdFx0ZGFzaDogZGFzaCxcclxuXHRcdFx0XHRcdFx0bGluZUNvbG9yOiBib3JkZXJDb2xvclxyXG5cdFx0XHRcdFx0fSwgZmFsc2UsIGlzTnVtYmVyKG92ZXJyaWRlWSksIG51bGwsIGZvcmNlUGFnZSk7XHJcblx0XHRcdFx0XHRjdXJyZW50TGluZSA9IG51bGw7XHJcblx0XHRcdFx0XHRib3JkZXJDb2xvciA9IG51bGw7XHJcblx0XHRcdFx0XHRjZWxsQWJvdmUgPSBudWxsO1xyXG5cdFx0XHRcdFx0Y3VycmVudENlbGwgPSBudWxsO1xyXG5cdFx0XHRcdFx0cm93Q2VsbEFib3ZlID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAobW92ZURvd24pIHtcclxuXHRcdFx0d3JpdGVyLmNvbnRleHQoKS5tb3ZlRG93bihsaW5lV2lkdGgpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcblRhYmxlUHJvY2Vzc29yLnByb3RvdHlwZS5kcmF3VmVydGljYWxMaW5lID0gZnVuY3Rpb24gKHgsIHkwLCB5MSwgdkxpbmVDb2xJbmRleCwgd3JpdGVyLCB2TGluZVJvd0luZGV4LCBiZWZvcmVWTGluZUNvbEluZGV4KSB7XHJcblx0dmFyIHdpZHRoID0gdGhpcy5sYXlvdXQudkxpbmVXaWR0aCh2TGluZUNvbEluZGV4LCB0aGlzLnRhYmxlTm9kZSk7XHJcblx0aWYgKHdpZHRoID09PSAwKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cdHZhciBzdHlsZSA9IHRoaXMubGF5b3V0LnZMaW5lU3R5bGUodkxpbmVDb2xJbmRleCwgdGhpcy50YWJsZU5vZGUpO1xyXG5cdHZhciBkYXNoO1xyXG5cdGlmIChzdHlsZSAmJiBzdHlsZS5kYXNoKSB7XHJcblx0XHRkYXNoID0gc3R5bGUuZGFzaDtcclxuXHR9XHJcblxyXG5cdHZhciBib2R5ID0gdGhpcy50YWJsZU5vZGUudGFibGUuYm9keTtcclxuXHR2YXIgY2VsbEJlZm9yZTtcclxuXHR2YXIgY3VycmVudENlbGw7XHJcblx0dmFyIGJvcmRlckNvbG9yO1xyXG5cclxuXHQvLyB0aGUgY2VsbCBpbiB0aGUgY29sIGJlZm9yZVxyXG5cdGlmICh2TGluZUNvbEluZGV4ID4gMCkge1xyXG5cdFx0Y2VsbEJlZm9yZSA9IGJvZHlbdkxpbmVSb3dJbmRleF1bYmVmb3JlVkxpbmVDb2xJbmRleF07XHJcblx0XHRpZiAoY2VsbEJlZm9yZSAmJiBjZWxsQmVmb3JlLmJvcmRlckNvbG9yKSB7XHJcblx0XHRcdGlmIChjZWxsQmVmb3JlLmJvcmRlciA/IGNlbGxCZWZvcmUuYm9yZGVyWzJdIDogdGhpcy5sYXlvdXQuZGVmYXVsdEJvcmRlcikge1xyXG5cdFx0XHRcdGJvcmRlckNvbG9yID0gY2VsbEJlZm9yZS5ib3JkZXJDb2xvclsyXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gdGhlIGN1cnJlbnQgY2VsbFxyXG5cdGlmIChib3JkZXJDb2xvciA9PSBudWxsICYmIHZMaW5lQ29sSW5kZXggPCBib2R5Lmxlbmd0aCkge1xyXG5cdFx0Y3VycmVudENlbGwgPSBib2R5W3ZMaW5lUm93SW5kZXhdW3ZMaW5lQ29sSW5kZXhdO1xyXG5cdFx0aWYgKGN1cnJlbnRDZWxsICYmIGN1cnJlbnRDZWxsLmJvcmRlckNvbG9yKSB7XHJcblx0XHRcdGlmIChjdXJyZW50Q2VsbC5ib3JkZXIgPyBjdXJyZW50Q2VsbC5ib3JkZXJbMF0gOiB0aGlzLmxheW91dC5kZWZhdWx0Qm9yZGVyKSB7XHJcblx0XHRcdFx0Ym9yZGVyQ29sb3IgPSBjdXJyZW50Q2VsbC5ib3JkZXJDb2xvclswXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKGJvcmRlckNvbG9yID09IG51bGwgJiYgY2VsbEJlZm9yZSAmJiBjZWxsQmVmb3JlLl9yb3dTcGFuQ3VycmVudE9mZnNldCkge1xyXG5cdFx0dmFyIHJvd0NlbGxCZWZvcmVBYm92ZSA9IGJvZHlbdkxpbmVSb3dJbmRleCAtIGNlbGxCZWZvcmUuX3Jvd1NwYW5DdXJyZW50T2Zmc2V0XVtiZWZvcmVWTGluZUNvbEluZGV4XTtcclxuXHRcdGlmIChyb3dDZWxsQmVmb3JlQWJvdmUuYm9yZGVyQ29sb3IpIHtcclxuXHRcdFx0aWYgKHJvd0NlbGxCZWZvcmVBYm92ZS5ib3JkZXIgPyByb3dDZWxsQmVmb3JlQWJvdmUuYm9yZGVyWzJdIDogdGhpcy5sYXlvdXQuZGVmYXVsdEJvcmRlcikge1xyXG5cdFx0XHRcdGJvcmRlckNvbG9yID0gcm93Q2VsbEJlZm9yZUFib3ZlLmJvcmRlckNvbG9yWzJdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZiAoYm9yZGVyQ29sb3IgPT0gbnVsbCAmJiBjdXJyZW50Q2VsbCAmJiBjdXJyZW50Q2VsbC5fcm93U3BhbkN1cnJlbnRPZmZzZXQpIHtcclxuXHRcdHZhciByb3dDdXJyZW50Q2VsbEFib3ZlID0gYm9keVt2TGluZVJvd0luZGV4IC0gY3VycmVudENlbGwuX3Jvd1NwYW5DdXJyZW50T2Zmc2V0XVt2TGluZUNvbEluZGV4XTtcclxuXHRcdGlmIChyb3dDdXJyZW50Q2VsbEFib3ZlLmJvcmRlckNvbG9yKSB7XHJcblx0XHRcdGlmIChyb3dDdXJyZW50Q2VsbEFib3ZlLmJvcmRlciA/IHJvd0N1cnJlbnRDZWxsQWJvdmUuYm9yZGVyWzJdIDogdGhpcy5sYXlvdXQuZGVmYXVsdEJvcmRlcikge1xyXG5cdFx0XHRcdGJvcmRlckNvbG9yID0gcm93Q3VycmVudENlbGxBYm92ZS5ib3JkZXJDb2xvclsyXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKGJvcmRlckNvbG9yID09IG51bGwpIHtcclxuXHRcdGJvcmRlckNvbG9yID0gaXNGdW5jdGlvbih0aGlzLmxheW91dC52TGluZUNvbG9yKSA/IHRoaXMubGF5b3V0LnZMaW5lQ29sb3IodkxpbmVDb2xJbmRleCwgdGhpcy50YWJsZU5vZGUsIHZMaW5lUm93SW5kZXgpIDogdGhpcy5sYXlvdXQudkxpbmVDb2xvcjtcclxuXHR9XHJcblx0d3JpdGVyLmFkZFZlY3Rvcih7XHJcblx0XHR0eXBlOiAnbGluZScsXHJcblx0XHR4MTogeCArIHdpZHRoIC8gMixcclxuXHRcdHgyOiB4ICsgd2lkdGggLyAyLFxyXG5cdFx0eTE6IHkwLFxyXG5cdFx0eTI6IHkxLFxyXG5cdFx0bGluZVdpZHRoOiB3aWR0aCxcclxuXHRcdGRhc2g6IGRhc2gsXHJcblx0XHRsaW5lQ29sb3I6IGJvcmRlckNvbG9yXHJcblx0fSwgZmFsc2UsIHRydWUpO1xyXG5cdGNlbGxCZWZvcmUgPSBudWxsO1xyXG5cdGN1cnJlbnRDZWxsID0gbnVsbDtcclxuXHRib3JkZXJDb2xvciA9IG51bGw7XHJcbn07XHJcblxyXG5UYWJsZVByb2Nlc3Nvci5wcm90b3R5cGUuZW5kVGFibGUgPSBmdW5jdGlvbiAod3JpdGVyKSB7XHJcblx0aWYgKHRoaXMuY2xlYW5VcFJlcGVhdGFibGVzKSB7XHJcblx0XHR3cml0ZXIucG9wRnJvbVJlcGVhdGFibGVzKCk7XHJcblx0fVxyXG59O1xyXG5cclxuVGFibGVQcm9jZXNzb3IucHJvdG90eXBlLmVuZFJvdyA9IGZ1bmN0aW9uIChyb3dJbmRleCwgd3JpdGVyLCBwYWdlQnJlYWtzKSB7XHJcblx0dmFyIGwsIGk7XHJcblx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdHdyaXRlci50cmFja2VyLnN0b3BUcmFja2luZygncGFnZUNoYW5nZWQnLCB0aGlzLnJvd0NhbGxiYWNrKTtcclxuXHR3cml0ZXIuY29udGV4dCgpLm1vdmVEb3duKHRoaXMubGF5b3V0LnBhZGRpbmdCb3R0b20ocm93SW5kZXgsIHRoaXMudGFibGVOb2RlKSk7XHJcblx0d3JpdGVyLmNvbnRleHQoKS5hdmFpbGFibGVIZWlnaHQgKz0gdGhpcy5yZXNlcnZlZEF0Qm90dG9tO1xyXG5cclxuXHR2YXIgZW5kaW5nUGFnZSA9IHdyaXRlci5jb250ZXh0KCkucGFnZTtcclxuXHR2YXIgZW5kaW5nWSA9IHdyaXRlci5jb250ZXh0KCkueTtcclxuXHJcblx0dmFyIHhzID0gZ2V0TGluZVhzKCk7XHJcblxyXG5cdHZhciB5cyA9IFtdO1xyXG5cclxuXHR2YXIgaGFzQnJlYWtzID0gcGFnZUJyZWFrcyAmJiBwYWdlQnJlYWtzLmxlbmd0aCA+IDA7XHJcblx0dmFyIGJvZHkgPSB0aGlzLnRhYmxlTm9kZS50YWJsZS5ib2R5O1xyXG5cclxuXHR5cy5wdXNoKHtcclxuXHRcdHkwOiB0aGlzLnJvd1RvcFksXHJcblx0XHRwYWdlOiBoYXNCcmVha3MgPyBwYWdlQnJlYWtzWzBdLnByZXZQYWdlIDogZW5kaW5nUGFnZVxyXG5cdH0pO1xyXG5cclxuXHRpZiAoaGFzQnJlYWtzKSB7XHJcblx0XHRmb3IgKGkgPSAwLCBsID0gcGFnZUJyZWFrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0dmFyIHBhZ2VCcmVhayA9IHBhZ2VCcmVha3NbaV07XHJcblx0XHRcdHlzW3lzLmxlbmd0aCAtIDFdLnkxID0gcGFnZUJyZWFrLnByZXZZO1xyXG5cclxuXHRcdFx0eXMucHVzaCh7IHkwOiBwYWdlQnJlYWsueSwgcGFnZTogcGFnZUJyZWFrLnByZXZQYWdlICsgMSB9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHlzW3lzLmxlbmd0aCAtIDFdLnkxID0gZW5kaW5nWTtcclxuXHJcblx0dmFyIHNraXBPcnBoYW5lUGFkZGluZyA9ICh5c1swXS55MSAtIHlzWzBdLnkwID09PSB0aGlzLnJvd1BhZGRpbmdUb3ApO1xyXG5cdGlmIChyb3dJbmRleCA9PT0gMCAmJiAhc2tpcE9ycGhhbmVQYWRkaW5nICYmICF0aGlzLnJvd3NXaXRob3V0UGFnZUJyZWFrICYmICF0aGlzLmRvbnRCcmVha1Jvd3MpIHtcclxuXHRcdC8vIERyYXcgdGhlIHRvcCBib3JkZXIgb2YgdGhlIHRhYmxlXHJcblx0XHR2YXIgcGFnZVRhYmxlU3RhcnRlZEF0ID0gbnVsbDtcclxuXHRcdGlmIChwYWdlQnJlYWtzICYmIHBhZ2VCcmVha3MubGVuZ3RoID4gMCkge1xyXG5cdFx0XHQvLyBHZXQgdGhlIHBhZ2Ugd2hlcmUgdGFibGUgc3RhcnRlZCBhdFxyXG5cdFx0XHRwYWdlVGFibGVTdGFydGVkQXQgPSBwYWdlQnJlYWtzWzBdLnByZXZQYWdlO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5kcmF3SG9yaXpvbnRhbExpbmUoMCwgd3JpdGVyLCB0aGlzLl90YWJsZVRvcEJvcmRlclksIGZhbHNlLCBwYWdlVGFibGVTdGFydGVkQXQpO1xyXG5cdH1cclxuXHRmb3IgKHZhciB5aSA9IChza2lwT3JwaGFuZVBhZGRpbmcgPyAxIDogMCksIHlsID0geXMubGVuZ3RoOyB5aSA8IHlsOyB5aSsrKSB7XHJcblx0XHR2YXIgd2lsbEJyZWFrID0geWkgPCB5cy5sZW5ndGggLSAxO1xyXG5cdFx0dmFyIHJvd0JyZWFrV2l0aG91dEhlYWRlciA9ICh5aSA+IDAgJiYgIXRoaXMuaGVhZGVyUm93cyk7XHJcblx0XHR2YXIgaHpMaW5lT2Zmc2V0ID0gcm93QnJlYWtXaXRob3V0SGVhZGVyID8gMCA6IHRoaXMudG9wTGluZVdpZHRoO1xyXG5cdFx0dmFyIHkxID0geXNbeWldLnkwO1xyXG5cdFx0dmFyIHkyID0geXNbeWldLnkxO1xyXG5cclxuXHRcdGlmICh3aWxsQnJlYWspIHtcclxuXHRcdFx0eTIgPSB5MiArIHRoaXMucm93UGFkZGluZ0JvdHRvbTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAod3JpdGVyLmNvbnRleHQoKS5wYWdlICE9IHlzW3lpXS5wYWdlKSB7XHJcblx0XHRcdHdyaXRlci5jb250ZXh0KCkucGFnZSA9IHlzW3lpXS5wYWdlO1xyXG5cclxuXHRcdFx0Ly9UT0RPOiBidWdneSwgYXZhaWxhYmxlSGVpZ2h0IHNob3VsZCBiZSB1cGRhdGVkIG9uIGV2ZXJ5IHBhZ2VDaGFuZ2VkIGV2ZW50XHJcblx0XHRcdC8vIFRhYmxlUHJvY2Vzc29yIHNob3VsZCBiZSBwYWdlQ2hhbmdlZCBsaXN0ZW5lciwgaW5zdGVhZCBvZiBwcm9jZXNzUm93XHJcblx0XHRcdHRoaXMucmVzZXJ2ZWRBdEJvdHRvbSA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRHJhdyBob3Jpem9udGFsIGxpbmVzIGJlZm9yZSB0aGUgdmVydGljYWwgbGluZXMgc28gdGhleSBhcmUgbm90IG92ZXJyaWRkZW5cclxuXHRcdGlmICh3aWxsQnJlYWsgJiYgdGhpcy5sYXlvdXQuaExpbmVXaGVuQnJva2VuICE9PSBmYWxzZSkge1xyXG5cdFx0XHR0aGlzLmRyYXdIb3Jpem9udGFsTGluZShyb3dJbmRleCArIDEsIHdyaXRlciwgeTIpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHJvd0JyZWFrV2l0aG91dEhlYWRlciAmJiB0aGlzLmxheW91dC5oTGluZVdoZW5Ccm9rZW4gIT09IGZhbHNlKSB7XHJcblx0XHRcdHRoaXMuZHJhd0hvcml6b250YWxMaW5lKHJvd0luZGV4LCB3cml0ZXIsIHkxKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRcdHZhciBsZWZ0Q2VsbEJvcmRlciA9IGZhbHNlO1xyXG5cdFx0XHR2YXIgcmlnaHRDZWxsQm9yZGVyID0gZmFsc2U7XHJcblx0XHRcdHZhciBjb2xJbmRleCA9IHhzW2ldLmluZGV4O1xyXG5cclxuXHRcdFx0Ly8gY3VycmVudCBjZWxsXHJcblx0XHRcdGlmIChjb2xJbmRleCA8IGJvZHlbcm93SW5kZXhdLmxlbmd0aCkge1xyXG5cdFx0XHRcdHZhciBjZWxsID0gYm9keVtyb3dJbmRleF1bY29sSW5kZXhdO1xyXG5cdFx0XHRcdGxlZnRDZWxsQm9yZGVyID0gY2VsbC5ib3JkZXIgPyBjZWxsLmJvcmRlclswXSA6IHRoaXMubGF5b3V0LmRlZmF1bHRCb3JkZXI7XHJcblx0XHRcdFx0cmlnaHRDZWxsQm9yZGVyID0gY2VsbC5ib3JkZXIgPyBjZWxsLmJvcmRlclsyXSA6IHRoaXMubGF5b3V0LmRlZmF1bHRCb3JkZXI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGJlZm9yZSBjZWxsXHJcblx0XHRcdGlmIChjb2xJbmRleCA+IDAgJiYgIWxlZnRDZWxsQm9yZGVyKSB7XHJcblx0XHRcdFx0dmFyIGNlbGwgPSBib2R5W3Jvd0luZGV4XVtjb2xJbmRleCAtIDFdO1xyXG5cdFx0XHRcdGxlZnRDZWxsQm9yZGVyID0gY2VsbC5ib3JkZXIgPyBjZWxsLmJvcmRlclsyXSA6IHRoaXMubGF5b3V0LmRlZmF1bHRCb3JkZXI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGFmdGVyIGNlbGxcclxuXHRcdFx0aWYgKGNvbEluZGV4ICsgMSA8IGJvZHlbcm93SW5kZXhdLmxlbmd0aCAmJiAhcmlnaHRDZWxsQm9yZGVyKSB7XHJcblx0XHRcdFx0dmFyIGNlbGwgPSBib2R5W3Jvd0luZGV4XVtjb2xJbmRleCArIDFdO1xyXG5cdFx0XHRcdHJpZ2h0Q2VsbEJvcmRlciA9IGNlbGwuYm9yZGVyID8gY2VsbC5ib3JkZXJbMF0gOiB0aGlzLmxheW91dC5kZWZhdWx0Qm9yZGVyO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAobGVmdENlbGxCb3JkZXIpIHtcclxuXHRcdFx0XHR0aGlzLmRyYXdWZXJ0aWNhbExpbmUoeHNbaV0ueCwgeTEgLSBoekxpbmVPZmZzZXQsIHkyICsgdGhpcy5ib3R0b21MaW5lV2lkdGgsIHhzW2ldLmluZGV4LCB3cml0ZXIsIHJvd0luZGV4LCB4c1tpIC0gMV0gPyB4c1tpIC0gMV0uaW5kZXggOiBudWxsKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGkgPCBsIC0gMSkge1xyXG5cdFx0XHRcdHZhciBmaWxsQ29sb3IgPSBib2R5W3Jvd0luZGV4XVtjb2xJbmRleF0uZmlsbENvbG9yO1xyXG5cdFx0XHRcdHZhciBmaWxsT3BhY2l0eSA9IGJvZHlbcm93SW5kZXhdW2NvbEluZGV4XS5maWxsT3BhY2l0eTtcclxuXHRcdFx0XHRpZiAoIWZpbGxDb2xvcikge1xyXG5cdFx0XHRcdFx0ZmlsbENvbG9yID0gaXNGdW5jdGlvbih0aGlzLmxheW91dC5maWxsQ29sb3IpID8gdGhpcy5sYXlvdXQuZmlsbENvbG9yKHJvd0luZGV4LCB0aGlzLnRhYmxlTm9kZSwgY29sSW5kZXgpIDogdGhpcy5sYXlvdXQuZmlsbENvbG9yO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoIWlzTnVtYmVyKGZpbGxPcGFjaXR5KSkge1xyXG5cdFx0XHRcdFx0ZmlsbE9wYWNpdHkgPSBpc0Z1bmN0aW9uKHRoaXMubGF5b3V0LmZpbGxPcGFjaXR5KSA/IHRoaXMubGF5b3V0LmZpbGxPcGFjaXR5KHJvd0luZGV4LCB0aGlzLnRhYmxlTm9kZSwgY29sSW5kZXgpIDogdGhpcy5sYXlvdXQuZmlsbE9wYWNpdHk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciBvdmVybGF5UGF0dGVybiA9IGJvZHlbcm93SW5kZXhdW2NvbEluZGV4XS5vdmVybGF5UGF0dGVybjtcclxuXHRcdFx0XHR2YXIgb3ZlcmxheU9wYWNpdHkgPSBib2R5W3Jvd0luZGV4XVtjb2xJbmRleF0ub3ZlcmxheU9wYWNpdHk7XHJcblx0XHRcdFx0aWYgKGZpbGxDb2xvciB8fCBvdmVybGF5UGF0dGVybikge1xyXG5cdFx0XHRcdFx0dmFyIHdpZHRoTGVmdEJvcmRlciA9IGxlZnRDZWxsQm9yZGVyID8gdGhpcy5sYXlvdXQudkxpbmVXaWR0aChjb2xJbmRleCwgdGhpcy50YWJsZU5vZGUpIDogMDtcclxuXHRcdFx0XHRcdHZhciB3aWR0aFJpZ2h0Qm9yZGVyO1xyXG5cdFx0XHRcdFx0aWYgKChjb2xJbmRleCA9PT0gMCB8fCBjb2xJbmRleCArIDEgPT0gYm9keVtyb3dJbmRleF0ubGVuZ3RoKSAmJiAhcmlnaHRDZWxsQm9yZGVyKSB7XHJcblx0XHRcdFx0XHRcdHdpZHRoUmlnaHRCb3JkZXIgPSB0aGlzLmxheW91dC52TGluZVdpZHRoKGNvbEluZGV4ICsgMSwgdGhpcy50YWJsZU5vZGUpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChyaWdodENlbGxCb3JkZXIpIHtcclxuXHRcdFx0XHRcdFx0d2lkdGhSaWdodEJvcmRlciA9IHRoaXMubGF5b3V0LnZMaW5lV2lkdGgoY29sSW5kZXggKyAxLCB0aGlzLnRhYmxlTm9kZSkgLyAyO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0d2lkdGhSaWdodEJvcmRlciA9IDA7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dmFyIHgxZiA9IHRoaXMuZG9udEJyZWFrUm93cyA/IHhzW2ldLnggKyB3aWR0aExlZnRCb3JkZXIgOiB4c1tpXS54ICsgKHdpZHRoTGVmdEJvcmRlciAvIDIpO1xyXG5cdFx0XHRcdFx0dmFyIHkxZiA9IHRoaXMuZG9udEJyZWFrUm93cyA/IHkxIDogeTEgLSAoaHpMaW5lT2Zmc2V0IC8gMik7XHJcblx0XHRcdFx0XHR2YXIgeDJmID0geHNbaSArIDFdLnggKyB3aWR0aFJpZ2h0Qm9yZGVyO1xyXG5cdFx0XHRcdFx0dmFyIHkyZiA9IHRoaXMuZG9udEJyZWFrUm93cyA/IHkyICsgdGhpcy5ib3R0b21MaW5lV2lkdGggOiB5MiArICh0aGlzLmJvdHRvbUxpbmVXaWR0aCAvIDIpO1xyXG5cdFx0XHRcdFx0dmFyIGJnV2lkdGggPSB4MmYgLSB4MWY7XHJcblx0XHRcdFx0XHR2YXIgYmdIZWlnaHQgPSB5MmYgLSB5MWY7XHJcblx0XHRcdFx0XHRpZiAoZmlsbENvbG9yKSB7XHJcblx0XHRcdFx0XHRcdHdyaXRlci5hZGRWZWN0b3Ioe1xyXG5cdFx0XHRcdFx0XHRcdHR5cGU6ICdyZWN0JyxcclxuXHRcdFx0XHRcdFx0XHR4OiB4MWYsXHJcblx0XHRcdFx0XHRcdFx0eTogeTFmLFxyXG5cdFx0XHRcdFx0XHRcdHc6IGJnV2lkdGgsXHJcblx0XHRcdFx0XHRcdFx0aDogYmdIZWlnaHQsXHJcblx0XHRcdFx0XHRcdFx0bGluZVdpZHRoOiAwLFxyXG5cdFx0XHRcdFx0XHRcdGNvbG9yOiBmaWxsQ29sb3IsXHJcblx0XHRcdFx0XHRcdFx0ZmlsbE9wYWNpdHk6IGZpbGxPcGFjaXR5LFxyXG5cdFx0XHRcdFx0XHRcdC8vIG1hcmsgaWYgd2UgYXJlIGluIGFuIHVuYnJlYWthYmxlIGJsb2NrXHJcblx0XHRcdFx0XHRcdFx0X2lzRmlsbENvbG9yRnJvbVVuYnJlYWthYmxlOiAhIXdyaXRlci50cmFuc2FjdGlvbkxldmVsXHJcblx0XHRcdFx0XHRcdH0sIGZhbHNlLCB0cnVlLCB3cml0ZXIuY29udGV4dCgpLmJhY2tncm91bmRMZW5ndGhbd3JpdGVyLmNvbnRleHQoKS5wYWdlXSk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKG92ZXJsYXlQYXR0ZXJuKSB7XHJcblx0XHRcdFx0XHRcdHdyaXRlci5hZGRWZWN0b3Ioe1xyXG5cdFx0XHRcdFx0XHRcdHR5cGU6ICdyZWN0JyxcclxuXHRcdFx0XHRcdFx0XHR4OiB4MWYsXHJcblx0XHRcdFx0XHRcdFx0eTogeTFmLFxyXG5cdFx0XHRcdFx0XHRcdHc6IGJnV2lkdGgsXHJcblx0XHRcdFx0XHRcdFx0aDogYmdIZWlnaHQsXHJcblx0XHRcdFx0XHRcdFx0bGluZVdpZHRoOiAwLFxyXG5cdFx0XHRcdFx0XHRcdGNvbG9yOiBvdmVybGF5UGF0dGVybixcclxuXHRcdFx0XHRcdFx0XHRmaWxsT3BhY2l0eTogb3ZlcmxheU9wYWNpdHlcclxuXHRcdFx0XHRcdFx0fSwgZmFsc2UsIHRydWUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0d3JpdGVyLmNvbnRleHQoKS5wYWdlID0gZW5kaW5nUGFnZTtcclxuXHR3cml0ZXIuY29udGV4dCgpLnkgPSBlbmRpbmdZO1xyXG5cclxuXHR2YXIgcm93ID0gdGhpcy50YWJsZU5vZGUudGFibGUuYm9keVtyb3dJbmRleF07XHJcblx0Zm9yIChpID0gMCwgbCA9IHJvdy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdGlmIChyb3dbaV0ucm93U3Bhbikge1xyXG5cdFx0XHR0aGlzLnJvd1NwYW5EYXRhW2ldLnJvd1NwYW4gPSByb3dbaV0ucm93U3BhbjtcclxuXHJcblx0XHRcdC8vIGZpeCBjb2xTcGFuc1xyXG5cdFx0XHRpZiAocm93W2ldLmNvbFNwYW4gJiYgcm93W2ldLmNvbFNwYW4gPiAxKSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDE7IGogPCByb3dbaV0ucm93U3BhbjsgaisrKSB7XHJcblx0XHRcdFx0XHR0aGlzLnRhYmxlTm9kZS50YWJsZS5ib2R5W3Jvd0luZGV4ICsgal1baV0uX2NvbFNwYW4gPSByb3dbaV0uY29sU3BhbjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gZml4IHJvd1NwYW5zXHJcblx0XHRcdGlmIChyb3dbaV0ucm93U3BhbiAmJiByb3dbaV0ucm93U3BhbiA+IDEpIHtcclxuXHRcdFx0XHRmb3IgKHZhciBqID0gMTsgaiA8IHJvd1tpXS5yb3dTcGFuOyBqKyspIHtcclxuXHRcdFx0XHRcdHRoaXMudGFibGVOb2RlLnRhYmxlLmJvZHlbcm93SW5kZXggKyBqXVtpXS5fcm93U3BhbkN1cnJlbnRPZmZzZXQgPSBqO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLnJvd1NwYW5EYXRhW2ldLnJvd1NwYW4gPiAwKSB7XHJcblx0XHRcdHRoaXMucm93U3BhbkRhdGFbaV0ucm93U3Bhbi0tO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dGhpcy5kcmF3SG9yaXpvbnRhbExpbmUocm93SW5kZXggKyAxLCB3cml0ZXIpO1xyXG5cclxuXHRpZiAodGhpcy5oZWFkZXJSb3dzICYmIHJvd0luZGV4ID09PSB0aGlzLmhlYWRlclJvd3MgLSAxKSB7XHJcblx0XHR0aGlzLmhlYWRlclJlcGVhdGFibGUgPSB3cml0ZXIuY3VycmVudEJsb2NrVG9SZXBlYXRhYmxlKCk7XHJcblx0fVxyXG5cclxuXHRpZiAodGhpcy5kb250QnJlYWtSb3dzKSB7XHJcblx0XHR3cml0ZXIudHJhY2tlci5hdXRvKCdwYWdlQ2hhbmdlZCcsXHJcblx0XHRcdGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRpZiAocm93SW5kZXggPiAwICYmICFzZWxmLmhlYWRlclJvd3MgJiYgc2VsZi5sYXlvdXQuaExpbmVXaGVuQnJva2VuICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0Ly8gRHJhdyB0aGUgdG9wIGJvcmRlciBvZiB0aGUgcm93IGFmdGVyIGEgcGFnZSBicmVha1xyXG5cdFx0XHRcdFx0c2VsZi5kcmF3SG9yaXpvbnRhbExpbmUocm93SW5kZXgsIHdyaXRlcik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0d3JpdGVyLmNvbW1pdFVuYnJlYWthYmxlQmxvY2soKTtcclxuXHRcdFx0fVxyXG5cdFx0KTtcclxuXHR9XHJcblxyXG5cdGlmICh0aGlzLmhlYWRlclJlcGVhdGFibGUgJiYgKHJvd0luZGV4ID09PSAodGhpcy5yb3dzV2l0aG91dFBhZ2VCcmVhayAtIDEpIHx8IHJvd0luZGV4ID09PSB0aGlzLnRhYmxlTm9kZS50YWJsZS5ib2R5Lmxlbmd0aCAtIDEpKSB7XHJcblx0XHR3cml0ZXIuY29tbWl0VW5icmVha2FibGVCbG9jaygpO1xyXG5cdFx0d3JpdGVyLnB1c2hUb1JlcGVhdGFibGVzKHRoaXMuaGVhZGVyUmVwZWF0YWJsZSk7XHJcblx0XHR0aGlzLmNsZWFuVXBSZXBlYXRhYmxlcyA9IHRydWU7XHJcblx0XHR0aGlzLmhlYWRlclJlcGVhdGFibGUgPSBudWxsO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0TGluZVhzKCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0dmFyIGNvbHMgPSAwO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VsZi50YWJsZU5vZGUudGFibGUuYm9keVtyb3dJbmRleF0ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRcdGlmICghY29scykge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKHsgeDogc2VsZi5yb3dTcGFuRGF0YVtpXS5sZWZ0LCBpbmRleDogaSB9KTtcclxuXHJcblx0XHRcdFx0dmFyIGl0ZW0gPSBzZWxmLnRhYmxlTm9kZS50YWJsZS5ib2R5W3Jvd0luZGV4XVtpXTtcclxuXHRcdFx0XHRjb2xzID0gKGl0ZW0uX2NvbFNwYW4gfHwgaXRlbS5jb2xTcGFuIHx8IDApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChjb2xzID4gMCkge1xyXG5cdFx0XHRcdGNvbHMtLTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJlc3VsdC5wdXNoKHsgeDogc2VsZi5yb3dTcGFuRGF0YVtzZWxmLnJvd1NwYW5EYXRhLmxlbmd0aCAtIDFdLmxlZnQsIGluZGV4OiBzZWxmLnJvd1NwYW5EYXRhLmxlbmd0aCAtIDEgfSk7XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFRhYmxlUHJvY2Vzc29yO1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/tableProcessor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/textDecorator.js":
/*!***************************************************!*\
  !*** ./node_modules/pdfmake/src/textDecorator.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar isArray = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isArray);\r\nvar isPattern = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isPattern);\r\nvar getPattern = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").getPattern);\r\n\r\nfunction groupDecorations(line) {\r\n\tvar groups = [], currentGroup = null;\r\n\tfor (var i = 0, l = line.inlines.length; i < l; i++) {\r\n\t\tvar inline = line.inlines[i];\r\n\t\tvar decoration = inline.decoration;\r\n\t\tif (!decoration) {\r\n\t\t\tcurrentGroup = null;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (!isArray(decoration)) {\r\n\t\t\tdecoration = [decoration];\r\n\t\t}\r\n\t\tvar color = inline.decorationColor || inline.color || 'black';\r\n\t\tvar style = inline.decorationStyle || 'solid';\r\n\t\tfor (var ii = 0, ll = decoration.length; ii < ll; ii++) {\r\n\t\t\tvar decorationItem = decoration[ii];\r\n\t\t\tif (!currentGroup || decorationItem !== currentGroup.decoration ||\r\n\t\t\t\tstyle !== currentGroup.decorationStyle || color !== currentGroup.decorationColor) {\r\n\r\n\t\t\t\tcurrentGroup = {\r\n\t\t\t\t\tline: line,\r\n\t\t\t\t\tdecoration: decorationItem,\r\n\t\t\t\t\tdecorationColor: color,\r\n\t\t\t\t\tdecorationStyle: style,\r\n\t\t\t\t\tinlines: [inline]\r\n\t\t\t\t};\r\n\t\t\t\tgroups.push(currentGroup);\r\n\t\t\t} else {\r\n\t\t\t\tcurrentGroup.inlines.push(inline);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn groups;\r\n}\r\n\r\nfunction drawDecoration(group, x, y, pdfKitDoc) {\r\n\tfunction maxInline() {\r\n\t\tvar max = 0;\r\n\t\tfor (var i = 0, l = group.inlines.length; i < l; i++) {\r\n\t\t\tvar inline = group.inlines[i];\r\n\t\t\tmax = inline.fontSize > max ? i : max;\r\n\t\t}\r\n\t\treturn group.inlines[max];\r\n\t}\r\n\tfunction width() {\r\n\t\tvar sum = 0;\r\n\t\tfor (var i = 0, l = group.inlines.length; i < l; i++) {\r\n\t\t\tvar justifyShift = (group.inlines[i].justifyShift || 0);\r\n\t\t\tsum += group.inlines[i].width + justifyShift;\r\n\t\t}\r\n\t\treturn sum;\r\n\t}\r\n\tvar firstInline = group.inlines[0],\r\n\t\tbiggerInline = maxInline(),\r\n\t\ttotalWidth = width(),\r\n\t\tlineAscent = group.line.getAscenderHeight(),\r\n\t\tascent = biggerInline.font.ascender / 1000 * biggerInline.fontSize,\r\n\t\theight = biggerInline.height,\r\n\t\tdescent = height - ascent;\r\n\r\n\tvar lw = 0.5 + Math.floor(Math.max(biggerInline.fontSize - 8, 0) / 2) * 0.12;\r\n\r\n\tswitch (group.decoration) {\r\n\t\tcase 'underline':\r\n\t\t\ty += lineAscent + descent * 0.45;\r\n\t\t\tbreak;\r\n\t\tcase 'overline':\r\n\t\t\ty += lineAscent - (ascent * 0.85);\r\n\t\t\tbreak;\r\n\t\tcase 'lineThrough':\r\n\t\t\ty += lineAscent - (ascent * 0.25);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow 'Unknown decoration : ' + group.decoration;\r\n\t}\r\n\tpdfKitDoc.save();\r\n\r\n\tif (group.decorationStyle === 'double') {\r\n\t\tvar gap = Math.max(0.5, lw * 2);\r\n\t\tpdfKitDoc.fillColor(group.decorationColor)\r\n\t\t\t.rect(x + firstInline.x, y - lw / 2, totalWidth, lw / 2).fill()\r\n\t\t\t.rect(x + firstInline.x, y + gap - lw / 2, totalWidth, lw / 2).fill();\r\n\t} else if (group.decorationStyle === 'dashed') {\r\n\t\tvar nbDashes = Math.ceil(totalWidth / (3.96 + 2.84));\r\n\t\tvar rdx = x + firstInline.x;\r\n\t\tpdfKitDoc.rect(rdx, y, totalWidth, lw).clip();\r\n\t\tpdfKitDoc.fillColor(group.decorationColor);\r\n\t\tfor (var i = 0; i < nbDashes; i++) {\r\n\t\t\tpdfKitDoc.rect(rdx, y - lw / 2, 3.96, lw).fill();\r\n\t\t\trdx += 3.96 + 2.84;\r\n\t\t}\r\n\t} else if (group.decorationStyle === 'dotted') {\r\n\t\tvar nbDots = Math.ceil(totalWidth / (lw * 3));\r\n\t\tvar rx = x + firstInline.x;\r\n\t\tpdfKitDoc.rect(rx, y, totalWidth, lw).clip();\r\n\t\tpdfKitDoc.fillColor(group.decorationColor);\r\n\t\tfor (var ii = 0; ii < nbDots; ii++) {\r\n\t\t\tpdfKitDoc.rect(rx, y - lw / 2, lw, lw).fill();\r\n\t\t\trx += (lw * 3);\r\n\t\t}\r\n\t} else if (group.decorationStyle === 'wavy') {\r\n\t\tvar sh = 0.7, sv = 1;\r\n\t\tvar nbWaves = Math.ceil(totalWidth / (sh * 2)) + 1;\r\n\t\tvar rwx = x + firstInline.x - 1;\r\n\t\tpdfKitDoc.rect(x + firstInline.x, y - sv, totalWidth, y + sv).clip();\r\n\t\tpdfKitDoc.lineWidth(0.24);\r\n\t\tpdfKitDoc.moveTo(rwx, y);\r\n\t\tfor (var iii = 0; iii < nbWaves; iii++) {\r\n\t\t\tpdfKitDoc.bezierCurveTo(rwx + sh, y - sv, rwx + sh * 2, y - sv, rwx + sh * 3, y)\r\n\t\t\t\t.bezierCurveTo(rwx + sh * 4, y + sv, rwx + sh * 5, y + sv, rwx + sh * 6, y);\r\n\t\t\trwx += sh * 6;\r\n\t\t}\r\n\t\tpdfKitDoc.stroke(group.decorationColor);\r\n\t} else {\r\n\t\tpdfKitDoc.fillColor(group.decorationColor)\r\n\t\t\t.rect(x + firstInline.x, y - lw / 2, totalWidth, lw)\r\n\t\t\t.fill();\r\n\t}\r\n\tpdfKitDoc.restore();\r\n}\r\n\r\nfunction drawDecorations(line, x, y, pdfKitDoc) {\r\n\tvar groups = groupDecorations(line);\r\n\tfor (var i = 0, l = groups.length; i < l; i++) {\r\n\t\tdrawDecoration(groups[i], x, y, pdfKitDoc);\r\n\t}\r\n}\r\n\r\nfunction drawBackground(line, x, y, patterns, pdfKitDoc) {\r\n\tvar height = line.getHeight();\r\n\tfor (var i = 0, l = line.inlines.length; i < l; i++) {\r\n\t\tvar inline = line.inlines[i];\r\n\t\tif (!inline.background) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tvar color = inline.background;\r\n\t\tif (isPattern(inline.background)) {\r\n\t\t\tcolor = getPattern(inline.background, patterns);\r\n\t\t}\r\n\t\tvar justifyShift = (inline.justifyShift || 0);\r\n\t\tpdfKitDoc.fillColor(color)\r\n\t\t\t.rect(x + inline.x - justifyShift, y, inline.width + justifyShift, height)\r\n\t\t\t.fill();\r\n\t}\r\n}\r\n\r\nmodule.exports = {\r\n\tdrawBackground: drawBackground,\r\n\tdrawDecorations: drawDecorations\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvdGV4dERlY29yYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsY0FBYyw2RkFBNEI7QUFDMUMsZ0JBQWdCLCtGQUE4QjtBQUM5QyxpQkFBaUIsZ0dBQStCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9nYXNjYXQvcHJpc21hcXVhbnQvcHJpc21hLXF1YW50dW0vbm9kZV9tb2R1bGVzL3BkZm1ha2Uvc3JjL3RleHREZWNvcmF0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc0FycmF5O1xyXG52YXIgaXNQYXR0ZXJuID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuaXNQYXR0ZXJuO1xyXG52YXIgZ2V0UGF0dGVybiA9IHJlcXVpcmUoJy4vaGVscGVycycpLmdldFBhdHRlcm47XHJcblxyXG5mdW5jdGlvbiBncm91cERlY29yYXRpb25zKGxpbmUpIHtcclxuXHR2YXIgZ3JvdXBzID0gW10sIGN1cnJlbnRHcm91cCA9IG51bGw7XHJcblx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lLmlubGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHR2YXIgaW5saW5lID0gbGluZS5pbmxpbmVzW2ldO1xyXG5cdFx0dmFyIGRlY29yYXRpb24gPSBpbmxpbmUuZGVjb3JhdGlvbjtcclxuXHRcdGlmICghZGVjb3JhdGlvbikge1xyXG5cdFx0XHRjdXJyZW50R3JvdXAgPSBudWxsO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHRcdGlmICghaXNBcnJheShkZWNvcmF0aW9uKSkge1xyXG5cdFx0XHRkZWNvcmF0aW9uID0gW2RlY29yYXRpb25dO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGNvbG9yID0gaW5saW5lLmRlY29yYXRpb25Db2xvciB8fCBpbmxpbmUuY29sb3IgfHwgJ2JsYWNrJztcclxuXHRcdHZhciBzdHlsZSA9IGlubGluZS5kZWNvcmF0aW9uU3R5bGUgfHwgJ3NvbGlkJztcclxuXHRcdGZvciAodmFyIGlpID0gMCwgbGwgPSBkZWNvcmF0aW9uLmxlbmd0aDsgaWkgPCBsbDsgaWkrKykge1xyXG5cdFx0XHR2YXIgZGVjb3JhdGlvbkl0ZW0gPSBkZWNvcmF0aW9uW2lpXTtcclxuXHRcdFx0aWYgKCFjdXJyZW50R3JvdXAgfHwgZGVjb3JhdGlvbkl0ZW0gIT09IGN1cnJlbnRHcm91cC5kZWNvcmF0aW9uIHx8XHJcblx0XHRcdFx0c3R5bGUgIT09IGN1cnJlbnRHcm91cC5kZWNvcmF0aW9uU3R5bGUgfHwgY29sb3IgIT09IGN1cnJlbnRHcm91cC5kZWNvcmF0aW9uQ29sb3IpIHtcclxuXHJcblx0XHRcdFx0Y3VycmVudEdyb3VwID0ge1xyXG5cdFx0XHRcdFx0bGluZTogbGluZSxcclxuXHRcdFx0XHRcdGRlY29yYXRpb246IGRlY29yYXRpb25JdGVtLFxyXG5cdFx0XHRcdFx0ZGVjb3JhdGlvbkNvbG9yOiBjb2xvcixcclxuXHRcdFx0XHRcdGRlY29yYXRpb25TdHlsZTogc3R5bGUsXHJcblx0XHRcdFx0XHRpbmxpbmVzOiBbaW5saW5lXVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0Z3JvdXBzLnB1c2goY3VycmVudEdyb3VwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjdXJyZW50R3JvdXAuaW5saW5lcy5wdXNoKGlubGluZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBncm91cHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYXdEZWNvcmF0aW9uKGdyb3VwLCB4LCB5LCBwZGZLaXREb2MpIHtcclxuXHRmdW5jdGlvbiBtYXhJbmxpbmUoKSB7XHJcblx0XHR2YXIgbWF4ID0gMDtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gZ3JvdXAuaW5saW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0dmFyIGlubGluZSA9IGdyb3VwLmlubGluZXNbaV07XHJcblx0XHRcdG1heCA9IGlubGluZS5mb250U2l6ZSA+IG1heCA/IGkgOiBtYXg7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZ3JvdXAuaW5saW5lc1ttYXhdO1xyXG5cdH1cclxuXHRmdW5jdGlvbiB3aWR0aCgpIHtcclxuXHRcdHZhciBzdW0gPSAwO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBncm91cC5pbmxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHR2YXIganVzdGlmeVNoaWZ0ID0gKGdyb3VwLmlubGluZXNbaV0uanVzdGlmeVNoaWZ0IHx8IDApO1xyXG5cdFx0XHRzdW0gKz0gZ3JvdXAuaW5saW5lc1tpXS53aWR0aCArIGp1c3RpZnlTaGlmdDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBzdW07XHJcblx0fVxyXG5cdHZhciBmaXJzdElubGluZSA9IGdyb3VwLmlubGluZXNbMF0sXHJcblx0XHRiaWdnZXJJbmxpbmUgPSBtYXhJbmxpbmUoKSxcclxuXHRcdHRvdGFsV2lkdGggPSB3aWR0aCgpLFxyXG5cdFx0bGluZUFzY2VudCA9IGdyb3VwLmxpbmUuZ2V0QXNjZW5kZXJIZWlnaHQoKSxcclxuXHRcdGFzY2VudCA9IGJpZ2dlcklubGluZS5mb250LmFzY2VuZGVyIC8gMTAwMCAqIGJpZ2dlcklubGluZS5mb250U2l6ZSxcclxuXHRcdGhlaWdodCA9IGJpZ2dlcklubGluZS5oZWlnaHQsXHJcblx0XHRkZXNjZW50ID0gaGVpZ2h0IC0gYXNjZW50O1xyXG5cclxuXHR2YXIgbHcgPSAwLjUgKyBNYXRoLmZsb29yKE1hdGgubWF4KGJpZ2dlcklubGluZS5mb250U2l6ZSAtIDgsIDApIC8gMikgKiAwLjEyO1xyXG5cclxuXHRzd2l0Y2ggKGdyb3VwLmRlY29yYXRpb24pIHtcclxuXHRcdGNhc2UgJ3VuZGVybGluZSc6XHJcblx0XHRcdHkgKz0gbGluZUFzY2VudCArIGRlc2NlbnQgKiAwLjQ1O1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ292ZXJsaW5lJzpcclxuXHRcdFx0eSArPSBsaW5lQXNjZW50IC0gKGFzY2VudCAqIDAuODUpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ2xpbmVUaHJvdWdoJzpcclxuXHRcdFx0eSArPSBsaW5lQXNjZW50IC0gKGFzY2VudCAqIDAuMjUpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRocm93ICdVbmtub3duIGRlY29yYXRpb24gOiAnICsgZ3JvdXAuZGVjb3JhdGlvbjtcclxuXHR9XHJcblx0cGRmS2l0RG9jLnNhdmUoKTtcclxuXHJcblx0aWYgKGdyb3VwLmRlY29yYXRpb25TdHlsZSA9PT0gJ2RvdWJsZScpIHtcclxuXHRcdHZhciBnYXAgPSBNYXRoLm1heCgwLjUsIGx3ICogMik7XHJcblx0XHRwZGZLaXREb2MuZmlsbENvbG9yKGdyb3VwLmRlY29yYXRpb25Db2xvcilcclxuXHRcdFx0LnJlY3QoeCArIGZpcnN0SW5saW5lLngsIHkgLSBsdyAvIDIsIHRvdGFsV2lkdGgsIGx3IC8gMikuZmlsbCgpXHJcblx0XHRcdC5yZWN0KHggKyBmaXJzdElubGluZS54LCB5ICsgZ2FwIC0gbHcgLyAyLCB0b3RhbFdpZHRoLCBsdyAvIDIpLmZpbGwoKTtcclxuXHR9IGVsc2UgaWYgKGdyb3VwLmRlY29yYXRpb25TdHlsZSA9PT0gJ2Rhc2hlZCcpIHtcclxuXHRcdHZhciBuYkRhc2hlcyA9IE1hdGguY2VpbCh0b3RhbFdpZHRoIC8gKDMuOTYgKyAyLjg0KSk7XHJcblx0XHR2YXIgcmR4ID0geCArIGZpcnN0SW5saW5lLng7XHJcblx0XHRwZGZLaXREb2MucmVjdChyZHgsIHksIHRvdGFsV2lkdGgsIGx3KS5jbGlwKCk7XHJcblx0XHRwZGZLaXREb2MuZmlsbENvbG9yKGdyb3VwLmRlY29yYXRpb25Db2xvcik7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5iRGFzaGVzOyBpKyspIHtcclxuXHRcdFx0cGRmS2l0RG9jLnJlY3QocmR4LCB5IC0gbHcgLyAyLCAzLjk2LCBsdykuZmlsbCgpO1xyXG5cdFx0XHRyZHggKz0gMy45NiArIDIuODQ7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmIChncm91cC5kZWNvcmF0aW9uU3R5bGUgPT09ICdkb3R0ZWQnKSB7XHJcblx0XHR2YXIgbmJEb3RzID0gTWF0aC5jZWlsKHRvdGFsV2lkdGggLyAobHcgKiAzKSk7XHJcblx0XHR2YXIgcnggPSB4ICsgZmlyc3RJbmxpbmUueDtcclxuXHRcdHBkZktpdERvYy5yZWN0KHJ4LCB5LCB0b3RhbFdpZHRoLCBsdykuY2xpcCgpO1xyXG5cdFx0cGRmS2l0RG9jLmZpbGxDb2xvcihncm91cC5kZWNvcmF0aW9uQ29sb3IpO1xyXG5cdFx0Zm9yICh2YXIgaWkgPSAwOyBpaSA8IG5iRG90czsgaWkrKykge1xyXG5cdFx0XHRwZGZLaXREb2MucmVjdChyeCwgeSAtIGx3IC8gMiwgbHcsIGx3KS5maWxsKCk7XHJcblx0XHRcdHJ4ICs9IChsdyAqIDMpO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAoZ3JvdXAuZGVjb3JhdGlvblN0eWxlID09PSAnd2F2eScpIHtcclxuXHRcdHZhciBzaCA9IDAuNywgc3YgPSAxO1xyXG5cdFx0dmFyIG5iV2F2ZXMgPSBNYXRoLmNlaWwodG90YWxXaWR0aCAvIChzaCAqIDIpKSArIDE7XHJcblx0XHR2YXIgcnd4ID0geCArIGZpcnN0SW5saW5lLnggLSAxO1xyXG5cdFx0cGRmS2l0RG9jLnJlY3QoeCArIGZpcnN0SW5saW5lLngsIHkgLSBzdiwgdG90YWxXaWR0aCwgeSArIHN2KS5jbGlwKCk7XHJcblx0XHRwZGZLaXREb2MubGluZVdpZHRoKDAuMjQpO1xyXG5cdFx0cGRmS2l0RG9jLm1vdmVUbyhyd3gsIHkpO1xyXG5cdFx0Zm9yICh2YXIgaWlpID0gMDsgaWlpIDwgbmJXYXZlczsgaWlpKyspIHtcclxuXHRcdFx0cGRmS2l0RG9jLmJlemllckN1cnZlVG8ocnd4ICsgc2gsIHkgLSBzdiwgcnd4ICsgc2ggKiAyLCB5IC0gc3YsIHJ3eCArIHNoICogMywgeSlcclxuXHRcdFx0XHQuYmV6aWVyQ3VydmVUbyhyd3ggKyBzaCAqIDQsIHkgKyBzdiwgcnd4ICsgc2ggKiA1LCB5ICsgc3YsIHJ3eCArIHNoICogNiwgeSk7XHJcblx0XHRcdHJ3eCArPSBzaCAqIDY7XHJcblx0XHR9XHJcblx0XHRwZGZLaXREb2Muc3Ryb2tlKGdyb3VwLmRlY29yYXRpb25Db2xvcik7XHJcblx0fSBlbHNlIHtcclxuXHRcdHBkZktpdERvYy5maWxsQ29sb3IoZ3JvdXAuZGVjb3JhdGlvbkNvbG9yKVxyXG5cdFx0XHQucmVjdCh4ICsgZmlyc3RJbmxpbmUueCwgeSAtIGx3IC8gMiwgdG90YWxXaWR0aCwgbHcpXHJcblx0XHRcdC5maWxsKCk7XHJcblx0fVxyXG5cdHBkZktpdERvYy5yZXN0b3JlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYXdEZWNvcmF0aW9ucyhsaW5lLCB4LCB5LCBwZGZLaXREb2MpIHtcclxuXHR2YXIgZ3JvdXBzID0gZ3JvdXBEZWNvcmF0aW9ucyhsaW5lKTtcclxuXHRmb3IgKHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdGRyYXdEZWNvcmF0aW9uKGdyb3Vwc1tpXSwgeCwgeSwgcGRmS2l0RG9jKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKGxpbmUsIHgsIHksIHBhdHRlcm5zLCBwZGZLaXREb2MpIHtcclxuXHR2YXIgaGVpZ2h0ID0gbGluZS5nZXRIZWlnaHQoKTtcclxuXHRmb3IgKHZhciBpID0gMCwgbCA9IGxpbmUuaW5saW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdHZhciBpbmxpbmUgPSBsaW5lLmlubGluZXNbaV07XHJcblx0XHRpZiAoIWlubGluZS5iYWNrZ3JvdW5kKSB7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGNvbG9yID0gaW5saW5lLmJhY2tncm91bmQ7XHJcblx0XHRpZiAoaXNQYXR0ZXJuKGlubGluZS5iYWNrZ3JvdW5kKSkge1xyXG5cdFx0XHRjb2xvciA9IGdldFBhdHRlcm4oaW5saW5lLmJhY2tncm91bmQsIHBhdHRlcm5zKTtcclxuXHRcdH1cclxuXHRcdHZhciBqdXN0aWZ5U2hpZnQgPSAoaW5saW5lLmp1c3RpZnlTaGlmdCB8fCAwKTtcclxuXHRcdHBkZktpdERvYy5maWxsQ29sb3IoY29sb3IpXHJcblx0XHRcdC5yZWN0KHggKyBpbmxpbmUueCAtIGp1c3RpZnlTaGlmdCwgeSwgaW5saW5lLndpZHRoICsganVzdGlmeVNoaWZ0LCBoZWlnaHQpXHJcblx0XHRcdC5maWxsKCk7XHJcblx0fVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHRkcmF3QmFja2dyb3VuZDogZHJhd0JhY2tncm91bmQsXHJcblx0ZHJhd0RlY29yYXRpb25zOiBkcmF3RGVjb3JhdGlvbnNcclxufTtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/textDecorator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/textTools.js":
/*!***********************************************!*\
  !*** ./node_modules/pdfmake/src/textTools.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar isString = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isString);\r\nvar isNumber = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isNumber);\r\nvar isObject = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isObject);\r\nvar isArray = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isArray);\r\nvar isUndefined = (__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/pdfmake/src/helpers.js\").isUndefined);\r\nvar LineBreaker = __webpack_require__(/*! @foliojs-fork/linebreak */ \"(rsc)/./node_modules/@foliojs-fork/linebreak/src/linebreaker.js\");\r\n\r\nvar LEADING = /^(\\s)+/g;\r\nvar TRAILING = /(\\s)+$/g;\r\n\r\n/**\r\n * Creates an instance of TextTools - text measurement utility\r\n *\r\n * @constructor\r\n * @param {FontProvider} fontProvider\r\n */\r\nfunction TextTools(fontProvider) {\r\n\tthis.fontProvider = fontProvider;\r\n}\r\n\r\n/**\r\n * Converts an array of strings (or inline-definition-objects) into a collection\r\n * of inlines and calculated minWidth/maxWidth.\r\n * and their min/max widths\r\n * @param  {Object} textArray - an array of inline-definition-objects (or strings)\r\n * @param  {Object} styleContextStack current style stack\r\n * @return {Object}                   collection of inlines, minWidth, maxWidth\r\n */\r\nTextTools.prototype.buildInlines = function (textArray, styleContextStack) {\r\n\tvar measured = measure(this.fontProvider, textArray, styleContextStack);\r\n\r\n\tvar minWidth = 0,\r\n\t\tmaxWidth = 0,\r\n\t\tcurrentLineWidth;\r\n\r\n\tmeasured.forEach(function (inline) {\r\n\t\tminWidth = Math.max(minWidth, inline.width - inline.leadingCut - inline.trailingCut);\r\n\r\n\t\tif (!currentLineWidth) {\r\n\t\t\tcurrentLineWidth = { width: 0, leadingCut: inline.leadingCut, trailingCut: 0 };\r\n\t\t}\r\n\r\n\t\tcurrentLineWidth.width += inline.width;\r\n\t\tcurrentLineWidth.trailingCut = inline.trailingCut;\r\n\r\n\t\tmaxWidth = Math.max(maxWidth, getTrimmedWidth(currentLineWidth));\r\n\r\n\t\tif (inline.lineEnd) {\r\n\t\t\tcurrentLineWidth = null;\r\n\t\t}\r\n\t});\r\n\r\n\tif (getStyleProperty({}, styleContextStack, 'noWrap', false)) {\r\n\t\tminWidth = maxWidth;\r\n\t}\r\n\r\n\treturn {\r\n\t\titems: measured,\r\n\t\tminWidth: minWidth,\r\n\t\tmaxWidth: maxWidth\r\n\t};\r\n\r\n\tfunction getTrimmedWidth(item) {\r\n\t\treturn Math.max(0, item.width - item.leadingCut - item.trailingCut);\r\n\t}\r\n};\r\n\r\n/**\r\n * Returns size of the specified string (without breaking it) using the current style\r\n * @param  {String} text              text to be measured\r\n * @param  {Object} styleContextStack current style stack\r\n * @return {Object}                   size of the specified string\r\n */\r\nTextTools.prototype.sizeOfString = function (text, styleContextStack) {\r\n\ttext = text ? text.toString().replace(/\\t/g, '    ') : '';\r\n\r\n\t//TODO: refactor - extract from measure\r\n\tvar fontName = getStyleProperty({}, styleContextStack, 'font', 'Roboto');\r\n\tvar fontSize = getStyleProperty({}, styleContextStack, 'fontSize', 12);\r\n\tvar fontFeatures = getStyleProperty({}, styleContextStack, 'fontFeatures', null);\r\n\tvar bold = getStyleProperty({}, styleContextStack, 'bold', false);\r\n\tvar italics = getStyleProperty({}, styleContextStack, 'italics', false);\r\n\tvar lineHeight = getStyleProperty({}, styleContextStack, 'lineHeight', 1);\r\n\tvar characterSpacing = getStyleProperty({}, styleContextStack, 'characterSpacing', 0);\r\n\r\n\tvar font = this.fontProvider.provideFont(fontName, bold, italics);\r\n\r\n\treturn {\r\n\t\twidth: widthOfString(text, font, fontSize, characterSpacing, fontFeatures),\r\n\t\theight: font.lineHeight(fontSize) * lineHeight,\r\n\t\tfontSize: fontSize,\r\n\t\tlineHeight: lineHeight,\r\n\t\tascender: font.ascender / 1000 * fontSize,\r\n\t\tdescender: font.descender / 1000 * fontSize\r\n\t};\r\n};\r\n\r\n/**\r\n * Returns size of the specified rotated string (without breaking it) using the current style\r\n *\r\n * @param  {string} text text to be measured\r\n * @param  {number} angle\r\n * @param  {object} styleContextStack current style stack\r\n * @returns {object} size of the specified string\r\n */\r\nTextTools.prototype.sizeOfRotatedText = function (text, angle, styleContextStack) {\r\n\tvar angleRad = angle * Math.PI / -180;\r\n\tvar size = this.sizeOfString(text, styleContextStack);\r\n\treturn {\r\n\t\twidth: Math.abs(size.height * Math.sin(angleRad)) + Math.abs(size.width * Math.cos(angleRad)),\r\n\t\theight: Math.abs(size.width * Math.sin(angleRad)) + Math.abs(size.height * Math.cos(angleRad))\r\n\t};\r\n};\r\n\r\nTextTools.prototype.widthOfString = function (text, font, fontSize, characterSpacing, fontFeatures) {\r\n\treturn widthOfString(text, font, fontSize, characterSpacing, fontFeatures);\r\n};\r\n\r\nfunction splitWords(text, noWrap) {\r\n\tvar results = [];\r\n\ttext = text.replace(/\\t/g, '    ');\r\n\r\n\tif (noWrap) {\r\n\t\tresults.push({ text: text });\r\n\t\treturn results;\r\n\t}\r\n\r\n\tvar breaker = new LineBreaker(text);\r\n\tvar last = 0;\r\n\tvar bk;\r\n\r\n\twhile (bk = breaker.nextBreak()) {\r\n\t\tvar word = text.slice(last, bk.position);\r\n\r\n\t\tif (bk.required || word.match(/\\r?\\n$|\\r$/)) { // new line\r\n\t\t\tword = word.replace(/\\r?\\n$|\\r$/, '');\r\n\t\t\tresults.push({ text: word, lineEnd: true });\r\n\t\t} else {\r\n\t\t\tresults.push({ text: word });\r\n\t\t}\r\n\r\n\t\tlast = bk.position;\r\n\t}\r\n\r\n\treturn results;\r\n}\r\n\r\nfunction copyStyle(source, destination) {\r\n\tdestination = destination || {};\r\n\tsource = source || {}; //TODO: default style\r\n\r\n\tfor (var key in source) {\r\n\t\tif (key != 'text' && source.hasOwnProperty(key)) {\r\n\t\t\tdestination[key] = source[key];\r\n\t\t}\r\n\t}\r\n\r\n\treturn destination;\r\n}\r\n\r\nfunction normalizeTextArray(array, styleContextStack) {\r\n\tfunction flatten(array) {\r\n\t\treturn array.reduce(function (prev, cur) {\r\n\t\t\tvar current = isArray(cur.text) ? flatten(cur.text) : cur;\r\n\t\t\tvar more = [].concat(current).some(Array.isArray);\r\n\t\t\treturn prev.concat(more ? flatten(current) : current);\r\n\t\t}, []);\r\n\t}\r\n\r\n\tfunction getOneWord(index, words, noWrap) {\r\n\t\tif (isUndefined(words[index])) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tif (words[index].lineEnd) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tvar word = words[index].text;\r\n\r\n\t\tif (noWrap) {\r\n\t\t\tvar tmpWords = splitWords(normalizeString(word), false);\r\n\t\t\tif (isUndefined(tmpWords[tmpWords.length - 1])) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\tword = tmpWords[tmpWords.length - 1].text;\r\n\t\t}\r\n\r\n\t\treturn word;\r\n\t}\r\n\r\n\tvar results = [];\r\n\r\n\tif (!isArray(array)) {\r\n\t\tarray = [array];\r\n\t}\r\n\r\n\tarray = flatten(array);\r\n\r\n\tvar lastWord = null;\r\n\tfor (var i = 0, l = array.length; i < l; i++) {\r\n\t\tvar item = array[i];\r\n\t\tvar style = null;\r\n\t\tvar words;\r\n\r\n\t\tvar noWrap = getStyleProperty(item || {}, styleContextStack, 'noWrap', false);\r\n\t\tif (isObject(item)) {\r\n\t\t\tif (item._textRef && item._textRef._textNodeRef.text) {\r\n\t\t\t\titem.text = item._textRef._textNodeRef.text;\r\n\t\t\t}\r\n\t\t\twords = splitWords(normalizeString(item.text), noWrap);\r\n\t\t\tstyle = copyStyle(item);\r\n\t\t} else {\r\n\t\t\twords = splitWords(normalizeString(item), noWrap);\r\n\t\t}\r\n\r\n\t\tif (lastWord && words.length) {\r\n\t\t\tvar firstWord = getOneWord(0, words, noWrap);\r\n\r\n\t\t\tvar wrapWords = splitWords(normalizeString(lastWord + firstWord), false);\r\n\t\t\tif (wrapWords.length === 1) {\r\n\t\t\t\tresults[results.length - 1].noNewLine = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (var i2 = 0, l2 = words.length; i2 < l2; i2++) {\r\n\t\t\tvar result = {\r\n\t\t\t\ttext: words[i2].text\r\n\t\t\t};\r\n\r\n\t\t\tif (words[i2].lineEnd) {\r\n\t\t\t\tresult.lineEnd = true;\r\n\t\t\t}\r\n\r\n\t\t\tcopyStyle(style, result);\r\n\r\n\t\t\tresults.push(result);\r\n\t\t}\r\n\r\n\t\tlastWord = null;\r\n\t\tif (i + 1 < l) {\r\n\t\t\tlastWord = getOneWord(words.length - 1, words, noWrap);\r\n\t\t}\r\n\t}\r\n\r\n\treturn results;\r\n}\r\n\r\nfunction normalizeString(value) {\r\n\tif (value === undefined || value === null) {\r\n\t\treturn '';\r\n\t} else if (isNumber(value)) {\r\n\t\treturn value.toString();\r\n\t} else if (isString(value)) {\r\n\t\treturn value;\r\n\t} else {\r\n\t\treturn value.toString();\r\n\t}\r\n}\r\n\r\nfunction getStyleProperty(item, styleContextStack, property, defaultValue) {\r\n\tvar value;\r\n\r\n\tif (item[property] !== undefined && item[property] !== null) {\r\n\t\t// item defines this property\r\n\t\treturn item[property];\r\n\t}\r\n\r\n\tif (!styleContextStack) {\r\n\t\treturn defaultValue;\r\n\t}\r\n\r\n\tstyleContextStack.auto(item, function () {\r\n\t\tvalue = styleContextStack.getProperty(property);\r\n\t});\r\n\r\n\tif (value !== null && value !== undefined) {\r\n\t\treturn value;\r\n\t} else {\r\n\t\treturn defaultValue;\r\n\t}\r\n}\r\n\r\nfunction measure(fontProvider, textArray, styleContextStack) {\r\n\tvar normalized = normalizeTextArray(textArray, styleContextStack);\r\n\r\n\tif (normalized.length) {\r\n\t\tvar leadingIndent = getStyleProperty(normalized[0], styleContextStack, 'leadingIndent', 0);\r\n\r\n\t\tif (leadingIndent) {\r\n\t\t\tnormalized[0].leadingCut = -leadingIndent;\r\n\t\t\tnormalized[0].leadingIndent = leadingIndent;\r\n\t\t}\r\n\t}\r\n\r\n\tnormalized.forEach(function (item) {\r\n\t\tvar fontName = getStyleProperty(item, styleContextStack, 'font', 'Roboto');\r\n\t\tvar fontSize = getStyleProperty(item, styleContextStack, 'fontSize', 12);\r\n\t\tvar fontFeatures = getStyleProperty(item, styleContextStack, 'fontFeatures', null);\r\n\t\tvar bold = getStyleProperty(item, styleContextStack, 'bold', false);\r\n\t\tvar italics = getStyleProperty(item, styleContextStack, 'italics', false);\r\n\t\tvar color = getStyleProperty(item, styleContextStack, 'color', 'black');\r\n\t\tvar decoration = getStyleProperty(item, styleContextStack, 'decoration', null);\r\n\t\tvar decorationColor = getStyleProperty(item, styleContextStack, 'decorationColor', null);\r\n\t\tvar decorationStyle = getStyleProperty(item, styleContextStack, 'decorationStyle', null);\r\n\t\tvar background = getStyleProperty(item, styleContextStack, 'background', null);\r\n\t\tvar lineHeight = getStyleProperty(item, styleContextStack, 'lineHeight', 1);\r\n\t\tvar characterSpacing = getStyleProperty(item, styleContextStack, 'characterSpacing', 0);\r\n\t\tvar link = getStyleProperty(item, styleContextStack, 'link', null);\r\n\t\tvar linkToPage = getStyleProperty(item, styleContextStack, 'linkToPage', null);\r\n\t\tvar linkToDestination = getStyleProperty(item, styleContextStack, 'linkToDestination', null);\r\n\t\tvar noWrap = getStyleProperty(item, styleContextStack, 'noWrap', null);\r\n\t\tvar preserveLeadingSpaces = getStyleProperty(item, styleContextStack, 'preserveLeadingSpaces', false);\r\n\t\tvar preserveTrailingSpaces = getStyleProperty(item, styleContextStack, 'preserveTrailingSpaces', false);\r\n\t\tvar opacity = getStyleProperty(item, styleContextStack, 'opacity', 1);\r\n\t\tvar sup = getStyleProperty(item, styleContextStack, 'sup', false);\r\n\t\tvar sub = getStyleProperty(item, styleContextStack, 'sub', false);\r\n\r\n\t\tif ((sup || sub) && item.fontSize === undefined) {\r\n\t\t\t// font size reduction taken from here: https://en.wikipedia.org/wiki/Subscript_and_superscript#Desktop_publishing\r\n\t\t\tfontSize *= 0.58;\r\n\t\t}\r\n\r\n\t\tvar font = fontProvider.provideFont(fontName, bold, italics);\r\n\r\n\t\titem.width = widthOfString(item.text, font, fontSize, characterSpacing, fontFeatures);\r\n\t\titem.height = font.lineHeight(fontSize) * lineHeight;\r\n\r\n\t\tif (!item.leadingCut) {\r\n\t\t\titem.leadingCut = 0;\r\n\t\t}\r\n\r\n\t\tvar leadingSpaces;\r\n\t\tif (!preserveLeadingSpaces && (leadingSpaces = item.text.match(LEADING))) {\r\n\t\t\titem.leadingCut += widthOfString(leadingSpaces[0], font, fontSize, characterSpacing, fontFeatures);\r\n\t\t}\r\n\r\n\t\tvar trailingSpaces;\r\n\t\tif (!preserveTrailingSpaces && (trailingSpaces = item.text.match(TRAILING))) {\r\n\t\t\titem.trailingCut = widthOfString(trailingSpaces[0], font, fontSize, characterSpacing, fontFeatures);\r\n\t\t} else {\r\n\t\t\titem.trailingCut = 0;\r\n\t\t}\r\n\r\n\t\titem.alignment = getStyleProperty(item, styleContextStack, 'alignment', 'left');\r\n\t\titem.font = font;\r\n\t\titem.fontSize = fontSize;\r\n\t\titem.fontFeatures = fontFeatures;\r\n\t\titem.characterSpacing = characterSpacing;\r\n\t\titem.color = color;\r\n\t\titem.decoration = decoration;\r\n\t\titem.decorationColor = decorationColor;\r\n\t\titem.decorationStyle = decorationStyle;\r\n\t\titem.background = background;\r\n\t\titem.link = link;\r\n\t\titem.linkToPage = linkToPage;\r\n\t\titem.linkToDestination = linkToDestination;\r\n\t\titem.noWrap = noWrap;\r\n\t\titem.opacity = opacity;\r\n\t\titem.sup = sup;\r\n\t\titem.sub = sub;\r\n\t});\r\n\r\n\treturn normalized;\r\n}\r\n\r\nfunction widthOfString(text, font, fontSize, characterSpacing, fontFeatures) {\r\n\treturn font.widthOfString(text, fontSize, fontFeatures) + ((characterSpacing || 0) * (text.length - 1));\r\n}\r\n\r\nmodule.exports = TextTools;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvdGV4dFRvb2xzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxlQUFlLDhGQUE2QjtBQUM1QyxlQUFlLDhGQUE2QjtBQUM1QyxlQUFlLDhGQUE2QjtBQUM1QyxjQUFjLDZGQUE0QjtBQUMxQyxrQkFBa0IsaUdBQWdDO0FBQ2xELGtCQUFrQixtQkFBTyxDQUFDLGdHQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyx1Q0FBdUM7QUFDdkMsK0JBQStCO0FBQy9CLGtDQUFrQztBQUNsQyxxQ0FBcUM7QUFDckMsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDLElBQUk7QUFDSixrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvZ2FzY2F0L3ByaXNtYXF1YW50L3ByaXNtYS1xdWFudHVtL25vZGVfbW9kdWxlcy9wZGZtYWtlL3NyYy90ZXh0VG9vbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGlzU3RyaW5nID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuaXNTdHJpbmc7XHJcbnZhciBpc051bWJlciA9IHJlcXVpcmUoJy4vaGVscGVycycpLmlzTnVtYmVyO1xyXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc09iamVjdDtcclxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc0FycmF5O1xyXG52YXIgaXNVbmRlZmluZWQgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5pc1VuZGVmaW5lZDtcclxudmFyIExpbmVCcmVha2VyID0gcmVxdWlyZSgnQGZvbGlvanMtZm9yay9saW5lYnJlYWsnKTtcclxuXHJcbnZhciBMRUFESU5HID0gL14oXFxzKSsvZztcclxudmFyIFRSQUlMSU5HID0gLyhcXHMpKyQvZztcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFRleHRUb29scyAtIHRleHQgbWVhc3VyZW1lbnQgdXRpbGl0eVxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtGb250UHJvdmlkZXJ9IGZvbnRQcm92aWRlclxyXG4gKi9cclxuZnVuY3Rpb24gVGV4dFRvb2xzKGZvbnRQcm92aWRlcikge1xyXG5cdHRoaXMuZm9udFByb3ZpZGVyID0gZm9udFByb3ZpZGVyO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYW4gYXJyYXkgb2Ygc3RyaW5ncyAob3IgaW5saW5lLWRlZmluaXRpb24tb2JqZWN0cykgaW50byBhIGNvbGxlY3Rpb25cclxuICogb2YgaW5saW5lcyBhbmQgY2FsY3VsYXRlZCBtaW5XaWR0aC9tYXhXaWR0aC5cclxuICogYW5kIHRoZWlyIG1pbi9tYXggd2lkdGhzXHJcbiAqIEBwYXJhbSAge09iamVjdH0gdGV4dEFycmF5IC0gYW4gYXJyYXkgb2YgaW5saW5lLWRlZmluaXRpb24tb2JqZWN0cyAob3Igc3RyaW5ncylcclxuICogQHBhcmFtICB7T2JqZWN0fSBzdHlsZUNvbnRleHRTdGFjayBjdXJyZW50IHN0eWxlIHN0YWNrXHJcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbiBvZiBpbmxpbmVzLCBtaW5XaWR0aCwgbWF4V2lkdGhcclxuICovXHJcblRleHRUb29scy5wcm90b3R5cGUuYnVpbGRJbmxpbmVzID0gZnVuY3Rpb24gKHRleHRBcnJheSwgc3R5bGVDb250ZXh0U3RhY2spIHtcclxuXHR2YXIgbWVhc3VyZWQgPSBtZWFzdXJlKHRoaXMuZm9udFByb3ZpZGVyLCB0ZXh0QXJyYXksIHN0eWxlQ29udGV4dFN0YWNrKTtcclxuXHJcblx0dmFyIG1pbldpZHRoID0gMCxcclxuXHRcdG1heFdpZHRoID0gMCxcclxuXHRcdGN1cnJlbnRMaW5lV2lkdGg7XHJcblxyXG5cdG1lYXN1cmVkLmZvckVhY2goZnVuY3Rpb24gKGlubGluZSkge1xyXG5cdFx0bWluV2lkdGggPSBNYXRoLm1heChtaW5XaWR0aCwgaW5saW5lLndpZHRoIC0gaW5saW5lLmxlYWRpbmdDdXQgLSBpbmxpbmUudHJhaWxpbmdDdXQpO1xyXG5cclxuXHRcdGlmICghY3VycmVudExpbmVXaWR0aCkge1xyXG5cdFx0XHRjdXJyZW50TGluZVdpZHRoID0geyB3aWR0aDogMCwgbGVhZGluZ0N1dDogaW5saW5lLmxlYWRpbmdDdXQsIHRyYWlsaW5nQ3V0OiAwIH07XHJcblx0XHR9XHJcblxyXG5cdFx0Y3VycmVudExpbmVXaWR0aC53aWR0aCArPSBpbmxpbmUud2lkdGg7XHJcblx0XHRjdXJyZW50TGluZVdpZHRoLnRyYWlsaW5nQ3V0ID0gaW5saW5lLnRyYWlsaW5nQ3V0O1xyXG5cclxuXHRcdG1heFdpZHRoID0gTWF0aC5tYXgobWF4V2lkdGgsIGdldFRyaW1tZWRXaWR0aChjdXJyZW50TGluZVdpZHRoKSk7XHJcblxyXG5cdFx0aWYgKGlubGluZS5saW5lRW5kKSB7XHJcblx0XHRcdGN1cnJlbnRMaW5lV2lkdGggPSBudWxsO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRpZiAoZ2V0U3R5bGVQcm9wZXJ0eSh7fSwgc3R5bGVDb250ZXh0U3RhY2ssICdub1dyYXAnLCBmYWxzZSkpIHtcclxuXHRcdG1pbldpZHRoID0gbWF4V2lkdGg7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0aXRlbXM6IG1lYXN1cmVkLFxyXG5cdFx0bWluV2lkdGg6IG1pbldpZHRoLFxyXG5cdFx0bWF4V2lkdGg6IG1heFdpZHRoXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gZ2V0VHJpbW1lZFdpZHRoKGl0ZW0pIHtcclxuXHRcdHJldHVybiBNYXRoLm1heCgwLCBpdGVtLndpZHRoIC0gaXRlbS5sZWFkaW5nQ3V0IC0gaXRlbS50cmFpbGluZ0N1dCk7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgc2l6ZSBvZiB0aGUgc3BlY2lmaWVkIHN0cmluZyAod2l0aG91dCBicmVha2luZyBpdCkgdXNpbmcgdGhlIGN1cnJlbnQgc3R5bGVcclxuICogQHBhcmFtICB7U3RyaW5nfSB0ZXh0ICAgICAgICAgICAgICB0ZXh0IHRvIGJlIG1lYXN1cmVkXHJcbiAqIEBwYXJhbSAge09iamVjdH0gc3R5bGVDb250ZXh0U3RhY2sgY3VycmVudCBzdHlsZSBzdGFja1xyXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgIHNpemUgb2YgdGhlIHNwZWNpZmllZCBzdHJpbmdcclxuICovXHJcblRleHRUb29scy5wcm90b3R5cGUuc2l6ZU9mU3RyaW5nID0gZnVuY3Rpb24gKHRleHQsIHN0eWxlQ29udGV4dFN0YWNrKSB7XHJcblx0dGV4dCA9IHRleHQgPyB0ZXh0LnRvU3RyaW5nKCkucmVwbGFjZSgvXFx0L2csICcgICAgJykgOiAnJztcclxuXHJcblx0Ly9UT0RPOiByZWZhY3RvciAtIGV4dHJhY3QgZnJvbSBtZWFzdXJlXHJcblx0dmFyIGZvbnROYW1lID0gZ2V0U3R5bGVQcm9wZXJ0eSh7fSwgc3R5bGVDb250ZXh0U3RhY2ssICdmb250JywgJ1JvYm90bycpO1xyXG5cdHZhciBmb250U2l6ZSA9IGdldFN0eWxlUHJvcGVydHkoe30sIHN0eWxlQ29udGV4dFN0YWNrLCAnZm9udFNpemUnLCAxMik7XHJcblx0dmFyIGZvbnRGZWF0dXJlcyA9IGdldFN0eWxlUHJvcGVydHkoe30sIHN0eWxlQ29udGV4dFN0YWNrLCAnZm9udEZlYXR1cmVzJywgbnVsbCk7XHJcblx0dmFyIGJvbGQgPSBnZXRTdHlsZVByb3BlcnR5KHt9LCBzdHlsZUNvbnRleHRTdGFjaywgJ2JvbGQnLCBmYWxzZSk7XHJcblx0dmFyIGl0YWxpY3MgPSBnZXRTdHlsZVByb3BlcnR5KHt9LCBzdHlsZUNvbnRleHRTdGFjaywgJ2l0YWxpY3MnLCBmYWxzZSk7XHJcblx0dmFyIGxpbmVIZWlnaHQgPSBnZXRTdHlsZVByb3BlcnR5KHt9LCBzdHlsZUNvbnRleHRTdGFjaywgJ2xpbmVIZWlnaHQnLCAxKTtcclxuXHR2YXIgY2hhcmFjdGVyU3BhY2luZyA9IGdldFN0eWxlUHJvcGVydHkoe30sIHN0eWxlQ29udGV4dFN0YWNrLCAnY2hhcmFjdGVyU3BhY2luZycsIDApO1xyXG5cclxuXHR2YXIgZm9udCA9IHRoaXMuZm9udFByb3ZpZGVyLnByb3ZpZGVGb250KGZvbnROYW1lLCBib2xkLCBpdGFsaWNzKTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHdpZHRoOiB3aWR0aE9mU3RyaW5nKHRleHQsIGZvbnQsIGZvbnRTaXplLCBjaGFyYWN0ZXJTcGFjaW5nLCBmb250RmVhdHVyZXMpLFxyXG5cdFx0aGVpZ2h0OiBmb250LmxpbmVIZWlnaHQoZm9udFNpemUpICogbGluZUhlaWdodCxcclxuXHRcdGZvbnRTaXplOiBmb250U2l6ZSxcclxuXHRcdGxpbmVIZWlnaHQ6IGxpbmVIZWlnaHQsXHJcblx0XHRhc2NlbmRlcjogZm9udC5hc2NlbmRlciAvIDEwMDAgKiBmb250U2l6ZSxcclxuXHRcdGRlc2NlbmRlcjogZm9udC5kZXNjZW5kZXIgLyAxMDAwICogZm9udFNpemVcclxuXHR9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgc2l6ZSBvZiB0aGUgc3BlY2lmaWVkIHJvdGF0ZWQgc3RyaW5nICh3aXRob3V0IGJyZWFraW5nIGl0KSB1c2luZyB0aGUgY3VycmVudCBzdHlsZVxyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgdGV4dCB0byBiZSBtZWFzdXJlZFxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlXHJcbiAqIEBwYXJhbSAge29iamVjdH0gc3R5bGVDb250ZXh0U3RhY2sgY3VycmVudCBzdHlsZSBzdGFja1xyXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBzaXplIG9mIHRoZSBzcGVjaWZpZWQgc3RyaW5nXHJcbiAqL1xyXG5UZXh0VG9vbHMucHJvdG90eXBlLnNpemVPZlJvdGF0ZWRUZXh0ID0gZnVuY3Rpb24gKHRleHQsIGFuZ2xlLCBzdHlsZUNvbnRleHRTdGFjaykge1xyXG5cdHZhciBhbmdsZVJhZCA9IGFuZ2xlICogTWF0aC5QSSAvIC0xODA7XHJcblx0dmFyIHNpemUgPSB0aGlzLnNpemVPZlN0cmluZyh0ZXh0LCBzdHlsZUNvbnRleHRTdGFjayk7XHJcblx0cmV0dXJuIHtcclxuXHRcdHdpZHRoOiBNYXRoLmFicyhzaXplLmhlaWdodCAqIE1hdGguc2luKGFuZ2xlUmFkKSkgKyBNYXRoLmFicyhzaXplLndpZHRoICogTWF0aC5jb3MoYW5nbGVSYWQpKSxcclxuXHRcdGhlaWdodDogTWF0aC5hYnMoc2l6ZS53aWR0aCAqIE1hdGguc2luKGFuZ2xlUmFkKSkgKyBNYXRoLmFicyhzaXplLmhlaWdodCAqIE1hdGguY29zKGFuZ2xlUmFkKSlcclxuXHR9O1xyXG59O1xyXG5cclxuVGV4dFRvb2xzLnByb3RvdHlwZS53aWR0aE9mU3RyaW5nID0gZnVuY3Rpb24gKHRleHQsIGZvbnQsIGZvbnRTaXplLCBjaGFyYWN0ZXJTcGFjaW5nLCBmb250RmVhdHVyZXMpIHtcclxuXHRyZXR1cm4gd2lkdGhPZlN0cmluZyh0ZXh0LCBmb250LCBmb250U2l6ZSwgY2hhcmFjdGVyU3BhY2luZywgZm9udEZlYXR1cmVzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHNwbGl0V29yZHModGV4dCwgbm9XcmFwKSB7XHJcblx0dmFyIHJlc3VsdHMgPSBbXTtcclxuXHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHQvZywgJyAgICAnKTtcclxuXHJcblx0aWYgKG5vV3JhcCkge1xyXG5cdFx0cmVzdWx0cy5wdXNoKHsgdGV4dDogdGV4dCB9KTtcclxuXHRcdHJldHVybiByZXN1bHRzO1xyXG5cdH1cclxuXHJcblx0dmFyIGJyZWFrZXIgPSBuZXcgTGluZUJyZWFrZXIodGV4dCk7XHJcblx0dmFyIGxhc3QgPSAwO1xyXG5cdHZhciBiaztcclxuXHJcblx0d2hpbGUgKGJrID0gYnJlYWtlci5uZXh0QnJlYWsoKSkge1xyXG5cdFx0dmFyIHdvcmQgPSB0ZXh0LnNsaWNlKGxhc3QsIGJrLnBvc2l0aW9uKTtcclxuXHJcblx0XHRpZiAoYmsucmVxdWlyZWQgfHwgd29yZC5tYXRjaCgvXFxyP1xcbiR8XFxyJC8pKSB7IC8vIG5ldyBsaW5lXHJcblx0XHRcdHdvcmQgPSB3b3JkLnJlcGxhY2UoL1xccj9cXG4kfFxcciQvLCAnJyk7XHJcblx0XHRcdHJlc3VsdHMucHVzaCh7IHRleHQ6IHdvcmQsIGxpbmVFbmQ6IHRydWUgfSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXN1bHRzLnB1c2goeyB0ZXh0OiB3b3JkIH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxhc3QgPSBiay5wb3NpdGlvbjtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXN1bHRzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb3B5U3R5bGUoc291cmNlLCBkZXN0aW5hdGlvbikge1xyXG5cdGRlc3RpbmF0aW9uID0gZGVzdGluYXRpb24gfHwge307XHJcblx0c291cmNlID0gc291cmNlIHx8IHt9OyAvL1RPRE86IGRlZmF1bHQgc3R5bGVcclxuXHJcblx0Zm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xyXG5cdFx0aWYgKGtleSAhPSAndGV4dCcgJiYgc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGRlc3RpbmF0aW9uO1xyXG59XHJcblxyXG5mdW5jdGlvbiBub3JtYWxpemVUZXh0QXJyYXkoYXJyYXksIHN0eWxlQ29udGV4dFN0YWNrKSB7XHJcblx0ZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xyXG5cdFx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XHJcblx0XHRcdHZhciBjdXJyZW50ID0gaXNBcnJheShjdXIudGV4dCkgPyBmbGF0dGVuKGN1ci50ZXh0KSA6IGN1cjtcclxuXHRcdFx0dmFyIG1vcmUgPSBbXS5jb25jYXQoY3VycmVudCkuc29tZShBcnJheS5pc0FycmF5KTtcclxuXHRcdFx0cmV0dXJuIHByZXYuY29uY2F0KG1vcmUgPyBmbGF0dGVuKGN1cnJlbnQpIDogY3VycmVudCk7XHJcblx0XHR9LCBbXSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRPbmVXb3JkKGluZGV4LCB3b3Jkcywgbm9XcmFwKSB7XHJcblx0XHRpZiAoaXNVbmRlZmluZWQod29yZHNbaW5kZXhdKSkge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAod29yZHNbaW5kZXhdLmxpbmVFbmQpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHdvcmQgPSB3b3Jkc1tpbmRleF0udGV4dDtcclxuXHJcblx0XHRpZiAobm9XcmFwKSB7XHJcblx0XHRcdHZhciB0bXBXb3JkcyA9IHNwbGl0V29yZHMobm9ybWFsaXplU3RyaW5nKHdvcmQpLCBmYWxzZSk7XHJcblx0XHRcdGlmIChpc1VuZGVmaW5lZCh0bXBXb3Jkc1t0bXBXb3Jkcy5sZW5ndGggLSAxXSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0XHR3b3JkID0gdG1wV29yZHNbdG1wV29yZHMubGVuZ3RoIC0gMV0udGV4dDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gd29yZDtcclxuXHR9XHJcblxyXG5cdHZhciByZXN1bHRzID0gW107XHJcblxyXG5cdGlmICghaXNBcnJheShhcnJheSkpIHtcclxuXHRcdGFycmF5ID0gW2FycmF5XTtcclxuXHR9XHJcblxyXG5cdGFycmF5ID0gZmxhdHRlbihhcnJheSk7XHJcblxyXG5cdHZhciBsYXN0V29yZCA9IG51bGw7XHJcblx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gYXJyYXlbaV07XHJcblx0XHR2YXIgc3R5bGUgPSBudWxsO1xyXG5cdFx0dmFyIHdvcmRzO1xyXG5cclxuXHRcdHZhciBub1dyYXAgPSBnZXRTdHlsZVByb3BlcnR5KGl0ZW0gfHwge30sIHN0eWxlQ29udGV4dFN0YWNrLCAnbm9XcmFwJywgZmFsc2UpO1xyXG5cdFx0aWYgKGlzT2JqZWN0KGl0ZW0pKSB7XHJcblx0XHRcdGlmIChpdGVtLl90ZXh0UmVmICYmIGl0ZW0uX3RleHRSZWYuX3RleHROb2RlUmVmLnRleHQpIHtcclxuXHRcdFx0XHRpdGVtLnRleHQgPSBpdGVtLl90ZXh0UmVmLl90ZXh0Tm9kZVJlZi50ZXh0O1xyXG5cdFx0XHR9XHJcblx0XHRcdHdvcmRzID0gc3BsaXRXb3Jkcyhub3JtYWxpemVTdHJpbmcoaXRlbS50ZXh0KSwgbm9XcmFwKTtcclxuXHRcdFx0c3R5bGUgPSBjb3B5U3R5bGUoaXRlbSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR3b3JkcyA9IHNwbGl0V29yZHMobm9ybWFsaXplU3RyaW5nKGl0ZW0pLCBub1dyYXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXN0V29yZCAmJiB3b3Jkcy5sZW5ndGgpIHtcclxuXHRcdFx0dmFyIGZpcnN0V29yZCA9IGdldE9uZVdvcmQoMCwgd29yZHMsIG5vV3JhcCk7XHJcblxyXG5cdFx0XHR2YXIgd3JhcFdvcmRzID0gc3BsaXRXb3Jkcyhub3JtYWxpemVTdHJpbmcobGFzdFdvcmQgKyBmaXJzdFdvcmQpLCBmYWxzZSk7XHJcblx0XHRcdGlmICh3cmFwV29yZHMubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdFx0cmVzdWx0c1tyZXN1bHRzLmxlbmd0aCAtIDFdLm5vTmV3TGluZSA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKHZhciBpMiA9IDAsIGwyID0gd29yZHMubGVuZ3RoOyBpMiA8IGwyOyBpMisrKSB7XHJcblx0XHRcdHZhciByZXN1bHQgPSB7XHJcblx0XHRcdFx0dGV4dDogd29yZHNbaTJdLnRleHRcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGlmICh3b3Jkc1tpMl0ubGluZUVuZCkge1xyXG5cdFx0XHRcdHJlc3VsdC5saW5lRW5kID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29weVN0eWxlKHN0eWxlLCByZXN1bHQpO1xyXG5cclxuXHRcdFx0cmVzdWx0cy5wdXNoKHJlc3VsdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGFzdFdvcmQgPSBudWxsO1xyXG5cdFx0aWYgKGkgKyAxIDwgbCkge1xyXG5cdFx0XHRsYXN0V29yZCA9IGdldE9uZVdvcmQod29yZHMubGVuZ3RoIC0gMSwgd29yZHMsIG5vV3JhcCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzdWx0cztcclxufVxyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nKHZhbHVlKSB7XHJcblx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcclxuXHRcdHJldHVybiAnJztcclxuXHR9IGVsc2UgaWYgKGlzTnVtYmVyKHZhbHVlKSkge1xyXG5cdFx0cmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XHJcblx0fSBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuXHRcdHJldHVybiB2YWx1ZTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTdHlsZVByb3BlcnR5KGl0ZW0sIHN0eWxlQ29udGV4dFN0YWNrLCBwcm9wZXJ0eSwgZGVmYXVsdFZhbHVlKSB7XHJcblx0dmFyIHZhbHVlO1xyXG5cclxuXHRpZiAoaXRlbVtwcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCAmJiBpdGVtW3Byb3BlcnR5XSAhPT0gbnVsbCkge1xyXG5cdFx0Ly8gaXRlbSBkZWZpbmVzIHRoaXMgcHJvcGVydHlcclxuXHRcdHJldHVybiBpdGVtW3Byb3BlcnR5XTtcclxuXHR9XHJcblxyXG5cdGlmICghc3R5bGVDb250ZXh0U3RhY2spIHtcclxuXHRcdHJldHVybiBkZWZhdWx0VmFsdWU7XHJcblx0fVxyXG5cclxuXHRzdHlsZUNvbnRleHRTdGFjay5hdXRvKGl0ZW0sIGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhbHVlID0gc3R5bGVDb250ZXh0U3RhY2suZ2V0UHJvcGVydHkocHJvcGVydHkpO1xyXG5cdH0pO1xyXG5cclxuXHRpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gZGVmYXVsdFZhbHVlO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gbWVhc3VyZShmb250UHJvdmlkZXIsIHRleHRBcnJheSwgc3R5bGVDb250ZXh0U3RhY2spIHtcclxuXHR2YXIgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVRleHRBcnJheSh0ZXh0QXJyYXksIHN0eWxlQ29udGV4dFN0YWNrKTtcclxuXHJcblx0aWYgKG5vcm1hbGl6ZWQubGVuZ3RoKSB7XHJcblx0XHR2YXIgbGVhZGluZ0luZGVudCA9IGdldFN0eWxlUHJvcGVydHkobm9ybWFsaXplZFswXSwgc3R5bGVDb250ZXh0U3RhY2ssICdsZWFkaW5nSW5kZW50JywgMCk7XHJcblxyXG5cdFx0aWYgKGxlYWRpbmdJbmRlbnQpIHtcclxuXHRcdFx0bm9ybWFsaXplZFswXS5sZWFkaW5nQ3V0ID0gLWxlYWRpbmdJbmRlbnQ7XHJcblx0XHRcdG5vcm1hbGl6ZWRbMF0ubGVhZGluZ0luZGVudCA9IGxlYWRpbmdJbmRlbnQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRub3JtYWxpemVkLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuXHRcdHZhciBmb250TmFtZSA9IGdldFN0eWxlUHJvcGVydHkoaXRlbSwgc3R5bGVDb250ZXh0U3RhY2ssICdmb250JywgJ1JvYm90bycpO1xyXG5cdFx0dmFyIGZvbnRTaXplID0gZ2V0U3R5bGVQcm9wZXJ0eShpdGVtLCBzdHlsZUNvbnRleHRTdGFjaywgJ2ZvbnRTaXplJywgMTIpO1xyXG5cdFx0dmFyIGZvbnRGZWF0dXJlcyA9IGdldFN0eWxlUHJvcGVydHkoaXRlbSwgc3R5bGVDb250ZXh0U3RhY2ssICdmb250RmVhdHVyZXMnLCBudWxsKTtcclxuXHRcdHZhciBib2xkID0gZ2V0U3R5bGVQcm9wZXJ0eShpdGVtLCBzdHlsZUNvbnRleHRTdGFjaywgJ2JvbGQnLCBmYWxzZSk7XHJcblx0XHR2YXIgaXRhbGljcyA9IGdldFN0eWxlUHJvcGVydHkoaXRlbSwgc3R5bGVDb250ZXh0U3RhY2ssICdpdGFsaWNzJywgZmFsc2UpO1xyXG5cdFx0dmFyIGNvbG9yID0gZ2V0U3R5bGVQcm9wZXJ0eShpdGVtLCBzdHlsZUNvbnRleHRTdGFjaywgJ2NvbG9yJywgJ2JsYWNrJyk7XHJcblx0XHR2YXIgZGVjb3JhdGlvbiA9IGdldFN0eWxlUHJvcGVydHkoaXRlbSwgc3R5bGVDb250ZXh0U3RhY2ssICdkZWNvcmF0aW9uJywgbnVsbCk7XHJcblx0XHR2YXIgZGVjb3JhdGlvbkNvbG9yID0gZ2V0U3R5bGVQcm9wZXJ0eShpdGVtLCBzdHlsZUNvbnRleHRTdGFjaywgJ2RlY29yYXRpb25Db2xvcicsIG51bGwpO1xyXG5cdFx0dmFyIGRlY29yYXRpb25TdHlsZSA9IGdldFN0eWxlUHJvcGVydHkoaXRlbSwgc3R5bGVDb250ZXh0U3RhY2ssICdkZWNvcmF0aW9uU3R5bGUnLCBudWxsKTtcclxuXHRcdHZhciBiYWNrZ3JvdW5kID0gZ2V0U3R5bGVQcm9wZXJ0eShpdGVtLCBzdHlsZUNvbnRleHRTdGFjaywgJ2JhY2tncm91bmQnLCBudWxsKTtcclxuXHRcdHZhciBsaW5lSGVpZ2h0ID0gZ2V0U3R5bGVQcm9wZXJ0eShpdGVtLCBzdHlsZUNvbnRleHRTdGFjaywgJ2xpbmVIZWlnaHQnLCAxKTtcclxuXHRcdHZhciBjaGFyYWN0ZXJTcGFjaW5nID0gZ2V0U3R5bGVQcm9wZXJ0eShpdGVtLCBzdHlsZUNvbnRleHRTdGFjaywgJ2NoYXJhY3RlclNwYWNpbmcnLCAwKTtcclxuXHRcdHZhciBsaW5rID0gZ2V0U3R5bGVQcm9wZXJ0eShpdGVtLCBzdHlsZUNvbnRleHRTdGFjaywgJ2xpbmsnLCBudWxsKTtcclxuXHRcdHZhciBsaW5rVG9QYWdlID0gZ2V0U3R5bGVQcm9wZXJ0eShpdGVtLCBzdHlsZUNvbnRleHRTdGFjaywgJ2xpbmtUb1BhZ2UnLCBudWxsKTtcclxuXHRcdHZhciBsaW5rVG9EZXN0aW5hdGlvbiA9IGdldFN0eWxlUHJvcGVydHkoaXRlbSwgc3R5bGVDb250ZXh0U3RhY2ssICdsaW5rVG9EZXN0aW5hdGlvbicsIG51bGwpO1xyXG5cdFx0dmFyIG5vV3JhcCA9IGdldFN0eWxlUHJvcGVydHkoaXRlbSwgc3R5bGVDb250ZXh0U3RhY2ssICdub1dyYXAnLCBudWxsKTtcclxuXHRcdHZhciBwcmVzZXJ2ZUxlYWRpbmdTcGFjZXMgPSBnZXRTdHlsZVByb3BlcnR5KGl0ZW0sIHN0eWxlQ29udGV4dFN0YWNrLCAncHJlc2VydmVMZWFkaW5nU3BhY2VzJywgZmFsc2UpO1xyXG5cdFx0dmFyIHByZXNlcnZlVHJhaWxpbmdTcGFjZXMgPSBnZXRTdHlsZVByb3BlcnR5KGl0ZW0sIHN0eWxlQ29udGV4dFN0YWNrLCAncHJlc2VydmVUcmFpbGluZ1NwYWNlcycsIGZhbHNlKTtcclxuXHRcdHZhciBvcGFjaXR5ID0gZ2V0U3R5bGVQcm9wZXJ0eShpdGVtLCBzdHlsZUNvbnRleHRTdGFjaywgJ29wYWNpdHknLCAxKTtcclxuXHRcdHZhciBzdXAgPSBnZXRTdHlsZVByb3BlcnR5KGl0ZW0sIHN0eWxlQ29udGV4dFN0YWNrLCAnc3VwJywgZmFsc2UpO1xyXG5cdFx0dmFyIHN1YiA9IGdldFN0eWxlUHJvcGVydHkoaXRlbSwgc3R5bGVDb250ZXh0U3RhY2ssICdzdWInLCBmYWxzZSk7XHJcblxyXG5cdFx0aWYgKChzdXAgfHwgc3ViKSAmJiBpdGVtLmZvbnRTaXplID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Ly8gZm9udCBzaXplIHJlZHVjdGlvbiB0YWtlbiBmcm9tIGhlcmU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1YnNjcmlwdF9hbmRfc3VwZXJzY3JpcHQjRGVza3RvcF9wdWJsaXNoaW5nXHJcblx0XHRcdGZvbnRTaXplICo9IDAuNTg7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGZvbnQgPSBmb250UHJvdmlkZXIucHJvdmlkZUZvbnQoZm9udE5hbWUsIGJvbGQsIGl0YWxpY3MpO1xyXG5cclxuXHRcdGl0ZW0ud2lkdGggPSB3aWR0aE9mU3RyaW5nKGl0ZW0udGV4dCwgZm9udCwgZm9udFNpemUsIGNoYXJhY3RlclNwYWNpbmcsIGZvbnRGZWF0dXJlcyk7XHJcblx0XHRpdGVtLmhlaWdodCA9IGZvbnQubGluZUhlaWdodChmb250U2l6ZSkgKiBsaW5lSGVpZ2h0O1xyXG5cclxuXHRcdGlmICghaXRlbS5sZWFkaW5nQ3V0KSB7XHJcblx0XHRcdGl0ZW0ubGVhZGluZ0N1dCA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGxlYWRpbmdTcGFjZXM7XHJcblx0XHRpZiAoIXByZXNlcnZlTGVhZGluZ1NwYWNlcyAmJiAobGVhZGluZ1NwYWNlcyA9IGl0ZW0udGV4dC5tYXRjaChMRUFESU5HKSkpIHtcclxuXHRcdFx0aXRlbS5sZWFkaW5nQ3V0ICs9IHdpZHRoT2ZTdHJpbmcobGVhZGluZ1NwYWNlc1swXSwgZm9udCwgZm9udFNpemUsIGNoYXJhY3RlclNwYWNpbmcsIGZvbnRGZWF0dXJlcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRyYWlsaW5nU3BhY2VzO1xyXG5cdFx0aWYgKCFwcmVzZXJ2ZVRyYWlsaW5nU3BhY2VzICYmICh0cmFpbGluZ1NwYWNlcyA9IGl0ZW0udGV4dC5tYXRjaChUUkFJTElORykpKSB7XHJcblx0XHRcdGl0ZW0udHJhaWxpbmdDdXQgPSB3aWR0aE9mU3RyaW5nKHRyYWlsaW5nU3BhY2VzWzBdLCBmb250LCBmb250U2l6ZSwgY2hhcmFjdGVyU3BhY2luZywgZm9udEZlYXR1cmVzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGl0ZW0udHJhaWxpbmdDdXQgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGl0ZW0uYWxpZ25tZW50ID0gZ2V0U3R5bGVQcm9wZXJ0eShpdGVtLCBzdHlsZUNvbnRleHRTdGFjaywgJ2FsaWdubWVudCcsICdsZWZ0Jyk7XHJcblx0XHRpdGVtLmZvbnQgPSBmb250O1xyXG5cdFx0aXRlbS5mb250U2l6ZSA9IGZvbnRTaXplO1xyXG5cdFx0aXRlbS5mb250RmVhdHVyZXMgPSBmb250RmVhdHVyZXM7XHJcblx0XHRpdGVtLmNoYXJhY3RlclNwYWNpbmcgPSBjaGFyYWN0ZXJTcGFjaW5nO1xyXG5cdFx0aXRlbS5jb2xvciA9IGNvbG9yO1xyXG5cdFx0aXRlbS5kZWNvcmF0aW9uID0gZGVjb3JhdGlvbjtcclxuXHRcdGl0ZW0uZGVjb3JhdGlvbkNvbG9yID0gZGVjb3JhdGlvbkNvbG9yO1xyXG5cdFx0aXRlbS5kZWNvcmF0aW9uU3R5bGUgPSBkZWNvcmF0aW9uU3R5bGU7XHJcblx0XHRpdGVtLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xyXG5cdFx0aXRlbS5saW5rID0gbGluaztcclxuXHRcdGl0ZW0ubGlua1RvUGFnZSA9IGxpbmtUb1BhZ2U7XHJcblx0XHRpdGVtLmxpbmtUb0Rlc3RpbmF0aW9uID0gbGlua1RvRGVzdGluYXRpb247XHJcblx0XHRpdGVtLm5vV3JhcCA9IG5vV3JhcDtcclxuXHRcdGl0ZW0ub3BhY2l0eSA9IG9wYWNpdHk7XHJcblx0XHRpdGVtLnN1cCA9IHN1cDtcclxuXHRcdGl0ZW0uc3ViID0gc3ViO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gbm9ybWFsaXplZDtcclxufVxyXG5cclxuZnVuY3Rpb24gd2lkdGhPZlN0cmluZyh0ZXh0LCBmb250LCBmb250U2l6ZSwgY2hhcmFjdGVyU3BhY2luZywgZm9udEZlYXR1cmVzKSB7XHJcblx0cmV0dXJuIGZvbnQud2lkdGhPZlN0cmluZyh0ZXh0LCBmb250U2l6ZSwgZm9udEZlYXR1cmVzKSArICgoY2hhcmFjdGVyU3BhY2luZyB8fCAwKSAqICh0ZXh0Lmxlbmd0aCAtIDEpKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZXh0VG9vbHM7XHJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/textTools.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pdfmake/src/traversalTracker.js":
/*!******************************************************!*\
  !*** ./node_modules/pdfmake/src/traversalTracker.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\nfunction TraversalTracker() {\r\n\tthis.events = {};\r\n}\r\n\r\nTraversalTracker.prototype.startTracking = function (event, callback) {\r\n\tvar callbacks = this.events[event] || (this.events[event] = []);\r\n\r\n\tif (callbacks.indexOf(callback) < 0) {\r\n\t\tcallbacks.push(callback);\r\n\t}\r\n};\r\n\r\nTraversalTracker.prototype.stopTracking = function (event, callback) {\r\n\tvar callbacks = this.events[event];\r\n\r\n\tif (!callbacks) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tvar index = callbacks.indexOf(callback);\r\n\tif (index >= 0) {\r\n\t\tcallbacks.splice(index, 1);\r\n\t}\r\n};\r\n\r\nTraversalTracker.prototype.emit = function (event) {\r\n\tvar args = Array.prototype.slice.call(arguments, 1);\r\n\tvar callbacks = this.events[event];\r\n\r\n\tif (!callbacks) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tcallbacks.forEach(function (callback) {\r\n\t\tcallback.apply(this, args);\r\n\t});\r\n};\r\n\r\nTraversalTracker.prototype.auto = function (event, callback, innerFunction) {\r\n\tthis.startTracking(event, callback);\r\n\tinnerFunction();\r\n\tthis.stopTracking(event, callback);\r\n};\r\n\r\nmodule.exports = TraversalTracker;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvdHJhdmVyc2FsVHJhY2tlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2dhc2NhdC9wcmlzbWFxdWFudC9wcmlzbWEtcXVhbnR1bS9ub2RlX21vZHVsZXMvcGRmbWFrZS9zcmMvdHJhdmVyc2FsVHJhY2tlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5mdW5jdGlvbiBUcmF2ZXJzYWxUcmFja2VyKCkge1xyXG5cdHRoaXMuZXZlbnRzID0ge307XHJcbn1cclxuXHJcblRyYXZlcnNhbFRyYWNrZXIucHJvdG90eXBlLnN0YXJ0VHJhY2tpbmcgPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKSB7XHJcblx0dmFyIGNhbGxiYWNrcyA9IHRoaXMuZXZlbnRzW2V2ZW50XSB8fCAodGhpcy5ldmVudHNbZXZlbnRdID0gW10pO1xyXG5cclxuXHRpZiAoY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spIDwgMCkge1xyXG5cdFx0Y2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG5cdH1cclxufTtcclxuXHJcblRyYXZlcnNhbFRyYWNrZXIucHJvdG90eXBlLnN0b3BUcmFja2luZyA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcclxuXHR2YXIgY2FsbGJhY2tzID0gdGhpcy5ldmVudHNbZXZlbnRdO1xyXG5cclxuXHRpZiAoIWNhbGxiYWNrcykge1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0dmFyIGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xyXG5cdGlmIChpbmRleCA+PSAwKSB7XHJcblx0XHRjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcclxuXHR9XHJcbn07XHJcblxyXG5UcmF2ZXJzYWxUcmFja2VyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cdHZhciBjYWxsYmFja3MgPSB0aGlzLmV2ZW50c1tldmVudF07XHJcblxyXG5cdGlmICghY2FsbGJhY2tzKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHRjYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuXHRcdGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuVHJhdmVyc2FsVHJhY2tlci5wcm90b3R5cGUuYXV0byA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2ssIGlubmVyRnVuY3Rpb24pIHtcclxuXHR0aGlzLnN0YXJ0VHJhY2tpbmcoZXZlbnQsIGNhbGxiYWNrKTtcclxuXHRpbm5lckZ1bmN0aW9uKCk7XHJcblx0dGhpcy5zdG9wVHJhY2tpbmcoZXZlbnQsIGNhbGxiYWNrKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVHJhdmVyc2FsVHJhY2tlcjtcclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfmake/src/traversalTracker.js\n");

/***/ })

};
;