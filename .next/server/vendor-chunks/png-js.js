/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/png-js";
exports.ids = ["vendor-chunks/png-js"];
exports.modules = {

/***/ "(rsc)/./node_modules/png-js/png-node.js":
/*!*****************************************!*\
  !*** ./node_modules/png-js/png-node.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n * MIT LICENSE\n * Copyright (c) 2011 Devon Govett\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nmodule.exports = class PNG {\n  static decode(path, fn) {\n    return fs.readFile(path, function(err, file) {\n      const png = new PNG(file);\n      return png.decode(pixels => fn(pixels));\n    });\n  }\n\n  static load(path) {\n    const file = fs.readFileSync(path);\n    return new PNG(file);\n  }\n\n  constructor(data) {\n    let i;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n\n    while (true) {\n      const chunkSize = this.readUInt32();\n      let section = '';\n      for (i = 0; i < 4; i++) {\n        section += String.fromCharCode(this.data[this.pos++]);\n      }\n\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n\n        case 'IDAT':\n          for (i = 0; i < chunkSize; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n          break;\n\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n              if (short > 0) {\n                for (i = 0; i < short; i++) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n              break;\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n          break;\n\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, text.slice(0, index));\n          this.text[key] = String.fromCharCode.apply(\n            String,\n            text.slice(index + 1)\n          );\n          break;\n\n        case 'IEND':\n          // we've got everything we need!\n          switch (this.colorType) {\n            case 0:\n            case 3:\n            case 4:\n              this.colors = 1;\n              break;\n            case 2:\n            case 6:\n              this.colors = 3;\n              break;\n          }\n\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n\n          switch (this.colors) {\n            case 1:\n              this.colorSpace = 'DeviceGray';\n              break;\n            case 3:\n              this.colorSpace = 'DeviceRGB';\n              break;\n          }\n\n          this.imgData = new Buffer(this.imgData);\n          return;\n          break;\n\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error('Incomplete or corrupt PNG file');\n      }\n    }\n  }\n\n  read(bytes) {\n    const result = new Array(bytes);\n    for (let i = 0; i < bytes; i++) {\n      result[i] = this.data[this.pos++];\n    }\n    return result;\n  }\n\n  readUInt32() {\n    const b1 = this.data[this.pos++] << 24;\n    const b2 = this.data[this.pos++] << 16;\n    const b3 = this.data[this.pos++] << 8;\n    const b4 = this.data[this.pos++];\n    return b1 | b2 | b3 | b4;\n  }\n\n  readUInt16() {\n    const b1 = this.data[this.pos++] << 8;\n    const b2 = this.data[this.pos++];\n    return b1 | b2;\n  }\n\n  decodePixels(fn) {\n    return zlib.inflate(this.imgData, (err, data) => {\n      if (err) {\n        throw err;\n      }\n\n      const { width, height } = this;\n      const pixelBytes = this.pixelBitlength / 8;\n\n      const pixels = new Buffer(width * height * pixelBytes);\n      const { length } = data;\n      let pos = 0;\n\n      function pass(x0, y0, dx, dy, singlePass = false) {\n        const w = Math.ceil((width - x0) / dx);\n        const h = Math.ceil((height - y0) / dy);\n        const scanlineLength = pixelBytes * w;\n        const buffer = singlePass ? pixels : new Buffer(scanlineLength * h);\n        let row = 0;\n        let c = 0;\n        while (row < h && pos < length) {\n          var byte, col, i, left, upper;\n          switch (data[pos++]) {\n            case 0: // None\n              for (i = 0; i < scanlineLength; i++) {\n                buffer[c++] = data[pos++];\n              }\n              break;\n\n            case 1: // Sub\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                buffer[c++] = (byte + left) % 256;\n              }\n              break;\n\n            case 2: // Up\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                upper =\n                  row &&\n                  buffer[\n                    (row - 1) * scanlineLength +\n                      col * pixelBytes +\n                      (i % pixelBytes)\n                  ];\n                buffer[c++] = (upper + byte) % 256;\n              }\n              break;\n\n            case 3: // Average\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                upper =\n                  row &&\n                  buffer[\n                    (row - 1) * scanlineLength +\n                      col * pixelBytes +\n                      (i % pixelBytes)\n                  ];\n                buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n              break;\n\n            case 4: // Paeth\n              for (i = 0; i < scanlineLength; i++) {\n                var paeth, upperLeft;\n                byte = data[pos++];\n                col = (i - (i % pixelBytes)) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper =\n                    buffer[\n                      (row - 1) * scanlineLength +\n                        col * pixelBytes +\n                        (i % pixelBytes)\n                    ];\n                  upperLeft =\n                    col &&\n                    buffer[\n                      (row - 1) * scanlineLength +\n                        (col - 1) * pixelBytes +\n                        (i % pixelBytes)\n                    ];\n                }\n\n                const p = left + upper - upperLeft;\n                const pa = Math.abs(p - left);\n                const pb = Math.abs(p - upper);\n                const pc = Math.abs(p - upperLeft);\n\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n\n                buffer[c++] = (byte + paeth) % 256;\n              }\n              break;\n\n            default:\n              throw new Error(`Invalid filter algorithm: ${data[pos - 1]}`);\n          }\n\n          if (!singlePass) {\n            let pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;\n            let bufferPos = row * scanlineLength;\n            for (i = 0; i < w; i++) {\n              for (let j = 0; j < pixelBytes; j++)\n                pixels[pixelsPos++] = buffer[bufferPos++];\n              pixelsPos += (dx - 1) * pixelBytes;\n            }\n          }\n\n          row++;\n        }\n      }\n\n      if (this.interlaceMethod === 1) {\n        /*\n          1 6 4 6 2 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n          3 6 4 6 3 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n        */\n        pass(0, 0, 8, 8); // 1\n        pass(4, 0, 8, 8); // 2\n        pass(0, 4, 4, 8); // 3\n        pass(2, 0, 4, 4); // 4\n        pass(0, 2, 2, 4); // 5\n        pass(1, 0, 2, 2); // 6\n        pass(0, 1, 1, 2); // 7\n      } else {\n        pass(0, 0, 1, 1, true);\n      }\n\n      return fn(pixels);\n    });\n  }\n\n  decodePalette() {\n    const { palette } = this;\n    const { length } = palette;\n    const transparency = this.transparency.indexed || [];\n    const ret = new Buffer(transparency.length + length);\n    let pos = 0;\n    let c = 0;\n\n    for (let i = 0; i < length; i += 3) {\n      var left;\n      ret[pos++] = palette[i];\n      ret[pos++] = palette[i + 1];\n      ret[pos++] = palette[i + 2];\n      ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n    }\n\n    return ret;\n  }\n\n  copyToImageData(imageData, pixels) {\n    let j, k;\n    let { colors } = this;\n    let palette = null;\n    let alpha = this.hasAlphaChannel;\n\n    if (this.palette.length) {\n      palette =\n        this._decodedPalette || (this._decodedPalette = this.decodePalette());\n      colors = 4;\n      alpha = true;\n    }\n\n    const data = imageData.data || imageData;\n    const { length } = data;\n    const input = palette || pixels;\n    let i = (j = 0);\n\n    if (colors === 1) {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        const v = input[k++];\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    } else {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    }\n  }\n\n  decode(fn) {\n    const ret = new Buffer(this.width * this.height * 4);\n    return this.decodePixels(pixels => {\n      this.copyToImageData(ret, pixels);\n      return fn(ret);\n    });\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcG5nLWpzL3BuZy1ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGdCQUFnQjtBQUM5Qjs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsb0JBQW9CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsb0JBQW9CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsb0JBQW9CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0IsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvZ2FzY2F0L3ByaXNtYXF1YW50L3ByaXNtYS1xdWFudHVtL25vZGVfbW9kdWxlcy9wbmctanMvcG5nLW5vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIE1JVCBMSUNFTlNFXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEgRGV2b24gR292ZXR0XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4gKiBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbiAqIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnNcbiAqIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvclxuICogc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HXG4gKiBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4gKiBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBORyB7XG4gIHN0YXRpYyBkZWNvZGUocGF0aCwgZm4pIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGUocGF0aCwgZnVuY3Rpb24oZXJyLCBmaWxlKSB7XG4gICAgICBjb25zdCBwbmcgPSBuZXcgUE5HKGZpbGUpO1xuICAgICAgcmV0dXJuIHBuZy5kZWNvZGUocGl4ZWxzID0+IGZuKHBpeGVscykpO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGxvYWQocGF0aCkge1xuICAgIGNvbnN0IGZpbGUgPSBmcy5yZWFkRmlsZVN5bmMocGF0aCk7XG4gICAgcmV0dXJuIG5ldyBQTkcoZmlsZSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgbGV0IGk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnBvcyA9IDg7IC8vIFNraXAgdGhlIGRlZmF1bHQgaGVhZGVyXG5cbiAgICB0aGlzLnBhbGV0dGUgPSBbXTtcbiAgICB0aGlzLmltZ0RhdGEgPSBbXTtcbiAgICB0aGlzLnRyYW5zcGFyZW5jeSA9IHt9O1xuICAgIHRoaXMudGV4dCA9IHt9O1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IHRoaXMucmVhZFVJbnQzMigpO1xuICAgICAgbGV0IHNlY3Rpb24gPSAnJztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgc2VjdGlvbiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuZGF0YVt0aGlzLnBvcysrXSk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoc2VjdGlvbikge1xuICAgICAgICBjYXNlICdJSERSJzpcbiAgICAgICAgICAvLyB3ZSBjYW4gZ3JhYiAgaW50ZXJlc3RpbmcgdmFsdWVzIGZyb20gaGVyZSAobGlrZSB3aWR0aCwgaGVpZ2h0LCBldGMpXG4gICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMucmVhZFVJbnQzMigpO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5yZWFkVUludDMyKCk7XG4gICAgICAgICAgdGhpcy5iaXRzID0gdGhpcy5kYXRhW3RoaXMucG9zKytdO1xuICAgICAgICAgIHRoaXMuY29sb3JUeXBlID0gdGhpcy5kYXRhW3RoaXMucG9zKytdO1xuICAgICAgICAgIHRoaXMuY29tcHJlc3Npb25NZXRob2QgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgICAgICAgdGhpcy5maWx0ZXJNZXRob2QgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgICAgICAgdGhpcy5pbnRlcmxhY2VNZXRob2QgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnUExURSc6XG4gICAgICAgICAgdGhpcy5wYWxldHRlID0gdGhpcy5yZWFkKGNodW5rU2l6ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnSURBVCc6XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNodW5rU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmltZ0RhdGEucHVzaCh0aGlzLmRhdGFbdGhpcy5wb3MrK10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0Uk5TJzpcbiAgICAgICAgICAvLyBUaGlzIGNodW5rIGNhbiBvbmx5IG9jY3VyIG9uY2UgYW5kIGl0IG11c3Qgb2NjdXIgYWZ0ZXIgdGhlXG4gICAgICAgICAgLy8gUExURSBjaHVuayBhbmQgYmVmb3JlIHRoZSBJREFUIGNodW5rLlxuICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5ID0ge307XG4gICAgICAgICAgc3dpdGNoICh0aGlzLmNvbG9yVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAvLyBJbmRleGVkIGNvbG9yLCBSR0IuIEVhY2ggYnl0ZSBpbiB0aGlzIGNodW5rIGlzIGFuIGFscGhhIGZvclxuICAgICAgICAgICAgICAvLyB0aGUgcGFsZXR0ZSBpbmRleCBpbiB0aGUgUExURSAoXCJwYWxldHRlXCIpIGNodW5rIHVwIHVudGlsIHRoZVxuICAgICAgICAgICAgICAvLyBsYXN0IG5vbi1vcGFxdWUgZW50cnkuIFNldCB1cCBhbiBhcnJheSwgc3RyZXRjaGluZyBvdmVyIGFsbFxuICAgICAgICAgICAgICAvLyBwYWxldHRlIGVudHJpZXMgd2hpY2ggd2lsbCBiZSAwIChvcGFxdWUpIG9yIDEgKHRyYW5zcGFyZW50KS5cbiAgICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVuY3kuaW5kZXhlZCA9IHRoaXMucmVhZChjaHVua1NpemUpO1xuICAgICAgICAgICAgICB2YXIgc2hvcnQgPSAyNTUgLSB0aGlzLnRyYW5zcGFyZW5jeS5pbmRleGVkLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKHNob3J0ID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaG9ydDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeS5pbmRleGVkLnB1c2goMjU1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIC8vIEdyZXlzY2FsZS4gQ29ycmVzcG9uZGluZyB0byBlbnRyaWVzIGluIHRoZSBQTFRFIGNodW5rLlxuICAgICAgICAgICAgICAvLyBHcmV5IGlzIHR3byBieXRlcywgcmFuZ2UgMCAuLiAoMiBeIGJpdC1kZXB0aCkgLSAxXG4gICAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5LmdyYXlzY2FsZSA9IHRoaXMucmVhZChjaHVua1NpemUpWzBdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgLy8gVHJ1ZSBjb2xvciB3aXRoIHByb3BlciBhbHBoYSBjaGFubmVsLlxuICAgICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeS5yZ2IgPSB0aGlzLnJlYWQoY2h1bmtTaXplKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RFWHQnOlxuICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5yZWFkKGNodW5rU2l6ZSk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gdGV4dC5pbmRleE9mKDApO1xuICAgICAgICAgIHZhciBrZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgdGV4dC5zbGljZSgwLCBpbmRleCkpO1xuICAgICAgICAgIHRoaXMudGV4dFtrZXldID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgICAgICAgIFN0cmluZyxcbiAgICAgICAgICAgIHRleHQuc2xpY2UoaW5kZXggKyAxKVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnSUVORCc6XG4gICAgICAgICAgLy8gd2UndmUgZ290IGV2ZXJ5dGhpbmcgd2UgbmVlZCFcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuY29sb3JUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHRoaXMuY29sb3JzID0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIHRoaXMuY29sb3JzID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5oYXNBbHBoYUNoYW5uZWwgPSBbNCwgNl0uaW5jbHVkZXModGhpcy5jb2xvclR5cGUpO1xuICAgICAgICAgIHZhciBjb2xvcnMgPSB0aGlzLmNvbG9ycyArICh0aGlzLmhhc0FscGhhQ2hhbm5lbCA/IDEgOiAwKTtcbiAgICAgICAgICB0aGlzLnBpeGVsQml0bGVuZ3RoID0gdGhpcy5iaXRzICogY29sb3JzO1xuXG4gICAgICAgICAgc3dpdGNoICh0aGlzLmNvbG9ycykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICB0aGlzLmNvbG9yU3BhY2UgPSAnRGV2aWNlR3JheSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICB0aGlzLmNvbG9yU3BhY2UgPSAnRGV2aWNlUkdCJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5pbWdEYXRhID0gbmV3IEJ1ZmZlcih0aGlzLmltZ0RhdGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIHVua25vd24gKG9yIHVuaW1wb3J0YW50KSBzZWN0aW9uLCBza2lwIGl0XG4gICAgICAgICAgdGhpcy5wb3MgKz0gY2h1bmtTaXplO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBvcyArPSA0OyAvLyBTa2lwIHRoZSBDUkNcblxuICAgICAgaWYgKHRoaXMucG9zID4gdGhpcy5kYXRhLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGxldGUgb3IgY29ycnVwdCBQTkcgZmlsZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlYWQoYnl0ZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoYnl0ZXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXM7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gdGhpcy5kYXRhW3RoaXMucG9zKytdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmVhZFVJbnQzMigpIHtcbiAgICBjb25zdCBiMSA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXSA8PCAyNDtcbiAgICBjb25zdCBiMiA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXSA8PCAxNjtcbiAgICBjb25zdCBiMyA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXSA8PCA4O1xuICAgIGNvbnN0IGI0ID0gdGhpcy5kYXRhW3RoaXMucG9zKytdO1xuICAgIHJldHVybiBiMSB8IGIyIHwgYjMgfCBiNDtcbiAgfVxuXG4gIHJlYWRVSW50MTYoKSB7XG4gICAgY29uc3QgYjEgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK10gPDwgODtcbiAgICBjb25zdCBiMiA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXTtcbiAgICByZXR1cm4gYjEgfCBiMjtcbiAgfVxuXG4gIGRlY29kZVBpeGVscyhmbikge1xuICAgIHJldHVybiB6bGliLmluZmxhdGUodGhpcy5pbWdEYXRhLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzO1xuICAgICAgY29uc3QgcGl4ZWxCeXRlcyA9IHRoaXMucGl4ZWxCaXRsZW5ndGggLyA4O1xuXG4gICAgICBjb25zdCBwaXhlbHMgPSBuZXcgQnVmZmVyKHdpZHRoICogaGVpZ2h0ICogcGl4ZWxCeXRlcyk7XG4gICAgICBjb25zdCB7IGxlbmd0aCB9ID0gZGF0YTtcbiAgICAgIGxldCBwb3MgPSAwO1xuXG4gICAgICBmdW5jdGlvbiBwYXNzKHgwLCB5MCwgZHgsIGR5LCBzaW5nbGVQYXNzID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgdyA9IE1hdGguY2VpbCgod2lkdGggLSB4MCkgLyBkeCk7XG4gICAgICAgIGNvbnN0IGggPSBNYXRoLmNlaWwoKGhlaWdodCAtIHkwKSAvIGR5KTtcbiAgICAgICAgY29uc3Qgc2NhbmxpbmVMZW5ndGggPSBwaXhlbEJ5dGVzICogdztcbiAgICAgICAgY29uc3QgYnVmZmVyID0gc2luZ2xlUGFzcyA/IHBpeGVscyA6IG5ldyBCdWZmZXIoc2NhbmxpbmVMZW5ndGggKiBoKTtcbiAgICAgICAgbGV0IHJvdyA9IDA7XG4gICAgICAgIGxldCBjID0gMDtcbiAgICAgICAgd2hpbGUgKHJvdyA8IGggJiYgcG9zIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGJ5dGUsIGNvbCwgaSwgbGVmdCwgdXBwZXI7XG4gICAgICAgICAgc3dpdGNoIChkYXRhW3BvcysrXSkge1xuICAgICAgICAgICAgY2FzZSAwOiAvLyBOb25lXG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FubGluZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2MrK10gPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxOiAvLyBTdWJcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYW5saW5lTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBieXRlID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICAgICAgbGVmdCA9IGkgPCBwaXhlbEJ5dGVzID8gMCA6IGJ1ZmZlcltjIC0gcGl4ZWxCeXRlc107XG4gICAgICAgICAgICAgICAgYnVmZmVyW2MrK10gPSAoYnl0ZSArIGxlZnQpICUgMjU2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDI6IC8vIFVwXG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FubGluZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnl0ZSA9IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgICAgIGNvbCA9IChpIC0gKGkgJSBwaXhlbEJ5dGVzKSkgLyBwaXhlbEJ5dGVzO1xuICAgICAgICAgICAgICAgIHVwcGVyID1cbiAgICAgICAgICAgICAgICAgIHJvdyAmJlxuICAgICAgICAgICAgICAgICAgYnVmZmVyW1xuICAgICAgICAgICAgICAgICAgICAocm93IC0gMSkgKiBzY2FubGluZUxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgICAgY29sICogcGl4ZWxCeXRlcyArXG4gICAgICAgICAgICAgICAgICAgICAgKGkgJSBwaXhlbEJ5dGVzKVxuICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBidWZmZXJbYysrXSA9ICh1cHBlciArIGJ5dGUpICUgMjU2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM6IC8vIEF2ZXJhZ2VcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYW5saW5lTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBieXRlID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICAgICAgY29sID0gKGkgLSAoaSAlIHBpeGVsQnl0ZXMpKSAvIHBpeGVsQnl0ZXM7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGkgPCBwaXhlbEJ5dGVzID8gMCA6IGJ1ZmZlcltjIC0gcGl4ZWxCeXRlc107XG4gICAgICAgICAgICAgICAgdXBwZXIgPVxuICAgICAgICAgICAgICAgICAgcm93ICYmXG4gICAgICAgICAgICAgICAgICBidWZmZXJbXG4gICAgICAgICAgICAgICAgICAgIChyb3cgLSAxKSAqIHNjYW5saW5lTGVuZ3RoICtcbiAgICAgICAgICAgICAgICAgICAgICBjb2wgKiBwaXhlbEJ5dGVzICtcbiAgICAgICAgICAgICAgICAgICAgICAoaSAlIHBpeGVsQnl0ZXMpXG4gICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltjKytdID0gKGJ5dGUgKyBNYXRoLmZsb29yKChsZWZ0ICsgdXBwZXIpIC8gMikpICUgMjU2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQ6IC8vIFBhZXRoXG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FubGluZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhZXRoLCB1cHBlckxlZnQ7XG4gICAgICAgICAgICAgICAgYnl0ZSA9IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgICAgIGNvbCA9IChpIC0gKGkgJSBwaXhlbEJ5dGVzKSkgLyBwaXhlbEJ5dGVzO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBpIDwgcGl4ZWxCeXRlcyA/IDAgOiBidWZmZXJbYyAtIHBpeGVsQnl0ZXNdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJvdyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgdXBwZXIgPSB1cHBlckxlZnQgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB1cHBlciA9XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltcbiAgICAgICAgICAgICAgICAgICAgICAocm93IC0gMSkgKiBzY2FubGluZUxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wgKiBwaXhlbEJ5dGVzICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChpICUgcGl4ZWxCeXRlcylcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgIHVwcGVyTGVmdCA9XG4gICAgICAgICAgICAgICAgICAgIGNvbCAmJlxuICAgICAgICAgICAgICAgICAgICBidWZmZXJbXG4gICAgICAgICAgICAgICAgICAgICAgKHJvdyAtIDEpICogc2NhbmxpbmVMZW5ndGggK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbCAtIDEpICogcGl4ZWxCeXRlcyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoaSAlIHBpeGVsQnl0ZXMpXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IGxlZnQgKyB1cHBlciAtIHVwcGVyTGVmdDtcbiAgICAgICAgICAgICAgICBjb25zdCBwYSA9IE1hdGguYWJzKHAgLSBsZWZ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYiA9IE1hdGguYWJzKHAgLSB1cHBlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgcGMgPSBNYXRoLmFicyhwIC0gdXBwZXJMZWZ0KTtcblxuICAgICAgICAgICAgICAgIGlmIChwYSA8PSBwYiAmJiBwYSA8PSBwYykge1xuICAgICAgICAgICAgICAgICAgcGFldGggPSBsZWZ0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGIgPD0gcGMpIHtcbiAgICAgICAgICAgICAgICAgIHBhZXRoID0gdXBwZXI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBhZXRoID0gdXBwZXJMZWZ0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJ1ZmZlcltjKytdID0gKGJ5dGUgKyBwYWV0aCkgJSAyNTY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWx0ZXIgYWxnb3JpdGhtOiAke2RhdGFbcG9zIC0gMV19YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFzaW5nbGVQYXNzKSB7XG4gICAgICAgICAgICBsZXQgcGl4ZWxzUG9zID0gKCh5MCArIHJvdyAqIGR5KSAqIHdpZHRoICsgeDApICogcGl4ZWxCeXRlcztcbiAgICAgICAgICAgIGxldCBidWZmZXJQb3MgPSByb3cgKiBzY2FubGluZUxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB3OyBpKyspIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwaXhlbEJ5dGVzOyBqKyspXG4gICAgICAgICAgICAgICAgcGl4ZWxzW3BpeGVsc1BvcysrXSA9IGJ1ZmZlcltidWZmZXJQb3MrK107XG4gICAgICAgICAgICAgIHBpeGVsc1BvcyArPSAoZHggLSAxKSAqIHBpeGVsQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm93Kys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaW50ZXJsYWNlTWV0aG9kID09PSAxKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgMSA2IDQgNiAyIDYgNCA2XG4gICAgICAgICAgNyA3IDcgNyA3IDcgNyA3XG4gICAgICAgICAgNSA2IDUgNiA1IDYgNSA2XG4gICAgICAgICAgNyA3IDcgNyA3IDcgNyA3XG4gICAgICAgICAgMyA2IDQgNiAzIDYgNCA2XG4gICAgICAgICAgNyA3IDcgNyA3IDcgNyA3XG4gICAgICAgICAgNSA2IDUgNiA1IDYgNSA2XG4gICAgICAgICAgNyA3IDcgNyA3IDcgNyA3XG4gICAgICAgICovXG4gICAgICAgIHBhc3MoMCwgMCwgOCwgOCk7IC8vIDFcbiAgICAgICAgcGFzcyg0LCAwLCA4LCA4KTsgLy8gMlxuICAgICAgICBwYXNzKDAsIDQsIDQsIDgpOyAvLyAzXG4gICAgICAgIHBhc3MoMiwgMCwgNCwgNCk7IC8vIDRcbiAgICAgICAgcGFzcygwLCAyLCAyLCA0KTsgLy8gNVxuICAgICAgICBwYXNzKDEsIDAsIDIsIDIpOyAvLyA2XG4gICAgICAgIHBhc3MoMCwgMSwgMSwgMik7IC8vIDdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhc3MoMCwgMCwgMSwgMSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbihwaXhlbHMpO1xuICAgIH0pO1xuICB9XG5cbiAgZGVjb2RlUGFsZXR0ZSgpIHtcbiAgICBjb25zdCB7IHBhbGV0dGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHBhbGV0dGU7XG4gICAgY29uc3QgdHJhbnNwYXJlbmN5ID0gdGhpcy50cmFuc3BhcmVuY3kuaW5kZXhlZCB8fCBbXTtcbiAgICBjb25zdCByZXQgPSBuZXcgQnVmZmVyKHRyYW5zcGFyZW5jeS5sZW5ndGggKyBsZW5ndGgpO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGxldCBjID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIHZhciBsZWZ0O1xuICAgICAgcmV0W3BvcysrXSA9IHBhbGV0dGVbaV07XG4gICAgICByZXRbcG9zKytdID0gcGFsZXR0ZVtpICsgMV07XG4gICAgICByZXRbcG9zKytdID0gcGFsZXR0ZVtpICsgMl07XG4gICAgICByZXRbcG9zKytdID0gKGxlZnQgPSB0cmFuc3BhcmVuY3lbYysrXSkgIT0gbnVsbCA/IGxlZnQgOiAyNTU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGNvcHlUb0ltYWdlRGF0YShpbWFnZURhdGEsIHBpeGVscykge1xuICAgIGxldCBqLCBrO1xuICAgIGxldCB7IGNvbG9ycyB9ID0gdGhpcztcbiAgICBsZXQgcGFsZXR0ZSA9IG51bGw7XG4gICAgbGV0IGFscGhhID0gdGhpcy5oYXNBbHBoYUNoYW5uZWw7XG5cbiAgICBpZiAodGhpcy5wYWxldHRlLmxlbmd0aCkge1xuICAgICAgcGFsZXR0ZSA9XG4gICAgICAgIHRoaXMuX2RlY29kZWRQYWxldHRlIHx8ICh0aGlzLl9kZWNvZGVkUGFsZXR0ZSA9IHRoaXMuZGVjb2RlUGFsZXR0ZSgpKTtcbiAgICAgIGNvbG9ycyA9IDQ7XG4gICAgICBhbHBoYSA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhIHx8IGltYWdlRGF0YTtcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gZGF0YTtcbiAgICBjb25zdCBpbnB1dCA9IHBhbGV0dGUgfHwgcGl4ZWxzO1xuICAgIGxldCBpID0gKGogPSAwKTtcblxuICAgIGlmIChjb2xvcnMgPT09IDEpIHtcbiAgICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgIGsgPSBwYWxldHRlID8gcGl4ZWxzW2kgLyA0XSAqIDQgOiBqO1xuICAgICAgICBjb25zdCB2ID0gaW5wdXRbaysrXTtcbiAgICAgICAgZGF0YVtpKytdID0gdjtcbiAgICAgICAgZGF0YVtpKytdID0gdjtcbiAgICAgICAgZGF0YVtpKytdID0gdjtcbiAgICAgICAgZGF0YVtpKytdID0gYWxwaGEgPyBpbnB1dFtrKytdIDogMjU1O1xuICAgICAgICBqID0gaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgayA9IHBhbGV0dGUgPyBwaXhlbHNbaSAvIDRdICogNCA6IGo7XG4gICAgICAgIGRhdGFbaSsrXSA9IGlucHV0W2srK107XG4gICAgICAgIGRhdGFbaSsrXSA9IGlucHV0W2srK107XG4gICAgICAgIGRhdGFbaSsrXSA9IGlucHV0W2srK107XG4gICAgICAgIGRhdGFbaSsrXSA9IGFscGhhID8gaW5wdXRbaysrXSA6IDI1NTtcbiAgICAgICAgaiA9IGs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVjb2RlKGZuKSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IEJ1ZmZlcih0aGlzLndpZHRoICogdGhpcy5oZWlnaHQgKiA0KTtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGVQaXhlbHMocGl4ZWxzID0+IHtcbiAgICAgIHRoaXMuY29weVRvSW1hZ2VEYXRhKHJldCwgcGl4ZWxzKTtcbiAgICAgIHJldHVybiBmbihyZXQpO1xuICAgIH0pO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/png-js/png-node.js\n");

/***/ })

};
;