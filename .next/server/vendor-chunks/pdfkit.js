"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdfkit";
exports.ids = ["vendor-chunks/pdfkit"];
exports.modules = {

/***/ "(rsc)/./node_modules/pdfkit/js/pdfkit.es.js":
/*!*********************************************!*\
  !*** ./node_modules/pdfkit/js/pdfkit.es.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PDFDocument)\n/* harmony export */ });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zlib */ \"zlib\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(zlib__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crypto-js */ \"(rsc)/./node_modules/crypto-js/index.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var fontkit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fontkit */ \"(rsc)/./node_modules/fontkit/dist/module.mjs\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var linebreak__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! linebreak */ \"(rsc)/./node_modules/linebreak/dist/module.mjs\");\n/* harmony import */ var jpeg_exif__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! jpeg-exif */ \"(rsc)/./node_modules/jpeg-exif/lib/index.js\");\n/* harmony import */ var png_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! png-js */ \"(rsc)/./node_modules/png-js/png-node.js\");\n/* harmony import */ var png_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(png_js__WEBPACK_IMPORTED_MODULE_8__);\n\n\n\n\n\n\n\n\n\n\nclass PDFAbstractReference {\n  toString() {\n    throw new Error('Must be implemented by subclasses');\n  }\n}\n\nclass PDFTree {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._items = {};\n    this.limits = typeof options.limits === 'boolean' ? options.limits : true;\n  }\n  add(key, val) {\n    return this._items[key] = val;\n  }\n  get(key) {\n    return this._items[key];\n  }\n  toString() {\n    const sortedKeys = Object.keys(this._items).sort((a, b) => this._compareKeys(a, b));\n    const out = ['<<'];\n    if (this.limits && sortedKeys.length > 1) {\n      const first = sortedKeys[0],\n        last = sortedKeys[sortedKeys.length - 1];\n      out.push(`  /Limits ${PDFObject.convert([this._dataForKey(first), this._dataForKey(last)])}`);\n    }\n    out.push(`  /${this._keysName()} [`);\n    for (let key of sortedKeys) {\n      out.push(`    ${PDFObject.convert(this._dataForKey(key))} ${PDFObject.convert(this._items[key])}`);\n    }\n    out.push(']');\n    out.push('>>');\n    return out.join('\\n');\n  }\n  _compareKeys() {\n    throw new Error('Must be implemented by subclasses');\n  }\n  _keysName() {\n    throw new Error('Must be implemented by subclasses');\n  }\n  _dataForKey() {\n    throw new Error('Must be implemented by subclasses');\n  }\n}\n\nclass SpotColor {\n  constructor(doc, name, C, M, Y, K) {\n    this.id = 'CS' + Object.keys(doc.spotColors).length;\n    this.name = name;\n    this.values = [C, M, Y, K];\n    this.ref = doc.ref(['Separation', this.name, 'DeviceCMYK', {\n      Range: [0, 1, 0, 1, 0, 1, 0, 1],\n      C0: [0, 0, 0, 0],\n      C1: this.values.map(value => value / 100),\n      FunctionType: 2,\n      Domain: [0, 1],\n      N: 1\n    }]);\n    this.ref.end();\n  }\n  toString() {\n    return `${this.ref.id} 0 R`;\n  }\n}\n\nconst pad = (str, length) => (Array(length + 1).join('0') + str).slice(-length);\nconst escapableRe = /[\\n\\r\\t\\b\\f()\\\\]/g;\nconst escapable = {\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\\\': '\\\\\\\\',\n  '(': '\\\\(',\n  ')': '\\\\)'\n};\nconst swapBytes = function (buff) {\n  const l = buff.length;\n  if (l & 0x01) {\n    throw new Error('Buffer length must be even');\n  } else {\n    for (let i = 0, end = l - 1; i < end; i += 2) {\n      const a = buff[i];\n      buff[i] = buff[i + 1];\n      buff[i + 1] = a;\n    }\n  }\n  return buff;\n};\nclass PDFObject {\n  static convert(object) {\n    let encryptFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (typeof object === 'string') {\n      return `/${object}`;\n    } else if (object instanceof String) {\n      let string = object;\n      let isUnicode = false;\n      for (let i = 0, end = string.length; i < end; i++) {\n        if (string.charCodeAt(i) > 0x7f) {\n          isUnicode = true;\n          break;\n        }\n      }\n      let stringBuffer;\n      if (isUnicode) {\n        stringBuffer = swapBytes(Buffer.from(`\\ufeff${string}`, 'utf16le'));\n      } else {\n        stringBuffer = Buffer.from(string.valueOf(), 'ascii');\n      }\n      if (encryptFn) {\n        string = encryptFn(stringBuffer).toString('binary');\n      } else {\n        string = stringBuffer.toString('binary');\n      }\n      string = string.replace(escapableRe, c => escapable[c]);\n      return `(${string})`;\n    } else if (Buffer.isBuffer(object)) {\n      return `<${object.toString('hex')}>`;\n    } else if (object instanceof PDFAbstractReference || object instanceof PDFTree || object instanceof SpotColor) {\n      return object.toString();\n    } else if (object instanceof Date) {\n      let string = `D:${pad(object.getUTCFullYear(), 4)}` + pad(object.getUTCMonth() + 1, 2) + pad(object.getUTCDate(), 2) + pad(object.getUTCHours(), 2) + pad(object.getUTCMinutes(), 2) + pad(object.getUTCSeconds(), 2) + 'Z';\n      if (encryptFn) {\n        string = encryptFn(Buffer.from(string, 'ascii')).toString('binary');\n        string = string.replace(escapableRe, c => escapable[c]);\n      }\n      return `(${string})`;\n    } else if (Array.isArray(object)) {\n      const items = object.map(e => PDFObject.convert(e, encryptFn)).join(' ');\n      return `[${items}]`;\n    } else if ({}.toString.call(object) === '[object Object]') {\n      const out = ['<<'];\n      for (let key in object) {\n        const val = object[key];\n        out.push(`/${key} ${PDFObject.convert(val, encryptFn)}`);\n      }\n      out.push('>>');\n      return out.join('\\n');\n    } else if (typeof object === 'number') {\n      return PDFObject.number(object);\n    } else {\n      return `${object}`;\n    }\n  }\n  static number(n) {\n    if (n > -1e21 && n < 1e21) {\n      return Math.round(n * 1e6) / 1e6;\n    }\n    throw new Error(`unsupported number: ${n}`);\n  }\n}\n\nclass PDFReference extends PDFAbstractReference {\n  constructor(document, id) {\n    let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    this.document = document;\n    this.id = id;\n    this.data = data;\n    this.gen = 0;\n    this.compress = this.document.compress && !this.data.Filter;\n    this.uncompressedLength = 0;\n    this.buffer = [];\n  }\n  write(chunk) {\n    if (!(chunk instanceof Uint8Array)) {\n      chunk = Buffer.from(chunk + '\\n', 'binary');\n    }\n    this.uncompressedLength += chunk.length;\n    if (this.data.Length == null) {\n      this.data.Length = 0;\n    }\n    this.buffer.push(chunk);\n    this.data.Length += chunk.length;\n    if (this.compress) {\n      this.data.Filter = 'FlateDecode';\n    }\n  }\n  end(chunk) {\n    if (chunk) {\n      this.write(chunk);\n    }\n    this.finalize();\n  }\n  finalize() {\n    this.offset = this.document._offset;\n    const encryptFn = this.document._security ? this.document._security.getEncryptFn(this.id, this.gen) : null;\n    if (this.buffer.length) {\n      this.buffer = Buffer.concat(this.buffer);\n      if (this.compress) {\n        this.buffer = zlib__WEBPACK_IMPORTED_MODULE_1___default().deflateSync(this.buffer);\n      }\n      if (encryptFn) {\n        this.buffer = encryptFn(this.buffer);\n      }\n      this.data.Length = this.buffer.length;\n    }\n    this.document._write(`${this.id} ${this.gen} obj`);\n    this.document._write(PDFObject.convert(this.data, encryptFn));\n    if (this.buffer.length) {\n      this.document._write('stream');\n      this.document._write(this.buffer);\n      this.buffer = [];\n      this.document._write('\\nendstream');\n    }\n    this.document._write('endobj');\n    this.document._refEnd(this);\n  }\n  toString() {\n    return `${this.id} ${this.gen} R`;\n  }\n}\n\nconst fArray = new Float32Array(1);\nconst uArray = new Uint32Array(fArray.buffer);\nfunction PDFNumber(n) {\n  const rounded = Math.fround(n);\n  if (rounded <= n) return rounded;\n  fArray[0] = n;\n  if (n <= 0) {\n    uArray[0] += 1;\n  } else {\n    uArray[0] -= 1;\n  }\n  return fArray[0];\n}\nfunction normalizeSides(sides) {\n  let defaultDefinition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  let transformer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : v => v;\n  if (sides == null || typeof sides === 'object' && Object.keys(sides).length === 0) {\n    sides = defaultDefinition;\n  }\n  if (sides == null || typeof sides !== 'object') {\n    sides = {\n      top: sides,\n      right: sides,\n      bottom: sides,\n      left: sides\n    };\n  } else if (Array.isArray(sides)) {\n    if (sides.length === 2) {\n      sides = {\n        vertical: sides[0],\n        horizontal: sides[1]\n      };\n    } else {\n      sides = {\n        top: sides[0],\n        right: sides[1],\n        bottom: sides[2],\n        left: sides[3]\n      };\n    }\n  }\n  if ('vertical' in sides || 'horizontal' in sides) {\n    sides = {\n      top: sides.vertical,\n      right: sides.horizontal,\n      bottom: sides.vertical,\n      left: sides.horizontal\n    };\n  }\n  return {\n    top: transformer(sides.top),\n    right: transformer(sides.right),\n    bottom: transformer(sides.bottom),\n    left: transformer(sides.left)\n  };\n}\nconst MM_TO_CM = 1 / 10;\nconst CM_TO_IN = 1 / 2.54;\nconst PX_TO_IN = 1 / 96;\nconst IN_TO_PT = 72;\nconst PC_TO_PT = 12;\nfunction cosine(a) {\n  if (a === 0) return 1;\n  if (a === 90) return 0;\n  if (a === 180) return -1;\n  if (a === 270) return 0;\n  return Math.cos(a * Math.PI / 180);\n}\nfunction sine(a) {\n  if (a === 0) return 0;\n  if (a === 90) return 1;\n  if (a === 180) return 0;\n  if (a === 270) return -1;\n  return Math.sin(a * Math.PI / 180);\n}\n\nconst DEFAULT_MARGINS = {\n  top: 72,\n  left: 72,\n  bottom: 72,\n  right: 72\n};\nconst SIZES = {\n  '4A0': [4767.87, 6740.79],\n  '2A0': [3370.39, 4767.87],\n  A0: [2383.94, 3370.39],\n  A1: [1683.78, 2383.94],\n  A2: [1190.55, 1683.78],\n  A3: [841.89, 1190.55],\n  A4: [595.28, 841.89],\n  A5: [419.53, 595.28],\n  A6: [297.64, 419.53],\n  A7: [209.76, 297.64],\n  A8: [147.4, 209.76],\n  A9: [104.88, 147.4],\n  A10: [73.7, 104.88],\n  B0: [2834.65, 4008.19],\n  B1: [2004.09, 2834.65],\n  B2: [1417.32, 2004.09],\n  B3: [1000.63, 1417.32],\n  B4: [708.66, 1000.63],\n  B5: [498.9, 708.66],\n  B6: [354.33, 498.9],\n  B7: [249.45, 354.33],\n  B8: [175.75, 249.45],\n  B9: [124.72, 175.75],\n  B10: [87.87, 124.72],\n  C0: [2599.37, 3676.54],\n  C1: [1836.85, 2599.37],\n  C2: [1298.27, 1836.85],\n  C3: [918.43, 1298.27],\n  C4: [649.13, 918.43],\n  C5: [459.21, 649.13],\n  C6: [323.15, 459.21],\n  C7: [229.61, 323.15],\n  C8: [161.57, 229.61],\n  C9: [113.39, 161.57],\n  C10: [79.37, 113.39],\n  RA0: [2437.8, 3458.27],\n  RA1: [1729.13, 2437.8],\n  RA2: [1218.9, 1729.13],\n  RA3: [864.57, 1218.9],\n  RA4: [609.45, 864.57],\n  SRA0: [2551.18, 3628.35],\n  SRA1: [1814.17, 2551.18],\n  SRA2: [1275.59, 1814.17],\n  SRA3: [907.09, 1275.59],\n  SRA4: [637.8, 907.09],\n  EXECUTIVE: [521.86, 756.0],\n  FOLIO: [612.0, 936.0],\n  LEGAL: [612.0, 1008.0],\n  LETTER: [612.0, 792.0],\n  TABLOID: [792.0, 1224.0]\n};\nclass PDFPage {\n  constructor(document) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.document = document;\n    this._options = options;\n    this.size = options.size || 'letter';\n    this.layout = options.layout || 'portrait';\n    const dimensions = Array.isArray(this.size) ? this.size : SIZES[this.size.toUpperCase()];\n    this.width = dimensions[this.layout === 'portrait' ? 0 : 1];\n    this.height = dimensions[this.layout === 'portrait' ? 1 : 0];\n    this.content = this.document.ref();\n    if (options.font) document.font(options.font, options.fontFamily);\n    if (options.fontSize) document.fontSize(options.fontSize);\n    this.margins = normalizeSides(options.margin ?? options.margins, DEFAULT_MARGINS, x => document.sizeToPoint(x, 0, this));\n    this.resources = this.document.ref({\n      ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI']\n    });\n    this.dictionary = this.document.ref({\n      Type: 'Page',\n      Parent: this.document._root.data.Pages,\n      MediaBox: [0, 0, this.width, this.height],\n      Contents: this.content,\n      Resources: this.resources\n    });\n    this.markings = [];\n  }\n  get fonts() {\n    const data = this.resources.data;\n    return data.Font != null ? data.Font : data.Font = {};\n  }\n  get xobjects() {\n    const data = this.resources.data;\n    return data.XObject != null ? data.XObject : data.XObject = {};\n  }\n  get ext_gstates() {\n    const data = this.resources.data;\n    return data.ExtGState != null ? data.ExtGState : data.ExtGState = {};\n  }\n  get patterns() {\n    const data = this.resources.data;\n    return data.Pattern != null ? data.Pattern : data.Pattern = {};\n  }\n  get colorSpaces() {\n    const data = this.resources.data;\n    return data.ColorSpace || (data.ColorSpace = {});\n  }\n  get annotations() {\n    const data = this.dictionary.data;\n    return data.Annots != null ? data.Annots : data.Annots = [];\n  }\n  get structParentTreeKey() {\n    const data = this.dictionary.data;\n    return data.StructParents != null ? data.StructParents : data.StructParents = this.document.createStructParentTreeNextKey();\n  }\n  get contentWidth() {\n    return this.width - this.margins.left - this.margins.right;\n  }\n  get contentHeight() {\n    return this.height - this.margins.top - this.margins.bottom;\n  }\n  maxY() {\n    return this.height - this.margins.bottom;\n  }\n  write(chunk) {\n    return this.content.write(chunk);\n  }\n  _setTabOrder() {\n    if (!this.dictionary.Tabs && this.document.hasMarkInfoDictionary()) {\n      this.dictionary.data.Tabs = 'S';\n    }\n  }\n  end() {\n    this._setTabOrder();\n    this.dictionary.end();\n    this.resources.data.ColorSpace = this.resources.data.ColorSpace || {};\n    for (let color of Object.values(this.document.spotColors)) {\n      this.resources.data.ColorSpace[color.id] = color;\n    }\n    this.resources.end();\n    return this.content.end();\n  }\n}\n\nclass PDFNameTree extends PDFTree {\n  _compareKeys(a, b) {\n    return a.localeCompare(b);\n  }\n  _keysName() {\n    return 'Names';\n  }\n  _dataForKey(k) {\n    return new String(k);\n  }\n}\n\nfunction inRange(value, rangeGroup) {\n  if (value < rangeGroup[0]) return false;\n  let startRange = 0;\n  let endRange = rangeGroup.length / 2;\n  while (startRange <= endRange) {\n    const middleRange = Math.floor((startRange + endRange) / 2);\n    const arrayIndex = middleRange * 2;\n    if (value >= rangeGroup[arrayIndex] && value <= rangeGroup[arrayIndex + 1]) {\n      return true;\n    }\n    if (value > rangeGroup[arrayIndex + 1]) {\n      startRange = middleRange + 1;\n    } else {\n      endRange = middleRange - 1;\n    }\n  }\n  return false;\n}\n\nconst unassigned_code_points = [0x0221, 0x0221, 0x0234, 0x024f, 0x02ae, 0x02af, 0x02ef, 0x02ff, 0x0350, 0x035f, 0x0370, 0x0373, 0x0376, 0x0379, 0x037b, 0x037d, 0x037f, 0x0383, 0x038b, 0x038b, 0x038d, 0x038d, 0x03a2, 0x03a2, 0x03cf, 0x03cf, 0x03f7, 0x03ff, 0x0487, 0x0487, 0x04cf, 0x04cf, 0x04f6, 0x04f7, 0x04fa, 0x04ff, 0x0510, 0x0530, 0x0557, 0x0558, 0x0560, 0x0560, 0x0588, 0x0588, 0x058b, 0x0590, 0x05a2, 0x05a2, 0x05ba, 0x05ba, 0x05c5, 0x05cf, 0x05eb, 0x05ef, 0x05f5, 0x060b, 0x060d, 0x061a, 0x061c, 0x061e, 0x0620, 0x0620, 0x063b, 0x063f, 0x0656, 0x065f, 0x06ee, 0x06ef, 0x06ff, 0x06ff, 0x070e, 0x070e, 0x072d, 0x072f, 0x074b, 0x077f, 0x07b2, 0x0900, 0x0904, 0x0904, 0x093a, 0x093b, 0x094e, 0x094f, 0x0955, 0x0957, 0x0971, 0x0980, 0x0984, 0x0984, 0x098d, 0x098e, 0x0991, 0x0992, 0x09a9, 0x09a9, 0x09b1, 0x09b1, 0x09b3, 0x09b5, 0x09ba, 0x09bb, 0x09bd, 0x09bd, 0x09c5, 0x09c6, 0x09c9, 0x09ca, 0x09ce, 0x09d6, 0x09d8, 0x09db, 0x09de, 0x09de, 0x09e4, 0x09e5, 0x09fb, 0x0a01, 0x0a03, 0x0a04, 0x0a0b, 0x0a0e, 0x0a11, 0x0a12, 0x0a29, 0x0a29, 0x0a31, 0x0a31, 0x0a34, 0x0a34, 0x0a37, 0x0a37, 0x0a3a, 0x0a3b, 0x0a3d, 0x0a3d, 0x0a43, 0x0a46, 0x0a49, 0x0a4a, 0x0a4e, 0x0a58, 0x0a5d, 0x0a5d, 0x0a5f, 0x0a65, 0x0a75, 0x0a80, 0x0a84, 0x0a84, 0x0a8c, 0x0a8c, 0x0a8e, 0x0a8e, 0x0a92, 0x0a92, 0x0aa9, 0x0aa9, 0x0ab1, 0x0ab1, 0x0ab4, 0x0ab4, 0x0aba, 0x0abb, 0x0ac6, 0x0ac6, 0x0aca, 0x0aca, 0x0ace, 0x0acf, 0x0ad1, 0x0adf, 0x0ae1, 0x0ae5, 0x0af0, 0x0b00, 0x0b04, 0x0b04, 0x0b0d, 0x0b0e, 0x0b11, 0x0b12, 0x0b29, 0x0b29, 0x0b31, 0x0b31, 0x0b34, 0x0b35, 0x0b3a, 0x0b3b, 0x0b44, 0x0b46, 0x0b49, 0x0b4a, 0x0b4e, 0x0b55, 0x0b58, 0x0b5b, 0x0b5e, 0x0b5e, 0x0b62, 0x0b65, 0x0b71, 0x0b81, 0x0b84, 0x0b84, 0x0b8b, 0x0b8d, 0x0b91, 0x0b91, 0x0b96, 0x0b98, 0x0b9b, 0x0b9b, 0x0b9d, 0x0b9d, 0x0ba0, 0x0ba2, 0x0ba5, 0x0ba7, 0x0bab, 0x0bad, 0x0bb6, 0x0bb6, 0x0bba, 0x0bbd, 0x0bc3, 0x0bc5, 0x0bc9, 0x0bc9, 0x0bce, 0x0bd6, 0x0bd8, 0x0be6, 0x0bf3, 0x0c00, 0x0c04, 0x0c04, 0x0c0d, 0x0c0d, 0x0c11, 0x0c11, 0x0c29, 0x0c29, 0x0c34, 0x0c34, 0x0c3a, 0x0c3d, 0x0c45, 0x0c45, 0x0c49, 0x0c49, 0x0c4e, 0x0c54, 0x0c57, 0x0c5f, 0x0c62, 0x0c65, 0x0c70, 0x0c81, 0x0c84, 0x0c84, 0x0c8d, 0x0c8d, 0x0c91, 0x0c91, 0x0ca9, 0x0ca9, 0x0cb4, 0x0cb4, 0x0cba, 0x0cbd, 0x0cc5, 0x0cc5, 0x0cc9, 0x0cc9, 0x0cce, 0x0cd4, 0x0cd7, 0x0cdd, 0x0cdf, 0x0cdf, 0x0ce2, 0x0ce5, 0x0cf0, 0x0d01, 0x0d04, 0x0d04, 0x0d0d, 0x0d0d, 0x0d11, 0x0d11, 0x0d29, 0x0d29, 0x0d3a, 0x0d3d, 0x0d44, 0x0d45, 0x0d49, 0x0d49, 0x0d4e, 0x0d56, 0x0d58, 0x0d5f, 0x0d62, 0x0d65, 0x0d70, 0x0d81, 0x0d84, 0x0d84, 0x0d97, 0x0d99, 0x0db2, 0x0db2, 0x0dbc, 0x0dbc, 0x0dbe, 0x0dbf, 0x0dc7, 0x0dc9, 0x0dcb, 0x0dce, 0x0dd5, 0x0dd5, 0x0dd7, 0x0dd7, 0x0de0, 0x0df1, 0x0df5, 0x0e00, 0x0e3b, 0x0e3e, 0x0e5c, 0x0e80, 0x0e83, 0x0e83, 0x0e85, 0x0e86, 0x0e89, 0x0e89, 0x0e8b, 0x0e8c, 0x0e8e, 0x0e93, 0x0e98, 0x0e98, 0x0ea0, 0x0ea0, 0x0ea4, 0x0ea4, 0x0ea6, 0x0ea6, 0x0ea8, 0x0ea9, 0x0eac, 0x0eac, 0x0eba, 0x0eba, 0x0ebe, 0x0ebf, 0x0ec5, 0x0ec5, 0x0ec7, 0x0ec7, 0x0ece, 0x0ecf, 0x0eda, 0x0edb, 0x0ede, 0x0eff, 0x0f48, 0x0f48, 0x0f6b, 0x0f70, 0x0f8c, 0x0f8f, 0x0f98, 0x0f98, 0x0fbd, 0x0fbd, 0x0fcd, 0x0fce, 0x0fd0, 0x0fff, 0x1022, 0x1022, 0x1028, 0x1028, 0x102b, 0x102b, 0x1033, 0x1035, 0x103a, 0x103f, 0x105a, 0x109f, 0x10c6, 0x10cf, 0x10f9, 0x10fa, 0x10fc, 0x10ff, 0x115a, 0x115e, 0x11a3, 0x11a7, 0x11fa, 0x11ff, 0x1207, 0x1207, 0x1247, 0x1247, 0x1249, 0x1249, 0x124e, 0x124f, 0x1257, 0x1257, 0x1259, 0x1259, 0x125e, 0x125f, 0x1287, 0x1287, 0x1289, 0x1289, 0x128e, 0x128f, 0x12af, 0x12af, 0x12b1, 0x12b1, 0x12b6, 0x12b7, 0x12bf, 0x12bf, 0x12c1, 0x12c1, 0x12c6, 0x12c7, 0x12cf, 0x12cf, 0x12d7, 0x12d7, 0x12ef, 0x12ef, 0x130f, 0x130f, 0x1311, 0x1311, 0x1316, 0x1317, 0x131f, 0x131f, 0x1347, 0x1347, 0x135b, 0x1360, 0x137d, 0x139f, 0x13f5, 0x1400, 0x1677, 0x167f, 0x169d, 0x169f, 0x16f1, 0x16ff, 0x170d, 0x170d, 0x1715, 0x171f, 0x1737, 0x173f, 0x1754, 0x175f, 0x176d, 0x176d, 0x1771, 0x1771, 0x1774, 0x177f, 0x17dd, 0x17df, 0x17ea, 0x17ff, 0x180f, 0x180f, 0x181a, 0x181f, 0x1878, 0x187f, 0x18aa, 0x1dff, 0x1e9c, 0x1e9f, 0x1efa, 0x1eff, 0x1f16, 0x1f17, 0x1f1e, 0x1f1f, 0x1f46, 0x1f47, 0x1f4e, 0x1f4f, 0x1f58, 0x1f58, 0x1f5a, 0x1f5a, 0x1f5c, 0x1f5c, 0x1f5e, 0x1f5e, 0x1f7e, 0x1f7f, 0x1fb5, 0x1fb5, 0x1fc5, 0x1fc5, 0x1fd4, 0x1fd5, 0x1fdc, 0x1fdc, 0x1ff0, 0x1ff1, 0x1ff5, 0x1ff5, 0x1fff, 0x1fff, 0x2053, 0x2056, 0x2058, 0x205e, 0x2064, 0x2069, 0x2072, 0x2073, 0x208f, 0x209f, 0x20b2, 0x20cf, 0x20eb, 0x20ff, 0x213b, 0x213c, 0x214c, 0x2152, 0x2184, 0x218f, 0x23cf, 0x23ff, 0x2427, 0x243f, 0x244b, 0x245f, 0x24ff, 0x24ff, 0x2614, 0x2615, 0x2618, 0x2618, 0x267e, 0x267f, 0x268a, 0x2700, 0x2705, 0x2705, 0x270a, 0x270b, 0x2728, 0x2728, 0x274c, 0x274c, 0x274e, 0x274e, 0x2753, 0x2755, 0x2757, 0x2757, 0x275f, 0x2760, 0x2795, 0x2797, 0x27b0, 0x27b0, 0x27bf, 0x27cf, 0x27ec, 0x27ef, 0x2b00, 0x2e7f, 0x2e9a, 0x2e9a, 0x2ef4, 0x2eff, 0x2fd6, 0x2fef, 0x2ffc, 0x2fff, 0x3040, 0x3040, 0x3097, 0x3098, 0x3100, 0x3104, 0x312d, 0x3130, 0x318f, 0x318f, 0x31b8, 0x31ef, 0x321d, 0x321f, 0x3244, 0x3250, 0x327c, 0x327e, 0x32cc, 0x32cf, 0x32ff, 0x32ff, 0x3377, 0x337a, 0x33de, 0x33df, 0x33ff, 0x33ff, 0x4db6, 0x4dff, 0x9fa6, 0x9fff, 0xa48d, 0xa48f, 0xa4c7, 0xabff, 0xd7a4, 0xd7ff, 0xfa2e, 0xfa2f, 0xfa6b, 0xfaff, 0xfb07, 0xfb12, 0xfb18, 0xfb1c, 0xfb37, 0xfb37, 0xfb3d, 0xfb3d, 0xfb3f, 0xfb3f, 0xfb42, 0xfb42, 0xfb45, 0xfb45, 0xfbb2, 0xfbd2, 0xfd40, 0xfd4f, 0xfd90, 0xfd91, 0xfdc8, 0xfdcf, 0xfdfd, 0xfdff, 0xfe10, 0xfe1f, 0xfe24, 0xfe2f, 0xfe47, 0xfe48, 0xfe53, 0xfe53, 0xfe67, 0xfe67, 0xfe6c, 0xfe6f, 0xfe75, 0xfe75, 0xfefd, 0xfefe, 0xff00, 0xff00, 0xffbf, 0xffc1, 0xffc8, 0xffc9, 0xffd0, 0xffd1, 0xffd8, 0xffd9, 0xffdd, 0xffdf, 0xffe7, 0xffe7, 0xffef, 0xfff8, 0x10000, 0x102ff, 0x1031f, 0x1031f, 0x10324, 0x1032f, 0x1034b, 0x103ff, 0x10426, 0x10427, 0x1044e, 0x1cfff, 0x1d0f6, 0x1d0ff, 0x1d127, 0x1d129, 0x1d1de, 0x1d3ff, 0x1d455, 0x1d455, 0x1d49d, 0x1d49d, 0x1d4a0, 0x1d4a1, 0x1d4a3, 0x1d4a4, 0x1d4a7, 0x1d4a8, 0x1d4ad, 0x1d4ad, 0x1d4ba, 0x1d4ba, 0x1d4bc, 0x1d4bc, 0x1d4c1, 0x1d4c1, 0x1d4c4, 0x1d4c4, 0x1d506, 0x1d506, 0x1d50b, 0x1d50c, 0x1d515, 0x1d515, 0x1d51d, 0x1d51d, 0x1d53a, 0x1d53a, 0x1d53f, 0x1d53f, 0x1d545, 0x1d545, 0x1d547, 0x1d549, 0x1d551, 0x1d551, 0x1d6a4, 0x1d6a7, 0x1d7ca, 0x1d7cd, 0x1d800, 0x1fffd, 0x2a6d7, 0x2f7ff, 0x2fa1e, 0x2fffd, 0x30000, 0x3fffd, 0x40000, 0x4fffd, 0x50000, 0x5fffd, 0x60000, 0x6fffd, 0x70000, 0x7fffd, 0x80000, 0x8fffd, 0x90000, 0x9fffd, 0xa0000, 0xafffd, 0xb0000, 0xbfffd, 0xc0000, 0xcfffd, 0xd0000, 0xdfffd, 0xe0000, 0xe0000, 0xe0002, 0xe001f, 0xe0080, 0xefffd];\nconst isUnassignedCodePoint = character => inRange(character, unassigned_code_points);\nconst commonly_mapped_to_nothing = [0x00ad, 0x00ad, 0x034f, 0x034f, 0x1806, 0x1806, 0x180b, 0x180b, 0x180c, 0x180c, 0x180d, 0x180d, 0x200b, 0x200b, 0x200c, 0x200c, 0x200d, 0x200d, 0x2060, 0x2060, 0xfe00, 0xfe00, 0xfe01, 0xfe01, 0xfe02, 0xfe02, 0xfe03, 0xfe03, 0xfe04, 0xfe04, 0xfe05, 0xfe05, 0xfe06, 0xfe06, 0xfe07, 0xfe07, 0xfe08, 0xfe08, 0xfe09, 0xfe09, 0xfe0a, 0xfe0a, 0xfe0b, 0xfe0b, 0xfe0c, 0xfe0c, 0xfe0d, 0xfe0d, 0xfe0e, 0xfe0e, 0xfe0f, 0xfe0f, 0xfeff, 0xfeff];\nconst isCommonlyMappedToNothing = character => inRange(character, commonly_mapped_to_nothing);\nconst non_ASCII_space_characters = [0x00a0, 0x00a0, 0x1680, 0x1680, 0x2000, 0x2000, 0x2001, 0x2001, 0x2002, 0x2002, 0x2003, 0x2003, 0x2004, 0x2004, 0x2005, 0x2005, 0x2006, 0x2006, 0x2007, 0x2007, 0x2008, 0x2008, 0x2009, 0x2009, 0x200a, 0x200a, 0x200b, 0x200b, 0x202f, 0x202f, 0x205f, 0x205f, 0x3000, 0x3000];\nconst isNonASCIISpaceCharacter = character => inRange(character, non_ASCII_space_characters);\nconst non_ASCII_controls_characters = [0x0080, 0x009f, 0x06dd, 0x06dd, 0x070f, 0x070f, 0x180e, 0x180e, 0x200c, 0x200c, 0x200d, 0x200d, 0x2028, 0x2028, 0x2029, 0x2029, 0x2060, 0x2060, 0x2061, 0x2061, 0x2062, 0x2062, 0x2063, 0x2063, 0x206a, 0x206f, 0xfeff, 0xfeff, 0xfff9, 0xfffc, 0x1d173, 0x1d17a];\nconst non_character_codepoints = [0xfdd0, 0xfdef, 0xfffe, 0xffff, 0x1fffe, 0x1ffff, 0x2fffe, 0x2ffff, 0x3fffe, 0x3ffff, 0x4fffe, 0x4ffff, 0x5fffe, 0x5ffff, 0x6fffe, 0x6ffff, 0x7fffe, 0x7ffff, 0x8fffe, 0x8ffff, 0x9fffe, 0x9ffff, 0xafffe, 0xaffff, 0xbfffe, 0xbffff, 0xcfffe, 0xcffff, 0xdfffe, 0xdffff, 0xefffe, 0xeffff, 0x10fffe, 0x10ffff];\nconst prohibited_characters = [0, 0x001f, 0x007f, 0x007f, 0x0340, 0x0340, 0x0341, 0x0341, 0x200e, 0x200e, 0x200f, 0x200f, 0x202a, 0x202a, 0x202b, 0x202b, 0x202c, 0x202c, 0x202d, 0x202d, 0x202e, 0x202e, 0x206a, 0x206a, 0x206b, 0x206b, 0x206c, 0x206c, 0x206d, 0x206d, 0x206e, 0x206e, 0x206f, 0x206f, 0x2ff0, 0x2ffb, 0xd800, 0xdfff, 0xe000, 0xf8ff, 0xfff9, 0xfff9, 0xfffa, 0xfffa, 0xfffb, 0xfffb, 0xfffc, 0xfffc, 0xfffd, 0xfffd, 0xe0001, 0xe0001, 0xe0020, 0xe007f, 0xf0000, 0xffffd, 0x100000, 0x10fffd];\nconst isProhibitedCharacter = character => inRange(character, non_ASCII_space_characters) || inRange(character, prohibited_characters) || inRange(character, non_ASCII_controls_characters) || inRange(character, non_character_codepoints);\nconst bidirectional_r_al = [0x05be, 0x05be, 0x05c0, 0x05c0, 0x05c3, 0x05c3, 0x05d0, 0x05ea, 0x05f0, 0x05f4, 0x061b, 0x061b, 0x061f, 0x061f, 0x0621, 0x063a, 0x0640, 0x064a, 0x066d, 0x066f, 0x0671, 0x06d5, 0x06dd, 0x06dd, 0x06e5, 0x06e6, 0x06fa, 0x06fe, 0x0700, 0x070d, 0x0710, 0x0710, 0x0712, 0x072c, 0x0780, 0x07a5, 0x07b1, 0x07b1, 0x200f, 0x200f, 0xfb1d, 0xfb1d, 0xfb1f, 0xfb28, 0xfb2a, 0xfb36, 0xfb38, 0xfb3c, 0xfb3e, 0xfb3e, 0xfb40, 0xfb41, 0xfb43, 0xfb44, 0xfb46, 0xfbb1, 0xfbd3, 0xfd3d, 0xfd50, 0xfd8f, 0xfd92, 0xfdc7, 0xfdf0, 0xfdfc, 0xfe70, 0xfe74, 0xfe76, 0xfefc];\nconst isBidirectionalRAL = character => inRange(character, bidirectional_r_al);\nconst bidirectional_l = [0x0041, 0x005a, 0x0061, 0x007a, 0x00aa, 0x00aa, 0x00b5, 0x00b5, 0x00ba, 0x00ba, 0x00c0, 0x00d6, 0x00d8, 0x00f6, 0x00f8, 0x0220, 0x0222, 0x0233, 0x0250, 0x02ad, 0x02b0, 0x02b8, 0x02bb, 0x02c1, 0x02d0, 0x02d1, 0x02e0, 0x02e4, 0x02ee, 0x02ee, 0x037a, 0x037a, 0x0386, 0x0386, 0x0388, 0x038a, 0x038c, 0x038c, 0x038e, 0x03a1, 0x03a3, 0x03ce, 0x03d0, 0x03f5, 0x0400, 0x0482, 0x048a, 0x04ce, 0x04d0, 0x04f5, 0x04f8, 0x04f9, 0x0500, 0x050f, 0x0531, 0x0556, 0x0559, 0x055f, 0x0561, 0x0587, 0x0589, 0x0589, 0x0903, 0x0903, 0x0905, 0x0939, 0x093d, 0x0940, 0x0949, 0x094c, 0x0950, 0x0950, 0x0958, 0x0961, 0x0964, 0x0970, 0x0982, 0x0983, 0x0985, 0x098c, 0x098f, 0x0990, 0x0993, 0x09a8, 0x09aa, 0x09b0, 0x09b2, 0x09b2, 0x09b6, 0x09b9, 0x09be, 0x09c0, 0x09c7, 0x09c8, 0x09cb, 0x09cc, 0x09d7, 0x09d7, 0x09dc, 0x09dd, 0x09df, 0x09e1, 0x09e6, 0x09f1, 0x09f4, 0x09fa, 0x0a05, 0x0a0a, 0x0a0f, 0x0a10, 0x0a13, 0x0a28, 0x0a2a, 0x0a30, 0x0a32, 0x0a33, 0x0a35, 0x0a36, 0x0a38, 0x0a39, 0x0a3e, 0x0a40, 0x0a59, 0x0a5c, 0x0a5e, 0x0a5e, 0x0a66, 0x0a6f, 0x0a72, 0x0a74, 0x0a83, 0x0a83, 0x0a85, 0x0a8b, 0x0a8d, 0x0a8d, 0x0a8f, 0x0a91, 0x0a93, 0x0aa8, 0x0aaa, 0x0ab0, 0x0ab2, 0x0ab3, 0x0ab5, 0x0ab9, 0x0abd, 0x0ac0, 0x0ac9, 0x0ac9, 0x0acb, 0x0acc, 0x0ad0, 0x0ad0, 0x0ae0, 0x0ae0, 0x0ae6, 0x0aef, 0x0b02, 0x0b03, 0x0b05, 0x0b0c, 0x0b0f, 0x0b10, 0x0b13, 0x0b28, 0x0b2a, 0x0b30, 0x0b32, 0x0b33, 0x0b36, 0x0b39, 0x0b3d, 0x0b3e, 0x0b40, 0x0b40, 0x0b47, 0x0b48, 0x0b4b, 0x0b4c, 0x0b57, 0x0b57, 0x0b5c, 0x0b5d, 0x0b5f, 0x0b61, 0x0b66, 0x0b70, 0x0b83, 0x0b83, 0x0b85, 0x0b8a, 0x0b8e, 0x0b90, 0x0b92, 0x0b95, 0x0b99, 0x0b9a, 0x0b9c, 0x0b9c, 0x0b9e, 0x0b9f, 0x0ba3, 0x0ba4, 0x0ba8, 0x0baa, 0x0bae, 0x0bb5, 0x0bb7, 0x0bb9, 0x0bbe, 0x0bbf, 0x0bc1, 0x0bc2, 0x0bc6, 0x0bc8, 0x0bca, 0x0bcc, 0x0bd7, 0x0bd7, 0x0be7, 0x0bf2, 0x0c01, 0x0c03, 0x0c05, 0x0c0c, 0x0c0e, 0x0c10, 0x0c12, 0x0c28, 0x0c2a, 0x0c33, 0x0c35, 0x0c39, 0x0c41, 0x0c44, 0x0c60, 0x0c61, 0x0c66, 0x0c6f, 0x0c82, 0x0c83, 0x0c85, 0x0c8c, 0x0c8e, 0x0c90, 0x0c92, 0x0ca8, 0x0caa, 0x0cb3, 0x0cb5, 0x0cb9, 0x0cbe, 0x0cbe, 0x0cc0, 0x0cc4, 0x0cc7, 0x0cc8, 0x0cca, 0x0ccb, 0x0cd5, 0x0cd6, 0x0cde, 0x0cde, 0x0ce0, 0x0ce1, 0x0ce6, 0x0cef, 0x0d02, 0x0d03, 0x0d05, 0x0d0c, 0x0d0e, 0x0d10, 0x0d12, 0x0d28, 0x0d2a, 0x0d39, 0x0d3e, 0x0d40, 0x0d46, 0x0d48, 0x0d4a, 0x0d4c, 0x0d57, 0x0d57, 0x0d60, 0x0d61, 0x0d66, 0x0d6f, 0x0d82, 0x0d83, 0x0d85, 0x0d96, 0x0d9a, 0x0db1, 0x0db3, 0x0dbb, 0x0dbd, 0x0dbd, 0x0dc0, 0x0dc6, 0x0dcf, 0x0dd1, 0x0dd8, 0x0ddf, 0x0df2, 0x0df4, 0x0e01, 0x0e30, 0x0e32, 0x0e33, 0x0e40, 0x0e46, 0x0e4f, 0x0e5b, 0x0e81, 0x0e82, 0x0e84, 0x0e84, 0x0e87, 0x0e88, 0x0e8a, 0x0e8a, 0x0e8d, 0x0e8d, 0x0e94, 0x0e97, 0x0e99, 0x0e9f, 0x0ea1, 0x0ea3, 0x0ea5, 0x0ea5, 0x0ea7, 0x0ea7, 0x0eaa, 0x0eab, 0x0ead, 0x0eb0, 0x0eb2, 0x0eb3, 0x0ebd, 0x0ebd, 0x0ec0, 0x0ec4, 0x0ec6, 0x0ec6, 0x0ed0, 0x0ed9, 0x0edc, 0x0edd, 0x0f00, 0x0f17, 0x0f1a, 0x0f34, 0x0f36, 0x0f36, 0x0f38, 0x0f38, 0x0f3e, 0x0f47, 0x0f49, 0x0f6a, 0x0f7f, 0x0f7f, 0x0f85, 0x0f85, 0x0f88, 0x0f8b, 0x0fbe, 0x0fc5, 0x0fc7, 0x0fcc, 0x0fcf, 0x0fcf, 0x1000, 0x1021, 0x1023, 0x1027, 0x1029, 0x102a, 0x102c, 0x102c, 0x1031, 0x1031, 0x1038, 0x1038, 0x1040, 0x1057, 0x10a0, 0x10c5, 0x10d0, 0x10f8, 0x10fb, 0x10fb, 0x1100, 0x1159, 0x115f, 0x11a2, 0x11a8, 0x11f9, 0x1200, 0x1206, 0x1208, 0x1246, 0x1248, 0x1248, 0x124a, 0x124d, 0x1250, 0x1256, 0x1258, 0x1258, 0x125a, 0x125d, 0x1260, 0x1286, 0x1288, 0x1288, 0x128a, 0x128d, 0x1290, 0x12ae, 0x12b0, 0x12b0, 0x12b2, 0x12b5, 0x12b8, 0x12be, 0x12c0, 0x12c0, 0x12c2, 0x12c5, 0x12c8, 0x12ce, 0x12d0, 0x12d6, 0x12d8, 0x12ee, 0x12f0, 0x130e, 0x1310, 0x1310, 0x1312, 0x1315, 0x1318, 0x131e, 0x1320, 0x1346, 0x1348, 0x135a, 0x1361, 0x137c, 0x13a0, 0x13f4, 0x1401, 0x1676, 0x1681, 0x169a, 0x16a0, 0x16f0, 0x1700, 0x170c, 0x170e, 0x1711, 0x1720, 0x1731, 0x1735, 0x1736, 0x1740, 0x1751, 0x1760, 0x176c, 0x176e, 0x1770, 0x1780, 0x17b6, 0x17be, 0x17c5, 0x17c7, 0x17c8, 0x17d4, 0x17da, 0x17dc, 0x17dc, 0x17e0, 0x17e9, 0x1810, 0x1819, 0x1820, 0x1877, 0x1880, 0x18a8, 0x1e00, 0x1e9b, 0x1ea0, 0x1ef9, 0x1f00, 0x1f15, 0x1f18, 0x1f1d, 0x1f20, 0x1f45, 0x1f48, 0x1f4d, 0x1f50, 0x1f57, 0x1f59, 0x1f59, 0x1f5b, 0x1f5b, 0x1f5d, 0x1f5d, 0x1f5f, 0x1f7d, 0x1f80, 0x1fb4, 0x1fb6, 0x1fbc, 0x1fbe, 0x1fbe, 0x1fc2, 0x1fc4, 0x1fc6, 0x1fcc, 0x1fd0, 0x1fd3, 0x1fd6, 0x1fdb, 0x1fe0, 0x1fec, 0x1ff2, 0x1ff4, 0x1ff6, 0x1ffc, 0x200e, 0x200e, 0x2071, 0x2071, 0x207f, 0x207f, 0x2102, 0x2102, 0x2107, 0x2107, 0x210a, 0x2113, 0x2115, 0x2115, 0x2119, 0x211d, 0x2124, 0x2124, 0x2126, 0x2126, 0x2128, 0x2128, 0x212a, 0x212d, 0x212f, 0x2131, 0x2133, 0x2139, 0x213d, 0x213f, 0x2145, 0x2149, 0x2160, 0x2183, 0x2336, 0x237a, 0x2395, 0x2395, 0x249c, 0x24e9, 0x3005, 0x3007, 0x3021, 0x3029, 0x3031, 0x3035, 0x3038, 0x303c, 0x3041, 0x3096, 0x309d, 0x309f, 0x30a1, 0x30fa, 0x30fc, 0x30ff, 0x3105, 0x312c, 0x3131, 0x318e, 0x3190, 0x31b7, 0x31f0, 0x321c, 0x3220, 0x3243, 0x3260, 0x327b, 0x327f, 0x32b0, 0x32c0, 0x32cb, 0x32d0, 0x32fe, 0x3300, 0x3376, 0x337b, 0x33dd, 0x33e0, 0x33fe, 0x3400, 0x4db5, 0x4e00, 0x9fa5, 0xa000, 0xa48c, 0xac00, 0xd7a3, 0xd800, 0xfa2d, 0xfa30, 0xfa6a, 0xfb00, 0xfb06, 0xfb13, 0xfb17, 0xff21, 0xff3a, 0xff41, 0xff5a, 0xff66, 0xffbe, 0xffc2, 0xffc7, 0xffca, 0xffcf, 0xffd2, 0xffd7, 0xffda, 0xffdc, 0x10300, 0x1031e, 0x10320, 0x10323, 0x10330, 0x1034a, 0x10400, 0x10425, 0x10428, 0x1044d, 0x1d000, 0x1d0f5, 0x1d100, 0x1d126, 0x1d12a, 0x1d166, 0x1d16a, 0x1d172, 0x1d183, 0x1d184, 0x1d18c, 0x1d1a9, 0x1d1ae, 0x1d1dd, 0x1d400, 0x1d454, 0x1d456, 0x1d49c, 0x1d49e, 0x1d49f, 0x1d4a2, 0x1d4a2, 0x1d4a5, 0x1d4a6, 0x1d4a9, 0x1d4ac, 0x1d4ae, 0x1d4b9, 0x1d4bb, 0x1d4bb, 0x1d4bd, 0x1d4c0, 0x1d4c2, 0x1d4c3, 0x1d4c5, 0x1d505, 0x1d507, 0x1d50a, 0x1d50d, 0x1d514, 0x1d516, 0x1d51c, 0x1d51e, 0x1d539, 0x1d53b, 0x1d53e, 0x1d540, 0x1d544, 0x1d546, 0x1d546, 0x1d54a, 0x1d550, 0x1d552, 0x1d6a3, 0x1d6a8, 0x1d7c9, 0x20000, 0x2a6d6, 0x2f800, 0x2fa1d, 0xf0000, 0xffffd, 0x100000, 0x10fffd];\nconst isBidirectionalL = character => inRange(character, bidirectional_l);\n\nconst mapping2space = isNonASCIISpaceCharacter;\nconst mapping2nothing = isCommonlyMappedToNothing;\nconst getCodePoint = character => character.codePointAt(0);\nconst first = x => x[0];\nconst last = x => x[x.length - 1];\nfunction toCodePoints(input) {\n  const codepoints = [];\n  const size = input.length;\n  for (let i = 0; i < size; i += 1) {\n    const before = input.charCodeAt(i);\n    if (before >= 0xd800 && before <= 0xdbff && size > i + 1) {\n      const next = input.charCodeAt(i + 1);\n      if (next >= 0xdc00 && next <= 0xdfff) {\n        codepoints.push((before - 0xd800) * 0x400 + next - 0xdc00 + 0x10000);\n        i += 1;\n        continue;\n      }\n    }\n    codepoints.push(before);\n  }\n  return codepoints;\n}\nfunction saslprep(input) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected string.');\n  }\n  if (input.length === 0) {\n    return '';\n  }\n  const mapped_input = toCodePoints(input).map(character => mapping2space(character) ? 0x20 : character).filter(character => !mapping2nothing(character));\n  const normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize('NFKC');\n  const normalized_map = toCodePoints(normalized_input);\n  const hasProhibited = normalized_map.some(isProhibitedCharacter);\n  if (hasProhibited) {\n    throw new Error('Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3');\n  }\n  if (opts.allowUnassigned !== true) {\n    const hasUnassigned = normalized_map.some(isUnassignedCodePoint);\n    if (hasUnassigned) {\n      throw new Error('Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5');\n    }\n  }\n  const hasBidiRAL = normalized_map.some(isBidirectionalRAL);\n  const hasBidiL = normalized_map.some(isBidirectionalL);\n  if (hasBidiRAL && hasBidiL) {\n    throw new Error('String must not contain RandALCat and LCat at the same time,' + ' see https://tools.ietf.org/html/rfc3454#section-6');\n  }\n  const isFirstBidiRAL = isBidirectionalRAL(getCodePoint(first(normalized_input)));\n  const isLastBidiRAL = isBidirectionalRAL(getCodePoint(last(normalized_input)));\n  if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {\n    throw new Error('Bidirectional RandALCat character must be the first and the last' + ' character of the string, see https://tools.ietf.org/html/rfc3454#section-6');\n  }\n  return normalized_input;\n}\n\nclass PDFSecurity {\n  static generateFileID() {\n    let info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let infoStr = `${info.CreationDate.getTime()}\\n`;\n    for (let key in info) {\n      if (!info.hasOwnProperty(key)) {\n        continue;\n      }\n      infoStr += `${key}: ${info[key].valueOf()}\\n`;\n    }\n    return wordArrayToBuffer(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(infoStr));\n  }\n  static generateRandomWordArray(bytes) {\n    return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.random(bytes);\n  }\n  static create(document) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!options.ownerPassword && !options.userPassword) {\n      return null;\n    }\n    return new PDFSecurity(document, options);\n  }\n  constructor(document) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!options.ownerPassword && !options.userPassword) {\n      throw new Error('None of owner password and user password is defined.');\n    }\n    this.document = document;\n    this._setupEncryption(options);\n  }\n  _setupEncryption(options) {\n    switch (options.pdfVersion) {\n      case '1.4':\n      case '1.5':\n        this.version = 2;\n        break;\n      case '1.6':\n      case '1.7':\n        this.version = 4;\n        break;\n      case '1.7ext3':\n        this.version = 5;\n        break;\n      default:\n        this.version = 1;\n        break;\n    }\n    const encDict = {\n      Filter: 'Standard'\n    };\n    switch (this.version) {\n      case 1:\n      case 2:\n      case 4:\n        this._setupEncryptionV1V2V4(this.version, encDict, options);\n        break;\n      case 5:\n        this._setupEncryptionV5(encDict, options);\n        break;\n    }\n    this.dictionary = this.document.ref(encDict);\n  }\n  _setupEncryptionV1V2V4(v, encDict, options) {\n    let r, permissions;\n    switch (v) {\n      case 1:\n        r = 2;\n        this.keyBits = 40;\n        permissions = getPermissionsR2(options.permissions);\n        break;\n      case 2:\n        r = 3;\n        this.keyBits = 128;\n        permissions = getPermissionsR3(options.permissions);\n        break;\n      case 4:\n        r = 4;\n        this.keyBits = 128;\n        permissions = getPermissionsR3(options.permissions);\n        break;\n    }\n    const paddedUserPassword = processPasswordR2R3R4(options.userPassword);\n    const paddedOwnerPassword = options.ownerPassword ? processPasswordR2R3R4(options.ownerPassword) : paddedUserPassword;\n    const ownerPasswordEntry = getOwnerPasswordR2R3R4(r, this.keyBits, paddedUserPassword, paddedOwnerPassword);\n    this.encryptionKey = getEncryptionKeyR2R3R4(r, this.keyBits, this.document._id, paddedUserPassword, ownerPasswordEntry, permissions);\n    let userPasswordEntry;\n    if (r === 2) {\n      userPasswordEntry = getUserPasswordR2(this.encryptionKey);\n    } else {\n      userPasswordEntry = getUserPasswordR3R4(this.document._id, this.encryptionKey);\n    }\n    encDict.V = v;\n    if (v >= 2) {\n      encDict.Length = this.keyBits;\n    }\n    if (v === 4) {\n      encDict.CF = {\n        StdCF: {\n          AuthEvent: 'DocOpen',\n          CFM: 'AESV2',\n          Length: this.keyBits / 8\n        }\n      };\n      encDict.StmF = 'StdCF';\n      encDict.StrF = 'StdCF';\n    }\n    encDict.R = r;\n    encDict.O = wordArrayToBuffer(ownerPasswordEntry);\n    encDict.U = wordArrayToBuffer(userPasswordEntry);\n    encDict.P = permissions;\n  }\n  _setupEncryptionV5(encDict, options) {\n    this.keyBits = 256;\n    const permissions = getPermissionsR3(options.permissions);\n    const processedUserPassword = processPasswordR5(options.userPassword);\n    const processedOwnerPassword = options.ownerPassword ? processPasswordR5(options.ownerPassword) : processedUserPassword;\n    this.encryptionKey = getEncryptionKeyR5(PDFSecurity.generateRandomWordArray);\n    const userPasswordEntry = getUserPasswordR5(processedUserPassword, PDFSecurity.generateRandomWordArray);\n    const userKeySalt = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(userPasswordEntry.words.slice(10, 12), 8);\n    const userEncryptionKeyEntry = getUserEncryptionKeyR5(processedUserPassword, userKeySalt, this.encryptionKey);\n    const ownerPasswordEntry = getOwnerPasswordR5(processedOwnerPassword, userPasswordEntry, PDFSecurity.generateRandomWordArray);\n    const ownerKeySalt = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(ownerPasswordEntry.words.slice(10, 12), 8);\n    const ownerEncryptionKeyEntry = getOwnerEncryptionKeyR5(processedOwnerPassword, ownerKeySalt, userPasswordEntry, this.encryptionKey);\n    const permsEntry = getEncryptedPermissionsR5(permissions, this.encryptionKey, PDFSecurity.generateRandomWordArray);\n    encDict.V = 5;\n    encDict.Length = this.keyBits;\n    encDict.CF = {\n      StdCF: {\n        AuthEvent: 'DocOpen',\n        CFM: 'AESV3',\n        Length: this.keyBits / 8\n      }\n    };\n    encDict.StmF = 'StdCF';\n    encDict.StrF = 'StdCF';\n    encDict.R = 5;\n    encDict.O = wordArrayToBuffer(ownerPasswordEntry);\n    encDict.OE = wordArrayToBuffer(ownerEncryptionKeyEntry);\n    encDict.U = wordArrayToBuffer(userPasswordEntry);\n    encDict.UE = wordArrayToBuffer(userEncryptionKeyEntry);\n    encDict.P = permissions;\n    encDict.Perms = wordArrayToBuffer(permsEntry);\n  }\n  getEncryptFn(obj, gen) {\n    let digest;\n    if (this.version < 5) {\n      digest = this.encryptionKey.clone().concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create([(obj & 0xff) << 24 | (obj & 0xff00) << 8 | obj >> 8 & 0xff00 | gen & 0xff, (gen & 0xff00) << 16], 5));\n    }\n    if (this.version === 1 || this.version === 2) {\n      let key = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(digest);\n      key.sigBytes = Math.min(16, this.keyBits / 8 + 5);\n      return buffer => wordArrayToBuffer(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().RC4.encrypt(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(buffer), key).ciphertext);\n    }\n    let key;\n    if (this.version === 4) {\n      key = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(digest.concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create([0x73416c54], 4)));\n    } else {\n      key = this.encryptionKey;\n    }\n    const iv = PDFSecurity.generateRandomWordArray(16);\n    const options = {\n      mode: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().mode).CBC,\n      padding: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().pad).Pkcs7,\n      iv\n    };\n    return buffer => wordArrayToBuffer(iv.clone().concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().AES.encrypt(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(buffer), key, options).ciphertext));\n  }\n  end() {\n    this.dictionary.end();\n  }\n}\nfunction getPermissionsR2() {\n  let permissionObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let permissions = 0xffffffc0 >> 0;\n  if (permissionObject.printing) {\n    permissions |= 0b000000000100;\n  }\n  if (permissionObject.modifying) {\n    permissions |= 0b000000001000;\n  }\n  if (permissionObject.copying) {\n    permissions |= 0b000000010000;\n  }\n  if (permissionObject.annotating) {\n    permissions |= 0b000000100000;\n  }\n  return permissions;\n}\nfunction getPermissionsR3() {\n  let permissionObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let permissions = 0xfffff0c0 >> 0;\n  if (permissionObject.printing === 'lowResolution') {\n    permissions |= 0b000000000100;\n  }\n  if (permissionObject.printing === 'highResolution') {\n    permissions |= 0b100000000100;\n  }\n  if (permissionObject.modifying) {\n    permissions |= 0b000000001000;\n  }\n  if (permissionObject.copying) {\n    permissions |= 0b000000010000;\n  }\n  if (permissionObject.annotating) {\n    permissions |= 0b000000100000;\n  }\n  if (permissionObject.fillingForms) {\n    permissions |= 0b000100000000;\n  }\n  if (permissionObject.contentAccessibility) {\n    permissions |= 0b001000000000;\n  }\n  if (permissionObject.documentAssembly) {\n    permissions |= 0b010000000000;\n  }\n  return permissions;\n}\nfunction getUserPasswordR2(encryptionKey) {\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().RC4.encrypt(processPasswordR2R3R4(), encryptionKey).ciphertext;\n}\nfunction getUserPasswordR3R4(documentId, encryptionKey) {\n  const key = encryptionKey.clone();\n  let cipher = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(processPasswordR2R3R4().concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(documentId)));\n  for (let i = 0; i < 20; i++) {\n    const xorRound = Math.ceil(key.sigBytes / 4);\n    for (let j = 0; j < xorRound; j++) {\n      key.words[j] = encryptionKey.words[j] ^ (i | i << 8 | i << 16 | i << 24);\n    }\n    cipher = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().RC4.encrypt(cipher, key).ciphertext;\n  }\n  return cipher.concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(null, 16));\n}\nfunction getOwnerPasswordR2R3R4(r, keyBits, paddedUserPassword, paddedOwnerPassword) {\n  let digest = paddedOwnerPassword;\n  let round = r >= 3 ? 51 : 1;\n  for (let i = 0; i < round; i++) {\n    digest = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(digest);\n  }\n  const key = digest.clone();\n  key.sigBytes = keyBits / 8;\n  let cipher = paddedUserPassword;\n  round = r >= 3 ? 20 : 1;\n  for (let i = 0; i < round; i++) {\n    const xorRound = Math.ceil(key.sigBytes / 4);\n    for (let j = 0; j < xorRound; j++) {\n      key.words[j] = digest.words[j] ^ (i | i << 8 | i << 16 | i << 24);\n    }\n    cipher = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().RC4.encrypt(cipher, key).ciphertext;\n  }\n  return cipher;\n}\nfunction getEncryptionKeyR2R3R4(r, keyBits, documentId, paddedUserPassword, ownerPasswordEntry, permissions) {\n  let key = paddedUserPassword.clone().concat(ownerPasswordEntry).concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create([lsbFirstWord(permissions)], 4)).concat(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(documentId));\n  const round = r >= 3 ? 51 : 1;\n  for (let i = 0; i < round; i++) {\n    key = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(key);\n    key.sigBytes = keyBits / 8;\n  }\n  return key;\n}\nfunction getUserPasswordR5(processedUserPassword, generateRandomWordArray) {\n  const validationSalt = generateRandomWordArray(8);\n  const keySalt = generateRandomWordArray(8);\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().SHA256(processedUserPassword.clone().concat(validationSalt)).concat(validationSalt).concat(keySalt);\n}\nfunction getUserEncryptionKeyR5(processedUserPassword, userKeySalt, encryptionKey) {\n  const key = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().SHA256(processedUserPassword.clone().concat(userKeySalt));\n  const options = {\n    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().mode).CBC,\n    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().pad).NoPadding,\n    iv: crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(null, 16)\n  };\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().AES.encrypt(encryptionKey, key, options).ciphertext;\n}\nfunction getOwnerPasswordR5(processedOwnerPassword, userPasswordEntry, generateRandomWordArray) {\n  const validationSalt = generateRandomWordArray(8);\n  const keySalt = generateRandomWordArray(8);\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().SHA256(processedOwnerPassword.clone().concat(validationSalt).concat(userPasswordEntry)).concat(validationSalt).concat(keySalt);\n}\nfunction getOwnerEncryptionKeyR5(processedOwnerPassword, ownerKeySalt, userPasswordEntry, encryptionKey) {\n  const key = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().SHA256(processedOwnerPassword.clone().concat(ownerKeySalt).concat(userPasswordEntry));\n  const options = {\n    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().mode).CBC,\n    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().pad).NoPadding,\n    iv: crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(null, 16)\n  };\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().AES.encrypt(encryptionKey, key, options).ciphertext;\n}\nfunction getEncryptionKeyR5(generateRandomWordArray) {\n  return generateRandomWordArray(32);\n}\nfunction getEncryptedPermissionsR5(permissions, encryptionKey, generateRandomWordArray) {\n  const cipher = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create([lsbFirstWord(permissions), 0xffffffff, 0x54616462], 12).concat(generateRandomWordArray(4));\n  const options = {\n    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().mode).ECB,\n    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_2___default().pad).NoPadding\n  };\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().AES.encrypt(cipher, encryptionKey, options).ciphertext;\n}\nfunction processPasswordR2R3R4() {\n  let password = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  const out = Buffer.alloc(32);\n  const length = password.length;\n  let index = 0;\n  while (index < length && index < 32) {\n    const code = password.charCodeAt(index);\n    if (code > 0xff) {\n      throw new Error('Password contains one or more invalid characters.');\n    }\n    out[index] = code;\n    index++;\n  }\n  while (index < 32) {\n    out[index] = PASSWORD_PADDING[index - length];\n    index++;\n  }\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(out);\n}\nfunction processPasswordR5() {\n  let password = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  password = unescape(encodeURIComponent(saslprep(password)));\n  const length = Math.min(127, password.length);\n  const out = Buffer.alloc(length);\n  for (let i = 0; i < length; i++) {\n    out[i] = password.charCodeAt(i);\n  }\n  return crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(out);\n}\nfunction lsbFirstWord(data) {\n  return (data & 0xff) << 24 | (data & 0xff00) << 8 | data >> 8 & 0xff00 | data >> 24 & 0xff;\n}\nfunction wordArrayToBuffer(wordArray) {\n  const byteArray = [];\n  for (let i = 0; i < wordArray.sigBytes; i++) {\n    byteArray.push(wordArray.words[Math.floor(i / 4)] >> 8 * (3 - i % 4) & 0xff);\n  }\n  return Buffer.from(byteArray);\n}\nconst PASSWORD_PADDING = [0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41, 0x64, 0x00, 0x4e, 0x56, 0xff, 0xfa, 0x01, 0x08, 0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80, 0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a];\n\nconst {\n  number: number$2\n} = PDFObject;\nclass PDFGradient$1 {\n  constructor(doc) {\n    this.doc = doc;\n    this.stops = [];\n    this.embedded = false;\n    this.transform = [1, 0, 0, 1, 0, 0];\n  }\n  stop(pos, color, opacity) {\n    if (opacity == null) {\n      opacity = 1;\n    }\n    color = this.doc._normalizeColor(color);\n    if (this.stops.length === 0) {\n      if (color.length === 3) {\n        this._colorSpace = 'DeviceRGB';\n      } else if (color.length === 4) {\n        this._colorSpace = 'DeviceCMYK';\n      } else if (color.length === 1) {\n        this._colorSpace = 'DeviceGray';\n      } else {\n        throw new Error('Unknown color space');\n      }\n    } else if (this._colorSpace === 'DeviceRGB' && color.length !== 3 || this._colorSpace === 'DeviceCMYK' && color.length !== 4 || this._colorSpace === 'DeviceGray' && color.length !== 1) {\n      throw new Error('All gradient stops must use the same color space');\n    }\n    opacity = Math.max(0, Math.min(1, opacity));\n    this.stops.push([pos, color, opacity]);\n    return this;\n  }\n  setTransform(m11, m12, m21, m22, dx, dy) {\n    this.transform = [m11, m12, m21, m22, dx, dy];\n    return this;\n  }\n  embed(m) {\n    let fn;\n    const stopsLength = this.stops.length;\n    if (stopsLength === 0) {\n      return;\n    }\n    this.embedded = true;\n    this.matrix = m;\n    const last = this.stops[stopsLength - 1];\n    if (last[0] < 1) {\n      this.stops.push([1, last[1], last[2]]);\n    }\n    const bounds = [];\n    const encode = [];\n    const stops = [];\n    for (let i = 0; i < stopsLength - 1; i++) {\n      encode.push(0, 1);\n      if (i + 2 !== stopsLength) {\n        bounds.push(this.stops[i + 1][0]);\n      }\n      fn = this.doc.ref({\n        FunctionType: 2,\n        Domain: [0, 1],\n        C0: this.stops[i + 0][1],\n        C1: this.stops[i + 1][1],\n        N: 1\n      });\n      stops.push(fn);\n      fn.end();\n    }\n    if (stopsLength === 1) {\n      fn = stops[0];\n    } else {\n      fn = this.doc.ref({\n        FunctionType: 3,\n        Domain: [0, 1],\n        Functions: stops,\n        Bounds: bounds,\n        Encode: encode\n      });\n      fn.end();\n    }\n    this.id = `Sh${++this.doc._gradCount}`;\n    const shader = this.shader(fn);\n    shader.end();\n    const pattern = this.doc.ref({\n      Type: 'Pattern',\n      PatternType: 2,\n      Shading: shader,\n      Matrix: this.matrix.map(number$2)\n    });\n    pattern.end();\n    if (this.stops.some(stop => stop[2] < 1)) {\n      let grad = this.opacityGradient();\n      grad._colorSpace = 'DeviceGray';\n      for (let stop of this.stops) {\n        grad.stop(stop[0], [stop[2]]);\n      }\n      grad = grad.embed(this.matrix);\n      const pageBBox = [0, 0, this.doc.page.width, this.doc.page.height];\n      const form = this.doc.ref({\n        Type: 'XObject',\n        Subtype: 'Form',\n        FormType: 1,\n        BBox: pageBBox,\n        Group: {\n          Type: 'Group',\n          S: 'Transparency',\n          CS: 'DeviceGray'\n        },\n        Resources: {\n          ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n          Pattern: {\n            Sh1: grad\n          }\n        }\n      });\n      form.write('/Pattern cs /Sh1 scn');\n      form.end(`${pageBBox.join(' ')} re f`);\n      const gstate = this.doc.ref({\n        Type: 'ExtGState',\n        SMask: {\n          Type: 'Mask',\n          S: 'Luminosity',\n          G: form\n        }\n      });\n      gstate.end();\n      const opacityPattern = this.doc.ref({\n        Type: 'Pattern',\n        PatternType: 1,\n        PaintType: 1,\n        TilingType: 2,\n        BBox: pageBBox,\n        XStep: pageBBox[2],\n        YStep: pageBBox[3],\n        Resources: {\n          ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n          Pattern: {\n            Sh1: pattern\n          },\n          ExtGState: {\n            Gs1: gstate\n          }\n        }\n      });\n      opacityPattern.write('/Gs1 gs /Pattern cs /Sh1 scn');\n      opacityPattern.end(`${pageBBox.join(' ')} re f`);\n      this.doc.page.patterns[this.id] = opacityPattern;\n    } else {\n      this.doc.page.patterns[this.id] = pattern;\n    }\n    return pattern;\n  }\n  apply(stroke) {\n    const [m0, m1, m2, m3, m4, m5] = this.doc._ctm;\n    const [m11, m12, m21, m22, dx, dy] = this.transform;\n    const m = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];\n    if (!this.embedded || m.join(' ') !== this.matrix.join(' ')) {\n      this.embed(m);\n    }\n    this.doc._setColorSpace('Pattern', stroke);\n    const op = stroke ? 'SCN' : 'scn';\n    return this.doc.addContent(`/${this.id} ${op}`);\n  }\n}\nclass PDFLinearGradient$1 extends PDFGradient$1 {\n  constructor(doc, x1, y1, x2, y2) {\n    super(doc);\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n  shader(fn) {\n    return this.doc.ref({\n      ShadingType: 2,\n      ColorSpace: this._colorSpace,\n      Coords: [this.x1, this.y1, this.x2, this.y2],\n      Function: fn,\n      Extend: [true, true]\n    });\n  }\n  opacityGradient() {\n    return new PDFLinearGradient$1(this.doc, this.x1, this.y1, this.x2, this.y2);\n  }\n}\nclass PDFRadialGradient$1 extends PDFGradient$1 {\n  constructor(doc, x1, y1, r1, x2, y2, r2) {\n    super(doc);\n    this.doc = doc;\n    this.x1 = x1;\n    this.y1 = y1;\n    this.r1 = r1;\n    this.x2 = x2;\n    this.y2 = y2;\n    this.r2 = r2;\n  }\n  shader(fn) {\n    return this.doc.ref({\n      ShadingType: 3,\n      ColorSpace: this._colorSpace,\n      Coords: [this.x1, this.y1, this.r1, this.x2, this.y2, this.r2],\n      Function: fn,\n      Extend: [true, true]\n    });\n  }\n  opacityGradient() {\n    return new PDFRadialGradient$1(this.doc, this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);\n  }\n}\nvar Gradient = {\n  PDFGradient: PDFGradient$1,\n  PDFLinearGradient: PDFLinearGradient$1,\n  PDFRadialGradient: PDFRadialGradient$1\n};\n\nconst underlyingColorSpaces = ['DeviceCMYK', 'DeviceRGB'];\nclass PDFTilingPattern$1 {\n  constructor(doc, bBox, xStep, yStep, stream) {\n    this.doc = doc;\n    this.bBox = bBox;\n    this.xStep = xStep;\n    this.yStep = yStep;\n    this.stream = stream;\n  }\n  createPattern() {\n    const resources = this.doc.ref();\n    resources.end();\n    const [m0, m1, m2, m3, m4, m5] = this.doc._ctm;\n    const [m11, m12, m21, m22, dx, dy] = [1, 0, 0, 1, 0, 0];\n    const m = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];\n    const pattern = this.doc.ref({\n      Type: 'Pattern',\n      PatternType: 1,\n      PaintType: 2,\n      TilingType: 2,\n      BBox: this.bBox,\n      XStep: this.xStep,\n      YStep: this.yStep,\n      Matrix: m.map(v => +v.toFixed(5)),\n      Resources: resources\n    });\n    pattern.end(this.stream);\n    return pattern;\n  }\n  embedPatternColorSpaces() {\n    underlyingColorSpaces.forEach(csName => {\n      const csId = this.getPatternColorSpaceId(csName);\n      if (this.doc.page.colorSpaces[csId]) return;\n      const cs = this.doc.ref(['Pattern', csName]);\n      cs.end();\n      this.doc.page.colorSpaces[csId] = cs;\n    });\n  }\n  getPatternColorSpaceId(underlyingColorspace) {\n    return `CsP${underlyingColorspace}`;\n  }\n  embed() {\n    if (!this.id) {\n      this.doc._patternCount = this.doc._patternCount + 1;\n      this.id = 'P' + this.doc._patternCount;\n      this.pattern = this.createPattern();\n    }\n    if (!this.doc.page.patterns[this.id]) {\n      this.doc.page.patterns[this.id] = this.pattern;\n    }\n  }\n  apply(stroke, patternColor) {\n    this.embedPatternColorSpaces();\n    this.embed();\n    const normalizedColor = this.doc._normalizeColor(patternColor);\n    if (!normalizedColor) throw Error(`invalid pattern color. (value: ${patternColor})`);\n    const csId = this.getPatternColorSpaceId(this.doc._getColorSpace(normalizedColor));\n    this.doc._setColorSpace(csId, stroke);\n    const op = stroke ? 'SCN' : 'scn';\n    return this.doc.addContent(`${normalizedColor.join(' ')} /${this.id} ${op}`);\n  }\n}\nvar pattern = {\n  PDFTilingPattern: PDFTilingPattern$1\n};\n\nconst {\n  PDFGradient,\n  PDFLinearGradient,\n  PDFRadialGradient\n} = Gradient;\nconst {\n  PDFTilingPattern\n} = pattern;\nvar ColorMixin = {\n  initColor() {\n    this.spotColors = {};\n    this._opacityRegistry = {};\n    this._opacityCount = 0;\n    this._patternCount = 0;\n    this._gradCount = 0;\n  },\n  _normalizeColor(color) {\n    if (typeof color === 'string') {\n      if (color.charAt(0) === '#') {\n        if (color.length === 4) {\n          color = color.replace(/#([0-9A-F])([0-9A-F])([0-9A-F])/i, '#$1$1$2$2$3$3');\n        }\n        const hex = parseInt(color.slice(1), 16);\n        color = [hex >> 16, hex >> 8 & 0xff, hex & 0xff];\n      } else if (namedColors[color]) {\n        color = namedColors[color];\n      } else if (this.spotColors[color]) {\n        return this.spotColors[color];\n      }\n    }\n    if (Array.isArray(color)) {\n      if (color.length === 3) {\n        color = color.map(part => part / 255);\n      } else if (color.length === 4) {\n        color = color.map(part => part / 100);\n      }\n      return color;\n    }\n    return null;\n  },\n  _setColor(color, stroke) {\n    if (color instanceof PDFGradient) {\n      color.apply(stroke);\n      return true;\n    } else if (Array.isArray(color) && color[0] instanceof PDFTilingPattern) {\n      color[0].apply(stroke, color[1]);\n      return true;\n    }\n    return this._setColorCore(color, stroke);\n  },\n  _setColorCore(color, stroke) {\n    color = this._normalizeColor(color);\n    if (!color) {\n      return false;\n    }\n    const op = stroke ? 'SCN' : 'scn';\n    const space = this._getColorSpace(color);\n    this._setColorSpace(space, stroke);\n    if (color instanceof SpotColor) {\n      this.page.colorSpaces[color.id] = color.ref;\n      this.addContent(`1 ${op}`);\n    } else {\n      this.addContent(`${color.join(' ')} ${op}`);\n    }\n    return true;\n  },\n  _setColorSpace(space, stroke) {\n    const op = stroke ? 'CS' : 'cs';\n    return this.addContent(`/${space} ${op}`);\n  },\n  _getColorSpace(color) {\n    if (color instanceof SpotColor) {\n      return color.id;\n    }\n    return color.length === 4 ? 'DeviceCMYK' : 'DeviceRGB';\n  },\n  fillColor(color, opacity) {\n    const set = this._setColor(color, false);\n    if (set) {\n      this.fillOpacity(opacity);\n    }\n    this._fillColor = [color, opacity];\n    return this;\n  },\n  strokeColor(color, opacity) {\n    const set = this._setColor(color, true);\n    if (set) {\n      this.strokeOpacity(opacity);\n    }\n    return this;\n  },\n  opacity(opacity) {\n    this._doOpacity(opacity, opacity);\n    return this;\n  },\n  fillOpacity(opacity) {\n    this._doOpacity(opacity, null);\n    return this;\n  },\n  strokeOpacity(opacity) {\n    this._doOpacity(null, opacity);\n    return this;\n  },\n  _doOpacity(fillOpacity, strokeOpacity) {\n    let dictionary, name;\n    if (fillOpacity == null && strokeOpacity == null) {\n      return;\n    }\n    if (fillOpacity != null) {\n      fillOpacity = Math.max(0, Math.min(1, fillOpacity));\n    }\n    if (strokeOpacity != null) {\n      strokeOpacity = Math.max(0, Math.min(1, strokeOpacity));\n    }\n    const key = `${fillOpacity}_${strokeOpacity}`;\n    if (this._opacityRegistry[key]) {\n      [dictionary, name] = this._opacityRegistry[key];\n    } else {\n      dictionary = {\n        Type: 'ExtGState'\n      };\n      if (fillOpacity != null) {\n        dictionary.ca = fillOpacity;\n      }\n      if (strokeOpacity != null) {\n        dictionary.CA = strokeOpacity;\n      }\n      dictionary = this.ref(dictionary);\n      dictionary.end();\n      const id = ++this._opacityCount;\n      name = `Gs${id}`;\n      this._opacityRegistry[key] = [dictionary, name];\n    }\n    this.page.ext_gstates[name] = dictionary;\n    return this.addContent(`/${name} gs`);\n  },\n  linearGradient(x1, y1, x2, y2) {\n    return new PDFLinearGradient(this, x1, y1, x2, y2);\n  },\n  radialGradient(x1, y1, r1, x2, y2, r2) {\n    return new PDFRadialGradient(this, x1, y1, r1, x2, y2, r2);\n  },\n  pattern(bbox, xStep, yStep, stream) {\n    return new PDFTilingPattern(this, bbox, xStep, yStep, stream);\n  },\n  addSpotColor(name, C, M, Y, K) {\n    const color = new SpotColor(this, name, C, M, Y, K);\n    this.spotColors[name] = color;\n    return this;\n  }\n};\nvar namedColors = {\n  aliceblue: [240, 248, 255],\n  antiquewhite: [250, 235, 215],\n  aqua: [0, 255, 255],\n  aquamarine: [127, 255, 212],\n  azure: [240, 255, 255],\n  beige: [245, 245, 220],\n  bisque: [255, 228, 196],\n  black: [0, 0, 0],\n  blanchedalmond: [255, 235, 205],\n  blue: [0, 0, 255],\n  blueviolet: [138, 43, 226],\n  brown: [165, 42, 42],\n  burlywood: [222, 184, 135],\n  cadetblue: [95, 158, 160],\n  chartreuse: [127, 255, 0],\n  chocolate: [210, 105, 30],\n  coral: [255, 127, 80],\n  cornflowerblue: [100, 149, 237],\n  cornsilk: [255, 248, 220],\n  crimson: [220, 20, 60],\n  cyan: [0, 255, 255],\n  darkblue: [0, 0, 139],\n  darkcyan: [0, 139, 139],\n  darkgoldenrod: [184, 134, 11],\n  darkgray: [169, 169, 169],\n  darkgreen: [0, 100, 0],\n  darkgrey: [169, 169, 169],\n  darkkhaki: [189, 183, 107],\n  darkmagenta: [139, 0, 139],\n  darkolivegreen: [85, 107, 47],\n  darkorange: [255, 140, 0],\n  darkorchid: [153, 50, 204],\n  darkred: [139, 0, 0],\n  darksalmon: [233, 150, 122],\n  darkseagreen: [143, 188, 143],\n  darkslateblue: [72, 61, 139],\n  darkslategray: [47, 79, 79],\n  darkslategrey: [47, 79, 79],\n  darkturquoise: [0, 206, 209],\n  darkviolet: [148, 0, 211],\n  deeppink: [255, 20, 147],\n  deepskyblue: [0, 191, 255],\n  dimgray: [105, 105, 105],\n  dimgrey: [105, 105, 105],\n  dodgerblue: [30, 144, 255],\n  firebrick: [178, 34, 34],\n  floralwhite: [255, 250, 240],\n  forestgreen: [34, 139, 34],\n  fuchsia: [255, 0, 255],\n  gainsboro: [220, 220, 220],\n  ghostwhite: [248, 248, 255],\n  gold: [255, 215, 0],\n  goldenrod: [218, 165, 32],\n  gray: [128, 128, 128],\n  grey: [128, 128, 128],\n  green: [0, 128, 0],\n  greenyellow: [173, 255, 47],\n  honeydew: [240, 255, 240],\n  hotpink: [255, 105, 180],\n  indianred: [205, 92, 92],\n  indigo: [75, 0, 130],\n  ivory: [255, 255, 240],\n  khaki: [240, 230, 140],\n  lavender: [230, 230, 250],\n  lavenderblush: [255, 240, 245],\n  lawngreen: [124, 252, 0],\n  lemonchiffon: [255, 250, 205],\n  lightblue: [173, 216, 230],\n  lightcoral: [240, 128, 128],\n  lightcyan: [224, 255, 255],\n  lightgoldenrodyellow: [250, 250, 210],\n  lightgray: [211, 211, 211],\n  lightgreen: [144, 238, 144],\n  lightgrey: [211, 211, 211],\n  lightpink: [255, 182, 193],\n  lightsalmon: [255, 160, 122],\n  lightseagreen: [32, 178, 170],\n  lightskyblue: [135, 206, 250],\n  lightslategray: [119, 136, 153],\n  lightslategrey: [119, 136, 153],\n  lightsteelblue: [176, 196, 222],\n  lightyellow: [255, 255, 224],\n  lime: [0, 255, 0],\n  limegreen: [50, 205, 50],\n  linen: [250, 240, 230],\n  magenta: [255, 0, 255],\n  maroon: [128, 0, 0],\n  mediumaquamarine: [102, 205, 170],\n  mediumblue: [0, 0, 205],\n  mediumorchid: [186, 85, 211],\n  mediumpurple: [147, 112, 219],\n  mediumseagreen: [60, 179, 113],\n  mediumslateblue: [123, 104, 238],\n  mediumspringgreen: [0, 250, 154],\n  mediumturquoise: [72, 209, 204],\n  mediumvioletred: [199, 21, 133],\n  midnightblue: [25, 25, 112],\n  mintcream: [245, 255, 250],\n  mistyrose: [255, 228, 225],\n  moccasin: [255, 228, 181],\n  navajowhite: [255, 222, 173],\n  navy: [0, 0, 128],\n  oldlace: [253, 245, 230],\n  olive: [128, 128, 0],\n  olivedrab: [107, 142, 35],\n  orange: [255, 165, 0],\n  orangered: [255, 69, 0],\n  orchid: [218, 112, 214],\n  palegoldenrod: [238, 232, 170],\n  palegreen: [152, 251, 152],\n  paleturquoise: [175, 238, 238],\n  palevioletred: [219, 112, 147],\n  papayawhip: [255, 239, 213],\n  peachpuff: [255, 218, 185],\n  peru: [205, 133, 63],\n  pink: [255, 192, 203],\n  plum: [221, 160, 221],\n  powderblue: [176, 224, 230],\n  purple: [128, 0, 128],\n  red: [255, 0, 0],\n  rosybrown: [188, 143, 143],\n  royalblue: [65, 105, 225],\n  saddlebrown: [139, 69, 19],\n  salmon: [250, 128, 114],\n  sandybrown: [244, 164, 96],\n  seagreen: [46, 139, 87],\n  seashell: [255, 245, 238],\n  sienna: [160, 82, 45],\n  silver: [192, 192, 192],\n  skyblue: [135, 206, 235],\n  slateblue: [106, 90, 205],\n  slategray: [112, 128, 144],\n  slategrey: [112, 128, 144],\n  snow: [255, 250, 250],\n  springgreen: [0, 255, 127],\n  steelblue: [70, 130, 180],\n  tan: [210, 180, 140],\n  teal: [0, 128, 128],\n  thistle: [216, 191, 216],\n  tomato: [255, 99, 71],\n  turquoise: [64, 224, 208],\n  violet: [238, 130, 238],\n  wheat: [245, 222, 179],\n  white: [255, 255, 255],\n  whitesmoke: [245, 245, 245],\n  yellow: [255, 255, 0],\n  yellowgreen: [154, 205, 50]\n};\n\nlet cx, cy, px, py, sx, sy;\ncx = cy = px = py = sx = sy = 0;\nconst parameters = {\n  A: 7,\n  a: 7,\n  C: 6,\n  c: 6,\n  H: 1,\n  h: 1,\n  L: 2,\n  l: 2,\n  M: 2,\n  m: 2,\n  Q: 4,\n  q: 4,\n  S: 4,\n  s: 4,\n  T: 2,\n  t: 2,\n  V: 1,\n  v: 1,\n  Z: 0,\n  z: 0\n};\nconst parse = function (path) {\n  let cmd;\n  const ret = [];\n  let args = [];\n  let curArg = '';\n  let foundDecimal = false;\n  let params = 0;\n  for (let c of path) {\n    if (parameters[c] != null) {\n      params = parameters[c];\n      if (cmd) {\n        if (curArg.length > 0) {\n          args[args.length] = +curArg;\n        }\n        ret[ret.length] = {\n          cmd,\n          args\n        };\n        args = [];\n        curArg = '';\n        foundDecimal = false;\n      }\n      cmd = c;\n    } else if ([' ', ','].includes(c) || c === '-' && curArg.length > 0 && curArg[curArg.length - 1] !== 'e' || c === '.' && foundDecimal) {\n      if (curArg.length === 0) {\n        continue;\n      }\n      if (args.length === params) {\n        ret[ret.length] = {\n          cmd,\n          args\n        };\n        args = [+curArg];\n        if (cmd === 'M') {\n          cmd = 'L';\n        }\n        if (cmd === 'm') {\n          cmd = 'l';\n        }\n      } else {\n        args[args.length] = +curArg;\n      }\n      foundDecimal = c === '.';\n      curArg = ['-', '.'].includes(c) ? c : '';\n    } else {\n      curArg += c;\n      if (c === '.') {\n        foundDecimal = true;\n      }\n    }\n  }\n  if (curArg.length > 0) {\n    if (args.length === params) {\n      ret[ret.length] = {\n        cmd,\n        args\n      };\n      args = [+curArg];\n      if (cmd === 'M') {\n        cmd = 'L';\n      }\n      if (cmd === 'm') {\n        cmd = 'l';\n      }\n    } else {\n      args[args.length] = +curArg;\n    }\n  }\n  ret[ret.length] = {\n    cmd,\n    args\n  };\n  return ret;\n};\nconst apply = function (commands, doc) {\n  cx = cy = px = py = sx = sy = 0;\n  for (let i = 0; i < commands.length; i++) {\n    const c = commands[i];\n    if (typeof runners[c.cmd] === 'function') {\n      runners[c.cmd](doc, c.args);\n    }\n  }\n};\nconst runners = {\n  M(doc, a) {\n    cx = a[0];\n    cy = a[1];\n    px = py = null;\n    sx = cx;\n    sy = cy;\n    return doc.moveTo(cx, cy);\n  },\n  m(doc, a) {\n    cx += a[0];\n    cy += a[1];\n    px = py = null;\n    sx = cx;\n    sy = cy;\n    return doc.moveTo(cx, cy);\n  },\n  C(doc, a) {\n    cx = a[4];\n    cy = a[5];\n    px = a[2];\n    py = a[3];\n    return doc.bezierCurveTo(...a);\n  },\n  c(doc, a) {\n    doc.bezierCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy, a[4] + cx, a[5] + cy);\n    px = cx + a[2];\n    py = cy + a[3];\n    cx += a[4];\n    return cy += a[5];\n  },\n  S(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    }\n    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), a[0], a[1], a[2], a[3]);\n    px = a[0];\n    py = a[1];\n    cx = a[2];\n    return cy = a[3];\n  },\n  s(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    }\n    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), cx + a[0], cy + a[1], cx + a[2], cy + a[3]);\n    px = cx + a[0];\n    py = cy + a[1];\n    cx += a[2];\n    return cy += a[3];\n  },\n  Q(doc, a) {\n    px = a[0];\n    py = a[1];\n    cx = a[2];\n    cy = a[3];\n    return doc.quadraticCurveTo(a[0], a[1], cx, cy);\n  },\n  q(doc, a) {\n    doc.quadraticCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy);\n    px = cx + a[0];\n    py = cy + a[1];\n    cx += a[2];\n    return cy += a[3];\n  },\n  T(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    } else {\n      px = cx - (px - cx);\n      py = cy - (py - cy);\n    }\n    doc.quadraticCurveTo(px, py, a[0], a[1]);\n    px = cx - (px - cx);\n    py = cy - (py - cy);\n    cx = a[0];\n    return cy = a[1];\n  },\n  t(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    } else {\n      px = cx - (px - cx);\n      py = cy - (py - cy);\n    }\n    doc.quadraticCurveTo(px, py, cx + a[0], cy + a[1]);\n    cx += a[0];\n    return cy += a[1];\n  },\n  A(doc, a) {\n    solveArc(doc, cx, cy, a);\n    cx = a[5];\n    return cy = a[6];\n  },\n  a(doc, a) {\n    a[5] += cx;\n    a[6] += cy;\n    solveArc(doc, cx, cy, a);\n    cx = a[5];\n    return cy = a[6];\n  },\n  L(doc, a) {\n    cx = a[0];\n    cy = a[1];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  l(doc, a) {\n    cx += a[0];\n    cy += a[1];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  H(doc, a) {\n    cx = a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  h(doc, a) {\n    cx += a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  V(doc, a) {\n    cy = a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  v(doc, a) {\n    cy += a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  Z(doc) {\n    doc.closePath();\n    cx = sx;\n    return cy = sy;\n  },\n  z(doc) {\n    doc.closePath();\n    cx = sx;\n    return cy = sy;\n  }\n};\nconst solveArc = function (doc, x, y, coords) {\n  const [rx, ry, rot, large, sweep, ex, ey] = coords;\n  const segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (let seg of segs) {\n    const bez = segmentToBezier(...seg);\n    doc.bezierCurveTo(...bez);\n  }\n};\nconst arcToSegments = function (x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  const th = rotateX * (Math.PI / 180);\n  const sin_th = Math.sin(th);\n  const cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  let pl = px * px / (rx * rx) + py * py / (ry * ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n  const a00 = cos_th / rx;\n  const a01 = sin_th / rx;\n  const a10 = -sin_th / ry;\n  const a11 = cos_th / ry;\n  const x0 = a00 * ox + a01 * oy;\n  const y0 = a10 * ox + a11 * oy;\n  const x1 = a00 * x + a01 * y;\n  const y1 = a10 * x + a11 * y;\n  const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);\n  let sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) {\n    sfactor_sq = 0;\n  }\n  let sfactor = Math.sqrt(sfactor_sq);\n  if (sweep === large) {\n    sfactor = -sfactor;\n  }\n  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);\n  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);\n  const th0 = Math.atan2(y0 - yc, x0 - xc);\n  const th1 = Math.atan2(y1 - yc, x1 - xc);\n  let th_arc = th1 - th0;\n  if (th_arc < 0 && sweep === 1) {\n    th_arc += 2 * Math.PI;\n  } else if (th_arc > 0 && sweep === 0) {\n    th_arc -= 2 * Math.PI;\n  }\n  const segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  const result = [];\n  for (let i = 0; i < segments; i++) {\n    const th2 = th0 + i * th_arc / segments;\n    const th3 = th0 + (i + 1) * th_arc / segments;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n  return result;\n};\nconst segmentToBezier = function (cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n  const a00 = cos_th * rx;\n  const a01 = -sin_th * ry;\n  const a10 = sin_th * rx;\n  const a11 = cos_th * ry;\n  const th_half = 0.5 * (th1 - th0);\n  const t = 8 / 3 * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half);\n  const x1 = cx + Math.cos(th0) - t * Math.sin(th0);\n  const y1 = cy + Math.sin(th0) + t * Math.cos(th0);\n  const x3 = cx + Math.cos(th1);\n  const y3 = cy + Math.sin(th1);\n  const x2 = x3 + t * Math.sin(th1);\n  const y2 = y3 - t * Math.cos(th1);\n  return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];\n};\nclass SVGPath {\n  static apply(doc, path) {\n    const commands = parse(path);\n    apply(commands, doc);\n  }\n}\n\nconst {\n  number: number$1\n} = PDFObject;\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nvar VectorMixin = {\n  initVector() {\n    this._ctm = [1, 0, 0, 1, 0, 0];\n    this._ctmStack = [];\n  },\n  save() {\n    this._ctmStack.push(this._ctm.slice());\n    return this.addContent('q');\n  },\n  restore() {\n    this._ctm = this._ctmStack.pop() || [1, 0, 0, 1, 0, 0];\n    return this.addContent('Q');\n  },\n  closePath() {\n    return this.addContent('h');\n  },\n  lineWidth(w) {\n    return this.addContent(`${number$1(w)} w`);\n  },\n  _CAP_STYLES: {\n    BUTT: 0,\n    ROUND: 1,\n    SQUARE: 2\n  },\n  lineCap(c) {\n    if (typeof c === 'string') {\n      c = this._CAP_STYLES[c.toUpperCase()];\n    }\n    return this.addContent(`${c} J`);\n  },\n  _JOIN_STYLES: {\n    MITER: 0,\n    ROUND: 1,\n    BEVEL: 2\n  },\n  lineJoin(j) {\n    if (typeof j === 'string') {\n      j = this._JOIN_STYLES[j.toUpperCase()];\n    }\n    return this.addContent(`${j} j`);\n  },\n  miterLimit(m) {\n    return this.addContent(`${number$1(m)} M`);\n  },\n  dash(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const originalLength = length;\n    if (!Array.isArray(length)) {\n      length = [length, options.space || length];\n    }\n    const valid = length.every(x => Number.isFinite(x) && x > 0);\n    if (!valid) {\n      throw new Error(`dash(${JSON.stringify(originalLength)}, ${JSON.stringify(options)}) invalid, lengths must be numeric and greater than zero`);\n    }\n    length = length.map(number$1).join(' ');\n    return this.addContent(`[${length}] ${number$1(options.phase || 0)} d`);\n  },\n  undash() {\n    return this.addContent('[] 0 d');\n  },\n  moveTo(x, y) {\n    return this.addContent(`${number$1(x)} ${number$1(y)} m`);\n  },\n  lineTo(x, y) {\n    return this.addContent(`${number$1(x)} ${number$1(y)} l`);\n  },\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n    return this.addContent(`${number$1(cp1x)} ${number$1(cp1y)} ${number$1(cp2x)} ${number$1(cp2y)} ${number$1(x)} ${number$1(y)} c`);\n  },\n  quadraticCurveTo(cpx, cpy, x, y) {\n    return this.addContent(`${number$1(cpx)} ${number$1(cpy)} ${number$1(x)} ${number$1(y)} v`);\n  },\n  rect(x, y, w, h) {\n    return this.addContent(`${number$1(x)} ${number$1(y)} ${number$1(w)} ${number$1(h)} re`);\n  },\n  roundedRect(x, y, w, h, r) {\n    if (r == null) {\n      r = 0;\n    }\n    r = Math.min(r, 0.5 * w, 0.5 * h);\n    const c = r * (1.0 - KAPPA);\n    this.moveTo(x + r, y);\n    this.lineTo(x + w - r, y);\n    this.bezierCurveTo(x + w - c, y, x + w, y + c, x + w, y + r);\n    this.lineTo(x + w, y + h - r);\n    this.bezierCurveTo(x + w, y + h - c, x + w - c, y + h, x + w - r, y + h);\n    this.lineTo(x + r, y + h);\n    this.bezierCurveTo(x + c, y + h, x, y + h - c, x, y + h - r);\n    this.lineTo(x, y + r);\n    this.bezierCurveTo(x, y + c, x + c, y, x + r, y);\n    return this.closePath();\n  },\n  ellipse(x, y, r1, r2) {\n    if (r2 == null) {\n      r2 = r1;\n    }\n    x -= r1;\n    y -= r2;\n    const ox = r1 * KAPPA;\n    const oy = r2 * KAPPA;\n    const xe = x + r1 * 2;\n    const ye = y + r2 * 2;\n    const xm = x + r1;\n    const ym = y + r2;\n    this.moveTo(x, ym);\n    this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n    this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n    return this.closePath();\n  },\n  circle(x, y, radius) {\n    return this.ellipse(x, y, radius);\n  },\n  arc(x, y, radius, startAngle, endAngle, anticlockwise) {\n    if (anticlockwise == null) {\n      anticlockwise = false;\n    }\n    const TWO_PI = 2.0 * Math.PI;\n    const HALF_PI = 0.5 * Math.PI;\n    let deltaAng = endAngle - startAngle;\n    if (Math.abs(deltaAng) > TWO_PI) {\n      deltaAng = TWO_PI;\n    } else if (deltaAng !== 0 && anticlockwise !== deltaAng < 0) {\n      const dir = anticlockwise ? -1 : 1;\n      deltaAng = dir * TWO_PI + deltaAng;\n    }\n    const numSegs = Math.ceil(Math.abs(deltaAng) / HALF_PI);\n    const segAng = deltaAng / numSegs;\n    const handleLen = segAng / HALF_PI * KAPPA * radius;\n    let curAng = startAngle;\n    let deltaCx = -Math.sin(curAng) * handleLen;\n    let deltaCy = Math.cos(curAng) * handleLen;\n    let ax = x + Math.cos(curAng) * radius;\n    let ay = y + Math.sin(curAng) * radius;\n    this.moveTo(ax, ay);\n    for (let segIdx = 0; segIdx < numSegs; segIdx++) {\n      const cp1x = ax + deltaCx;\n      const cp1y = ay + deltaCy;\n      curAng += segAng;\n      ax = x + Math.cos(curAng) * radius;\n      ay = y + Math.sin(curAng) * radius;\n      deltaCx = -Math.sin(curAng) * handleLen;\n      deltaCy = Math.cos(curAng) * handleLen;\n      const cp2x = ax - deltaCx;\n      const cp2y = ay - deltaCy;\n      this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ax, ay);\n    }\n    return this;\n  },\n  polygon() {\n    for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {\n      points[_key] = arguments[_key];\n    }\n    this.moveTo(...(points.shift() || []));\n    for (let point of points) {\n      this.lineTo(...(point || []));\n    }\n    return this.closePath();\n  },\n  path(path) {\n    SVGPath.apply(this, path);\n    return this;\n  },\n  _windingRule(rule) {\n    if (/even-?odd/.test(rule)) {\n      return '*';\n    }\n    return '';\n  },\n  fill(color, rule) {\n    if (/(even-?odd)|(non-?zero)/.test(color)) {\n      rule = color;\n      color = null;\n    }\n    if (color) {\n      this.fillColor(color);\n    }\n    return this.addContent(`f${this._windingRule(rule)}`);\n  },\n  stroke(color) {\n    if (color) {\n      this.strokeColor(color);\n    }\n    return this.addContent('S');\n  },\n  fillAndStroke(fillColor, strokeColor, rule) {\n    if (strokeColor == null) {\n      strokeColor = fillColor;\n    }\n    const isFillRule = /(even-?odd)|(non-?zero)/;\n    if (isFillRule.test(fillColor)) {\n      rule = fillColor;\n      fillColor = null;\n    }\n    if (isFillRule.test(strokeColor)) {\n      rule = strokeColor;\n      strokeColor = fillColor;\n    }\n    if (fillColor) {\n      this.fillColor(fillColor);\n      this.strokeColor(strokeColor);\n    }\n    return this.addContent(`B${this._windingRule(rule)}`);\n  },\n  clip(rule) {\n    return this.addContent(`W${this._windingRule(rule)} n`);\n  },\n  transform(m11, m12, m21, m22, dx, dy) {\n    if (m11 === 1 && m12 === 0 && m21 === 0 && m22 === 1 && dx === 0 && dy === 0) {\n      return this;\n    }\n    const m = this._ctm;\n    const [m0, m1, m2, m3, m4, m5] = m;\n    m[0] = m0 * m11 + m2 * m12;\n    m[1] = m1 * m11 + m3 * m12;\n    m[2] = m0 * m21 + m2 * m22;\n    m[3] = m1 * m21 + m3 * m22;\n    m[4] = m0 * dx + m2 * dy + m4;\n    m[5] = m1 * dx + m3 * dy + m5;\n    const values = [m11, m12, m21, m22, dx, dy].map(v => number$1(v)).join(' ');\n    return this.addContent(`${values} cm`);\n  },\n  translate(x, y) {\n    return this.transform(1, 0, 0, 1, x, y);\n  },\n  rotate(angle) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let y;\n    const rad = angle * Math.PI / 180;\n    const cos = Math.cos(rad);\n    const sin = Math.sin(rad);\n    let x = y = 0;\n    if (options.origin != null) {\n      [x, y] = options.origin;\n      const x1 = x * cos - y * sin;\n      const y1 = x * sin + y * cos;\n      x -= x1;\n      y -= y1;\n    }\n    return this.transform(cos, sin, -sin, cos, x, y);\n  },\n  scale(xFactor, yFactor) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let y;\n    if (yFactor == null) {\n      yFactor = xFactor;\n    }\n    if (typeof yFactor === 'object') {\n      options = yFactor;\n      yFactor = xFactor;\n    }\n    let x = y = 0;\n    if (options.origin != null) {\n      [x, y] = options.origin;\n      x -= xFactor * x;\n      y -= yFactor * y;\n    }\n    return this.transform(xFactor, 0, 0, yFactor, x, y);\n  }\n};\n\nconst WIN_ANSI_MAP = {\n  402: 131,\n  8211: 150,\n  8212: 151,\n  8216: 145,\n  8217: 146,\n  8218: 130,\n  8220: 147,\n  8221: 148,\n  8222: 132,\n  8224: 134,\n  8225: 135,\n  8226: 149,\n  8230: 133,\n  8364: 128,\n  8240: 137,\n  8249: 139,\n  8250: 155,\n  710: 136,\n  8482: 153,\n  338: 140,\n  339: 156,\n  732: 152,\n  352: 138,\n  353: 154,\n  376: 159,\n  381: 142,\n  382: 158\n};\nconst characters = `\\\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n  \nspace         exclam         quotedbl       numbersign\ndollar        percent        ampersand      quotesingle\nparenleft     parenright     asterisk       plus\ncomma         hyphen         period         slash\nzero          one            two            three\nfour          five           six            seven\neight         nine           colon          semicolon\nless          equal          greater        question\n  \nat            A              B              C\nD             E              F              G\nH             I              J              K\nL             M              N              O\nP             Q              R              S\nT             U              V              W\nX             Y              Z              bracketleft\nbackslash     bracketright   asciicircum    underscore\n  \ngrave         a              b              c\nd             e              f              g\nh             i              j              k\nl             m              n              o\np             q              r              s\nt             u              v              w\nx             y              z              braceleft\nbar           braceright     asciitilde     .notdef\n  \nEuro          .notdef        quotesinglbase florin\nquotedblbase  ellipsis       dagger         daggerdbl\ncircumflex    perthousand    Scaron         guilsinglleft\nOE            .notdef        Zcaron         .notdef\n.notdef       quoteleft      quoteright     quotedblleft\nquotedblright bullet         endash         emdash\ntilde         trademark      scaron         guilsinglright\noe            .notdef        zcaron         ydieresis\n  \nspace         exclamdown     cent           sterling\ncurrency      yen            brokenbar      section\ndieresis      copyright      ordfeminine    guillemotleft\nlogicalnot    hyphen         registered     macron\ndegree        plusminus      twosuperior    threesuperior\nacute         mu             paragraph      periodcentered\ncedilla       onesuperior    ordmasculine   guillemotright\nonequarter    onehalf        threequarters  questiondown\n  \nAgrave        Aacute         Acircumflex    Atilde\nAdieresis     Aring          AE             Ccedilla\nEgrave        Eacute         Ecircumflex    Edieresis\nIgrave        Iacute         Icircumflex    Idieresis\nEth           Ntilde         Ograve         Oacute\nOcircumflex   Otilde         Odieresis      multiply\nOslash        Ugrave         Uacute         Ucircumflex\nUdieresis     Yacute         Thorn          germandbls\n  \nagrave        aacute         acircumflex    atilde\nadieresis     aring          ae             ccedilla\negrave        eacute         ecircumflex    edieresis\nigrave        iacute         icircumflex    idieresis\neth           ntilde         ograve         oacute\nocircumflex   otilde         odieresis      divide\noslash        ugrave         uacute         ucircumflex\nudieresis     yacute         thorn          ydieresis\\\n`.split(/\\s+/);\nclass AFMFont {\n  constructor(contents) {\n    this.attributes = {};\n    this.glyphWidths = {};\n    this.boundingBoxes = {};\n    this.kernPairs = {};\n    this.parse(contents);\n    this.bbox = this.attributes['FontBBox'].split(/\\s+/).map(e => +e);\n    this.ascender = +(this.attributes['Ascender'] || 0);\n    this.descender = +(this.attributes['Descender'] || 0);\n    this.xHeight = +(this.attributes['XHeight'] || 0);\n    this.capHeight = +(this.attributes['CapHeight'] || 0);\n    this.lineGap = this.bbox[3] - this.bbox[1] - (this.ascender - this.descender);\n  }\n  parse(contents) {\n    let section = '';\n    for (let line of contents.split('\\n')) {\n      var match;\n      var a;\n      if (match = line.match(/^Start(\\w+)/)) {\n        section = match[1];\n        continue;\n      } else if (match = line.match(/^End(\\w+)/)) {\n        section = '';\n        continue;\n      }\n      switch (section) {\n        case 'FontMetrics':\n          match = line.match(/(^\\w+)\\s+(.*)/);\n          var key = match[1];\n          var value = match[2];\n          if (a = this.attributes[key]) {\n            if (!Array.isArray(a)) {\n              a = this.attributes[key] = [a];\n            }\n            a.push(value);\n          } else {\n            this.attributes[key] = value;\n          }\n          break;\n        case 'CharMetrics':\n          if (!/^CH?\\s/.test(line)) {\n            continue;\n          }\n          var name = line.match(/\\bN\\s+(\\.?\\w+)\\s*;/)[1];\n          this.glyphWidths[name] = +line.match(/\\bWX\\s+(\\d+)\\s*;/)[1];\n          break;\n        case 'KernPairs':\n          match = line.match(/^KPX\\s+(\\.?\\w+)\\s+(\\.?\\w+)\\s+(-?\\d+)/);\n          if (match) {\n            this.kernPairs[match[1] + '\\0' + match[2]] = parseInt(match[3]);\n          }\n          break;\n      }\n    }\n  }\n  encodeText(text) {\n    const res = [];\n    for (let i = 0, len = text.length; i < len; i++) {\n      let char = text.charCodeAt(i);\n      char = WIN_ANSI_MAP[char] || char;\n      res.push(char.toString(16));\n    }\n    return res;\n  }\n  glyphsForString(string) {\n    const glyphs = [];\n    for (let i = 0, len = string.length; i < len; i++) {\n      const charCode = string.charCodeAt(i);\n      glyphs.push(this.characterToGlyph(charCode));\n    }\n    return glyphs;\n  }\n  characterToGlyph(character) {\n    return characters[WIN_ANSI_MAP[character] || character] || '.notdef';\n  }\n  widthOfGlyph(glyph) {\n    return this.glyphWidths[glyph] || 0;\n  }\n  getKernPair(left, right) {\n    return this.kernPairs[left + '\\0' + right] || 0;\n  }\n  advancesForGlyphs(glyphs) {\n    const advances = [];\n    for (let index = 0; index < glyphs.length; index++) {\n      const left = glyphs[index];\n      const right = glyphs[index + 1];\n      advances.push(this.widthOfGlyph(left) + this.getKernPair(left, right));\n    }\n    return advances;\n  }\n}\n\nclass PDFFont {\n  constructor() {}\n  encode() {\n    throw new Error('Must be implemented by subclasses');\n  }\n  widthOfString() {\n    throw new Error('Must be implemented by subclasses');\n  }\n  ref() {\n    return this.dictionary != null ? this.dictionary : this.dictionary = this.document.ref();\n  }\n  finalize() {\n    if (this.embedded || this.dictionary == null) {\n      return;\n    }\n    this.embed();\n    this.embedded = true;\n  }\n  embed() {\n    throw new Error('Must be implemented by subclasses');\n  }\n  lineHeight(size) {\n    let includeGap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const gap = includeGap ? this.lineGap : 0;\n    return (this.ascender + gap - this.descender) / 1000 * size;\n  }\n}\n\nconst STANDARD_FONTS = {\n  Courier() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Courier.afm', 'utf8');\n  },\n  'Courier-Bold'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Courier-Bold.afm', 'utf8');\n  },\n  'Courier-Oblique'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Courier-Oblique.afm', 'utf8');\n  },\n  'Courier-BoldOblique'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Courier-BoldOblique.afm', 'utf8');\n  },\n  Helvetica() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Helvetica.afm', 'utf8');\n  },\n  'Helvetica-Bold'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Helvetica-Bold.afm', 'utf8');\n  },\n  'Helvetica-Oblique'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Helvetica-Oblique.afm', 'utf8');\n  },\n  'Helvetica-BoldOblique'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Helvetica-BoldOblique.afm', 'utf8');\n  },\n  'Times-Roman'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Times-Roman.afm', 'utf8');\n  },\n  'Times-Bold'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Times-Bold.afm', 'utf8');\n  },\n  'Times-Italic'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Times-Italic.afm', 'utf8');\n  },\n  'Times-BoldItalic'() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Times-BoldItalic.afm', 'utf8');\n  },\n  Symbol() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/Symbol.afm', 'utf8');\n  },\n  ZapfDingbats() {\n    return fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(__dirname + '/data/ZapfDingbats.afm', 'utf8');\n  }\n};\nclass StandardFont extends PDFFont {\n  constructor(document, name, id) {\n    super();\n    this.document = document;\n    this.name = name;\n    this.id = id;\n    this.font = new AFMFont(STANDARD_FONTS[this.name]());\n    ({\n      ascender: this.ascender,\n      descender: this.descender,\n      bbox: this.bbox,\n      lineGap: this.lineGap,\n      xHeight: this.xHeight,\n      capHeight: this.capHeight\n    } = this.font);\n  }\n  embed() {\n    this.dictionary.data = {\n      Type: 'Font',\n      BaseFont: this.name,\n      Subtype: 'Type1',\n      Encoding: 'WinAnsiEncoding'\n    };\n    return this.dictionary.end();\n  }\n  encode(text) {\n    const encoded = this.font.encodeText(text);\n    const glyphs = this.font.glyphsForString(`${text}`);\n    const advances = this.font.advancesForGlyphs(glyphs);\n    const positions = [];\n    for (let i = 0; i < glyphs.length; i++) {\n      const glyph = glyphs[i];\n      positions.push({\n        xAdvance: advances[i],\n        yAdvance: 0,\n        xOffset: 0,\n        yOffset: 0,\n        advanceWidth: this.font.widthOfGlyph(glyph)\n      });\n    }\n    return [encoded, positions];\n  }\n  widthOfString(string, size) {\n    const glyphs = this.font.glyphsForString(`${string}`);\n    const advances = this.font.advancesForGlyphs(glyphs);\n    let width = 0;\n    for (let advance of advances) {\n      width += advance;\n    }\n    const scale = size / 1000;\n    return width * scale;\n  }\n  static isStandardFont(name) {\n    return name in STANDARD_FONTS;\n  }\n}\n\nconst toHex = function (num) {\n  return `0000${num.toString(16)}`.slice(-4);\n};\nclass EmbeddedFont extends PDFFont {\n  constructor(document, font, id) {\n    super();\n    this.document = document;\n    this.font = font;\n    this.id = id;\n    this.subset = this.font.createSubset();\n    this.unicode = [[0]];\n    this.widths = [this.font.getGlyph(0).advanceWidth];\n    this.name = this.font.postscriptName;\n    this.scale = 1000 / this.font.unitsPerEm;\n    this.ascender = this.font.ascent * this.scale;\n    this.descender = this.font.descent * this.scale;\n    this.xHeight = this.font.xHeight * this.scale;\n    this.capHeight = this.font.capHeight * this.scale;\n    this.lineGap = this.font.lineGap * this.scale;\n    this.bbox = this.font.bbox;\n    if (document.options.fontLayoutCache !== false) {\n      this.layoutCache = Object.create(null);\n    }\n  }\n  layoutRun(text, features) {\n    const run = this.font.layout(text, features);\n    for (let i = 0; i < run.positions.length; i++) {\n      const position = run.positions[i];\n      for (let key in position) {\n        position[key] *= this.scale;\n      }\n      position.advanceWidth = run.glyphs[i].advanceWidth * this.scale;\n    }\n    return run;\n  }\n  layoutCached(text) {\n    if (!this.layoutCache) {\n      return this.layoutRun(text);\n    }\n    let cached;\n    if (cached = this.layoutCache[text]) {\n      return cached;\n    }\n    const run = this.layoutRun(text);\n    this.layoutCache[text] = run;\n    return run;\n  }\n  layout(text, features, onlyWidth) {\n    if (features) {\n      return this.layoutRun(text, features);\n    }\n    let glyphs = onlyWidth ? null : [];\n    let positions = onlyWidth ? null : [];\n    let advanceWidth = 0;\n    let last = 0;\n    let index = 0;\n    while (index <= text.length) {\n      var needle;\n      if (index === text.length && last < index || (needle = text.charAt(index), [' ', '\\t'].includes(needle))) {\n        const run = this.layoutCached(text.slice(last, ++index));\n        if (!onlyWidth) {\n          glyphs = glyphs.concat(run.glyphs);\n          positions = positions.concat(run.positions);\n        }\n        advanceWidth += run.advanceWidth;\n        last = index;\n      } else {\n        index++;\n      }\n    }\n    return {\n      glyphs,\n      positions,\n      advanceWidth\n    };\n  }\n  encode(text, features) {\n    const {\n      glyphs,\n      positions\n    } = this.layout(text, features);\n    const res = [];\n    for (let i = 0; i < glyphs.length; i++) {\n      const glyph = glyphs[i];\n      const gid = this.subset.includeGlyph(glyph.id);\n      res.push(`0000${gid.toString(16)}`.slice(-4));\n      if (this.widths[gid] == null) {\n        this.widths[gid] = glyph.advanceWidth * this.scale;\n      }\n      if (this.unicode[gid] == null) {\n        this.unicode[gid] = glyph.codePoints;\n      }\n    }\n    return [res, positions];\n  }\n  widthOfString(string, size, features) {\n    const width = this.layout(string, features, true).advanceWidth;\n    const scale = size / 1000;\n    return width * scale;\n  }\n  embed() {\n    const isCFF = this.subset.cff != null;\n    const fontFile = this.document.ref();\n    if (isCFF) {\n      fontFile.data.Subtype = 'CIDFontType0C';\n    }\n    fontFile.end(this.subset.encode());\n    const familyClass = ((this.font['OS/2'] != null ? this.font['OS/2'].sFamilyClass : undefined) || 0) >> 8;\n    let flags = 0;\n    if (this.font.post.isFixedPitch) {\n      flags |= 1 << 0;\n    }\n    if (1 <= familyClass && familyClass <= 7) {\n      flags |= 1 << 1;\n    }\n    flags |= 1 << 2;\n    if (familyClass === 10) {\n      flags |= 1 << 3;\n    }\n    if (this.font.head.macStyle.italic) {\n      flags |= 1 << 6;\n    }\n    const tag = [1, 2, 3, 4, 5, 6].map(i => String.fromCharCode((this.id.charCodeAt(i) || 73) + 17)).join('');\n    const name = tag + '+' + this.font.postscriptName?.replaceAll(' ', '_');\n    const {\n      bbox\n    } = this.font;\n    const descriptor = this.document.ref({\n      Type: 'FontDescriptor',\n      FontName: name,\n      Flags: flags,\n      FontBBox: [bbox.minX * this.scale, bbox.minY * this.scale, bbox.maxX * this.scale, bbox.maxY * this.scale],\n      ItalicAngle: this.font.italicAngle,\n      Ascent: this.ascender,\n      Descent: this.descender,\n      CapHeight: (this.font.capHeight || this.font.ascent) * this.scale,\n      XHeight: (this.font.xHeight || 0) * this.scale,\n      StemV: 0\n    });\n    if (isCFF) {\n      descriptor.data.FontFile3 = fontFile;\n    } else {\n      descriptor.data.FontFile2 = fontFile;\n    }\n    if (this.document.subset && this.document.subset === 1) {\n      const CIDSet = Buffer.from('FFFFFFFFC0', 'hex');\n      const CIDSetRef = this.document.ref();\n      CIDSetRef.write(CIDSet);\n      CIDSetRef.end();\n      descriptor.data.CIDSet = CIDSetRef;\n    }\n    descriptor.end();\n    const descendantFontData = {\n      Type: 'Font',\n      Subtype: 'CIDFontType0',\n      BaseFont: name,\n      CIDSystemInfo: {\n        Registry: new String('Adobe'),\n        Ordering: new String('Identity'),\n        Supplement: 0\n      },\n      FontDescriptor: descriptor,\n      W: [0, this.widths]\n    };\n    if (!isCFF) {\n      descendantFontData.Subtype = 'CIDFontType2';\n      descendantFontData.CIDToGIDMap = 'Identity';\n    }\n    const descendantFont = this.document.ref(descendantFontData);\n    descendantFont.end();\n    this.dictionary.data = {\n      Type: 'Font',\n      Subtype: 'Type0',\n      BaseFont: name,\n      Encoding: 'Identity-H',\n      DescendantFonts: [descendantFont],\n      ToUnicode: this.toUnicodeCmap()\n    };\n    return this.dictionary.end();\n  }\n  toUnicodeCmap() {\n    const cmap = this.document.ref();\n    const entries = [];\n    for (let codePoints of this.unicode) {\n      const encoded = [];\n      for (let value of codePoints) {\n        if (value > 0xffff) {\n          value -= 0x10000;\n          encoded.push(toHex(value >>> 10 & 0x3ff | 0xd800));\n          value = 0xdc00 | value & 0x3ff;\n        }\n        encoded.push(toHex(value));\n      }\n      entries.push(`<${encoded.join(' ')}>`);\n    }\n    const chunkSize = 256;\n    const chunks = Math.ceil(entries.length / chunkSize);\n    const ranges = [];\n    for (let i = 0; i < chunks; i++) {\n      const start = i * chunkSize;\n      const end = Math.min((i + 1) * chunkSize, entries.length);\n      ranges.push(`<${toHex(start)}> <${toHex(end - 1)}> [${entries.slice(start, end).join(' ')}]`);\n    }\n    cmap.end(`\\\n/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange\n1 beginbfrange\n${ranges.join('\\n')}\nendbfrange\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend\\\n`);\n    return cmap;\n  }\n}\n\nclass PDFFontFactory {\n  static open(document, src, family, id) {\n    let font;\n    if (typeof src === 'string') {\n      if (StandardFont.isStandardFont(src)) {\n        return new StandardFont(document, src, id);\n      }\n      src = fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(src);\n    }\n    if (src instanceof Uint8Array) {\n      font = fontkit__WEBPACK_IMPORTED_MODULE_4__.create(src, family);\n    } else if (src instanceof ArrayBuffer) {\n      font = fontkit__WEBPACK_IMPORTED_MODULE_4__.create(new Uint8Array(src), family);\n    }\n    if (font == null) {\n      throw new Error('Not a supported font format or standard PDF font.');\n    }\n    return new EmbeddedFont(document, font, id);\n  }\n}\n\nconst isEqualFont = (font1, font2) => {\n  if (font1.font._tables?.head?.checkSumAdjustment !== font2.font._tables?.head?.checkSumAdjustment) {\n    return false;\n  }\n  if (JSON.stringify(font1.font._tables?.name?.records) !== JSON.stringify(font2.font._tables?.name?.records)) {\n    return false;\n  }\n  return true;\n};\nvar FontsMixin = {\n  initFonts() {\n    let defaultFont = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Helvetica';\n    let defaultFontFamily = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let defaultFontSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 12;\n    this._fontFamilies = {};\n    this._fontCount = 0;\n    this._fontSource = defaultFont;\n    this._fontFamily = defaultFontFamily;\n    this._fontSize = defaultFontSize;\n    this._font = null;\n    this._remSize = defaultFontSize;\n    this._registeredFonts = {};\n    if (defaultFont) {\n      this.font(defaultFont, defaultFontFamily);\n    }\n  },\n  font(src, family, size) {\n    let cacheKey, font;\n    if (typeof family === 'number') {\n      size = family;\n      family = null;\n    }\n    if (typeof src === 'string' && this._registeredFonts[src]) {\n      cacheKey = src;\n      ({\n        src,\n        family\n      } = this._registeredFonts[src]);\n    } else {\n      cacheKey = family || src;\n      if (typeof cacheKey !== 'string') {\n        cacheKey = null;\n      }\n    }\n    this._fontSource = src;\n    this._fontFamily = family;\n    if (size != null) {\n      this.fontSize(size);\n    }\n    if (font = this._fontFamilies[cacheKey]) {\n      this._font = font;\n      return this;\n    }\n    const id = `F${++this._fontCount}`;\n    this._font = PDFFontFactory.open(this, src, family, id);\n    if ((font = this._fontFamilies[this._font.name]) && isEqualFont(this._font, font)) {\n      this._font = font;\n      return this;\n    }\n    if (cacheKey) {\n      this._fontFamilies[cacheKey] = this._font;\n    }\n    if (this._font.name) {\n      this._fontFamilies[this._font.name] = this._font;\n    }\n    return this;\n  },\n  fontSize(_fontSize) {\n    this._fontSize = this.sizeToPoint(_fontSize);\n    return this;\n  },\n  currentLineHeight(includeGap) {\n    return this._font.lineHeight(this._fontSize, includeGap);\n  },\n  registerFont(name, src, family) {\n    this._registeredFonts[name] = {\n      src,\n      family\n    };\n    return this;\n  },\n  sizeToPoint(size) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let page = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.page;\n    let percentageWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    if (!percentageWidth) percentageWidth = this._fontSize;\n    if (typeof defaultValue !== 'number') defaultValue = this.sizeToPoint(defaultValue);\n    if (size === undefined) return defaultValue;\n    if (typeof size === 'number') return size;\n    if (typeof size === 'boolean') return Number(size);\n    const match = String(size).match(/((\\d+)?(\\.\\d+)?)(em|in|px|cm|mm|pc|ex|ch|rem|vw|vh|vmin|vmax|%|pt)?/);\n    if (!match) throw new Error(`Unsupported size '${size}'`);\n    let multiplier;\n    switch (match[4]) {\n      case 'em':\n        multiplier = this._fontSize;\n        break;\n      case 'in':\n        multiplier = IN_TO_PT;\n        break;\n      case 'px':\n        multiplier = PX_TO_IN * IN_TO_PT;\n        break;\n      case 'cm':\n        multiplier = CM_TO_IN * IN_TO_PT;\n        break;\n      case 'mm':\n        multiplier = MM_TO_CM * CM_TO_IN * IN_TO_PT;\n        break;\n      case 'pc':\n        multiplier = PC_TO_PT;\n        break;\n      case 'ex':\n        multiplier = this.currentLineHeight();\n        break;\n      case 'ch':\n        multiplier = this.widthOfString('0');\n        break;\n      case 'rem':\n        multiplier = this._remSize;\n        break;\n      case 'vw':\n        multiplier = page.width / 100;\n        break;\n      case 'vh':\n        multiplier = page.height / 100;\n        break;\n      case 'vmin':\n        multiplier = Math.min(page.width, page.height) / 100;\n        break;\n      case 'vmax':\n        multiplier = Math.max(page.width, page.height) / 100;\n        break;\n      case '%':\n        multiplier = percentageWidth / 100;\n        break;\n      case 'pt':\n      default:\n        multiplier = 1;\n    }\n    return multiplier * Number(match[1]);\n  }\n};\n\nconst SOFT_HYPHEN = '\\u00AD';\nconst HYPHEN = '-';\nclass LineWrapper extends events__WEBPACK_IMPORTED_MODULE_5__.EventEmitter {\n  constructor(document, options) {\n    super();\n    this.document = document;\n    this.horizontalScaling = options.horizontalScaling || 100;\n    this.indent = (options.indent || 0) * this.horizontalScaling / 100;\n    this.characterSpacing = (options.characterSpacing || 0) * this.horizontalScaling / 100;\n    this.wordSpacing = (options.wordSpacing === 0) * this.horizontalScaling / 100;\n    this.columns = options.columns || 1;\n    this.columnGap = (options.columnGap != null ? options.columnGap : 18) * this.horizontalScaling / 100;\n    this.lineWidth = (options.width * this.horizontalScaling / 100 - this.columnGap * (this.columns - 1)) / this.columns;\n    this.spaceLeft = this.lineWidth;\n    this.startX = this.document.x;\n    this.startY = this.document.y;\n    this.column = 1;\n    this.ellipsis = options.ellipsis;\n    this.continuedX = 0;\n    this.features = options.features;\n    if (options.height != null) {\n      this.height = options.height;\n      this.maxY = PDFNumber(this.startY + options.height);\n    } else {\n      this.maxY = PDFNumber(this.document.page.maxY());\n    }\n    this.on('firstLine', options => {\n      const indent = this.continuedX || this.indent;\n      this.document.x += indent;\n      this.lineWidth -= indent;\n      if (options.indentAllLines) {\n        return;\n      }\n      this.once('line', () => {\n        this.document.x -= indent;\n        this.lineWidth += indent;\n        if (options.continued && !this.continuedX) {\n          this.continuedX = this.indent;\n        }\n        if (!options.continued) {\n          this.continuedX = 0;\n        }\n      });\n    });\n    this.on('lastLine', options => {\n      const {\n        align\n      } = options;\n      if (align === 'justify') {\n        options.align = 'left';\n      }\n      this.lastLine = true;\n      this.once('line', () => {\n        this.document.y += options.paragraphGap || 0;\n        options.align = align;\n        return this.lastLine = false;\n      });\n    });\n  }\n  wordWidth(word) {\n    return PDFNumber(this.document.widthOfString(word, this) + this.characterSpacing + this.wordSpacing);\n  }\n  canFit(word, w) {\n    if (word[word.length - 1] != SOFT_HYPHEN) {\n      return w <= this.spaceLeft;\n    }\n    return w + this.wordWidth(HYPHEN) <= this.spaceLeft;\n  }\n  eachWord(text, fn) {\n    let bk;\n    const breaker = new linebreak__WEBPACK_IMPORTED_MODULE_6__[\"default\"](text);\n    let last = null;\n    const wordWidths = Object.create(null);\n    while (bk = breaker.nextBreak()) {\n      var shouldContinue;\n      let word = text.slice((last != null ? last.position : undefined) || 0, bk.position);\n      let w = wordWidths[word] != null ? wordWidths[word] : wordWidths[word] = this.wordWidth(word);\n      if (w > this.lineWidth + this.continuedX) {\n        let lbk = last;\n        const fbk = {};\n        while (word.length) {\n          var l, mightGrow;\n          if (w > this.spaceLeft) {\n            l = Math.ceil(this.spaceLeft / (w / word.length));\n            w = this.wordWidth(word.slice(0, l));\n            mightGrow = w <= this.spaceLeft && l < word.length;\n          } else {\n            l = word.length;\n          }\n          let mustShrink = w > this.spaceLeft && l > 0;\n          while (mustShrink || mightGrow) {\n            if (mustShrink) {\n              w = this.wordWidth(word.slice(0, --l));\n              mustShrink = w > this.spaceLeft && l > 0;\n            } else {\n              w = this.wordWidth(word.slice(0, ++l));\n              mustShrink = w > this.spaceLeft && l > 0;\n              mightGrow = w <= this.spaceLeft && l < word.length;\n            }\n          }\n          if (l === 0 && this.spaceLeft === this.lineWidth) {\n            l = 1;\n          }\n          fbk.required = bk.required || l < word.length;\n          shouldContinue = fn(word.slice(0, l), w, fbk, lbk);\n          lbk = {\n            required: false\n          };\n          word = word.slice(l);\n          w = this.wordWidth(word);\n          if (shouldContinue === false) {\n            break;\n          }\n        }\n      } else {\n        shouldContinue = fn(word, w, bk, last);\n      }\n      if (shouldContinue === false) {\n        break;\n      }\n      last = bk;\n    }\n  }\n  wrap(text, options) {\n    this.horizontalScaling = options.horizontalScaling || 100;\n    if (options.indent != null) {\n      this.indent = options.indent * this.horizontalScaling / 100;\n    }\n    if (options.characterSpacing != null) {\n      this.characterSpacing = options.characterSpacing * this.horizontalScaling / 100;\n    }\n    if (options.wordSpacing != null) {\n      this.wordSpacing = options.wordSpacing * this.horizontalScaling / 100;\n    }\n    if (options.ellipsis != null) {\n      this.ellipsis = options.ellipsis;\n    }\n    const nextY = this.document.y + this.document.currentLineHeight(true);\n    if (this.document.y > this.maxY || nextY > this.maxY) {\n      this.nextSection();\n    }\n    let buffer = '';\n    let textWidth = 0;\n    let wc = 0;\n    let lc = 0;\n    let {\n      y\n    } = this.document;\n    const emitLine = () => {\n      options.textWidth = textWidth + this.wordSpacing * (wc - 1);\n      options.wordCount = wc;\n      options.lineWidth = this.lineWidth;\n      ({\n        y\n      } = this.document);\n      this.emit('line', buffer, options, this);\n      return lc++;\n    };\n    this.emit('sectionStart', options, this);\n    this.eachWord(text, (word, w, bk, last) => {\n      if (last == null || last.required) {\n        this.emit('firstLine', options, this);\n        this.spaceLeft = this.lineWidth;\n      }\n      if (this.canFit(word, w)) {\n        buffer += word;\n        textWidth += w;\n        wc++;\n      }\n      if (bk.required || !this.canFit(word, w)) {\n        const lh = this.document.currentLineHeight(true);\n        if (this.height != null && this.ellipsis && PDFNumber(this.document.y + lh * 2) > this.maxY && this.column >= this.columns) {\n          if (this.ellipsis === true) {\n            this.ellipsis = '…';\n          }\n          buffer = buffer.replace(/\\s+$/, '');\n          textWidth = this.wordWidth(buffer + this.ellipsis);\n          while (buffer && textWidth > this.lineWidth) {\n            buffer = buffer.slice(0, -1).replace(/\\s+$/, '');\n            textWidth = this.wordWidth(buffer + this.ellipsis);\n          }\n          if (textWidth <= this.lineWidth) {\n            buffer = buffer + this.ellipsis;\n          }\n          textWidth = this.wordWidth(buffer);\n        }\n        if (bk.required) {\n          if (w > this.spaceLeft) {\n            emitLine();\n            buffer = word;\n            textWidth = w;\n            wc = 1;\n          }\n          this.emit('lastLine', options, this);\n        }\n        if (buffer[buffer.length - 1] == SOFT_HYPHEN) {\n          buffer = buffer.slice(0, -1) + HYPHEN;\n          this.spaceLeft -= this.wordWidth(HYPHEN);\n        }\n        emitLine();\n        if (PDFNumber(this.document.y + lh) > this.maxY) {\n          const shouldContinue = this.nextSection();\n          if (!shouldContinue) {\n            wc = 0;\n            buffer = '';\n            return false;\n          }\n        }\n        if (bk.required) {\n          this.spaceLeft = this.lineWidth;\n          buffer = '';\n          textWidth = 0;\n          return wc = 0;\n        } else {\n          this.spaceLeft = this.lineWidth - w;\n          buffer = word;\n          textWidth = w;\n          return wc = 1;\n        }\n      } else {\n        return this.spaceLeft -= w;\n      }\n    });\n    if (wc > 0) {\n      this.emit('lastLine', options, this);\n      emitLine();\n    }\n    this.emit('sectionEnd', options, this);\n    if (options.continued === true) {\n      if (lc > 1) {\n        this.continuedX = 0;\n      }\n      this.continuedX += options.textWidth || 0;\n      this.document.y = y;\n    } else {\n      this.document.x = this.startX;\n    }\n  }\n  nextSection(options) {\n    this.emit('sectionEnd', options, this);\n    if (++this.column > this.columns) {\n      if (this.height != null) {\n        return false;\n      }\n      this.document.continueOnNewPage();\n      this.column = 1;\n      this.startY = this.document.page.margins.top;\n      this.maxY = this.document.page.maxY();\n      this.document.x = this.startX;\n      if (this.document._fillColor) {\n        this.document.fillColor(...this.document._fillColor);\n      }\n      this.emit('pageBreak', options, this);\n    } else {\n      this.document.x += this.lineWidth + this.columnGap;\n      this.document.y = this.startY;\n      this.emit('columnBreak', options, this);\n    }\n    this.emit('sectionStart', options, this);\n    return true;\n  }\n}\n\nconst {\n  number\n} = PDFObject;\nvar TextMixin = {\n  initText() {\n    this._line = this._line.bind(this);\n    this.x = 0;\n    this.y = 0;\n    this._lineGap = 0;\n  },\n  lineGap(_lineGap) {\n    this._lineGap = _lineGap;\n    return this;\n  },\n  moveDown(lines) {\n    if (lines == null) {\n      lines = 1;\n    }\n    this.y += this.currentLineHeight(true) * lines + this._lineGap;\n    return this;\n  },\n  moveUp(lines) {\n    if (lines == null) {\n      lines = 1;\n    }\n    this.y -= this.currentLineHeight(true) * lines + this._lineGap;\n    return this;\n  },\n  _text(text, x, y, options, lineCallback) {\n    options = this._initOptions(x, y, options);\n    text = text == null ? '' : `${text}`;\n    if (options.wordSpacing) {\n      text = text.replace(/\\s{2,}/g, ' ');\n    }\n    const addStructure = () => {\n      if (options.structParent) {\n        options.structParent.add(this.struct(options.structType || 'P', [this.markStructureContent(options.structType || 'P')]));\n      }\n    };\n    if (options.rotation !== 0) {\n      this.save();\n      this.rotate(-options.rotation, {\n        origin: [this.x, this.y]\n      });\n    }\n    if (options.width) {\n      let wrapper = this._wrapper;\n      if (!wrapper) {\n        wrapper = new LineWrapper(this, options);\n        wrapper.on('line', lineCallback);\n        wrapper.on('firstLine', addStructure);\n      }\n      this._wrapper = options.continued ? wrapper : null;\n      this._textOptions = options.continued ? options : null;\n      wrapper.wrap(text, options);\n    } else {\n      for (let line of text.split('\\n')) {\n        addStructure();\n        lineCallback(line, options);\n      }\n    }\n    if (options.rotation !== 0) this.restore();\n    return this;\n  },\n  text(text, x, y, options) {\n    return this._text(text, x, y, options, this._line);\n  },\n  widthOfString(string) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const horizontalScaling = options.horizontalScaling || 100;\n    return (this._font.widthOfString(string, this._fontSize, options.features) + (options.characterSpacing || 0) * (string.length - 1)) * horizontalScaling / 100;\n  },\n  boundsOfString(string, x, y, options) {\n    options = this._initOptions(x, y, options);\n    ({\n      x,\n      y\n    } = this);\n    const lineGap = options.lineGap ?? this._lineGap ?? 0;\n    const lineHeight = this.currentLineHeight(true) + lineGap;\n    let contentWidth = 0;\n    string = String(string ?? '');\n    if (options.wordSpacing) {\n      string = string.replace(/\\s{2,}/g, ' ');\n    }\n    if (options.width) {\n      let wrapper = new LineWrapper(this, options);\n      wrapper.on('line', (text, options) => {\n        this.y += lineHeight;\n        text = text.replace(/\\n/g, '');\n        if (text.length) {\n          let wordSpacing = options.wordSpacing ?? 0;\n          const characterSpacing = options.characterSpacing ?? 0;\n          if (options.width && options.align === 'justify') {\n            const words = text.trim().split(/\\s+/);\n            const textWidth = this.widthOfString(text.replace(/\\s+/g, ''), options);\n            const spaceWidth = this.widthOfString(' ') + characterSpacing;\n            wordSpacing = Math.max(0, (options.lineWidth - textWidth) / Math.max(1, words.length - 1) - spaceWidth);\n          }\n          contentWidth = Math.max(contentWidth, options.textWidth + wordSpacing * (options.wordCount - 1) + characterSpacing * (text.length - 1));\n        }\n      });\n      wrapper.wrap(string, options);\n    } else {\n      for (let line of string.split('\\n')) {\n        const lineWidth = this.widthOfString(line, options);\n        this.y += lineHeight;\n        contentWidth = Math.max(contentWidth, lineWidth);\n      }\n    }\n    let contentHeight = this.y - y;\n    if (options.height) contentHeight = Math.min(contentHeight, options.height);\n    this.x = x;\n    this.y = y;\n    if (options.rotation === 0) {\n      return {\n        x,\n        y,\n        width: contentWidth,\n        height: contentHeight\n      };\n    } else if (options.rotation === 90) {\n      return {\n        x: x,\n        y: y - contentWidth,\n        width: contentHeight,\n        height: contentWidth\n      };\n    } else if (options.rotation === 180) {\n      return {\n        x: x - contentWidth,\n        y: y - contentHeight,\n        width: contentWidth,\n        height: contentHeight\n      };\n    } else if (options.rotation === 270) {\n      return {\n        x: x - contentHeight,\n        y: y,\n        width: contentHeight,\n        height: contentWidth\n      };\n    }\n    const cos = cosine(options.rotation);\n    const sin = sine(options.rotation);\n    const x1 = x;\n    const y1 = y;\n    const x2 = x + contentWidth * cos;\n    const y2 = y - contentWidth * sin;\n    const x3 = x + contentWidth * cos + contentHeight * sin;\n    const y3 = y - contentWidth * sin + contentHeight * cos;\n    const x4 = x + contentHeight * sin;\n    const y4 = y + contentHeight * cos;\n    const xMin = Math.min(x1, x2, x3, x4);\n    const xMax = Math.max(x1, x2, x3, x4);\n    const yMin = Math.min(y1, y2, y3, y4);\n    const yMax = Math.max(y1, y2, y3, y4);\n    return {\n      x: xMin,\n      y: yMin,\n      width: xMax - xMin,\n      height: yMax - yMin\n    };\n  },\n  heightOfString(text, options) {\n    const {\n      x,\n      y\n    } = this;\n    options = this._initOptions(options);\n    options.height = Infinity;\n    const lineGap = options.lineGap || this._lineGap || 0;\n    this._text(text, this.x, this.y, options, () => {\n      this.y += this.currentLineHeight(true) + lineGap;\n    });\n    const height = this.y - y;\n    this.x = x;\n    this.y = y;\n    return height;\n  },\n  list(list, x, y, options, wrapper) {\n    options = this._initOptions(x, y, options);\n    const listType = options.listType || 'bullet';\n    const unit = Math.round(this._font.ascender / 1000 * this._fontSize);\n    const midLine = unit / 2;\n    const r = options.bulletRadius || unit / 3;\n    const indent = options.textIndent || (listType === 'bullet' ? r * 5 : unit * 2);\n    const itemIndent = options.bulletIndent || (listType === 'bullet' ? r * 8 : unit * 2);\n    let level = 1;\n    const items = [];\n    const levels = [];\n    const numbers = [];\n    var flatten = function (list) {\n      let n = 1;\n      for (let i = 0; i < list.length; i++) {\n        const item = list[i];\n        if (Array.isArray(item)) {\n          level++;\n          flatten(item);\n          level--;\n        } else {\n          items.push(item);\n          levels.push(level);\n          if (listType !== 'bullet') {\n            numbers.push(n++);\n          }\n        }\n      }\n    };\n    flatten(list);\n    const label = function (n) {\n      switch (listType) {\n        case 'numbered':\n          return `${n}.`;\n        case 'lettered':\n          var letter = String.fromCharCode((n - 1) % 26 + 65);\n          var times = Math.floor((n - 1) / 26 + 1);\n          var text = Array(times + 1).join(letter);\n          return `${text}.`;\n      }\n    };\n    const drawListItem = function (listItem, i) {\n      wrapper = new LineWrapper(this, options);\n      wrapper.on('line', this._line);\n      level = 1;\n      wrapper.once('firstLine', () => {\n        let item, itemType, labelType, bodyType;\n        if (options.structParent) {\n          if (options.structTypes) {\n            [itemType, labelType, bodyType] = options.structTypes;\n          } else {\n            [itemType, labelType, bodyType] = ['LI', 'Lbl', 'LBody'];\n          }\n        }\n        if (itemType) {\n          item = this.struct(itemType);\n          options.structParent.add(item);\n        } else if (options.structParent) {\n          item = options.structParent;\n        }\n        let l;\n        if ((l = levels[i++]) !== level) {\n          const diff = itemIndent * (l - level);\n          this.x += diff;\n          wrapper.lineWidth -= diff;\n          level = l;\n        }\n        if (item && (labelType || bodyType)) {\n          item.add(this.struct(labelType || bodyType, [this.markStructureContent(labelType || bodyType)]));\n        }\n        switch (listType) {\n          case 'bullet':\n            this.circle(this.x - indent + r, this.y + midLine, r);\n            this.fill();\n            break;\n          case 'numbered':\n          case 'lettered':\n            var text = label(numbers[i - 1]);\n            this._fragment(text, this.x - indent, this.y, options);\n            break;\n        }\n        if (item && labelType && bodyType) {\n          item.add(this.struct(bodyType, [this.markStructureContent(bodyType)]));\n        }\n        if (item && item !== options.structParent) {\n          item.end();\n        }\n      });\n      wrapper.on('sectionStart', () => {\n        const pos = indent + itemIndent * (level - 1);\n        this.x += pos;\n        wrapper.lineWidth -= pos;\n      });\n      wrapper.on('sectionEnd', () => {\n        const pos = indent + itemIndent * (level - 1);\n        this.x -= pos;\n        wrapper.lineWidth += pos;\n      });\n      wrapper.wrap(listItem, options);\n    };\n    for (let i = 0; i < items.length; i++) {\n      drawListItem.call(this, items[i], i);\n    }\n    return this;\n  },\n  _initOptions() {\n    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let y = arguments.length > 1 ? arguments[1] : undefined;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (typeof x === 'object') {\n      options = x;\n      x = null;\n    }\n    const result = Object.assign({}, options);\n    if (this._textOptions) {\n      for (let key in this._textOptions) {\n        const val = this._textOptions[key];\n        if (key !== 'continued') {\n          if (result[key] === undefined) {\n            result[key] = val;\n          }\n        }\n      }\n    }\n    if (x != null) {\n      this.x = x;\n    }\n    if (y != null) {\n      this.y = y;\n    }\n    if (result.lineBreak !== false) {\n      if (result.width == null) {\n        result.width = this.page.width - this.x - this.page.margins.right;\n      }\n      result.width = Math.max(result.width, 0);\n    }\n    if (!result.columns) {\n      result.columns = 0;\n    }\n    if (result.columnGap == null) {\n      result.columnGap = 18;\n    }\n    result.rotation = Number(options.rotation ?? 0) % 360;\n    if (result.rotation < 0) result.rotation += 360;\n    return result;\n  },\n  _line(text) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let wrapper = arguments.length > 2 ? arguments[2] : undefined;\n    this._fragment(text, this.x, this.y, options);\n    const lineGap = options.lineGap || this._lineGap || 0;\n    if (!wrapper) {\n      this.x += this.widthOfString(text, options);\n    } else {\n      this.y += this.currentLineHeight(true) + lineGap;\n    }\n  },\n  _fragment(text, x, y, options) {\n    let dy, encoded, i, positions, textWidth, words;\n    text = `${text}`.replace(/\\n/g, '');\n    if (text.length === 0) {\n      return;\n    }\n    const align = options.align || 'left';\n    let wordSpacing = options.wordSpacing || 0;\n    const characterSpacing = options.characterSpacing || 0;\n    const horizontalScaling = options.horizontalScaling || 100;\n    if (options.width) {\n      switch (align) {\n        case 'right':\n          textWidth = this.widthOfString(text.replace(/\\s+$/, ''), options);\n          x += options.lineWidth - textWidth;\n          break;\n        case 'center':\n          x += options.lineWidth / 2 - options.textWidth / 2;\n          break;\n        case 'justify':\n          words = text.trim().split(/\\s+/);\n          textWidth = this.widthOfString(text.replace(/\\s+/g, ''), options);\n          var spaceWidth = this.widthOfString(' ') + characterSpacing;\n          wordSpacing = Math.max(0, (options.lineWidth - textWidth) / Math.max(1, words.length - 1) - spaceWidth);\n          break;\n      }\n    }\n    if (typeof options.baseline === 'number') {\n      dy = -options.baseline;\n    } else {\n      switch (options.baseline) {\n        case 'svg-middle':\n          dy = 0.5 * this._font.xHeight;\n          break;\n        case 'middle':\n        case 'svg-central':\n          dy = 0.5 * (this._font.descender + this._font.ascender);\n          break;\n        case 'bottom':\n        case 'ideographic':\n          dy = this._font.descender;\n          break;\n        case 'alphabetic':\n          dy = 0;\n          break;\n        case 'mathematical':\n          dy = 0.5 * this._font.ascender;\n          break;\n        case 'hanging':\n          dy = 0.8 * this._font.ascender;\n          break;\n        case 'top':\n          dy = this._font.ascender;\n          break;\n        default:\n          dy = this._font.ascender;\n      }\n      dy = dy / 1000 * this._fontSize;\n    }\n    const renderedWidth = options.textWidth + wordSpacing * (options.wordCount - 1) + characterSpacing * (text.length - 1);\n    if (options.link != null) {\n      this.link(x, y, renderedWidth, this.currentLineHeight(), options.link);\n    }\n    if (options.goTo != null) {\n      this.goTo(x, y, renderedWidth, this.currentLineHeight(), options.goTo);\n    }\n    if (options.destination != null) {\n      this.addNamedDestination(options.destination, 'XYZ', x, y, null);\n    }\n    if (options.underline) {\n      this.save();\n      if (!options.stroke) {\n        this.strokeColor(...(this._fillColor || []));\n      }\n      const lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);\n      this.lineWidth(lineWidth);\n      let lineY = y + this.currentLineHeight() - lineWidth;\n      this.moveTo(x, lineY);\n      this.lineTo(x + renderedWidth, lineY);\n      this.stroke();\n      this.restore();\n    }\n    if (options.strike) {\n      this.save();\n      if (!options.stroke) {\n        this.strokeColor(...(this._fillColor || []));\n      }\n      const lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);\n      this.lineWidth(lineWidth);\n      let lineY = y + this.currentLineHeight() / 2;\n      this.moveTo(x, lineY);\n      this.lineTo(x + renderedWidth, lineY);\n      this.stroke();\n      this.restore();\n    }\n    this.save();\n    if (options.oblique) {\n      let skew;\n      if (typeof options.oblique === 'number') {\n        skew = -Math.tan(options.oblique * Math.PI / 180);\n      } else {\n        skew = -0.25;\n      }\n      this.transform(1, 0, 0, 1, x, y);\n      this.transform(1, 0, skew, 1, -skew * dy, 0);\n      this.transform(1, 0, 0, 1, -x, -y);\n    }\n    this.transform(1, 0, 0, -1, 0, this.page.height);\n    y = this.page.height - y - dy;\n    if (this.page.fonts[this._font.id] == null) {\n      this.page.fonts[this._font.id] = this._font.ref();\n    }\n    this.addContent('BT');\n    this.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n    this.addContent(`/${this._font.id} ${number(this._fontSize)} Tf`);\n    const mode = options.fill && options.stroke ? 2 : options.stroke ? 1 : 0;\n    if (mode) {\n      this.addContent(`${mode} Tr`);\n    }\n    if (characterSpacing) {\n      this.addContent(`${number(characterSpacing)} Tc`);\n    }\n    if (horizontalScaling !== 100) {\n      this.addContent(`${horizontalScaling} Tz`);\n    }\n    if (wordSpacing) {\n      words = text.trim().split(/\\s+/);\n      wordSpacing += this.widthOfString(' ') + characterSpacing;\n      wordSpacing *= 1000 / this._fontSize;\n      encoded = [];\n      positions = [];\n      for (let word of words) {\n        const [encodedWord, positionsWord] = this._font.encode(word, options.features);\n        encoded = encoded.concat(encodedWord);\n        positions = positions.concat(positionsWord);\n        const space = {};\n        const object = positions[positions.length - 1];\n        for (let key in object) {\n          const val = object[key];\n          space[key] = val;\n        }\n        space.xAdvance += wordSpacing;\n        positions[positions.length - 1] = space;\n      }\n    } else {\n      [encoded, positions] = this._font.encode(text, options.features);\n    }\n    const scale = this._fontSize / 1000;\n    const commands = [];\n    let last = 0;\n    let hadOffset = false;\n    const addSegment = cur => {\n      if (last < cur) {\n        const hex = encoded.slice(last, cur).join('');\n        const advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;\n        commands.push(`<${hex}> ${number(-advance)}`);\n      }\n      last = cur;\n    };\n    const flush = i => {\n      addSegment(i);\n      if (commands.length > 0) {\n        this.addContent(`[${commands.join(' ')}] TJ`);\n        commands.length = 0;\n      }\n    };\n    for (i = 0; i < positions.length; i++) {\n      const pos = positions[i];\n      if (pos.xOffset || pos.yOffset) {\n        flush(i);\n        this.addContent(`1 0 0 1 ${number(x + pos.xOffset * scale)} ${number(y + pos.yOffset * scale)} Tm`);\n        flush(i + 1);\n        hadOffset = true;\n      } else {\n        if (hadOffset) {\n          this.addContent(`1 0 0 1 ${number(x)} ${number(y)} Tm`);\n          hadOffset = false;\n        }\n        if (pos.xAdvance - pos.advanceWidth !== 0) {\n          addSegment(i + 1);\n        }\n      }\n      x += pos.xAdvance * scale;\n    }\n    flush(i);\n    this.addContent('ET');\n    this.restore();\n  }\n};\n\nconst MARKERS = [0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc8, 0xffc9, 0xffca, 0xffcb, 0xffcc, 0xffcd, 0xffce, 0xffcf];\nconst COLOR_SPACE_MAP = {\n  1: 'DeviceGray',\n  3: 'DeviceRGB',\n  4: 'DeviceCMYK'\n};\nclass JPEG {\n  constructor(data, label) {\n    let marker;\n    this.data = data;\n    this.label = label;\n    if (this.data.readUInt16BE(0) !== 0xffd8) {\n      throw 'SOI not found in JPEG';\n    }\n    this.orientation = jpeg_exif__WEBPACK_IMPORTED_MODULE_7__.fromBuffer(this.data).Orientation || 1;\n    let pos = 2;\n    while (pos < this.data.length) {\n      marker = this.data.readUInt16BE(pos);\n      pos += 2;\n      if (MARKERS.includes(marker)) {\n        break;\n      }\n      pos += this.data.readUInt16BE(pos);\n    }\n    if (!MARKERS.includes(marker)) {\n      throw 'Invalid JPEG.';\n    }\n    pos += 2;\n    this.bits = this.data[pos++];\n    this.height = this.data.readUInt16BE(pos);\n    pos += 2;\n    this.width = this.data.readUInt16BE(pos);\n    pos += 2;\n    const channels = this.data[pos++];\n    this.colorSpace = COLOR_SPACE_MAP[channels];\n    this.obj = null;\n  }\n  embed(document) {\n    if (this.obj) {\n      return;\n    }\n    this.obj = document.ref({\n      Type: 'XObject',\n      Subtype: 'Image',\n      BitsPerComponent: this.bits,\n      Width: this.width,\n      Height: this.height,\n      ColorSpace: this.colorSpace,\n      Filter: 'DCTDecode'\n    });\n    if (this.colorSpace === 'DeviceCMYK') {\n      this.obj.data['Decode'] = [1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0];\n    }\n    this.obj.end(this.data);\n    return this.data = null;\n  }\n}\n\nclass PNGImage {\n  constructor(data, label) {\n    this.label = label;\n    this.image = new (png_js__WEBPACK_IMPORTED_MODULE_8___default())(data);\n    this.width = this.image.width;\n    this.height = this.image.height;\n    this.imgData = this.image.imgData;\n    this.obj = null;\n  }\n  embed(document) {\n    let dataDecoded = false;\n    this.document = document;\n    if (this.obj) {\n      return;\n    }\n    const hasAlphaChannel = this.image.hasAlphaChannel;\n    const isInterlaced = this.image.interlaceMethod === 1;\n    this.obj = this.document.ref({\n      Type: 'XObject',\n      Subtype: 'Image',\n      BitsPerComponent: hasAlphaChannel ? 8 : this.image.bits,\n      Width: this.width,\n      Height: this.height,\n      Filter: 'FlateDecode'\n    });\n    if (!hasAlphaChannel) {\n      const params = this.document.ref({\n        Predictor: isInterlaced ? 1 : 15,\n        Colors: this.image.colors,\n        BitsPerComponent: this.image.bits,\n        Columns: this.width\n      });\n      this.obj.data['DecodeParms'] = params;\n      params.end();\n    }\n    if (this.image.palette.length === 0) {\n      this.obj.data['ColorSpace'] = this.image.colorSpace;\n    } else {\n      const palette = this.document.ref();\n      palette.end(Buffer.from(this.image.palette));\n      this.obj.data['ColorSpace'] = ['Indexed', 'DeviceRGB', this.image.palette.length / 3 - 1, palette];\n    }\n    if (this.image.transparency.grayscale != null) {\n      const val = this.image.transparency.grayscale;\n      this.obj.data['Mask'] = [val, val];\n    } else if (this.image.transparency.rgb) {\n      const {\n        rgb\n      } = this.image.transparency;\n      const mask = [];\n      for (let x of rgb) {\n        mask.push(x, x);\n      }\n      this.obj.data['Mask'] = mask;\n    } else if (this.image.transparency.indexed) {\n      dataDecoded = true;\n      return this.loadIndexedAlphaChannel();\n    } else if (hasAlphaChannel) {\n      dataDecoded = true;\n      return this.splitAlphaChannel();\n    }\n    if (isInterlaced && !dataDecoded) {\n      return this.decodeData();\n    }\n    this.finalize();\n  }\n  finalize() {\n    if (this.alphaChannel) {\n      const sMask = this.document.ref({\n        Type: 'XObject',\n        Subtype: 'Image',\n        Height: this.height,\n        Width: this.width,\n        BitsPerComponent: 8,\n        Filter: 'FlateDecode',\n        ColorSpace: 'DeviceGray',\n        Decode: [0, 1]\n      });\n      sMask.end(this.alphaChannel);\n      this.obj.data['SMask'] = sMask;\n    }\n    this.obj.end(this.imgData);\n    this.image = null;\n    return this.imgData = null;\n  }\n  splitAlphaChannel() {\n    return this.image.decodePixels(pixels => {\n      let a, p;\n      const colorCount = this.image.colors;\n      const pixelCount = this.width * this.height;\n      const imgData = Buffer.alloc(pixelCount * colorCount);\n      const alphaChannel = Buffer.alloc(pixelCount);\n      let i = p = a = 0;\n      const len = pixels.length;\n      const skipByteCount = this.image.bits === 16 ? 1 : 0;\n      while (i < len) {\n        for (let colorIndex = 0; colorIndex < colorCount; colorIndex++) {\n          imgData[p++] = pixels[i++];\n          i += skipByteCount;\n        }\n        alphaChannel[a++] = pixels[i++];\n        i += skipByteCount;\n      }\n      this.imgData = zlib__WEBPACK_IMPORTED_MODULE_1___default().deflateSync(imgData);\n      this.alphaChannel = zlib__WEBPACK_IMPORTED_MODULE_1___default().deflateSync(alphaChannel);\n      return this.finalize();\n    });\n  }\n  loadIndexedAlphaChannel() {\n    const transparency = this.image.transparency.indexed;\n    return this.image.decodePixels(pixels => {\n      const alphaChannel = Buffer.alloc(this.width * this.height);\n      let i = 0;\n      for (let j = 0, end = pixels.length; j < end; j++) {\n        alphaChannel[i++] = transparency[pixels[j]];\n      }\n      this.alphaChannel = zlib__WEBPACK_IMPORTED_MODULE_1___default().deflateSync(alphaChannel);\n      return this.finalize();\n    });\n  }\n  decodeData() {\n    this.image.decodePixels(pixels => {\n      this.imgData = zlib__WEBPACK_IMPORTED_MODULE_1___default().deflateSync(pixels);\n      this.finalize();\n    });\n  }\n}\n\nclass PDFImage {\n  static open(src, label) {\n    let data;\n    if (Buffer.isBuffer(src)) {\n      data = src;\n    } else if (src instanceof ArrayBuffer) {\n      data = Buffer.from(new Uint8Array(src));\n    } else {\n      const match = /^data:.+?;base64,(.*)$/.exec(src);\n      if (match) {\n        data = Buffer.from(match[1], 'base64');\n      } else {\n        data = fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(src);\n        if (!data) {\n          return;\n        }\n      }\n    }\n    if (data[0] === 0xff && data[1] === 0xd8) {\n      return new JPEG(data, label);\n    } else if (data[0] === 0x89 && data.toString('ascii', 1, 4) === 'PNG') {\n      return new PNGImage(data, label);\n    } else {\n      throw new Error('Unknown image format.');\n    }\n  }\n}\n\nvar ImagesMixin = {\n  initImages() {\n    this._imageRegistry = {};\n    this._imageCount = 0;\n  },\n  image(src, x, y) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let bh, bp, bw, image, ip, left, left1, originX, originY;\n    if (typeof x === 'object') {\n      options = x;\n      x = null;\n    }\n    const ignoreOrientation = options.ignoreOrientation || options.ignoreOrientation !== false && this.options.ignoreOrientation;\n    const inDocumentFlow = typeof y !== 'number';\n    x = (left = x != null ? x : options.x) != null ? left : this.x;\n    y = (left1 = y != null ? y : options.y) != null ? left1 : this.y;\n    if (typeof src === 'string') {\n      image = this._imageRegistry[src];\n    }\n    if (!image) {\n      if (src.width && src.height) {\n        image = src;\n      } else {\n        image = this.openImage(src);\n      }\n    }\n    if (!image.obj) {\n      image.embed(this);\n    }\n    if (this.page.xobjects[image.label] == null) {\n      this.page.xobjects[image.label] = image.obj;\n    }\n    let {\n      width,\n      height\n    } = image;\n    if (!ignoreOrientation && image.orientation > 4) {\n      [width, height] = [height, width];\n    }\n    let w = options.width || width;\n    let h = options.height || height;\n    if (options.width && !options.height) {\n      const wp = w / width;\n      w = width * wp;\n      h = height * wp;\n    } else if (options.height && !options.width) {\n      const hp = h / height;\n      w = width * hp;\n      h = height * hp;\n    } else if (options.scale) {\n      w = width * options.scale;\n      h = height * options.scale;\n    } else if (options.fit) {\n      [bw, bh] = options.fit;\n      bp = bw / bh;\n      ip = width / height;\n      if (ip > bp) {\n        w = bw;\n        h = bw / ip;\n      } else {\n        h = bh;\n        w = bh * ip;\n      }\n    } else if (options.cover) {\n      [bw, bh] = options.cover;\n      bp = bw / bh;\n      ip = width / height;\n      if (ip > bp) {\n        h = bh;\n        w = bh * ip;\n      } else {\n        w = bw;\n        h = bw / ip;\n      }\n    }\n    if (options.fit || options.cover) {\n      if (options.align === 'center') {\n        x = x + bw / 2 - w / 2;\n      } else if (options.align === 'right') {\n        x = x + bw - w;\n      }\n      if (options.valign === 'center') {\n        y = y + bh / 2 - h / 2;\n      } else if (options.valign === 'bottom') {\n        y = y + bh - h;\n      }\n    }\n    let rotateAngle = 0;\n    let xTransform = x;\n    let yTransform = y;\n    let hTransform = h;\n    let wTransform = w;\n    if (!ignoreOrientation) {\n      switch (image.orientation) {\n        default:\n        case 1:\n          hTransform = -h;\n          yTransform += h;\n          break;\n        case 2:\n          wTransform = -w;\n          hTransform = -h;\n          xTransform += w;\n          yTransform += h;\n          break;\n        case 3:\n          originX = x;\n          originY = y;\n          hTransform = -h;\n          xTransform -= w;\n          rotateAngle = 180;\n          break;\n        case 4:\n          break;\n        case 5:\n          originX = x;\n          originY = y;\n          wTransform = h;\n          hTransform = w;\n          yTransform -= hTransform;\n          rotateAngle = 90;\n          break;\n        case 6:\n          originX = x;\n          originY = y;\n          wTransform = h;\n          hTransform = -w;\n          rotateAngle = 90;\n          break;\n        case 7:\n          originX = x;\n          originY = y;\n          hTransform = -w;\n          wTransform = -h;\n          xTransform += h;\n          rotateAngle = 90;\n          break;\n        case 8:\n          originX = x;\n          originY = y;\n          wTransform = h;\n          hTransform = -w;\n          xTransform -= h;\n          yTransform += w;\n          rotateAngle = -90;\n          break;\n      }\n    } else {\n      hTransform = -h;\n      yTransform += h;\n    }\n    if (options.link != null) {\n      this.link(x, y, w, h, options.link);\n    }\n    if (options.goTo != null) {\n      this.goTo(x, y, w, h, options.goTo);\n    }\n    if (options.destination != null) {\n      this.addNamedDestination(options.destination, 'XYZ', x, y, null);\n    }\n    if (inDocumentFlow) {\n      this.y += h;\n    }\n    this.save();\n    if (rotateAngle) {\n      this.rotate(rotateAngle, {\n        origin: [originX, originY]\n      });\n    }\n    this.transform(wTransform, 0, 0, hTransform, xTransform, yTransform);\n    this.addContent(`/${image.label} Do`);\n    this.restore();\n    return this;\n  },\n  openImage(src) {\n    let image;\n    if (typeof src === 'string') {\n      image = this._imageRegistry[src];\n    }\n    if (!image) {\n      image = PDFImage.open(src, `I${++this._imageCount}`);\n      if (typeof src === 'string') {\n        this._imageRegistry[src] = image;\n      }\n    }\n    return image;\n  }\n};\n\nvar AnnotationsMixin = {\n  annotate(x, y, w, h, options) {\n    options.Type = 'Annot';\n    options.Rect = this._convertRect(x, y, w, h);\n    options.Border = [0, 0, 0];\n    if (options.Subtype === 'Link' && typeof options.F === 'undefined') {\n      options.F = 1 << 2;\n    }\n    if (options.Subtype !== 'Link') {\n      if (options.C == null) {\n        options.C = this._normalizeColor(options.color || [0, 0, 0]);\n      }\n    }\n    delete options.color;\n    if (typeof options.Dest === 'string') {\n      options.Dest = new String(options.Dest);\n    }\n    for (let key in options) {\n      const val = options[key];\n      options[key[0].toUpperCase() + key.slice(1)] = val;\n    }\n    const ref = this.ref(options);\n    this.page.annotations.push(ref);\n    ref.end();\n    return this;\n  },\n  note(x, y, w, h, contents) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    options.Subtype = 'Text';\n    options.Contents = new String(contents);\n    if (options.Name == null) {\n      options.Name = 'Comment';\n    }\n    if (options.color == null) {\n      options.color = [243, 223, 92];\n    }\n    return this.annotate(x, y, w, h, options);\n  },\n  goTo(x, y, w, h, name) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    options.Subtype = 'Link';\n    options.A = this.ref({\n      S: 'GoTo',\n      D: new String(name)\n    });\n    options.A.end();\n    return this.annotate(x, y, w, h, options);\n  },\n  link(x, y, w, h, url) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    options.Subtype = 'Link';\n    if (typeof url === 'number') {\n      const pages = this._root.data.Pages.data;\n      if (url >= 0 && url < pages.Kids.length) {\n        options.A = this.ref({\n          S: 'GoTo',\n          D: [pages.Kids[url], 'XYZ', null, null, null]\n        });\n        options.A.end();\n      } else {\n        throw new Error(`The document has no page ${url}`);\n      }\n    } else {\n      options.A = this.ref({\n        S: 'URI',\n        URI: new String(url)\n      });\n      options.A.end();\n    }\n    return this.annotate(x, y, w, h, options);\n  },\n  _markup(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    const [x1, y1, x2, y2] = this._convertRect(x, y, w, h);\n    options.QuadPoints = [x1, y2, x2, y2, x1, y1, x2, y1];\n    options.Contents = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n  highlight(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Highlight';\n    if (options.color == null) {\n      options.color = [241, 238, 148];\n    }\n    return this._markup(x, y, w, h, options);\n  },\n  underline(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Underline';\n    return this._markup(x, y, w, h, options);\n  },\n  strike(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'StrikeOut';\n    return this._markup(x, y, w, h, options);\n  },\n  lineAnnotation(x1, y1, x2, y2) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Line';\n    options.Contents = new String();\n    options.L = [x1, this.page.height - y1, x2, this.page.height - y2];\n    return this.annotate(x1, y1, x2, y2, options);\n  },\n  rectAnnotation(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Square';\n    options.Contents = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n  ellipseAnnotation(x, y, w, h) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Circle';\n    options.Contents = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n  textAnnotation(x, y, w, h, text) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    options.Subtype = 'FreeText';\n    options.Contents = new String(text);\n    options.DA = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n  fileAnnotation(x, y, w, h) {\n    let file = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    const filespec = this.file(file.src, Object.assign({\n      hidden: true\n    }, file));\n    options.Subtype = 'FileAttachment';\n    options.FS = filespec;\n    if (options.Contents) {\n      options.Contents = new String(options.Contents);\n    } else if (filespec.data.Desc) {\n      options.Contents = filespec.data.Desc;\n    }\n    return this.annotate(x, y, w, h, options);\n  },\n  _convertRect(x1, y1, w, h) {\n    let y2 = y1;\n    y1 += h;\n    let x2 = x1 + w;\n    const [m0, m1, m2, m3, m4, m5] = this._ctm;\n    x1 = m0 * x1 + m2 * y1 + m4;\n    y1 = m1 * x1 + m3 * y1 + m5;\n    x2 = m0 * x2 + m2 * y2 + m4;\n    y2 = m1 * x2 + m3 * y2 + m5;\n    return [x1, y1, x2, y2];\n  }\n};\n\nclass PDFOutline {\n  constructor(document, parent, title, dest) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      expanded: false\n    };\n    this.document = document;\n    this.options = options;\n    this.outlineData = {};\n    if (dest !== null) {\n      this.outlineData['Dest'] = [dest.dictionary, 'Fit'];\n    }\n    if (parent !== null) {\n      this.outlineData['Parent'] = parent;\n    }\n    if (title !== null) {\n      this.outlineData['Title'] = new String(title);\n    }\n    this.dictionary = this.document.ref(this.outlineData);\n    this.children = [];\n  }\n  addItem(title) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      expanded: false\n    };\n    const result = new PDFOutline(this.document, this.dictionary, title, this.document.page, options);\n    this.children.push(result);\n    return result;\n  }\n  endOutline() {\n    if (this.children.length > 0) {\n      if (this.options.expanded) {\n        this.outlineData.Count = this.children.length;\n      }\n      const first = this.children[0],\n        last = this.children[this.children.length - 1];\n      this.outlineData.First = first.dictionary;\n      this.outlineData.Last = last.dictionary;\n      for (let i = 0, len = this.children.length; i < len; i++) {\n        const child = this.children[i];\n        if (i > 0) {\n          child.outlineData.Prev = this.children[i - 1].dictionary;\n        }\n        if (i < this.children.length - 1) {\n          child.outlineData.Next = this.children[i + 1].dictionary;\n        }\n        child.endOutline();\n      }\n    }\n    return this.dictionary.end();\n  }\n}\n\nvar OutlineMixin = {\n  initOutline() {\n    this.outline = new PDFOutline(this, null, null, null);\n  },\n  endOutline() {\n    this.outline.endOutline();\n    if (this.outline.children.length > 0) {\n      this._root.data.Outlines = this.outline.dictionary;\n      return this._root.data.PageMode = 'UseOutlines';\n    }\n  }\n};\n\nclass PDFStructureContent {\n  constructor(pageRef, mcid) {\n    this.refs = [{\n      pageRef,\n      mcid\n    }];\n  }\n  push(structContent) {\n    structContent.refs.forEach(ref => this.refs.push(ref));\n  }\n}\n\nclass PDFStructureElement {\n  constructor(document, type) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    this.document = document;\n    this._attached = false;\n    this._ended = false;\n    this._flushed = false;\n    this.dictionary = document.ref({\n      S: type\n    });\n    const data = this.dictionary.data;\n    if (Array.isArray(options) || this._isValidChild(options)) {\n      children = options;\n      options = {};\n    }\n    if (typeof options.title !== 'undefined') {\n      data.T = new String(options.title);\n    }\n    if (typeof options.lang !== 'undefined') {\n      data.Lang = new String(options.lang);\n    }\n    if (typeof options.alt !== 'undefined') {\n      data.Alt = new String(options.alt);\n    }\n    if (typeof options.expanded !== 'undefined') {\n      data.E = new String(options.expanded);\n    }\n    if (typeof options.actual !== 'undefined') {\n      data.ActualText = new String(options.actual);\n    }\n    this._children = [];\n    if (children) {\n      if (!Array.isArray(children)) {\n        children = [children];\n      }\n      children.forEach(child => this.add(child));\n      this.end();\n    }\n  }\n  add(child) {\n    if (this._ended) {\n      throw new Error(`Cannot add child to already-ended structure element`);\n    }\n    if (!this._isValidChild(child)) {\n      throw new Error(`Invalid structure element child`);\n    }\n    if (child instanceof PDFStructureElement) {\n      child.setParent(this.dictionary);\n      if (this._attached) {\n        child.setAttached();\n      }\n    }\n    if (child instanceof PDFStructureContent) {\n      this._addContentToParentTree(child);\n    }\n    if (typeof child === 'function' && this._attached) {\n      child = this._contentForClosure(child);\n    }\n    this._children.push(child);\n    return this;\n  }\n  _addContentToParentTree(content) {\n    content.refs.forEach(_ref => {\n      let {\n        pageRef,\n        mcid\n      } = _ref;\n      const pageStructParents = this.document.getStructParentTree().get(pageRef.data.StructParents);\n      pageStructParents[mcid] = this.dictionary;\n    });\n  }\n  setParent(parentRef) {\n    if (this.dictionary.data.P) {\n      throw new Error(`Structure element added to more than one parent`);\n    }\n    this.dictionary.data.P = parentRef;\n    this._flush();\n  }\n  setAttached() {\n    if (this._attached) {\n      return;\n    }\n    this._children.forEach((child, index) => {\n      if (child instanceof PDFStructureElement) {\n        child.setAttached();\n      }\n      if (typeof child === 'function') {\n        this._children[index] = this._contentForClosure(child);\n      }\n    });\n    this._attached = true;\n    this._flush();\n  }\n  end() {\n    if (this._ended) {\n      return;\n    }\n    this._children.filter(child => child instanceof PDFStructureElement).forEach(child => child.end());\n    this._ended = true;\n    this._flush();\n  }\n  _isValidChild(child) {\n    return child instanceof PDFStructureElement || child instanceof PDFStructureContent || typeof child === 'function';\n  }\n  _contentForClosure(closure) {\n    const content = this.document.markStructureContent(this.dictionary.data.S);\n    closure();\n    this.document.endMarkedContent();\n    this._addContentToParentTree(content);\n    return content;\n  }\n  _isFlushable() {\n    if (!this.dictionary.data.P || !this._ended) {\n      return false;\n    }\n    return this._children.every(child => {\n      if (typeof child === 'function') {\n        return false;\n      }\n      if (child instanceof PDFStructureElement) {\n        return child._isFlushable();\n      }\n      return true;\n    });\n  }\n  _flush() {\n    if (this._flushed || !this._isFlushable()) {\n      return;\n    }\n    this.dictionary.data.K = [];\n    this._children.forEach(child => this._flushChild(child));\n    this.dictionary.end();\n    this._children = [];\n    this.dictionary.data.K = null;\n    this._flushed = true;\n  }\n  _flushChild(child) {\n    if (child instanceof PDFStructureElement) {\n      this.dictionary.data.K.push(child.dictionary);\n    }\n    if (child instanceof PDFStructureContent) {\n      child.refs.forEach(_ref2 => {\n        let {\n          pageRef,\n          mcid\n        } = _ref2;\n        if (!this.dictionary.data.Pg) {\n          this.dictionary.data.Pg = pageRef;\n        }\n        if (this.dictionary.data.Pg === pageRef) {\n          this.dictionary.data.K.push(mcid);\n        } else {\n          this.dictionary.data.K.push({\n            Type: 'MCR',\n            Pg: pageRef,\n            MCID: mcid\n          });\n        }\n      });\n    }\n  }\n}\n\nclass PDFNumberTree extends PDFTree {\n  _compareKeys(a, b) {\n    return parseInt(a) - parseInt(b);\n  }\n  _keysName() {\n    return 'Nums';\n  }\n  _dataForKey(k) {\n    return parseInt(k);\n  }\n}\n\nvar MarkingsMixin = {\n  initMarkings(options) {\n    this.structChildren = [];\n    if (options.tagged) {\n      this.getMarkInfoDictionary().data.Marked = true;\n      this.getStructTreeRoot();\n    }\n  },\n  markContent(tag) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (tag === 'Artifact' || options && options.mcid) {\n      let toClose = 0;\n      this.page.markings.forEach(marking => {\n        if (toClose || marking.structContent || marking.tag === 'Artifact') {\n          toClose++;\n        }\n      });\n      while (toClose--) {\n        this.endMarkedContent();\n      }\n    }\n    if (!options) {\n      this.page.markings.push({\n        tag\n      });\n      this.addContent(`/${tag} BMC`);\n      return this;\n    }\n    this.page.markings.push({\n      tag,\n      options\n    });\n    const dictionary = {};\n    if (typeof options.mcid !== 'undefined') {\n      dictionary.MCID = options.mcid;\n    }\n    if (tag === 'Artifact') {\n      if (typeof options.type === 'string') {\n        dictionary.Type = options.type;\n      }\n      if (Array.isArray(options.bbox)) {\n        dictionary.BBox = [options.bbox[0], this.page.height - options.bbox[3], options.bbox[2], this.page.height - options.bbox[1]];\n      }\n      if (Array.isArray(options.attached) && options.attached.every(val => typeof val === 'string')) {\n        dictionary.Attached = options.attached;\n      }\n    }\n    if (tag === 'Span') {\n      if (options.lang) {\n        dictionary.Lang = new String(options.lang);\n      }\n      if (options.alt) {\n        dictionary.Alt = new String(options.alt);\n      }\n      if (options.expanded) {\n        dictionary.E = new String(options.expanded);\n      }\n      if (options.actual) {\n        dictionary.ActualText = new String(options.actual);\n      }\n    }\n    this.addContent(`/${tag} ${PDFObject.convert(dictionary)} BDC`);\n    return this;\n  },\n  markStructureContent(tag) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const pageStructParents = this.getStructParentTree().get(this.page.structParentTreeKey);\n    const mcid = pageStructParents.length;\n    pageStructParents.push(null);\n    this.markContent(tag, {\n      ...options,\n      mcid\n    });\n    const structContent = new PDFStructureContent(this.page.dictionary, mcid);\n    this.page.markings.slice(-1)[0].structContent = structContent;\n    return structContent;\n  },\n  endMarkedContent() {\n    this.page.markings.pop();\n    this.addContent('EMC');\n    return this;\n  },\n  struct(type) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return new PDFStructureElement(this, type, options, children);\n  },\n  addStructure(structElem) {\n    const structTreeRoot = this.getStructTreeRoot();\n    structElem.setParent(structTreeRoot);\n    structElem.setAttached();\n    this.structChildren.push(structElem);\n    if (!structTreeRoot.data.K) {\n      structTreeRoot.data.K = [];\n    }\n    structTreeRoot.data.K.push(structElem.dictionary);\n    return this;\n  },\n  initPageMarkings(pageMarkings) {\n    pageMarkings.forEach(marking => {\n      if (marking.structContent) {\n        const structContent = marking.structContent;\n        const newStructContent = this.markStructureContent(marking.tag, marking.options);\n        structContent.push(newStructContent);\n        this.page.markings.slice(-1)[0].structContent = structContent;\n      } else {\n        this.markContent(marking.tag, marking.options);\n      }\n    });\n  },\n  endPageMarkings(page) {\n    const pageMarkings = page.markings;\n    pageMarkings.forEach(() => page.write('EMC'));\n    page.markings = [];\n    return pageMarkings;\n  },\n  getMarkInfoDictionary() {\n    if (!this._root.data.MarkInfo) {\n      this._root.data.MarkInfo = this.ref({});\n    }\n    return this._root.data.MarkInfo;\n  },\n  hasMarkInfoDictionary() {\n    return !!this._root.data.MarkInfo;\n  },\n  getStructTreeRoot() {\n    if (!this._root.data.StructTreeRoot) {\n      this._root.data.StructTreeRoot = this.ref({\n        Type: 'StructTreeRoot',\n        ParentTree: new PDFNumberTree(),\n        ParentTreeNextKey: 0\n      });\n    }\n    return this._root.data.StructTreeRoot;\n  },\n  getStructParentTree() {\n    return this.getStructTreeRoot().data.ParentTree;\n  },\n  createStructParentTreeNextKey() {\n    this.getMarkInfoDictionary();\n    const structTreeRoot = this.getStructTreeRoot();\n    const key = structTreeRoot.data.ParentTreeNextKey++;\n    structTreeRoot.data.ParentTree.add(key, []);\n    return key;\n  },\n  endMarkings() {\n    const structTreeRoot = this._root.data.StructTreeRoot;\n    if (structTreeRoot) {\n      structTreeRoot.end();\n      this.structChildren.forEach(structElem => structElem.end());\n    }\n    if (this._root.data.MarkInfo) {\n      this._root.data.MarkInfo.end();\n    }\n  }\n};\n\nconst FIELD_FLAGS = {\n  readOnly: 1,\n  required: 2,\n  noExport: 4,\n  multiline: 0x1000,\n  password: 0x2000,\n  toggleToOffButton: 0x4000,\n  radioButton: 0x8000,\n  pushButton: 0x10000,\n  combo: 0x20000,\n  edit: 0x40000,\n  sort: 0x80000,\n  multiSelect: 0x200000,\n  noSpell: 0x400000\n};\nconst FIELD_JUSTIFY = {\n  left: 0,\n  center: 1,\n  right: 2\n};\nconst VALUE_MAP = {\n  value: 'V',\n  defaultValue: 'DV'\n};\nconst FORMAT_SPECIAL = {\n  zip: '0',\n  zipPlus4: '1',\n  zip4: '1',\n  phone: '2',\n  ssn: '3'\n};\nconst FORMAT_DEFAULT = {\n  number: {\n    nDec: 0,\n    sepComma: false,\n    negStyle: 'MinusBlack',\n    currency: '',\n    currencyPrepend: true\n  },\n  percent: {\n    nDec: 0,\n    sepComma: false\n  }\n};\nvar AcroFormMixin = {\n  initForm() {\n    if (!this._font) {\n      throw new Error('Must set a font before calling initForm method');\n    }\n    this._acroform = {\n      fonts: {},\n      defaultFont: this._font.name\n    };\n    this._acroform.fonts[this._font.id] = this._font.ref();\n    let data = {\n      Fields: [],\n      NeedAppearances: true,\n      DA: new String(`/${this._font.id} 0 Tf 0 g`),\n      DR: {\n        Font: {}\n      }\n    };\n    data.DR.Font[this._font.id] = this._font.ref();\n    const AcroForm = this.ref(data);\n    this._root.data.AcroForm = AcroForm;\n    return this;\n  },\n  endAcroForm() {\n    if (this._root.data.AcroForm) {\n      if (!Object.keys(this._acroform.fonts).length && !this._acroform.defaultFont) {\n        throw new Error('No fonts specified for PDF form');\n      }\n      let fontDict = this._root.data.AcroForm.data.DR.Font;\n      Object.keys(this._acroform.fonts).forEach(name => {\n        fontDict[name] = this._acroform.fonts[name];\n      });\n      this._root.data.AcroForm.data.Fields.forEach(fieldRef => {\n        this._endChild(fieldRef);\n      });\n      this._root.data.AcroForm.end();\n    }\n    return this;\n  },\n  _endChild(ref) {\n    if (Array.isArray(ref.data.Kids)) {\n      ref.data.Kids.forEach(childRef => {\n        this._endChild(childRef);\n      });\n      ref.end();\n    }\n    return this;\n  },\n  formField(name) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let fieldDict = this._fieldDict(name, null, options);\n    let fieldRef = this.ref(fieldDict);\n    this._addToParent(fieldRef);\n    return fieldRef;\n  },\n  formAnnotation(name, type, x, y, w, h) {\n    let options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n    let fieldDict = this._fieldDict(name, type, options);\n    fieldDict.Subtype = 'Widget';\n    if (fieldDict.F === undefined) {\n      fieldDict.F = 4;\n    }\n    this.annotate(x, y, w, h, fieldDict);\n    let annotRef = this.page.annotations[this.page.annotations.length - 1];\n    return this._addToParent(annotRef);\n  },\n  formText(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'text', x, y, w, h, options);\n  },\n  formPushButton(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'pushButton', x, y, w, h, options);\n  },\n  formCombo(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'combo', x, y, w, h, options);\n  },\n  formList(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'list', x, y, w, h, options);\n  },\n  formRadioButton(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'radioButton', x, y, w, h, options);\n  },\n  formCheckbox(name, x, y, w, h) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'checkbox', x, y, w, h, options);\n  },\n  _addToParent(fieldRef) {\n    let parent = fieldRef.data.Parent;\n    if (parent) {\n      if (!parent.data.Kids) {\n        parent.data.Kids = [];\n      }\n      parent.data.Kids.push(fieldRef);\n    } else {\n      this._root.data.AcroForm.data.Fields.push(fieldRef);\n    }\n    return this;\n  },\n  _fieldDict(name, type) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!this._acroform) {\n      throw new Error('Call document.initForm() method before adding form elements to document');\n    }\n    let opts = Object.assign({}, options);\n    if (type !== null) {\n      opts = this._resolveType(type, options);\n    }\n    opts = this._resolveFlags(opts);\n    opts = this._resolveJustify(opts);\n    opts = this._resolveFont(opts);\n    opts = this._resolveStrings(opts);\n    opts = this._resolveColors(opts);\n    opts = this._resolveFormat(opts);\n    opts.T = new String(name);\n    if (opts.parent) {\n      opts.Parent = opts.parent;\n      delete opts.parent;\n    }\n    return opts;\n  },\n  _resolveType(type, opts) {\n    if (type === 'text') {\n      opts.FT = 'Tx';\n    } else if (type === 'pushButton') {\n      opts.FT = 'Btn';\n      opts.pushButton = true;\n    } else if (type === 'radioButton') {\n      opts.FT = 'Btn';\n      opts.radioButton = true;\n    } else if (type === 'checkbox') {\n      opts.FT = 'Btn';\n    } else if (type === 'combo') {\n      opts.FT = 'Ch';\n      opts.combo = true;\n    } else if (type === 'list') {\n      opts.FT = 'Ch';\n    } else {\n      throw new Error(`Invalid form annotation type '${type}'`);\n    }\n    return opts;\n  },\n  _resolveFormat(opts) {\n    const f = opts.format;\n    if (f && f.type) {\n      let fnKeystroke;\n      let fnFormat;\n      let params = '';\n      if (FORMAT_SPECIAL[f.type] !== undefined) {\n        fnKeystroke = `AFSpecial_Keystroke`;\n        fnFormat = `AFSpecial_Format`;\n        params = FORMAT_SPECIAL[f.type];\n      } else {\n        let format = f.type.charAt(0).toUpperCase() + f.type.slice(1);\n        fnKeystroke = `AF${format}_Keystroke`;\n        fnFormat = `AF${format}_Format`;\n        if (f.type === 'date') {\n          fnKeystroke += 'Ex';\n          params = String(f.param);\n        } else if (f.type === 'time') {\n          params = String(f.param);\n        } else if (f.type === 'number') {\n          let p = Object.assign({}, FORMAT_DEFAULT.number, f);\n          params = String([String(p.nDec), p.sepComma ? '0' : '1', '\"' + p.negStyle + '\"', 'null', '\"' + p.currency + '\"', String(p.currencyPrepend)].join(','));\n        } else if (f.type === 'percent') {\n          let p = Object.assign({}, FORMAT_DEFAULT.percent, f);\n          params = String([String(p.nDec), p.sepComma ? '0' : '1'].join(','));\n        }\n      }\n      opts.AA = opts.AA ? opts.AA : {};\n      opts.AA.K = {\n        S: 'JavaScript',\n        JS: new String(`${fnKeystroke}(${params});`)\n      };\n      opts.AA.F = {\n        S: 'JavaScript',\n        JS: new String(`${fnFormat}(${params});`)\n      };\n    }\n    delete opts.format;\n    return opts;\n  },\n  _resolveColors(opts) {\n    let color = this._normalizeColor(opts.backgroundColor);\n    if (color) {\n      if (!opts.MK) {\n        opts.MK = {};\n      }\n      opts.MK.BG = color;\n    }\n    color = this._normalizeColor(opts.borderColor);\n    if (color) {\n      if (!opts.MK) {\n        opts.MK = {};\n      }\n      opts.MK.BC = color;\n    }\n    delete opts.backgroundColor;\n    delete opts.borderColor;\n    return opts;\n  },\n  _resolveFlags(options) {\n    let result = 0;\n    Object.keys(options).forEach(key => {\n      if (FIELD_FLAGS[key]) {\n        if (options[key]) {\n          result |= FIELD_FLAGS[key];\n        }\n        delete options[key];\n      }\n    });\n    if (result !== 0) {\n      options.Ff = options.Ff ? options.Ff : 0;\n      options.Ff |= result;\n    }\n    return options;\n  },\n  _resolveJustify(options) {\n    let result = 0;\n    if (options.align !== undefined) {\n      if (typeof FIELD_JUSTIFY[options.align] === 'number') {\n        result = FIELD_JUSTIFY[options.align];\n      }\n      delete options.align;\n    }\n    if (result !== 0) {\n      options.Q = result;\n    }\n    return options;\n  },\n  _resolveFont(options) {\n    if (this._acroform.fonts[this._font.id] == null) {\n      this._acroform.fonts[this._font.id] = this._font.ref();\n    }\n    if (this._acroform.defaultFont !== this._font.name) {\n      options.DR = {\n        Font: {}\n      };\n      const fontSize = options.fontSize || 0;\n      options.DR.Font[this._font.id] = this._font.ref();\n      options.DA = new String(`/${this._font.id} ${fontSize} Tf 0 g`);\n    }\n    return options;\n  },\n  _resolveStrings(options) {\n    let select = [];\n    function appendChoices(a) {\n      if (Array.isArray(a)) {\n        for (let idx = 0; idx < a.length; idx++) {\n          if (typeof a[idx] === 'string') {\n            select.push(new String(a[idx]));\n          } else {\n            select.push(a[idx]);\n          }\n        }\n      }\n    }\n    appendChoices(options.Opt);\n    if (options.select) {\n      appendChoices(options.select);\n      delete options.select;\n    }\n    if (select.length) {\n      options.Opt = select;\n    }\n    Object.keys(VALUE_MAP).forEach(key => {\n      if (options[key] !== undefined) {\n        options[VALUE_MAP[key]] = options[key];\n        delete options[key];\n      }\n    });\n    ['V', 'DV'].forEach(key => {\n      if (typeof options[key] === 'string') {\n        options[key] = new String(options[key]);\n      }\n    });\n    if (options.MK && options.MK.CA) {\n      options.MK.CA = new String(options.MK.CA);\n    }\n    if (options.label) {\n      options.MK = options.MK ? options.MK : {};\n      options.MK.CA = new String(options.label);\n      delete options.label;\n    }\n    return options;\n  }\n};\n\nvar AttachmentsMixin = {\n  file(src) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options.name = options.name || src;\n    options.relationship = options.relationship || 'Unspecified';\n    const refBody = {\n      Type: 'EmbeddedFile',\n      Params: {}\n    };\n    let data;\n    if (!src) {\n      throw new Error('No src specified');\n    }\n    if (Buffer.isBuffer(src)) {\n      data = src;\n    } else if (src instanceof ArrayBuffer) {\n      data = Buffer.from(new Uint8Array(src));\n    } else {\n      const match = /^data:(.*?);base64,(.*)$/.exec(src);\n      if (match) {\n        if (match[1]) {\n          refBody.Subtype = match[1].replace('/', '#2F');\n        }\n        data = Buffer.from(match[2], 'base64');\n      } else {\n        data = fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(src);\n        if (!data) {\n          throw new Error(`Could not read contents of file at filepath ${src}`);\n        }\n        const {\n          birthtime,\n          ctime\n        } = fs__WEBPACK_IMPORTED_MODULE_3___default().statSync(src);\n        refBody.Params.CreationDate = birthtime;\n        refBody.Params.ModDate = ctime;\n      }\n    }\n    if (options.creationDate instanceof Date) {\n      refBody.Params.CreationDate = options.creationDate;\n    }\n    if (options.modifiedDate instanceof Date) {\n      refBody.Params.ModDate = options.modifiedDate;\n    }\n    if (options.type) {\n      refBody.Subtype = options.type.replace('/', '#2F');\n    }\n    const checksum = crypto_js__WEBPACK_IMPORTED_MODULE_2___default().MD5(crypto_js__WEBPACK_IMPORTED_MODULE_2___default().lib.WordArray.create(new Uint8Array(data)));\n    refBody.Params.CheckSum = new String(checksum);\n    refBody.Params.Size = data.byteLength;\n    let ref;\n    if (!this._fileRegistry) this._fileRegistry = {};\n    let file = this._fileRegistry[options.name];\n    if (file && isEqual(refBody, file)) {\n      ref = file.ref;\n    } else {\n      ref = this.ref(refBody);\n      ref.end(data);\n      this._fileRegistry[options.name] = {\n        ...refBody,\n        ref\n      };\n    }\n    const fileSpecBody = {\n      Type: 'Filespec',\n      AFRelationship: options.relationship,\n      F: new String(options.name),\n      EF: {\n        F: ref\n      },\n      UF: new String(options.name)\n    };\n    if (options.description) {\n      fileSpecBody.Desc = new String(options.description);\n    }\n    const filespec = this.ref(fileSpecBody);\n    filespec.end();\n    if (!options.hidden) {\n      this.addNamedEmbeddedFile(options.name, filespec);\n    }\n    if (this._root.data.AF) {\n      this._root.data.AF.push(filespec);\n    } else {\n      this._root.data.AF = [filespec];\n    }\n    return filespec;\n  }\n};\nfunction isEqual(a, b) {\n  return a.Subtype === b.Subtype && a.Params.CheckSum.toString() === b.Params.CheckSum.toString() && a.Params.Size === b.Params.Size && a.Params.CreationDate.getTime() === b.Params.CreationDate.getTime() && (a.Params.ModDate === undefined && b.Params.ModDate === undefined || a.Params.ModDate.getTime() === b.Params.ModDate.getTime());\n}\n\nvar PDFA = {\n  initPDFA(pSubset) {\n    if (pSubset.charAt(pSubset.length - 3) === '-') {\n      this.subset_conformance = pSubset.charAt(pSubset.length - 1).toUpperCase();\n      this.subset = parseInt(pSubset.charAt(pSubset.length - 2));\n    } else {\n      this.subset_conformance = 'B';\n      this.subset = parseInt(pSubset.charAt(pSubset.length - 1));\n    }\n  },\n  endSubset() {\n    this._addPdfaMetadata();\n    this._addColorOutputIntent();\n  },\n  _addColorOutputIntent() {\n    const iccProfile = fs__WEBPACK_IMPORTED_MODULE_3___default().readFileSync(`${__dirname}/data/sRGB_IEC61966_2_1.icc`);\n    const colorProfileRef = this.ref({\n      Length: iccProfile.length,\n      N: 3\n    });\n    colorProfileRef.write(iccProfile);\n    colorProfileRef.end();\n    const intentRef = this.ref({\n      Type: 'OutputIntent',\n      S: 'GTS_PDFA1',\n      Info: new String('sRGB IEC61966-2.1'),\n      OutputConditionIdentifier: new String('sRGB IEC61966-2.1'),\n      DestOutputProfile: colorProfileRef\n    });\n    intentRef.end();\n    this._root.data.OutputIntents = [intentRef];\n  },\n  _getPdfaid() {\n    return `\n        <rdf:Description xmlns:pdfaid=\"http://www.aiim.org/pdfa/ns/id/\" rdf:about=\"\">\n            <pdfaid:part>${this.subset}</pdfaid:part>\n            <pdfaid:conformance>${this.subset_conformance}</pdfaid:conformance>\n        </rdf:Description>\n        `;\n  },\n  _addPdfaMetadata() {\n    this.appendXML(this._getPdfaid());\n  }\n};\n\nvar PDFUA = {\n  initPDFUA() {\n    this.subset = 1;\n  },\n  endSubset() {\n    this._addPdfuaMetadata();\n  },\n  _addPdfuaMetadata() {\n    this.appendXML(this._getPdfuaid());\n  },\n  _getPdfuaid() {\n    return `\n        <rdf:Description xmlns:pdfuaid=\"http://www.aiim.org/pdfua/ns/id/\" rdf:about=\"\">\n            <pdfuaid:part>${this.subset}</pdfuaid:part>\n        </rdf:Description>\n        `;\n  }\n};\n\nvar SubsetMixin = {\n  _importSubset(subset) {\n    Object.assign(this, subset);\n  },\n  initSubset(options) {\n    switch (options.subset) {\n      case 'PDF/A-1':\n      case 'PDF/A-1a':\n      case 'PDF/A-1b':\n      case 'PDF/A-2':\n      case 'PDF/A-2a':\n      case 'PDF/A-2b':\n      case 'PDF/A-3':\n      case 'PDF/A-3a':\n      case 'PDF/A-3b':\n        this._importSubset(PDFA);\n        this.initPDFA(options.subset);\n        break;\n      case 'PDF/UA':\n        this._importSubset(PDFUA);\n        this.initPDFUA();\n        break;\n    }\n  }\n};\n\nconst ROW_FIELDS = ['height', 'minHeight', 'maxHeight'];\nconst COLUMN_FIELDS = ['width', 'minWidth', 'maxWidth'];\nfunction memoize(fn, maxSize) {\n  const cache = new Map();\n  return function () {\n    const key = arguments.length <= 0 ? undefined : arguments[0];\n    if (!cache.has(key)) {\n      cache.set(key, fn(...arguments));\n      if (cache.size > maxSize) cache.delete(cache.keys().next());\n    }\n    return cache.get(key);\n  };\n}\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\nfunction deepMerge(target) {\n  if (!isObject(target)) return target;\n  target = deepClone(target);\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n  for (const source of sources) {\n    if (isObject(source)) {\n      for (const key in source) {\n        if (isObject(source[key])) {\n          if (!(key in target)) target[key] = {};\n          target[key] = deepMerge(target[key], source[key]);\n        } else if (source[key] !== undefined) {\n          target[key] = deepClone(source[key]);\n        }\n      }\n    }\n  }\n  return target;\n}\nfunction deepClone(obj) {\n  let result = obj;\n  if (obj && typeof obj == 'object') {\n    result = Array.isArray(obj) ? [] : {};\n    for (const key in obj) result[key] = deepClone(obj[key]);\n  }\n  return result;\n}\n\nfunction normalizedDefaultStyle(defaultStyleInternal) {\n  let defaultStyle = defaultStyleInternal;\n  if (typeof defaultStyle !== 'object') defaultStyle = {\n    text: defaultStyle\n  };\n  const defaultRowStyle = Object.fromEntries(Object.entries(defaultStyle).filter(_ref => {\n    let [k] = _ref;\n    return ROW_FIELDS.includes(k);\n  }));\n  const defaultColStyle = Object.fromEntries(Object.entries(defaultStyle).filter(_ref2 => {\n    let [k] = _ref2;\n    return COLUMN_FIELDS.includes(k);\n  }));\n  defaultStyle.padding = normalizeSides(defaultStyle.padding);\n  defaultStyle.border = normalizeSides(defaultStyle.border);\n  defaultStyle.borderColor = normalizeSides(defaultStyle.borderColor);\n  defaultStyle.align = normalizeAlignment(defaultStyle.align);\n  return {\n    defaultStyle,\n    defaultRowStyle,\n    defaultColStyle\n  };\n}\nfunction normalizedRowStyle(defaultRowStyle, rowStyleInternal, i) {\n  let rowStyle = rowStyleInternal(i);\n  if (rowStyle == null || typeof rowStyle !== 'object') {\n    rowStyle = {\n      height: rowStyle\n    };\n  }\n  rowStyle.padding = normalizeSides(rowStyle.padding);\n  rowStyle.border = normalizeSides(rowStyle.border);\n  rowStyle.borderColor = normalizeSides(rowStyle.borderColor);\n  rowStyle.align = normalizeAlignment(rowStyle.align);\n  rowStyle = deepMerge(defaultRowStyle, rowStyle);\n  const document = this.document;\n  const page = document.page;\n  const contentHeight = page.contentHeight;\n  if (rowStyle.height == null || rowStyle.height === 'auto') {\n    rowStyle.height = 'auto';\n  } else {\n    rowStyle.height = document.sizeToPoint(rowStyle.height, 0, page, contentHeight);\n  }\n  rowStyle.minHeight = document.sizeToPoint(rowStyle.minHeight, 0, page, contentHeight);\n  rowStyle.maxHeight = document.sizeToPoint(rowStyle.maxHeight, 0, page, contentHeight);\n  return rowStyle;\n}\nfunction normalizedColumnStyle(defaultColStyle, colStyleInternal, i) {\n  let colStyle = colStyleInternal(i);\n  if (colStyle == null || typeof colStyle !== 'object') {\n    colStyle = {\n      width: colStyle\n    };\n  }\n  colStyle.padding = normalizeSides(colStyle.padding);\n  colStyle.border = normalizeSides(colStyle.border);\n  colStyle.borderColor = normalizeSides(colStyle.borderColor);\n  colStyle.align = normalizeAlignment(colStyle.align);\n  colStyle = deepMerge(defaultColStyle, colStyle);\n  if (colStyle.width == null || colStyle.width === '*') {\n    colStyle.width = '*';\n  } else {\n    colStyle.width = this.document.sizeToPoint(colStyle.width, 0, this.document.page, this._maxWidth);\n  }\n  colStyle.minWidth = this.document.sizeToPoint(colStyle.minWidth, 0, this.document.page, this._maxWidth);\n  colStyle.maxWidth = this.document.sizeToPoint(colStyle.maxWidth, 0, this.document.page, this._maxWidth);\n  return colStyle;\n}\nfunction normalizeAlignment(align) {\n  return align == null || typeof align === 'string' ? {\n    x: align,\n    y: align\n  } : align;\n}\n\nfunction normalizeTable() {\n  const doc = this.document;\n  const opts = this.opts;\n  let index = doc._tableIndex++;\n  this._id = new String(opts.id ?? `table-${index}`);\n  this._position = {\n    x: doc.sizeToPoint(opts.position?.x, doc.x),\n    y: doc.sizeToPoint(opts.position?.y, doc.y)\n  };\n  this._maxWidth = doc.sizeToPoint(opts.maxWidth, doc.page.width - doc.page.margins.right - this._position.x);\n  const {\n    defaultStyle,\n    defaultColStyle,\n    defaultRowStyle\n  } = normalizedDefaultStyle(opts.defaultStyle);\n  this._defaultStyle = defaultStyle;\n  let colStyle;\n  if (opts.columnStyles) {\n    if (Array.isArray(opts.columnStyles)) {\n      colStyle = i => opts.columnStyles[i];\n    } else if (typeof opts.columnStyles === 'function') {\n      colStyle = memoize(i => opts.columnStyles(i), Infinity);\n    } else if (typeof opts.columnStyles === 'object') {\n      colStyle = () => opts.columnStyles;\n    }\n  }\n  if (!colStyle) colStyle = () => ({});\n  this._colStyle = normalizedColumnStyle.bind(this, defaultColStyle, colStyle);\n  let rowStyle;\n  if (opts.rowStyles) {\n    if (Array.isArray(opts.rowStyles)) {\n      rowStyle = i => opts.rowStyles[i];\n    } else if (typeof opts.rowStyles === 'function') {\n      rowStyle = memoize(i => opts.rowStyles(i), 10);\n    } else if (typeof opts.rowStyles === 'object') {\n      rowStyle = () => opts.rowStyles;\n    }\n  }\n  if (!rowStyle) rowStyle = () => ({});\n  this._rowStyle = normalizedRowStyle.bind(this, defaultRowStyle, rowStyle);\n}\nfunction normalizeText(text) {\n  if (text != null) text = `${text}`;\n  return text;\n}\nfunction normalizeCell(cell, rowIndex, colIndex) {\n  const colStyle = this._colStyle(colIndex);\n  let rowStyle = this._rowStyle(rowIndex);\n  const font = deepMerge({}, colStyle.font, rowStyle.font, cell.font);\n  const customFont = Object.values(font).filter(v => v != null).length > 0;\n  const doc = this.document;\n  const rollbackFont = doc._fontSource;\n  const rollbackFontSize = doc._fontSize;\n  const rollbackFontFamily = doc._fontFamily;\n  if (customFont) {\n    if (font.src) doc.font(font.src, font.family);\n    if (font.size) doc.fontSize(font.size);\n    rowStyle = this._rowStyle(rowIndex);\n  }\n  cell.padding = normalizeSides(cell.padding);\n  cell.border = normalizeSides(cell.border);\n  cell.borderColor = normalizeSides(cell.borderColor);\n  const config = deepMerge(this._defaultStyle, colStyle, rowStyle, cell);\n  config.rowIndex = rowIndex;\n  config.colIndex = colIndex;\n  config.font = font ?? {};\n  config.customFont = customFont;\n  config.text = normalizeText(config.text);\n  config.rowSpan = config.rowSpan ?? 1;\n  config.colSpan = config.colSpan ?? 1;\n  config.padding = normalizeSides(config.padding, '0.25em', x => doc.sizeToPoint(x, '0.25em'));\n  config.border = normalizeSides(config.border, 1, x => doc.sizeToPoint(x, 1));\n  config.borderColor = normalizeSides(config.borderColor, 'black', x => x ?? 'black');\n  config.align = normalizeAlignment(config.align);\n  config.align.x = config.align.x ?? 'left';\n  config.align.y = config.align.y ?? 'top';\n  config.textStroke = doc.sizeToPoint(config.textStroke, 0);\n  config.textStrokeColor = config.textStrokeColor ?? 'black';\n  config.textColor = config.textColor ?? 'black';\n  config.textOptions = config.textOptions ?? {};\n  config.id = new String(config.id ?? `${this._id}-${rowIndex}-${colIndex}`);\n  config.type = config.type?.toUpperCase() === 'TH' ? 'TH' : 'TD';\n  if (config.scope) {\n    config.scope = config.scope.toLowerCase();\n    if (config.scope === 'row') config.scope = 'Row';else if (config.scope === 'both') config.scope = 'Both';else if (config.scope === 'column') config.scope = 'Column';\n  }\n  if (typeof this.opts.debug === 'boolean') config.debug = this.opts.debug;\n  if (customFont) doc.font(rollbackFont, rollbackFontFamily, rollbackFontSize);\n  return config;\n}\nfunction normalizeRow(row, rowIndex) {\n  if (!this._cellClaim) this._cellClaim = new Set();\n  let colIndex = 0;\n  return row.map(cell => {\n    if (cell == null || typeof cell !== 'object') cell = {\n      text: cell\n    };\n    while (this._cellClaim.has(`${rowIndex},${colIndex}`)) {\n      colIndex++;\n    }\n    cell = normalizeCell.call(this, cell, rowIndex, colIndex);\n    for (let i = 0; i < cell.rowSpan; i++) {\n      for (let j = 0; j < cell.colSpan; j++) {\n        this._cellClaim.add(`${rowIndex + i},${colIndex + j}`);\n      }\n    }\n    colIndex += cell.colSpan;\n    return cell;\n  });\n}\n\nfunction ensure(row) {\n  this._columnWidths = [];\n  ensureColumnWidths.call(this, row.reduce((a, cell) => a + cell.colSpan, 0));\n  this._rowHeights = [];\n  this._rowYPos = [this._position.y];\n  this._rowBuffer = new Set();\n}\nfunction ensureColumnWidths(numCols) {\n  let starColumnIndexes = [];\n  let starMinAcc = 0;\n  let unclaimedWidth = this._maxWidth;\n  for (let i = 0; i < numCols; i++) {\n    let col = this._colStyle(i);\n    if (col.width === '*') {\n      starColumnIndexes[i] = col;\n      starMinAcc += col.minWidth;\n    } else {\n      unclaimedWidth -= col.width;\n      this._columnWidths[i] = col.width;\n    }\n  }\n  let starColCount = starColumnIndexes.reduce(x => x + 1, 0);\n  if (starMinAcc >= unclaimedWidth) {\n    starColumnIndexes.forEach((cell, i) => {\n      this._columnWidths[i] = cell.minWidth;\n    });\n  } else if (starColCount > 0) {\n    starColumnIndexes.forEach((col, i) => {\n      let starSize = unclaimedWidth / starColCount;\n      this._columnWidths[i] = Math.max(starSize, col.minWidth);\n      if (col.maxWidth > 0) {\n        this._columnWidths[i] = Math.min(this._columnWidths[i], col.maxWidth);\n      }\n      unclaimedWidth -= this._columnWidths[i];\n      starColCount--;\n    });\n  }\n  let tempX = this._position.x;\n  this._columnXPos = Array.from(this._columnWidths, v => {\n    const t = tempX;\n    tempX += v;\n    return t;\n  });\n}\nfunction measure(row, rowIndex) {\n  row.forEach(cell => this._rowBuffer.add(cell));\n  if (rowIndex > 0) {\n    this._rowYPos[rowIndex] = this._rowYPos[rowIndex - 1] + this._rowHeights[rowIndex - 1];\n  }\n  const rowStyle = this._rowStyle(rowIndex);\n  let toRender = [];\n  this._rowBuffer.forEach(cell => {\n    if (cell.rowIndex + cell.rowSpan - 1 === rowIndex) {\n      toRender.push(measureCell.call(this, cell, rowStyle.height));\n      this._rowBuffer.delete(cell);\n    }\n  });\n  let rowHeight = rowStyle.height;\n  if (rowHeight === 'auto') {\n    rowHeight = toRender.reduce((acc, cell) => {\n      let minHeight = cell.textBounds.height + cell.padding.top + cell.padding.bottom;\n      for (let i = 0; i < cell.rowSpan - 1; i++) {\n        minHeight -= this._rowHeights[cell.rowIndex + i];\n      }\n      return Math.max(acc, minHeight);\n    }, 0);\n  }\n  rowHeight = Math.max(rowHeight, rowStyle.minHeight);\n  if (rowStyle.maxHeight > 0) {\n    rowHeight = Math.min(rowHeight, rowStyle.maxHeight);\n  }\n  this._rowHeights[rowIndex] = rowHeight;\n  let newPage = false;\n  if (rowHeight > this.document.page.contentHeight) {\n    console.warn(new Error(`Row ${rowIndex} requested more than the safe page height, row has been clamped`).stack.slice(7));\n    this._rowHeights[rowIndex] = this.document.page.maxY() - this._rowYPos[rowIndex];\n  } else if (this._rowYPos[rowIndex] + rowHeight >= this.document.page.maxY()) {\n    this._rowYPos[rowIndex] = this.document.page.margins.top;\n    newPage = true;\n  }\n  return {\n    newPage,\n    toRender: toRender.map(cell => measureCell.call(this, cell, rowHeight))\n  };\n}\nfunction measureCell(cell, rowHeight) {\n  let cellWidth = 0;\n  for (let i = 0; i < cell.colSpan; i++) {\n    cellWidth += this._columnWidths[cell.colIndex + i];\n  }\n  let cellHeight = rowHeight;\n  if (cellHeight === 'auto') {\n    cellHeight = this.document.page.contentHeight;\n  } else {\n    for (let i = 0; i < cell.rowSpan - 1; i++) {\n      cellHeight += this._rowHeights[cell.rowIndex + i];\n    }\n  }\n  const textAllocatedWidth = cellWidth - cell.padding.left - cell.padding.right;\n  const textAllocatedHeight = cellHeight - cell.padding.top - cell.padding.bottom;\n  const rotation = cell.textOptions.rotation ?? 0;\n  const {\n    width: textMaxWidth,\n    height: textMaxHeight\n  } = computeBounds(rotation, textAllocatedWidth, textAllocatedHeight);\n  const textOptions = {\n    align: cell.align.x,\n    ellipsis: true,\n    stroke: cell.textStroke > 0,\n    fill: true,\n    width: textMaxWidth,\n    height: textMaxHeight,\n    rotation,\n    ...cell.textOptions\n  };\n  let textBounds = {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n  if (cell.text) {\n    const rollbackFont = this.document._fontSource;\n    const rollbackFontSize = this.document._fontSize;\n    const rollbackFontFamily = this.document._fontFamily;\n    if (cell.font?.src) this.document.font(cell.font.src, cell.font?.family);\n    if (cell.font?.size) this.document.fontSize(cell.font.size);\n    const unRotatedTextBounds = this.document.boundsOfString(cell.text, 0, 0, {\n      ...textOptions,\n      rotation: 0\n    });\n    textOptions.width = unRotatedTextBounds.width;\n    textOptions.height = unRotatedTextBounds.height;\n    textBounds = this.document.boundsOfString(cell.text, 0, 0, textOptions);\n    this.document.font(rollbackFont, rollbackFontFamily, rollbackFontSize);\n  }\n  return {\n    ...cell,\n    textOptions,\n    x: this._columnXPos[cell.colIndex],\n    y: this._rowYPos[cell.rowIndex],\n    textX: this._columnXPos[cell.colIndex] + cell.padding.left,\n    textY: this._rowYPos[cell.rowIndex] + cell.padding.top,\n    width: cellWidth,\n    height: cellHeight,\n    textAllocatedHeight,\n    textAllocatedWidth,\n    textBounds\n  };\n}\nfunction computeBounds(rotation, allocWidth, allocHeight) {\n  let textMaxWidth, textMaxHeight;\n  const cos = cosine(rotation);\n  const sin = sine(rotation);\n  if (rotation === 0 || rotation === 180) {\n    textMaxWidth = allocWidth;\n    textMaxHeight = allocHeight;\n  } else if (rotation === 90 || rotation === 270) {\n    textMaxWidth = allocHeight;\n    textMaxHeight = allocWidth;\n  } else if (rotation < 90 || rotation > 180 && rotation < 270) {\n    textMaxWidth = allocWidth / (2 * cos);\n    textMaxHeight = allocWidth / (2 * sin);\n  } else {\n    textMaxHeight = allocWidth / (2 * cos);\n    textMaxWidth = allocWidth / (2 * sin);\n  }\n  const EF = sin * textMaxWidth;\n  const FG = cos * textMaxHeight;\n  if (EF + FG > allocHeight) {\n    const denominator = cos * cos - sin * sin;\n    if (rotation === 0 || rotation === 180) {\n      textMaxWidth = allocWidth;\n      textMaxHeight = allocHeight;\n    } else if (rotation === 90 || rotation === 270) {\n      textMaxWidth = allocHeight;\n      textMaxHeight = allocWidth;\n    } else if (rotation < 90 || rotation > 180 && rotation < 270) {\n      textMaxWidth = (allocWidth * cos - allocHeight * sin) / denominator;\n      textMaxHeight = (allocHeight * cos - allocWidth * sin) / denominator;\n    } else {\n      textMaxHeight = (allocWidth * cos - allocHeight * sin) / denominator;\n      textMaxWidth = (allocHeight * cos - allocWidth * sin) / denominator;\n    }\n  }\n  return {\n    width: Math.abs(textMaxWidth),\n    height: Math.abs(textMaxHeight)\n  };\n}\n\nfunction accommodateTable() {\n  const structParent = this.opts.structParent;\n  if (structParent) {\n    this._tableStruct = this.document.struct('Table');\n    this._tableStruct.dictionary.data.ID = this._id;\n    if (structParent instanceof PDFStructureElement) {\n      structParent.add(this._tableStruct);\n    } else if (structParent instanceof PDFDocument) {\n      structParent.addStructure(this._tableStruct);\n    }\n    this._headerRowLookup = {};\n    this._headerColumnLookup = {};\n  }\n}\nfunction accommodateCleanup() {\n  if (this._tableStruct) this._tableStruct.end();\n}\nfunction accessibleRow(row, rowIndex, renderCell) {\n  const rowStruct = this.document.struct('TR');\n  rowStruct.dictionary.data.ID = new String(`${this._id}-${rowIndex}`);\n  this._tableStruct.add(rowStruct);\n  row.forEach(cell => renderCell(cell, rowStruct));\n  rowStruct.end();\n}\nfunction accessibleCell(cell, rowStruct, callback) {\n  const doc = this.document;\n  const cellStruct = doc.struct(cell.type, {\n    title: cell.title\n  });\n  cellStruct.dictionary.data.ID = cell.id;\n  rowStruct.add(cellStruct);\n  const padding = cell.padding;\n  const border = cell.border;\n  const attributes = {\n    O: 'Table',\n    Width: cell.width,\n    Height: cell.height,\n    Padding: [padding.top, padding.bottom, padding.left, padding.right],\n    RowSpan: cell.rowSpan > 1 ? cell.rowSpan : undefined,\n    ColSpan: cell.colSpan > 1 ? cell.colSpan : undefined,\n    BorderThickness: [border.top, border.bottom, border.left, border.right]\n  };\n  if (cell.type === 'TH') {\n    if (cell.scope === 'Row' || cell.scope === 'Both') {\n      for (let i = 0; i < cell.rowSpan; i++) {\n        if (!this._headerRowLookup[cell.rowIndex + i]) {\n          this._headerRowLookup[cell.rowIndex + i] = [];\n        }\n        this._headerRowLookup[cell.rowIndex + i].push(cell.id);\n      }\n      attributes.Scope = cell.scope;\n    }\n    if (cell.scope === 'Column' || cell.scope === 'Both') {\n      for (let i = 0; i < cell.colSpan; i++) {\n        if (!this._headerColumnLookup[cell.colIndex + i]) {\n          this._headerColumnLookup[cell.colIndex + i] = [];\n        }\n        this._headerColumnLookup[cell.colIndex + i].push(cell.id);\n      }\n      attributes.Scope = cell.scope;\n    }\n  }\n  const Headers = new Set([...Array.from({\n    length: cell.colSpan\n  }, (_, i) => this._headerColumnLookup[cell.colIndex + i]).flat(), ...Array.from({\n    length: cell.rowSpan\n  }, (_, i) => this._headerRowLookup[cell.rowIndex + i]).flat()].filter(Boolean));\n  if (Headers.size) attributes.Headers = Array.from(Headers);\n  const normalizeColor = doc._normalizeColor;\n  if (cell.backgroundColor != null) {\n    attributes.BackgroundColor = normalizeColor(cell.backgroundColor);\n  }\n  const hasBorder = [border.top, border.bottom, border.left, border.right];\n  if (hasBorder.some(x => x)) {\n    const borderColor = cell.borderColor;\n    attributes.BorderColor = [hasBorder[0] ? normalizeColor(borderColor.top) : null, hasBorder[1] ? normalizeColor(borderColor.bottom) : null, hasBorder[2] ? normalizeColor(borderColor.left) : null, hasBorder[3] ? normalizeColor(borderColor.right) : null];\n  }\n  Object.keys(attributes).forEach(key => attributes[key] === undefined && delete attributes[key]);\n  cellStruct.dictionary.data.A = doc.ref(attributes);\n  cellStruct.add(callback);\n  cellStruct.end();\n  cellStruct.dictionary.data.A.end();\n}\n\nfunction renderRow(row, rowIndex) {\n  if (this._tableStruct) {\n    accessibleRow.call(this, row, rowIndex, renderCell.bind(this));\n  } else {\n    row.forEach(cell => renderCell.call(this, cell));\n  }\n  return this._rowYPos[rowIndex] + this._rowHeights[rowIndex];\n}\nfunction renderCell(cell, rowStruct) {\n  const cellRenderer = () => {\n    if (cell.backgroundColor != null) {\n      this.document.save().rect(cell.x, cell.y, cell.width, cell.height).fill(cell.backgroundColor).restore();\n    }\n    renderBorder.call(this, cell.border, cell.borderColor, cell.x, cell.y, cell.width, cell.height);\n    if (cell.debug) {\n      this.document.save();\n      this.document.dash(1, {\n        space: 1\n      }).lineWidth(1).strokeOpacity(0.3);\n      this.document.rect(cell.x, cell.y, cell.width, cell.height).stroke('green');\n      this.document.restore();\n    }\n    if (cell.text) renderCellText.call(this, cell);\n  };\n  if (rowStruct) accessibleCell.call(this, cell, rowStruct, cellRenderer);else cellRenderer();\n}\nfunction renderCellText(cell) {\n  const doc = this.document;\n  const rollbackFont = doc._fontSource;\n  const rollbackFontSize = doc._fontSize;\n  const rollbackFontFamily = doc._fontFamily;\n  if (cell.customFont) {\n    if (cell.font.src) doc.font(cell.font.src, cell.font.family);\n    if (cell.font.size) doc.fontSize(cell.font.size);\n  }\n  const x = cell.textX;\n  const y = cell.textY;\n  const Ah = cell.textAllocatedHeight;\n  const Aw = cell.textAllocatedWidth;\n  const Cw = cell.textBounds.width;\n  const Ch = cell.textBounds.height;\n  const Ox = -cell.textBounds.x;\n  const Oy = -cell.textBounds.y;\n  const PxScale = cell.align.x === 'right' ? 1 : cell.align.x === 'center' ? 0.5 : 0;\n  const Px = (Aw - Cw) * PxScale;\n  const PyScale = cell.align.y === 'bottom' ? 1 : cell.align.y === 'center' ? 0.5 : 0;\n  const Py = (Ah - Ch) * PyScale;\n  const dx = Px + Ox;\n  const dy = Py + Oy;\n  if (cell.debug) {\n    doc.save();\n    doc.dash(1, {\n      space: 1\n    }).lineWidth(1).strokeOpacity(0.3);\n    if (cell.text) {\n      doc.moveTo(x + Px, y).lineTo(x + Px, y + Ah).moveTo(x + Px + Cw, y).lineTo(x + Px + Cw, y + Ah).stroke('blue').moveTo(x, y + Py).lineTo(x + Aw, y + Py).moveTo(x, y + Py + Ch).lineTo(x + Aw, y + Py + Ch).stroke('green');\n    }\n    doc.rect(x, y, Aw, Ah).stroke('orange');\n    doc.restore();\n  }\n  doc.save().rect(x, y, Aw, Ah).clip();\n  doc.fillColor(cell.textColor).strokeColor(cell.textStrokeColor);\n  if (cell.textStroke > 0) doc.lineWidth(cell.textStroke);\n  doc.text(cell.text, x + dx, y + dy, cell.textOptions);\n  doc.restore();\n  if (cell.font) doc.font(rollbackFont, rollbackFontFamily, rollbackFontSize);\n}\nfunction renderBorder(border, borderColor, x, y, width, height, mask) {\n  border = Object.fromEntries(Object.entries(border).map(_ref => {\n    let [k, v] = _ref;\n    return [k, mask && !mask[k] ? 0 : v];\n  }));\n  const doc = this.document;\n  if ([border.right, border.bottom, border.left].every(val => val === border.top)) {\n    if (border.top > 0) {\n      doc.save().lineWidth(border.top).rect(x, y, width, height).stroke(borderColor.top).restore();\n    }\n  } else {\n    if (border.top > 0) {\n      doc.save().lineWidth(border.top).moveTo(x, y).lineTo(x + width, y).stroke(borderColor.top).restore();\n    }\n    if (border.right > 0) {\n      doc.save().lineWidth(border.right).moveTo(x + width, y).lineTo(x + width, y + height).stroke(borderColor.right).restore();\n    }\n    if (border.bottom > 0) {\n      doc.save().lineWidth(border.bottom).moveTo(x + width, y + height).lineTo(x, y + height).stroke(borderColor.bottom).restore();\n    }\n    if (border.left > 0) {\n      doc.save().lineWidth(border.left).moveTo(x, y + height).lineTo(x, y).stroke(borderColor.left).restore();\n    }\n  }\n}\n\nclass PDFTable {\n  constructor(document) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.document = document;\n    this.opts = Object.freeze(opts);\n    normalizeTable.call(this);\n    accommodateTable.call(this);\n    this._currRowIndex = 0;\n    this._ended = false;\n    if (opts.data) {\n      for (const row of opts.data) this.row(row);\n      return this.end();\n    }\n  }\n  row(row) {\n    let lastRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this._ended) {\n      throw new Error(`Table was marked as ended on row ${this._currRowIndex}`);\n    }\n    row = Array.from(row);\n    row = normalizeRow.call(this, row, this._currRowIndex);\n    if (this._currRowIndex === 0) ensure.call(this, row);\n    const {\n      newPage,\n      toRender\n    } = measure.call(this, row, this._currRowIndex);\n    if (newPage) this.document.continueOnNewPage();\n    const yPos = renderRow.call(this, toRender, this._currRowIndex);\n    this.document.x = this._position.x;\n    this.document.y = yPos;\n    if (lastRow) return this.end();\n    this._currRowIndex++;\n    return this;\n  }\n  end() {\n    while (this._rowBuffer?.size) this.row([]);\n    this._ended = true;\n    accommodateCleanup.call(this);\n    return this.document;\n  }\n}\n\nvar TableMixin = {\n  initTables() {\n    this._tableIndex = 0;\n  },\n  table(opts) {\n    return new PDFTable(this, opts);\n  }\n};\n\nclass PDFMetadata {\n  constructor() {\n    this._metadata = `\n        <?xpacket begin=\"\\ufeff\" id=\"W5M0MpCehiHzreSzNTczkc9d\"?>\n            <x:xmpmeta xmlns:x=\"adobe:ns:meta/\">\n                <rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">\n        `;\n  }\n  _closeTags() {\n    this._metadata = this._metadata.concat(`\n                </rdf:RDF>\n            </x:xmpmeta>\n        <?xpacket end=\"w\"?>\n        `);\n  }\n  append(xml) {\n    let newline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this._metadata = this._metadata.concat(xml);\n    if (newline) this._metadata = this._metadata.concat('\\n');\n  }\n  getXML() {\n    return this._metadata;\n  }\n  getLength() {\n    return this._metadata.length;\n  }\n  end() {\n    this._closeTags();\n    this._metadata = this._metadata.trim();\n  }\n}\n\nvar MetadataMixin = {\n  initMetadata() {\n    this.metadata = new PDFMetadata();\n  },\n  appendXML(xml) {\n    let newline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.metadata.append(xml, newline);\n  },\n  _addInfo() {\n    this.appendXML(`\n        <rdf:Description rdf:about=\"\" xmlns:xmp=\"http://ns.adobe.com/xap/1.0/\">\n            <xmp:CreateDate>${this.info.CreationDate.toISOString().split('.')[0] + 'Z'}</xmp:CreateDate>\n            <xmp:CreatorTool>${this.info.Creator}</xmp:CreatorTool>\n        </rdf:Description>\n        `);\n    if (this.info.Title || this.info.Author || this.info.Subject) {\n      this.appendXML(`\n            <rdf:Description rdf:about=\"\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\">\n            `);\n      if (this.info.Title) {\n        this.appendXML(`\n                <dc:title>\n                    <rdf:Alt>\n                        <rdf:li xml:lang=\"x-default\">${this.info.Title}</rdf:li>\n                    </rdf:Alt>\n                </dc:title>\n                `);\n      }\n      if (this.info.Author) {\n        this.appendXML(`\n                <dc:creator>\n                    <rdf:Seq>\n                        <rdf:li>${this.info.Author}</rdf:li>\n                    </rdf:Seq>\n                </dc:creator>\n                `);\n      }\n      if (this.info.Subject) {\n        this.appendXML(`\n                <dc:description>\n                    <rdf:Alt>\n                        <rdf:li xml:lang=\"x-default\">${this.info.Subject}</rdf:li>\n                    </rdf:Alt>\n                </dc:description>\n                `);\n      }\n      this.appendXML(`\n            </rdf:Description>\n            `);\n    }\n    this.appendXML(`\n        <rdf:Description rdf:about=\"\" xmlns:pdf=\"http://ns.adobe.com/pdf/1.3/\">\n            <pdf:Producer>${this.info.Creator}</pdf:Producer>`, false);\n    if (this.info.Keywords) {\n      this.appendXML(`\n            <pdf:Keywords>${this.info.Keywords}</pdf:Keywords>`, false);\n    }\n    this.appendXML(`\n        </rdf:Description>\n        `);\n  },\n  endMetadata() {\n    this._addInfo();\n    this.metadata.end();\n    if (this.version != 1.3) {\n      this.metadataRef = this.ref({\n        length: this.metadata.getLength(),\n        Type: 'Metadata',\n        Subtype: 'XML'\n      });\n      this.metadataRef.compress = false;\n      this.metadataRef.write(Buffer.from(this.metadata.getXML(), 'utf-8'));\n      this.metadataRef.end();\n      this._root.data.Metadata = this.metadataRef;\n    }\n  }\n};\n\nclass PDFDocument extends (stream__WEBPACK_IMPORTED_MODULE_0___default().Readable) {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(options);\n    this.options = options;\n    switch (options.pdfVersion) {\n      case '1.4':\n        this.version = 1.4;\n        break;\n      case '1.5':\n        this.version = 1.5;\n        break;\n      case '1.6':\n        this.version = 1.6;\n        break;\n      case '1.7':\n      case '1.7ext3':\n        this.version = 1.7;\n        break;\n      default:\n        this.version = 1.3;\n        break;\n    }\n    this.compress = this.options.compress != null ? this.options.compress : true;\n    this._pageBuffer = [];\n    this._pageBufferStart = 0;\n    this._offsets = [];\n    this._waiting = 0;\n    this._ended = false;\n    this._offset = 0;\n    const Pages = this.ref({\n      Type: 'Pages',\n      Count: 0,\n      Kids: []\n    });\n    const Names = this.ref({\n      Dests: new PDFNameTree()\n    });\n    this._root = this.ref({\n      Type: 'Catalog',\n      Pages,\n      Names\n    });\n    if (this.options.lang) {\n      this._root.data.Lang = new String(this.options.lang);\n    }\n    this.page = null;\n    this.initMetadata();\n    this.initColor();\n    this.initVector();\n    this.initFonts(options.font);\n    this.initText();\n    this.initImages();\n    this.initOutline();\n    this.initMarkings(options);\n    this.initTables();\n    this.initSubset(options);\n    this.info = {\n      Producer: 'PDFKit',\n      Creator: 'PDFKit',\n      CreationDate: new Date()\n    };\n    if (this.options.info) {\n      for (let key in this.options.info) {\n        const val = this.options.info[key];\n        this.info[key] = val;\n      }\n    }\n    if (this.options.displayTitle) {\n      this._root.data.ViewerPreferences = this.ref({\n        DisplayDocTitle: true\n      });\n    }\n    this._id = PDFSecurity.generateFileID(this.info);\n    this._security = PDFSecurity.create(this, options);\n    this._write(`%PDF-${this.version}`);\n    this._write('%\\xFF\\xFF\\xFF\\xFF');\n    if (this.options.autoFirstPage !== false) {\n      this.addPage();\n    }\n  }\n  addPage(options) {\n    if (options == null) {\n      ({\n        options\n      } = this);\n    }\n    if (!this.options.bufferPages) {\n      this.flushPages();\n    }\n    this.page = new PDFPage(this, options);\n    this._pageBuffer.push(this.page);\n    const pages = this._root.data.Pages.data;\n    pages.Kids.push(this.page.dictionary);\n    pages.Count++;\n    this.x = this.page.margins.left;\n    this.y = this.page.margins.top;\n    this._ctm = [1, 0, 0, 1, 0, 0];\n    this.transform(1, 0, 0, -1, 0, this.page.height);\n    this.emit('pageAdded');\n    return this;\n  }\n  continueOnNewPage(options) {\n    const pageMarkings = this.endPageMarkings(this.page);\n    this.addPage(options ?? this.page._options);\n    this.initPageMarkings(pageMarkings);\n    return this;\n  }\n  bufferedPageRange() {\n    return {\n      start: this._pageBufferStart,\n      count: this._pageBuffer.length\n    };\n  }\n  switchToPage(n) {\n    let page;\n    if (!(page = this._pageBuffer[n - this._pageBufferStart])) {\n      throw new Error(`switchToPage(${n}) out of bounds, current buffer covers pages ${this._pageBufferStart} to ${this._pageBufferStart + this._pageBuffer.length - 1}`);\n    }\n    return this.page = page;\n  }\n  flushPages() {\n    const pages = this._pageBuffer;\n    this._pageBuffer = [];\n    this._pageBufferStart += pages.length;\n    for (let page of pages) {\n      this.endPageMarkings(page);\n      page.end();\n    }\n  }\n  addNamedDestination(name) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    if (args.length === 0) {\n      args = ['XYZ', null, null, null];\n    }\n    if (args[0] === 'XYZ' && args[2] !== null) {\n      args[2] = this.page.height - args[2];\n    }\n    args.unshift(this.page.dictionary);\n    this._root.data.Names.data.Dests.add(name, args);\n  }\n  addNamedEmbeddedFile(name, ref) {\n    if (!this._root.data.Names.data.EmbeddedFiles) {\n      this._root.data.Names.data.EmbeddedFiles = new PDFNameTree({\n        limits: false\n      });\n    }\n    this._root.data.Names.data.EmbeddedFiles.add(name, ref);\n  }\n  addNamedJavaScript(name, js) {\n    if (!this._root.data.Names.data.JavaScript) {\n      this._root.data.Names.data.JavaScript = new PDFNameTree();\n    }\n    let data = {\n      JS: new String(js),\n      S: 'JavaScript'\n    };\n    this._root.data.Names.data.JavaScript.add(name, data);\n  }\n  ref(data) {\n    const ref = new PDFReference(this, this._offsets.length + 1, data);\n    this._offsets.push(null);\n    this._waiting++;\n    return ref;\n  }\n  _read() {}\n  _write(data) {\n    if (!Buffer.isBuffer(data)) {\n      data = Buffer.from(data + '\\n', 'binary');\n    }\n    this.push(data);\n    this._offset += data.length;\n  }\n  addContent(data) {\n    this.page.write(data);\n    return this;\n  }\n  _refEnd(ref) {\n    this._offsets[ref.id - 1] = ref.offset;\n    if (--this._waiting === 0 && this._ended) {\n      this._finalize();\n      this._ended = false;\n    }\n  }\n  end() {\n    this.flushPages();\n    this._info = this.ref();\n    for (let key in this.info) {\n      let val = this.info[key];\n      if (typeof val === 'string') {\n        val = new String(val);\n      }\n      let entry = this.ref(val);\n      entry.end();\n      this._info.data[key] = entry;\n    }\n    this._info.end();\n    for (let name in this._fontFamilies) {\n      const font = this._fontFamilies[name];\n      font.finalize();\n    }\n    this.endOutline();\n    this.endMarkings();\n    if (this.subset) {\n      this.endSubset();\n    }\n    this.endMetadata();\n    this._root.end();\n    this._root.data.Pages.end();\n    this._root.data.Names.end();\n    this.endAcroForm();\n    if (this._root.data.ViewerPreferences) {\n      this._root.data.ViewerPreferences.end();\n    }\n    if (this._security) {\n      this._security.end();\n    }\n    if (this._waiting === 0) {\n      this._finalize();\n    } else {\n      this._ended = true;\n    }\n  }\n  _finalize() {\n    const xRefOffset = this._offset;\n    this._write('xref');\n    this._write(`0 ${this._offsets.length + 1}`);\n    this._write('0000000000 65535 f ');\n    for (let offset of this._offsets) {\n      offset = `0000000000${offset}`.slice(-10);\n      this._write(offset + ' 00000 n ');\n    }\n    const trailer = {\n      Size: this._offsets.length + 1,\n      Root: this._root,\n      Info: this._info,\n      ID: [this._id, this._id]\n    };\n    if (this._security) {\n      trailer.Encrypt = this._security.dictionary;\n    }\n    this._write('trailer');\n    this._write(PDFObject.convert(trailer));\n    this._write('startxref');\n    this._write(`${xRefOffset}`);\n    this._write('%%EOF');\n    this.push(null);\n  }\n  toString() {\n    return '[object PDFDocument]';\n  }\n}\nconst mixin = methods => {\n  Object.assign(PDFDocument.prototype, methods);\n};\nmixin(MetadataMixin);\nmixin(ColorMixin);\nmixin(VectorMixin);\nmixin(FontsMixin);\nmixin(TextMixin);\nmixin(ImagesMixin);\nmixin(AnnotationsMixin);\nmixin(OutlineMixin);\nmixin(MarkingsMixin);\nmixin(AcroFormMixin);\nmixin(AttachmentsMixin);\nmixin(SubsetMixin);\nmixin(TableMixin);\nPDFDocument.LineWrapper = LineWrapper;\n\n\n//# sourceMappingURL=pdfkit.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRma2l0L2pzL3BkZmtpdC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRCO0FBQ0o7QUFDUztBQUNiO0FBQ2U7QUFDRztBQUNGO0FBQ1A7QUFDSjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUVBQXFFO0FBQ2pHO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBLHNCQUFzQiwwQ0FBMEMsRUFBRSxvQ0FBb0M7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsTUFBTTtBQUNOO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixNQUFNO0FBQ04saUJBQWlCLHVCQUF1QjtBQUN4QyxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ04sd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLE1BQU07QUFDTjtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCLE1BQU0sV0FBVztBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBSyxFQUFFLGtDQUFrQztBQUM5RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ04sZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEVBQUU7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVEQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUyxFQUFFLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUyxFQUFFLFVBQVU7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsc0RBQWU7QUFDMUIsR0FBRztBQUNIO0FBQ0EsV0FBVyxzREFBZTtBQUMxQixHQUFHO0FBQ0g7QUFDQSxXQUFXLHNEQUFlO0FBQzFCLEdBQUc7QUFDSDtBQUNBLFdBQVcsc0RBQWU7QUFDMUIsR0FBRztBQUNIO0FBQ0EsV0FBVyxzREFBZTtBQUMxQixHQUFHO0FBQ0g7QUFDQSxXQUFXLHNEQUFlO0FBQzFCLEdBQUc7QUFDSDtBQUNBLFdBQVcsc0RBQWU7QUFDMUIsR0FBRztBQUNIO0FBQ0EsV0FBVyxzREFBZTtBQUMxQixHQUFHO0FBQ0g7QUFDQSxXQUFXLHNEQUFlO0FBQzFCLEdBQUc7QUFDSDtBQUNBLFdBQVcsc0RBQWU7QUFDMUIsR0FBRztBQUNIO0FBQ0EsV0FBVyxzREFBZTtBQUMxQixHQUFHO0FBQ0g7QUFDQSxXQUFXLHNEQUFlO0FBQzFCLEdBQUc7QUFDSDtBQUNBLFdBQVcsc0RBQWU7QUFDMUIsR0FBRztBQUNIO0FBQ0EsV0FBVyxzREFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFB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QUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGdEQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlEQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esa0NBQWtDLEtBQUs7QUFDdkM7QUFDQSw4QkFBOEIsR0FBRztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEdBQUc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0EsUUFBUTtBQUNSLGVBQWUsc0RBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSLG9EQUFvRCxJQUFJO0FBQ3hEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMEJBQTBCLEtBQUs7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUssRUFBRSwrQkFBK0I7QUFDOUQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLHVEQUF1RCxLQUFLO0FBQzVEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwyQkFBMkIsT0FBTztBQUNsQyx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Ysa0NBQWtDO0FBQ2xDO0FBQ0EsVUFBVTtBQUNWLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWSxHQUFHLE9BQU8sRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUyxHQUFHLE9BQU8sRUFBRTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWUsRUFBRSxVQUFVO0FBQzdEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGVBQWUsc0RBQWU7QUFDOUI7QUFDQSx5RUFBeUUsSUFBSTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsRUFBRSxrREFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBWSxDQUFDLG9EQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHVCQUF1QixzREFBZSxJQUFJLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QyxrQ0FBa0Msd0JBQXdCO0FBQzFEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLGFBQWE7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVMsR0FBRyxTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtDO0FBQ2xDIiwic291cmNlcyI6WyIvaG9tZS9nYXNjYXQvcHJpc21hcXVhbnQvcHJpc21hLXF1YW50dW0vbm9kZV9tb2R1bGVzL3BkZmtpdC9qcy9wZGZraXQuZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN0cmVhbSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IHpsaWIgZnJvbSAnemxpYic7XG5pbXBvcnQgQ3J5cHRvSlMgZnJvbSAnY3J5cHRvLWpzJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgKiBhcyBmb250a2l0IGZyb20gJ2ZvbnRraXQnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCBMaW5lQnJlYWtlciBmcm9tICdsaW5lYnJlYWsnO1xuaW1wb3J0IGV4aWYgZnJvbSAnanBlZy1leGlmJztcbmltcG9ydCBQTkcgZnJvbSAncG5nLWpzJztcblxuY2xhc3MgUERGQWJzdHJhY3RSZWZlcmVuY2Uge1xuICB0b1N0cmluZygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NlcycpO1xuICB9XG59XG5cbmNsYXNzIFBERlRyZWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdGhpcy5faXRlbXMgPSB7fTtcbiAgICB0aGlzLmxpbWl0cyA9IHR5cGVvZiBvcHRpb25zLmxpbWl0cyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5saW1pdHMgOiB0cnVlO1xuICB9XG4gIGFkZChrZXksIHZhbCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtc1trZXldID0gdmFsO1xuICB9XG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXNba2V5XTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBzb3J0ZWRLZXlzID0gT2JqZWN0LmtleXModGhpcy5faXRlbXMpLnNvcnQoKGEsIGIpID0+IHRoaXMuX2NvbXBhcmVLZXlzKGEsIGIpKTtcbiAgICBjb25zdCBvdXQgPSBbJzw8J107XG4gICAgaWYgKHRoaXMubGltaXRzICYmIHNvcnRlZEtleXMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgZmlyc3QgPSBzb3J0ZWRLZXlzWzBdLFxuICAgICAgICBsYXN0ID0gc29ydGVkS2V5c1tzb3J0ZWRLZXlzLmxlbmd0aCAtIDFdO1xuICAgICAgb3V0LnB1c2goYCAgL0xpbWl0cyAke1BERk9iamVjdC5jb252ZXJ0KFt0aGlzLl9kYXRhRm9yS2V5KGZpcnN0KSwgdGhpcy5fZGF0YUZvcktleShsYXN0KV0pfWApO1xuICAgIH1cbiAgICBvdXQucHVzaChgICAvJHt0aGlzLl9rZXlzTmFtZSgpfSBbYCk7XG4gICAgZm9yIChsZXQga2V5IG9mIHNvcnRlZEtleXMpIHtcbiAgICAgIG91dC5wdXNoKGAgICAgJHtQREZPYmplY3QuY29udmVydCh0aGlzLl9kYXRhRm9yS2V5KGtleSkpfSAke1BERk9iamVjdC5jb252ZXJ0KHRoaXMuX2l0ZW1zW2tleV0pfWApO1xuICAgIH1cbiAgICBvdXQucHVzaCgnXScpO1xuICAgIG91dC5wdXNoKCc+PicpO1xuICAgIHJldHVybiBvdXQuam9pbignXFxuJyk7XG4gIH1cbiAgX2NvbXBhcmVLZXlzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzJyk7XG4gIH1cbiAgX2tleXNOYW1lKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzJyk7XG4gIH1cbiAgX2RhdGFGb3JLZXkoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMnKTtcbiAgfVxufVxuXG5jbGFzcyBTcG90Q29sb3Ige1xuICBjb25zdHJ1Y3Rvcihkb2MsIG5hbWUsIEMsIE0sIFksIEspIHtcbiAgICB0aGlzLmlkID0gJ0NTJyArIE9iamVjdC5rZXlzKGRvYy5zcG90Q29sb3JzKS5sZW5ndGg7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnZhbHVlcyA9IFtDLCBNLCBZLCBLXTtcbiAgICB0aGlzLnJlZiA9IGRvYy5yZWYoWydTZXBhcmF0aW9uJywgdGhpcy5uYW1lLCAnRGV2aWNlQ01ZSycsIHtcbiAgICAgIFJhbmdlOiBbMCwgMSwgMCwgMSwgMCwgMSwgMCwgMV0sXG4gICAgICBDMDogWzAsIDAsIDAsIDBdLFxuICAgICAgQzE6IHRoaXMudmFsdWVzLm1hcCh2YWx1ZSA9PiB2YWx1ZSAvIDEwMCksXG4gICAgICBGdW5jdGlvblR5cGU6IDIsXG4gICAgICBEb21haW46IFswLCAxXSxcbiAgICAgIE46IDFcbiAgICB9XSk7XG4gICAgdGhpcy5yZWYuZW5kKCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMucmVmLmlkfSAwIFJgO1xuICB9XG59XG5cbmNvbnN0IHBhZCA9IChzdHIsIGxlbmd0aCkgPT4gKEFycmF5KGxlbmd0aCArIDEpLmpvaW4oJzAnKSArIHN0cikuc2xpY2UoLWxlbmd0aCk7XG5jb25zdCBlc2NhcGFibGVSZSA9IC9bXFxuXFxyXFx0XFxiXFxmKClcXFxcXS9nO1xuY29uc3QgZXNjYXBhYmxlID0ge1xuICAnXFxuJzogJ1xcXFxuJyxcbiAgJ1xccic6ICdcXFxccicsXG4gICdcXHQnOiAnXFxcXHQnLFxuICAnXFxiJzogJ1xcXFxiJyxcbiAgJ1xcZic6ICdcXFxcZicsXG4gICdcXFxcJzogJ1xcXFxcXFxcJyxcbiAgJygnOiAnXFxcXCgnLFxuICAnKSc6ICdcXFxcKSdcbn07XG5jb25zdCBzd2FwQnl0ZXMgPSBmdW5jdGlvbiAoYnVmZikge1xuICBjb25zdCBsID0gYnVmZi5sZW5ndGg7XG4gIGlmIChsICYgMHgwMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyIGxlbmd0aCBtdXN0IGJlIGV2ZW4nKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMCwgZW5kID0gbCAtIDE7IGkgPCBlbmQ7IGkgKz0gMikge1xuICAgICAgY29uc3QgYSA9IGJ1ZmZbaV07XG4gICAgICBidWZmW2ldID0gYnVmZltpICsgMV07XG4gICAgICBidWZmW2kgKyAxXSA9IGE7XG4gICAgfVxuICB9XG4gIHJldHVybiBidWZmO1xufTtcbmNsYXNzIFBERk9iamVjdCB7XG4gIHN0YXRpYyBjb252ZXJ0KG9iamVjdCkge1xuICAgIGxldCBlbmNyeXB0Rm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gYC8ke29iamVjdH1gO1xuICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICBsZXQgc3RyaW5nID0gb2JqZWN0O1xuICAgICAgbGV0IGlzVW5pY29kZSA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGVuZCA9IHN0cmluZy5sZW5ndGg7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPiAweDdmKSB7XG4gICAgICAgICAgaXNVbmljb2RlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHN0cmluZ0J1ZmZlcjtcbiAgICAgIGlmIChpc1VuaWNvZGUpIHtcbiAgICAgICAgc3RyaW5nQnVmZmVyID0gc3dhcEJ5dGVzKEJ1ZmZlci5mcm9tKGBcXHVmZWZmJHtzdHJpbmd9YCwgJ3V0ZjE2bGUnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpbmdCdWZmZXIgPSBCdWZmZXIuZnJvbShzdHJpbmcudmFsdWVPZigpLCAnYXNjaWknKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmNyeXB0Rm4pIHtcbiAgICAgICAgc3RyaW5nID0gZW5jcnlwdEZuKHN0cmluZ0J1ZmZlcikudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nQnVmZmVyLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZVJlLCBjID0+IGVzY2FwYWJsZVtjXSk7XG4gICAgICByZXR1cm4gYCgke3N0cmluZ30pYDtcbiAgICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgICByZXR1cm4gYDwke29iamVjdC50b1N0cmluZygnaGV4Jyl9PmA7XG4gICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBQREZBYnN0cmFjdFJlZmVyZW5jZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBQREZUcmVlIHx8IG9iamVjdCBpbnN0YW5jZW9mIFNwb3RDb2xvcikge1xuICAgICAgcmV0dXJuIG9iamVjdC50b1N0cmluZygpO1xuICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgbGV0IHN0cmluZyA9IGBEOiR7cGFkKG9iamVjdC5nZXRVVENGdWxsWWVhcigpLCA0KX1gICsgcGFkKG9iamVjdC5nZXRVVENNb250aCgpICsgMSwgMikgKyBwYWQob2JqZWN0LmdldFVUQ0RhdGUoKSwgMikgKyBwYWQob2JqZWN0LmdldFVUQ0hvdXJzKCksIDIpICsgcGFkKG9iamVjdC5nZXRVVENNaW51dGVzKCksIDIpICsgcGFkKG9iamVjdC5nZXRVVENTZWNvbmRzKCksIDIpICsgJ1onO1xuICAgICAgaWYgKGVuY3J5cHRGbikge1xuICAgICAgICBzdHJpbmcgPSBlbmNyeXB0Rm4oQnVmZmVyLmZyb20oc3RyaW5nLCAnYXNjaWknKSkudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShlc2NhcGFibGVSZSwgYyA9PiBlc2NhcGFibGVbY10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGAoJHtzdHJpbmd9KWA7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gb2JqZWN0Lm1hcChlID0+IFBERk9iamVjdC5jb252ZXJ0KGUsIGVuY3J5cHRGbikpLmpvaW4oJyAnKTtcbiAgICAgIHJldHVybiBgWyR7aXRlbXN9XWA7XG4gICAgfSBlbHNlIGlmICh7fS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICBjb25zdCBvdXQgPSBbJzw8J107XG4gICAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtrZXldO1xuICAgICAgICBvdXQucHVzaChgLyR7a2V5fSAke1BERk9iamVjdC5jb252ZXJ0KHZhbCwgZW5jcnlwdEZuKX1gKTtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKCc+PicpO1xuICAgICAgcmV0dXJuIG91dC5qb2luKCdcXG4nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gUERGT2JqZWN0Lm51bWJlcihvYmplY3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYCR7b2JqZWN0fWA7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBudW1iZXIobikge1xuICAgIGlmIChuID4gLTFlMjEgJiYgbiA8IDFlMjEpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKG4gKiAxZTYpIC8gMWU2O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIG51bWJlcjogJHtufWApO1xuICB9XG59XG5cbmNsYXNzIFBERlJlZmVyZW5jZSBleHRlbmRzIFBERkFic3RyYWN0UmVmZXJlbmNlIHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIGlkKSB7XG4gICAgbGV0IGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZ2VuID0gMDtcbiAgICB0aGlzLmNvbXByZXNzID0gdGhpcy5kb2N1bWVudC5jb21wcmVzcyAmJiAhdGhpcy5kYXRhLkZpbHRlcjtcbiAgICB0aGlzLnVuY29tcHJlc3NlZExlbmd0aCA9IDA7XG4gICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgfVxuICB3cml0ZShjaHVuaykge1xuICAgIGlmICghKGNodW5rIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmsgKyAnXFxuJywgJ2JpbmFyeScpO1xuICAgIH1cbiAgICB0aGlzLnVuY29tcHJlc3NlZExlbmd0aCArPSBjaHVuay5sZW5ndGg7XG4gICAgaWYgKHRoaXMuZGF0YS5MZW5ndGggPT0gbnVsbCkge1xuICAgICAgdGhpcy5kYXRhLkxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgIHRoaXMuZGF0YS5MZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuICAgIGlmICh0aGlzLmNvbXByZXNzKSB7XG4gICAgICB0aGlzLmRhdGEuRmlsdGVyID0gJ0ZsYXRlRGVjb2RlJztcbiAgICB9XG4gIH1cbiAgZW5kKGNodW5rKSB7XG4gICAgaWYgKGNodW5rKSB7XG4gICAgICB0aGlzLndyaXRlKGNodW5rKTtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuICB9XG4gIGZpbmFsaXplKCkge1xuICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5kb2N1bWVudC5fb2Zmc2V0O1xuICAgIGNvbnN0IGVuY3J5cHRGbiA9IHRoaXMuZG9jdW1lbnQuX3NlY3VyaXR5ID8gdGhpcy5kb2N1bWVudC5fc2VjdXJpdHkuZ2V0RW5jcnlwdEZuKHRoaXMuaWQsIHRoaXMuZ2VuKSA6IG51bGw7XG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuY29uY2F0KHRoaXMuYnVmZmVyKTtcbiAgICAgIGlmICh0aGlzLmNvbXByZXNzKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gemxpYi5kZWZsYXRlU3luYyh0aGlzLmJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBpZiAoZW5jcnlwdEZuKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gZW5jcnlwdEZuKHRoaXMuYnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGF0YS5MZW5ndGggPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIHRoaXMuZG9jdW1lbnQuX3dyaXRlKGAke3RoaXMuaWR9ICR7dGhpcy5nZW59IG9iamApO1xuICAgIHRoaXMuZG9jdW1lbnQuX3dyaXRlKFBERk9iamVjdC5jb252ZXJ0KHRoaXMuZGF0YSwgZW5jcnlwdEZuKSk7XG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5kb2N1bWVudC5fd3JpdGUoJ3N0cmVhbScpO1xuICAgICAgdGhpcy5kb2N1bWVudC5fd3JpdGUodGhpcy5idWZmZXIpO1xuICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgIHRoaXMuZG9jdW1lbnQuX3dyaXRlKCdcXG5lbmRzdHJlYW0nKTtcbiAgICB9XG4gICAgdGhpcy5kb2N1bWVudC5fd3JpdGUoJ2VuZG9iaicpO1xuICAgIHRoaXMuZG9jdW1lbnQuX3JlZkVuZCh0aGlzKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5pZH0gJHt0aGlzLmdlbn0gUmA7XG4gIH1cbn1cblxuY29uc3QgZkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgxKTtcbmNvbnN0IHVBcnJheSA9IG5ldyBVaW50MzJBcnJheShmQXJyYXkuYnVmZmVyKTtcbmZ1bmN0aW9uIFBERk51bWJlcihuKSB7XG4gIGNvbnN0IHJvdW5kZWQgPSBNYXRoLmZyb3VuZChuKTtcbiAgaWYgKHJvdW5kZWQgPD0gbikgcmV0dXJuIHJvdW5kZWQ7XG4gIGZBcnJheVswXSA9IG47XG4gIGlmIChuIDw9IDApIHtcbiAgICB1QXJyYXlbMF0gKz0gMTtcbiAgfSBlbHNlIHtcbiAgICB1QXJyYXlbMF0gLT0gMTtcbiAgfVxuICByZXR1cm4gZkFycmF5WzBdO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU2lkZXMoc2lkZXMpIHtcbiAgbGV0IGRlZmF1bHREZWZpbml0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIGxldCB0cmFuc2Zvcm1lciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdiA9PiB2O1xuICBpZiAoc2lkZXMgPT0gbnVsbCB8fCB0eXBlb2Ygc2lkZXMgPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKHNpZGVzKS5sZW5ndGggPT09IDApIHtcbiAgICBzaWRlcyA9IGRlZmF1bHREZWZpbml0aW9uO1xuICB9XG4gIGlmIChzaWRlcyA9PSBudWxsIHx8IHR5cGVvZiBzaWRlcyAhPT0gJ29iamVjdCcpIHtcbiAgICBzaWRlcyA9IHtcbiAgICAgIHRvcDogc2lkZXMsXG4gICAgICByaWdodDogc2lkZXMsXG4gICAgICBib3R0b206IHNpZGVzLFxuICAgICAgbGVmdDogc2lkZXNcbiAgICB9O1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2lkZXMpKSB7XG4gICAgaWYgKHNpZGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgc2lkZXMgPSB7XG4gICAgICAgIHZlcnRpY2FsOiBzaWRlc1swXSxcbiAgICAgICAgaG9yaXpvbnRhbDogc2lkZXNbMV1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpZGVzID0ge1xuICAgICAgICB0b3A6IHNpZGVzWzBdLFxuICAgICAgICByaWdodDogc2lkZXNbMV0sXG4gICAgICAgIGJvdHRvbTogc2lkZXNbMl0sXG4gICAgICAgIGxlZnQ6IHNpZGVzWzNdXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBpZiAoJ3ZlcnRpY2FsJyBpbiBzaWRlcyB8fCAnaG9yaXpvbnRhbCcgaW4gc2lkZXMpIHtcbiAgICBzaWRlcyA9IHtcbiAgICAgIHRvcDogc2lkZXMudmVydGljYWwsXG4gICAgICByaWdodDogc2lkZXMuaG9yaXpvbnRhbCxcbiAgICAgIGJvdHRvbTogc2lkZXMudmVydGljYWwsXG4gICAgICBsZWZ0OiBzaWRlcy5ob3Jpem9udGFsXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvcDogdHJhbnNmb3JtZXIoc2lkZXMudG9wKSxcbiAgICByaWdodDogdHJhbnNmb3JtZXIoc2lkZXMucmlnaHQpLFxuICAgIGJvdHRvbTogdHJhbnNmb3JtZXIoc2lkZXMuYm90dG9tKSxcbiAgICBsZWZ0OiB0cmFuc2Zvcm1lcihzaWRlcy5sZWZ0KVxuICB9O1xufVxuY29uc3QgTU1fVE9fQ00gPSAxIC8gMTA7XG5jb25zdCBDTV9UT19JTiA9IDEgLyAyLjU0O1xuY29uc3QgUFhfVE9fSU4gPSAxIC8gOTY7XG5jb25zdCBJTl9UT19QVCA9IDcyO1xuY29uc3QgUENfVE9fUFQgPSAxMjtcbmZ1bmN0aW9uIGNvc2luZShhKSB7XG4gIGlmIChhID09PSAwKSByZXR1cm4gMTtcbiAgaWYgKGEgPT09IDkwKSByZXR1cm4gMDtcbiAgaWYgKGEgPT09IDE4MCkgcmV0dXJuIC0xO1xuICBpZiAoYSA9PT0gMjcwKSByZXR1cm4gMDtcbiAgcmV0dXJuIE1hdGguY29zKGEgKiBNYXRoLlBJIC8gMTgwKTtcbn1cbmZ1bmN0aW9uIHNpbmUoYSkge1xuICBpZiAoYSA9PT0gMCkgcmV0dXJuIDA7XG4gIGlmIChhID09PSA5MCkgcmV0dXJuIDE7XG4gIGlmIChhID09PSAxODApIHJldHVybiAwO1xuICBpZiAoYSA9PT0gMjcwKSByZXR1cm4gLTE7XG4gIHJldHVybiBNYXRoLnNpbihhICogTWF0aC5QSSAvIDE4MCk7XG59XG5cbmNvbnN0IERFRkFVTFRfTUFSR0lOUyA9IHtcbiAgdG9wOiA3MixcbiAgbGVmdDogNzIsXG4gIGJvdHRvbTogNzIsXG4gIHJpZ2h0OiA3MlxufTtcbmNvbnN0IFNJWkVTID0ge1xuICAnNEEwJzogWzQ3NjcuODcsIDY3NDAuNzldLFxuICAnMkEwJzogWzMzNzAuMzksIDQ3NjcuODddLFxuICBBMDogWzIzODMuOTQsIDMzNzAuMzldLFxuICBBMTogWzE2ODMuNzgsIDIzODMuOTRdLFxuICBBMjogWzExOTAuNTUsIDE2ODMuNzhdLFxuICBBMzogWzg0MS44OSwgMTE5MC41NV0sXG4gIEE0OiBbNTk1LjI4LCA4NDEuODldLFxuICBBNTogWzQxOS41MywgNTk1LjI4XSxcbiAgQTY6IFsyOTcuNjQsIDQxOS41M10sXG4gIEE3OiBbMjA5Ljc2LCAyOTcuNjRdLFxuICBBODogWzE0Ny40LCAyMDkuNzZdLFxuICBBOTogWzEwNC44OCwgMTQ3LjRdLFxuICBBMTA6IFs3My43LCAxMDQuODhdLFxuICBCMDogWzI4MzQuNjUsIDQwMDguMTldLFxuICBCMTogWzIwMDQuMDksIDI4MzQuNjVdLFxuICBCMjogWzE0MTcuMzIsIDIwMDQuMDldLFxuICBCMzogWzEwMDAuNjMsIDE0MTcuMzJdLFxuICBCNDogWzcwOC42NiwgMTAwMC42M10sXG4gIEI1OiBbNDk4LjksIDcwOC42Nl0sXG4gIEI2OiBbMzU0LjMzLCA0OTguOV0sXG4gIEI3OiBbMjQ5LjQ1LCAzNTQuMzNdLFxuICBCODogWzE3NS43NSwgMjQ5LjQ1XSxcbiAgQjk6IFsxMjQuNzIsIDE3NS43NV0sXG4gIEIxMDogWzg3Ljg3LCAxMjQuNzJdLFxuICBDMDogWzI1OTkuMzcsIDM2NzYuNTRdLFxuICBDMTogWzE4MzYuODUsIDI1OTkuMzddLFxuICBDMjogWzEyOTguMjcsIDE4MzYuODVdLFxuICBDMzogWzkxOC40MywgMTI5OC4yN10sXG4gIEM0OiBbNjQ5LjEzLCA5MTguNDNdLFxuICBDNTogWzQ1OS4yMSwgNjQ5LjEzXSxcbiAgQzY6IFszMjMuMTUsIDQ1OS4yMV0sXG4gIEM3OiBbMjI5LjYxLCAzMjMuMTVdLFxuICBDODogWzE2MS41NywgMjI5LjYxXSxcbiAgQzk6IFsxMTMuMzksIDE2MS41N10sXG4gIEMxMDogWzc5LjM3LCAxMTMuMzldLFxuICBSQTA6IFsyNDM3LjgsIDM0NTguMjddLFxuICBSQTE6IFsxNzI5LjEzLCAyNDM3LjhdLFxuICBSQTI6IFsxMjE4LjksIDE3MjkuMTNdLFxuICBSQTM6IFs4NjQuNTcsIDEyMTguOV0sXG4gIFJBNDogWzYwOS40NSwgODY0LjU3XSxcbiAgU1JBMDogWzI1NTEuMTgsIDM2MjguMzVdLFxuICBTUkExOiBbMTgxNC4xNywgMjU1MS4xOF0sXG4gIFNSQTI6IFsxMjc1LjU5LCAxODE0LjE3XSxcbiAgU1JBMzogWzkwNy4wOSwgMTI3NS41OV0sXG4gIFNSQTQ6IFs2MzcuOCwgOTA3LjA5XSxcbiAgRVhFQ1VUSVZFOiBbNTIxLjg2LCA3NTYuMF0sXG4gIEZPTElPOiBbNjEyLjAsIDkzNi4wXSxcbiAgTEVHQUw6IFs2MTIuMCwgMTAwOC4wXSxcbiAgTEVUVEVSOiBbNjEyLjAsIDc5Mi4wXSxcbiAgVEFCTE9JRDogWzc5Mi4wLCAxMjI0LjBdXG59O1xuY2xhc3MgUERGUGFnZSB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnNpemUgPSBvcHRpb25zLnNpemUgfHwgJ2xldHRlcic7XG4gICAgdGhpcy5sYXlvdXQgPSBvcHRpb25zLmxheW91dCB8fCAncG9ydHJhaXQnO1xuICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBBcnJheS5pc0FycmF5KHRoaXMuc2l6ZSkgPyB0aGlzLnNpemUgOiBTSVpFU1t0aGlzLnNpemUudG9VcHBlckNhc2UoKV07XG4gICAgdGhpcy53aWR0aCA9IGRpbWVuc2lvbnNbdGhpcy5sYXlvdXQgPT09ICdwb3J0cmFpdCcgPyAwIDogMV07XG4gICAgdGhpcy5oZWlnaHQgPSBkaW1lbnNpb25zW3RoaXMubGF5b3V0ID09PSAncG9ydHJhaXQnID8gMSA6IDBdO1xuICAgIHRoaXMuY29udGVudCA9IHRoaXMuZG9jdW1lbnQucmVmKCk7XG4gICAgaWYgKG9wdGlvbnMuZm9udCkgZG9jdW1lbnQuZm9udChvcHRpb25zLmZvbnQsIG9wdGlvbnMuZm9udEZhbWlseSk7XG4gICAgaWYgKG9wdGlvbnMuZm9udFNpemUpIGRvY3VtZW50LmZvbnRTaXplKG9wdGlvbnMuZm9udFNpemUpO1xuICAgIHRoaXMubWFyZ2lucyA9IG5vcm1hbGl6ZVNpZGVzKG9wdGlvbnMubWFyZ2luID8/IG9wdGlvbnMubWFyZ2lucywgREVGQVVMVF9NQVJHSU5TLCB4ID0+IGRvY3VtZW50LnNpemVUb1BvaW50KHgsIDAsIHRoaXMpKTtcbiAgICB0aGlzLnJlc291cmNlcyA9IHRoaXMuZG9jdW1lbnQucmVmKHtcbiAgICAgIFByb2NTZXQ6IFsnUERGJywgJ1RleHQnLCAnSW1hZ2VCJywgJ0ltYWdlQycsICdJbWFnZUknXVxuICAgIH0pO1xuICAgIHRoaXMuZGljdGlvbmFyeSA9IHRoaXMuZG9jdW1lbnQucmVmKHtcbiAgICAgIFR5cGU6ICdQYWdlJyxcbiAgICAgIFBhcmVudDogdGhpcy5kb2N1bWVudC5fcm9vdC5kYXRhLlBhZ2VzLFxuICAgICAgTWVkaWFCb3g6IFswLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF0sXG4gICAgICBDb250ZW50czogdGhpcy5jb250ZW50LFxuICAgICAgUmVzb3VyY2VzOiB0aGlzLnJlc291cmNlc1xuICAgIH0pO1xuICAgIHRoaXMubWFya2luZ3MgPSBbXTtcbiAgfVxuICBnZXQgZm9udHMoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzb3VyY2VzLmRhdGE7XG4gICAgcmV0dXJuIGRhdGEuRm9udCAhPSBudWxsID8gZGF0YS5Gb250IDogZGF0YS5Gb250ID0ge307XG4gIH1cbiAgZ2V0IHhvYmplY3RzKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc291cmNlcy5kYXRhO1xuICAgIHJldHVybiBkYXRhLlhPYmplY3QgIT0gbnVsbCA/IGRhdGEuWE9iamVjdCA6IGRhdGEuWE9iamVjdCA9IHt9O1xuICB9XG4gIGdldCBleHRfZ3N0YXRlcygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXNvdXJjZXMuZGF0YTtcbiAgICByZXR1cm4gZGF0YS5FeHRHU3RhdGUgIT0gbnVsbCA/IGRhdGEuRXh0R1N0YXRlIDogZGF0YS5FeHRHU3RhdGUgPSB7fTtcbiAgfVxuICBnZXQgcGF0dGVybnMoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucmVzb3VyY2VzLmRhdGE7XG4gICAgcmV0dXJuIGRhdGEuUGF0dGVybiAhPSBudWxsID8gZGF0YS5QYXR0ZXJuIDogZGF0YS5QYXR0ZXJuID0ge307XG4gIH1cbiAgZ2V0IGNvbG9yU3BhY2VzKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlc291cmNlcy5kYXRhO1xuICAgIHJldHVybiBkYXRhLkNvbG9yU3BhY2UgfHwgKGRhdGEuQ29sb3JTcGFjZSA9IHt9KTtcbiAgfVxuICBnZXQgYW5ub3RhdGlvbnMoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGljdGlvbmFyeS5kYXRhO1xuICAgIHJldHVybiBkYXRhLkFubm90cyAhPSBudWxsID8gZGF0YS5Bbm5vdHMgOiBkYXRhLkFubm90cyA9IFtdO1xuICB9XG4gIGdldCBzdHJ1Y3RQYXJlbnRUcmVlS2V5KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRpY3Rpb25hcnkuZGF0YTtcbiAgICByZXR1cm4gZGF0YS5TdHJ1Y3RQYXJlbnRzICE9IG51bGwgPyBkYXRhLlN0cnVjdFBhcmVudHMgOiBkYXRhLlN0cnVjdFBhcmVudHMgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZVN0cnVjdFBhcmVudFRyZWVOZXh0S2V5KCk7XG4gIH1cbiAgZ2V0IGNvbnRlbnRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0IC0gdGhpcy5tYXJnaW5zLnJpZ2h0O1xuICB9XG4gIGdldCBjb250ZW50SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmhlaWdodCAtIHRoaXMubWFyZ2lucy50b3AgLSB0aGlzLm1hcmdpbnMuYm90dG9tO1xuICB9XG4gIG1heFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVpZ2h0IC0gdGhpcy5tYXJnaW5zLmJvdHRvbTtcbiAgfVxuICB3cml0ZShjaHVuaykge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQud3JpdGUoY2h1bmspO1xuICB9XG4gIF9zZXRUYWJPcmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGljdGlvbmFyeS5UYWJzICYmIHRoaXMuZG9jdW1lbnQuaGFzTWFya0luZm9EaWN0aW9uYXJ5KCkpIHtcbiAgICAgIHRoaXMuZGljdGlvbmFyeS5kYXRhLlRhYnMgPSAnUyc7XG4gICAgfVxuICB9XG4gIGVuZCgpIHtcbiAgICB0aGlzLl9zZXRUYWJPcmRlcigpO1xuICAgIHRoaXMuZGljdGlvbmFyeS5lbmQoKTtcbiAgICB0aGlzLnJlc291cmNlcy5kYXRhLkNvbG9yU3BhY2UgPSB0aGlzLnJlc291cmNlcy5kYXRhLkNvbG9yU3BhY2UgfHwge307XG4gICAgZm9yIChsZXQgY29sb3Igb2YgT2JqZWN0LnZhbHVlcyh0aGlzLmRvY3VtZW50LnNwb3RDb2xvcnMpKSB7XG4gICAgICB0aGlzLnJlc291cmNlcy5kYXRhLkNvbG9yU3BhY2VbY29sb3IuaWRdID0gY29sb3I7XG4gICAgfVxuICAgIHRoaXMucmVzb3VyY2VzLmVuZCgpO1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZW5kKCk7XG4gIH1cbn1cblxuY2xhc3MgUERGTmFtZVRyZWUgZXh0ZW5kcyBQREZUcmVlIHtcbiAgX2NvbXBhcmVLZXlzKGEsIGIpIHtcbiAgICByZXR1cm4gYS5sb2NhbGVDb21wYXJlKGIpO1xuICB9XG4gIF9rZXlzTmFtZSgpIHtcbiAgICByZXR1cm4gJ05hbWVzJztcbiAgfVxuICBfZGF0YUZvcktleShrKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJpbmcoayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5SYW5nZSh2YWx1ZSwgcmFuZ2VHcm91cCkge1xuICBpZiAodmFsdWUgPCByYW5nZUdyb3VwWzBdKSByZXR1cm4gZmFsc2U7XG4gIGxldCBzdGFydFJhbmdlID0gMDtcbiAgbGV0IGVuZFJhbmdlID0gcmFuZ2VHcm91cC5sZW5ndGggLyAyO1xuICB3aGlsZSAoc3RhcnRSYW5nZSA8PSBlbmRSYW5nZSkge1xuICAgIGNvbnN0IG1pZGRsZVJhbmdlID0gTWF0aC5mbG9vcigoc3RhcnRSYW5nZSArIGVuZFJhbmdlKSAvIDIpO1xuICAgIGNvbnN0IGFycmF5SW5kZXggPSBtaWRkbGVSYW5nZSAqIDI7XG4gICAgaWYgKHZhbHVlID49IHJhbmdlR3JvdXBbYXJyYXlJbmRleF0gJiYgdmFsdWUgPD0gcmFuZ2VHcm91cFthcnJheUluZGV4ICsgMV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPiByYW5nZUdyb3VwW2FycmF5SW5kZXggKyAxXSkge1xuICAgICAgc3RhcnRSYW5nZSA9IG1pZGRsZVJhbmdlICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kUmFuZ2UgPSBtaWRkbGVSYW5nZSAtIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgdW5hc3NpZ25lZF9jb2RlX3BvaW50cyA9IFsweDAyMjEsIDB4MDIyMSwgMHgwMjM0LCAweDAyNGYsIDB4MDJhZSwgMHgwMmFmLCAweDAyZWYsIDB4MDJmZiwgMHgwMzUwLCAweDAzNWYsIDB4MDM3MCwgMHgwMzczLCAweDAzNzYsIDB4MDM3OSwgMHgwMzdiLCAweDAzN2QsIDB4MDM3ZiwgMHgwMzgzLCAweDAzOGIsIDB4MDM4YiwgMHgwMzhkLCAweDAzOGQsIDB4MDNhMiwgMHgwM2EyLCAweDAzY2YsIDB4MDNjZiwgMHgwM2Y3LCAweDAzZmYsIDB4MDQ4NywgMHgwNDg3LCAweDA0Y2YsIDB4MDRjZiwgMHgwNGY2LCAweDA0ZjcsIDB4MDRmYSwgMHgwNGZmLCAweDA1MTAsIDB4MDUzMCwgMHgwNTU3LCAweDA1NTgsIDB4MDU2MCwgMHgwNTYwLCAweDA1ODgsIDB4MDU4OCwgMHgwNThiLCAweDA1OTAsIDB4MDVhMiwgMHgwNWEyLCAweDA1YmEsIDB4MDViYSwgMHgwNWM1LCAweDA1Y2YsIDB4MDVlYiwgMHgwNWVmLCAweDA1ZjUsIDB4MDYwYiwgMHgwNjBkLCAweDA2MWEsIDB4MDYxYywgMHgwNjFlLCAweDA2MjAsIDB4MDYyMCwgMHgwNjNiLCAweDA2M2YsIDB4MDY1NiwgMHgwNjVmLCAweDA2ZWUsIDB4MDZlZiwgMHgwNmZmLCAweDA2ZmYsIDB4MDcwZSwgMHgwNzBlLCAweDA3MmQsIDB4MDcyZiwgMHgwNzRiLCAweDA3N2YsIDB4MDdiMiwgMHgwOTAwLCAweDA5MDQsIDB4MDkwNCwgMHgwOTNhLCAweDA5M2IsIDB4MDk0ZSwgMHgwOTRmLCAweDA5NTUsIDB4MDk1NywgMHgwOTcxLCAweDA5ODAsIDB4MDk4NCwgMHgwOTg0LCAweDA5OGQsIDB4MDk4ZSwgMHgwOTkxLCAweDA5OTIsIDB4MDlhOSwgMHgwOWE5LCAweDA5YjEsIDB4MDliMSwgMHgwOWIzLCAweDA5YjUsIDB4MDliYSwgMHgwOWJiLCAweDA5YmQsIDB4MDliZCwgMHgwOWM1LCAweDA5YzYsIDB4MDljOSwgMHgwOWNhLCAweDA5Y2UsIDB4MDlkNiwgMHgwOWQ4LCAweDA5ZGIsIDB4MDlkZSwgMHgwOWRlLCAweDA5ZTQsIDB4MDllNSwgMHgwOWZiLCAweDBhMDEsIDB4MGEwMywgMHgwYTA0LCAweDBhMGIsIDB4MGEwZSwgMHgwYTExLCAweDBhMTIsIDB4MGEyOSwgMHgwYTI5LCAweDBhMzEsIDB4MGEzMSwgMHgwYTM0LCAweDBhMzQsIDB4MGEzNywgMHgwYTM3LCAweDBhM2EsIDB4MGEzYiwgMHgwYTNkLCAweDBhM2QsIDB4MGE0MywgMHgwYTQ2LCAweDBhNDksIDB4MGE0YSwgMHgwYTRlLCAweDBhNTgsIDB4MGE1ZCwgMHgwYTVkLCAweDBhNWYsIDB4MGE2NSwgMHgwYTc1LCAweDBhODAsIDB4MGE4NCwgMHgwYTg0LCAweDBhOGMsIDB4MGE4YywgMHgwYThlLCAweDBhOGUsIDB4MGE5MiwgMHgwYTkyLCAweDBhYTksIDB4MGFhOSwgMHgwYWIxLCAweDBhYjEsIDB4MGFiNCwgMHgwYWI0LCAweDBhYmEsIDB4MGFiYiwgMHgwYWM2LCAweDBhYzYsIDB4MGFjYSwgMHgwYWNhLCAweDBhY2UsIDB4MGFjZiwgMHgwYWQxLCAweDBhZGYsIDB4MGFlMSwgMHgwYWU1LCAweDBhZjAsIDB4MGIwMCwgMHgwYjA0LCAweDBiMDQsIDB4MGIwZCwgMHgwYjBlLCAweDBiMTEsIDB4MGIxMiwgMHgwYjI5LCAweDBiMjksIDB4MGIzMSwgMHgwYjMxLCAweDBiMzQsIDB4MGIzNSwgMHgwYjNhLCAweDBiM2IsIDB4MGI0NCwgMHgwYjQ2LCAweDBiNDksIDB4MGI0YSwgMHgwYjRlLCAweDBiNTUsIDB4MGI1OCwgMHgwYjViLCAweDBiNWUsIDB4MGI1ZSwgMHgwYjYyLCAweDBiNjUsIDB4MGI3MSwgMHgwYjgxLCAweDBiODQsIDB4MGI4NCwgMHgwYjhiLCAweDBiOGQsIDB4MGI5MSwgMHgwYjkxLCAweDBiOTYsIDB4MGI5OCwgMHgwYjliLCAweDBiOWIsIDB4MGI5ZCwgMHgwYjlkLCAweDBiYTAsIDB4MGJhMiwgMHgwYmE1LCAweDBiYTcsIDB4MGJhYiwgMHgwYmFkLCAweDBiYjYsIDB4MGJiNiwgMHgwYmJhLCAweDBiYmQsIDB4MGJjMywgMHgwYmM1LCAweDBiYzksIDB4MGJjOSwgMHgwYmNlLCAweDBiZDYsIDB4MGJkOCwgMHgwYmU2LCAweDBiZjMsIDB4MGMwMCwgMHgwYzA0LCAweDBjMDQsIDB4MGMwZCwgMHgwYzBkLCAweDBjMTEsIDB4MGMxMSwgMHgwYzI5LCAweDBjMjksIDB4MGMzNCwgMHgwYzM0LCAweDBjM2EsIDB4MGMzZCwgMHgwYzQ1LCAweDBjNDUsIDB4MGM0OSwgMHgwYzQ5LCAweDBjNGUsIDB4MGM1NCwgMHgwYzU3LCAweDBjNWYsIDB4MGM2MiwgMHgwYzY1LCAweDBjNzAsIDB4MGM4MSwgMHgwYzg0LCAweDBjODQsIDB4MGM4ZCwgMHgwYzhkLCAweDBjOTEsIDB4MGM5MSwgMHgwY2E5LCAweDBjYTksIDB4MGNiNCwgMHgwY2I0LCAweDBjYmEsIDB4MGNiZCwgMHgwY2M1LCAweDBjYzUsIDB4MGNjOSwgMHgwY2M5LCAweDBjY2UsIDB4MGNkNCwgMHgwY2Q3LCAweDBjZGQsIDB4MGNkZiwgMHgwY2RmLCAweDBjZTIsIDB4MGNlNSwgMHgwY2YwLCAweDBkMDEsIDB4MGQwNCwgMHgwZDA0LCAweDBkMGQsIDB4MGQwZCwgMHgwZDExLCAweDBkMTEsIDB4MGQyOSwgMHgwZDI5LCAweDBkM2EsIDB4MGQzZCwgMHgwZDQ0LCAweDBkNDUsIDB4MGQ0OSwgMHgwZDQ5LCAweDBkNGUsIDB4MGQ1NiwgMHgwZDU4LCAweDBkNWYsIDB4MGQ2MiwgMHgwZDY1LCAweDBkNzAsIDB4MGQ4MSwgMHgwZDg0LCAweDBkODQsIDB4MGQ5NywgMHgwZDk5LCAweDBkYjIsIDB4MGRiMiwgMHgwZGJjLCAweDBkYmMsIDB4MGRiZSwgMHgwZGJmLCAweDBkYzcsIDB4MGRjOSwgMHgwZGNiLCAweDBkY2UsIDB4MGRkNSwgMHgwZGQ1LCAweDBkZDcsIDB4MGRkNywgMHgwZGUwLCAweDBkZjEsIDB4MGRmNSwgMHgwZTAwLCAweDBlM2IsIDB4MGUzZSwgMHgwZTVjLCAweDBlODAsIDB4MGU4MywgMHgwZTgzLCAweDBlODUsIDB4MGU4NiwgMHgwZTg5LCAweDBlODksIDB4MGU4YiwgMHgwZThjLCAweDBlOGUsIDB4MGU5MywgMHgwZTk4LCAweDBlOTgsIDB4MGVhMCwgMHgwZWEwLCAweDBlYTQsIDB4MGVhNCwgMHgwZWE2LCAweDBlYTYsIDB4MGVhOCwgMHgwZWE5LCAweDBlYWMsIDB4MGVhYywgMHgwZWJhLCAweDBlYmEsIDB4MGViZSwgMHgwZWJmLCAweDBlYzUsIDB4MGVjNSwgMHgwZWM3LCAweDBlYzcsIDB4MGVjZSwgMHgwZWNmLCAweDBlZGEsIDB4MGVkYiwgMHgwZWRlLCAweDBlZmYsIDB4MGY0OCwgMHgwZjQ4LCAweDBmNmIsIDB4MGY3MCwgMHgwZjhjLCAweDBmOGYsIDB4MGY5OCwgMHgwZjk4LCAweDBmYmQsIDB4MGZiZCwgMHgwZmNkLCAweDBmY2UsIDB4MGZkMCwgMHgwZmZmLCAweDEwMjIsIDB4MTAyMiwgMHgxMDI4LCAweDEwMjgsIDB4MTAyYiwgMHgxMDJiLCAweDEwMzMsIDB4MTAzNSwgMHgxMDNhLCAweDEwM2YsIDB4MTA1YSwgMHgxMDlmLCAweDEwYzYsIDB4MTBjZiwgMHgxMGY5LCAweDEwZmEsIDB4MTBmYywgMHgxMGZmLCAweDExNWEsIDB4MTE1ZSwgMHgxMWEzLCAweDExYTcsIDB4MTFmYSwgMHgxMWZmLCAweDEyMDcsIDB4MTIwNywgMHgxMjQ3LCAweDEyNDcsIDB4MTI0OSwgMHgxMjQ5LCAweDEyNGUsIDB4MTI0ZiwgMHgxMjU3LCAweDEyNTcsIDB4MTI1OSwgMHgxMjU5LCAweDEyNWUsIDB4MTI1ZiwgMHgxMjg3LCAweDEyODcsIDB4MTI4OSwgMHgxMjg5LCAweDEyOGUsIDB4MTI4ZiwgMHgxMmFmLCAweDEyYWYsIDB4MTJiMSwgMHgxMmIxLCAweDEyYjYsIDB4MTJiNywgMHgxMmJmLCAweDEyYmYsIDB4MTJjMSwgMHgxMmMxLCAweDEyYzYsIDB4MTJjNywgMHgxMmNmLCAweDEyY2YsIDB4MTJkNywgMHgxMmQ3LCAweDEyZWYsIDB4MTJlZiwgMHgxMzBmLCAweDEzMGYsIDB4MTMxMSwgMHgxMzExLCAweDEzMTYsIDB4MTMxNywgMHgxMzFmLCAweDEzMWYsIDB4MTM0NywgMHgxMzQ3LCAweDEzNWIsIDB4MTM2MCwgMHgxMzdkLCAweDEzOWYsIDB4MTNmNSwgMHgxNDAwLCAweDE2NzcsIDB4MTY3ZiwgMHgxNjlkLCAweDE2OWYsIDB4MTZmMSwgMHgxNmZmLCAweDE3MGQsIDB4MTcwZCwgMHgxNzE1LCAweDE3MWYsIDB4MTczNywgMHgxNzNmLCAweDE3NTQsIDB4MTc1ZiwgMHgxNzZkLCAweDE3NmQsIDB4MTc3MSwgMHgxNzcxLCAweDE3NzQsIDB4MTc3ZiwgMHgxN2RkLCAweDE3ZGYsIDB4MTdlYSwgMHgxN2ZmLCAweDE4MGYsIDB4MTgwZiwgMHgxODFhLCAweDE4MWYsIDB4MTg3OCwgMHgxODdmLCAweDE4YWEsIDB4MWRmZiwgMHgxZTljLCAweDFlOWYsIDB4MWVmYSwgMHgxZWZmLCAweDFmMTYsIDB4MWYxNywgMHgxZjFlLCAweDFmMWYsIDB4MWY0NiwgMHgxZjQ3LCAweDFmNGUsIDB4MWY0ZiwgMHgxZjU4LCAweDFmNTgsIDB4MWY1YSwgMHgxZjVhLCAweDFmNWMsIDB4MWY1YywgMHgxZjVlLCAweDFmNWUsIDB4MWY3ZSwgMHgxZjdmLCAweDFmYjUsIDB4MWZiNSwgMHgxZmM1LCAweDFmYzUsIDB4MWZkNCwgMHgxZmQ1LCAweDFmZGMsIDB4MWZkYywgMHgxZmYwLCAweDFmZjEsIDB4MWZmNSwgMHgxZmY1LCAweDFmZmYsIDB4MWZmZiwgMHgyMDUzLCAweDIwNTYsIDB4MjA1OCwgMHgyMDVlLCAweDIwNjQsIDB4MjA2OSwgMHgyMDcyLCAweDIwNzMsIDB4MjA4ZiwgMHgyMDlmLCAweDIwYjIsIDB4MjBjZiwgMHgyMGViLCAweDIwZmYsIDB4MjEzYiwgMHgyMTNjLCAweDIxNGMsIDB4MjE1MiwgMHgyMTg0LCAweDIxOGYsIDB4MjNjZiwgMHgyM2ZmLCAweDI0MjcsIDB4MjQzZiwgMHgyNDRiLCAweDI0NWYsIDB4MjRmZiwgMHgyNGZmLCAweDI2MTQsIDB4MjYxNSwgMHgyNjE4LCAweDI2MTgsIDB4MjY3ZSwgMHgyNjdmLCAweDI2OGEsIDB4MjcwMCwgMHgyNzA1LCAweDI3MDUsIDB4MjcwYSwgMHgyNzBiLCAweDI3MjgsIDB4MjcyOCwgMHgyNzRjLCAweDI3NGMsIDB4Mjc0ZSwgMHgyNzRlLCAweDI3NTMsIDB4Mjc1NSwgMHgyNzU3LCAweDI3NTcsIDB4Mjc1ZiwgMHgyNzYwLCAweDI3OTUsIDB4Mjc5NywgMHgyN2IwLCAweDI3YjAsIDB4MjdiZiwgMHgyN2NmLCAweDI3ZWMsIDB4MjdlZiwgMHgyYjAwLCAweDJlN2YsIDB4MmU5YSwgMHgyZTlhLCAweDJlZjQsIDB4MmVmZiwgMHgyZmQ2LCAweDJmZWYsIDB4MmZmYywgMHgyZmZmLCAweDMwNDAsIDB4MzA0MCwgMHgzMDk3LCAweDMwOTgsIDB4MzEwMCwgMHgzMTA0LCAweDMxMmQsIDB4MzEzMCwgMHgzMThmLCAweDMxOGYsIDB4MzFiOCwgMHgzMWVmLCAweDMyMWQsIDB4MzIxZiwgMHgzMjQ0LCAweDMyNTAsIDB4MzI3YywgMHgzMjdlLCAweDMyY2MsIDB4MzJjZiwgMHgzMmZmLCAweDMyZmYsIDB4MzM3NywgMHgzMzdhLCAweDMzZGUsIDB4MzNkZiwgMHgzM2ZmLCAweDMzZmYsIDB4NGRiNiwgMHg0ZGZmLCAweDlmYTYsIDB4OWZmZiwgMHhhNDhkLCAweGE0OGYsIDB4YTRjNywgMHhhYmZmLCAweGQ3YTQsIDB4ZDdmZiwgMHhmYTJlLCAweGZhMmYsIDB4ZmE2YiwgMHhmYWZmLCAweGZiMDcsIDB4ZmIxMiwgMHhmYjE4LCAweGZiMWMsIDB4ZmIzNywgMHhmYjM3LCAweGZiM2QsIDB4ZmIzZCwgMHhmYjNmLCAweGZiM2YsIDB4ZmI0MiwgMHhmYjQyLCAweGZiNDUsIDB4ZmI0NSwgMHhmYmIyLCAweGZiZDIsIDB4ZmQ0MCwgMHhmZDRmLCAweGZkOTAsIDB4ZmQ5MSwgMHhmZGM4LCAweGZkY2YsIDB4ZmRmZCwgMHhmZGZmLCAweGZlMTAsIDB4ZmUxZiwgMHhmZTI0LCAweGZlMmYsIDB4ZmU0NywgMHhmZTQ4LCAweGZlNTMsIDB4ZmU1MywgMHhmZTY3LCAweGZlNjcsIDB4ZmU2YywgMHhmZTZmLCAweGZlNzUsIDB4ZmU3NSwgMHhmZWZkLCAweGZlZmUsIDB4ZmYwMCwgMHhmZjAwLCAweGZmYmYsIDB4ZmZjMSwgMHhmZmM4LCAweGZmYzksIDB4ZmZkMCwgMHhmZmQxLCAweGZmZDgsIDB4ZmZkOSwgMHhmZmRkLCAweGZmZGYsIDB4ZmZlNywgMHhmZmU3LCAweGZmZWYsIDB4ZmZmOCwgMHgxMDAwMCwgMHgxMDJmZiwgMHgxMDMxZiwgMHgxMDMxZiwgMHgxMDMyNCwgMHgxMDMyZiwgMHgxMDM0YiwgMHgxMDNmZiwgMHgxMDQyNiwgMHgxMDQyNywgMHgxMDQ0ZSwgMHgxY2ZmZiwgMHgxZDBmNiwgMHgxZDBmZiwgMHgxZDEyNywgMHgxZDEyOSwgMHgxZDFkZSwgMHgxZDNmZiwgMHgxZDQ1NSwgMHgxZDQ1NSwgMHgxZDQ5ZCwgMHgxZDQ5ZCwgMHgxZDRhMCwgMHgxZDRhMSwgMHgxZDRhMywgMHgxZDRhNCwgMHgxZDRhNywgMHgxZDRhOCwgMHgxZDRhZCwgMHgxZDRhZCwgMHgxZDRiYSwgMHgxZDRiYSwgMHgxZDRiYywgMHgxZDRiYywgMHgxZDRjMSwgMHgxZDRjMSwgMHgxZDRjNCwgMHgxZDRjNCwgMHgxZDUwNiwgMHgxZDUwNiwgMHgxZDUwYiwgMHgxZDUwYywgMHgxZDUxNSwgMHgxZDUxNSwgMHgxZDUxZCwgMHgxZDUxZCwgMHgxZDUzYSwgMHgxZDUzYSwgMHgxZDUzZiwgMHgxZDUzZiwgMHgxZDU0NSwgMHgxZDU0NSwgMHgxZDU0NywgMHgxZDU0OSwgMHgxZDU1MSwgMHgxZDU1MSwgMHgxZDZhNCwgMHgxZDZhNywgMHgxZDdjYSwgMHgxZDdjZCwgMHgxZDgwMCwgMHgxZmZmZCwgMHgyYTZkNywgMHgyZjdmZiwgMHgyZmExZSwgMHgyZmZmZCwgMHgzMDAwMCwgMHgzZmZmZCwgMHg0MDAwMCwgMHg0ZmZmZCwgMHg1MDAwMCwgMHg1ZmZmZCwgMHg2MDAwMCwgMHg2ZmZmZCwgMHg3MDAwMCwgMHg3ZmZmZCwgMHg4MDAwMCwgMHg4ZmZmZCwgMHg5MDAwMCwgMHg5ZmZmZCwgMHhhMDAwMCwgMHhhZmZmZCwgMHhiMDAwMCwgMHhiZmZmZCwgMHhjMDAwMCwgMHhjZmZmZCwgMHhkMDAwMCwgMHhkZmZmZCwgMHhlMDAwMCwgMHhlMDAwMCwgMHhlMDAwMiwgMHhlMDAxZiwgMHhlMDA4MCwgMHhlZmZmZF07XG5jb25zdCBpc1VuYXNzaWduZWRDb2RlUG9pbnQgPSBjaGFyYWN0ZXIgPT4gaW5SYW5nZShjaGFyYWN0ZXIsIHVuYXNzaWduZWRfY29kZV9wb2ludHMpO1xuY29uc3QgY29tbW9ubHlfbWFwcGVkX3RvX25vdGhpbmcgPSBbMHgwMGFkLCAweDAwYWQsIDB4MDM0ZiwgMHgwMzRmLCAweDE4MDYsIDB4MTgwNiwgMHgxODBiLCAweDE4MGIsIDB4MTgwYywgMHgxODBjLCAweDE4MGQsIDB4MTgwZCwgMHgyMDBiLCAweDIwMGIsIDB4MjAwYywgMHgyMDBjLCAweDIwMGQsIDB4MjAwZCwgMHgyMDYwLCAweDIwNjAsIDB4ZmUwMCwgMHhmZTAwLCAweGZlMDEsIDB4ZmUwMSwgMHhmZTAyLCAweGZlMDIsIDB4ZmUwMywgMHhmZTAzLCAweGZlMDQsIDB4ZmUwNCwgMHhmZTA1LCAweGZlMDUsIDB4ZmUwNiwgMHhmZTA2LCAweGZlMDcsIDB4ZmUwNywgMHhmZTA4LCAweGZlMDgsIDB4ZmUwOSwgMHhmZTA5LCAweGZlMGEsIDB4ZmUwYSwgMHhmZTBiLCAweGZlMGIsIDB4ZmUwYywgMHhmZTBjLCAweGZlMGQsIDB4ZmUwZCwgMHhmZTBlLCAweGZlMGUsIDB4ZmUwZiwgMHhmZTBmLCAweGZlZmYsIDB4ZmVmZl07XG5jb25zdCBpc0NvbW1vbmx5TWFwcGVkVG9Ob3RoaW5nID0gY2hhcmFjdGVyID0+IGluUmFuZ2UoY2hhcmFjdGVyLCBjb21tb25seV9tYXBwZWRfdG9fbm90aGluZyk7XG5jb25zdCBub25fQVNDSUlfc3BhY2VfY2hhcmFjdGVycyA9IFsweDAwYTAsIDB4MDBhMCwgMHgxNjgwLCAweDE2ODAsIDB4MjAwMCwgMHgyMDAwLCAweDIwMDEsIDB4MjAwMSwgMHgyMDAyLCAweDIwMDIsIDB4MjAwMywgMHgyMDAzLCAweDIwMDQsIDB4MjAwNCwgMHgyMDA1LCAweDIwMDUsIDB4MjAwNiwgMHgyMDA2LCAweDIwMDcsIDB4MjAwNywgMHgyMDA4LCAweDIwMDgsIDB4MjAwOSwgMHgyMDA5LCAweDIwMGEsIDB4MjAwYSwgMHgyMDBiLCAweDIwMGIsIDB4MjAyZiwgMHgyMDJmLCAweDIwNWYsIDB4MjA1ZiwgMHgzMDAwLCAweDMwMDBdO1xuY29uc3QgaXNOb25BU0NJSVNwYWNlQ2hhcmFjdGVyID0gY2hhcmFjdGVyID0+IGluUmFuZ2UoY2hhcmFjdGVyLCBub25fQVNDSUlfc3BhY2VfY2hhcmFjdGVycyk7XG5jb25zdCBub25fQVNDSUlfY29udHJvbHNfY2hhcmFjdGVycyA9IFsweDAwODAsIDB4MDA5ZiwgMHgwNmRkLCAweDA2ZGQsIDB4MDcwZiwgMHgwNzBmLCAweDE4MGUsIDB4MTgwZSwgMHgyMDBjLCAweDIwMGMsIDB4MjAwZCwgMHgyMDBkLCAweDIwMjgsIDB4MjAyOCwgMHgyMDI5LCAweDIwMjksIDB4MjA2MCwgMHgyMDYwLCAweDIwNjEsIDB4MjA2MSwgMHgyMDYyLCAweDIwNjIsIDB4MjA2MywgMHgyMDYzLCAweDIwNmEsIDB4MjA2ZiwgMHhmZWZmLCAweGZlZmYsIDB4ZmZmOSwgMHhmZmZjLCAweDFkMTczLCAweDFkMTdhXTtcbmNvbnN0IG5vbl9jaGFyYWN0ZXJfY29kZXBvaW50cyA9IFsweGZkZDAsIDB4ZmRlZiwgMHhmZmZlLCAweGZmZmYsIDB4MWZmZmUsIDB4MWZmZmYsIDB4MmZmZmUsIDB4MmZmZmYsIDB4M2ZmZmUsIDB4M2ZmZmYsIDB4NGZmZmUsIDB4NGZmZmYsIDB4NWZmZmUsIDB4NWZmZmYsIDB4NmZmZmUsIDB4NmZmZmYsIDB4N2ZmZmUsIDB4N2ZmZmYsIDB4OGZmZmUsIDB4OGZmZmYsIDB4OWZmZmUsIDB4OWZmZmYsIDB4YWZmZmUsIDB4YWZmZmYsIDB4YmZmZmUsIDB4YmZmZmYsIDB4Y2ZmZmUsIDB4Y2ZmZmYsIDB4ZGZmZmUsIDB4ZGZmZmYsIDB4ZWZmZmUsIDB4ZWZmZmYsIDB4MTBmZmZlLCAweDEwZmZmZl07XG5jb25zdCBwcm9oaWJpdGVkX2NoYXJhY3RlcnMgPSBbMCwgMHgwMDFmLCAweDAwN2YsIDB4MDA3ZiwgMHgwMzQwLCAweDAzNDAsIDB4MDM0MSwgMHgwMzQxLCAweDIwMGUsIDB4MjAwZSwgMHgyMDBmLCAweDIwMGYsIDB4MjAyYSwgMHgyMDJhLCAweDIwMmIsIDB4MjAyYiwgMHgyMDJjLCAweDIwMmMsIDB4MjAyZCwgMHgyMDJkLCAweDIwMmUsIDB4MjAyZSwgMHgyMDZhLCAweDIwNmEsIDB4MjA2YiwgMHgyMDZiLCAweDIwNmMsIDB4MjA2YywgMHgyMDZkLCAweDIwNmQsIDB4MjA2ZSwgMHgyMDZlLCAweDIwNmYsIDB4MjA2ZiwgMHgyZmYwLCAweDJmZmIsIDB4ZDgwMCwgMHhkZmZmLCAweGUwMDAsIDB4ZjhmZiwgMHhmZmY5LCAweGZmZjksIDB4ZmZmYSwgMHhmZmZhLCAweGZmZmIsIDB4ZmZmYiwgMHhmZmZjLCAweGZmZmMsIDB4ZmZmZCwgMHhmZmZkLCAweGUwMDAxLCAweGUwMDAxLCAweGUwMDIwLCAweGUwMDdmLCAweGYwMDAwLCAweGZmZmZkLCAweDEwMDAwMCwgMHgxMGZmZmRdO1xuY29uc3QgaXNQcm9oaWJpdGVkQ2hhcmFjdGVyID0gY2hhcmFjdGVyID0+IGluUmFuZ2UoY2hhcmFjdGVyLCBub25fQVNDSUlfc3BhY2VfY2hhcmFjdGVycykgfHwgaW5SYW5nZShjaGFyYWN0ZXIsIHByb2hpYml0ZWRfY2hhcmFjdGVycykgfHwgaW5SYW5nZShjaGFyYWN0ZXIsIG5vbl9BU0NJSV9jb250cm9sc19jaGFyYWN0ZXJzKSB8fCBpblJhbmdlKGNoYXJhY3Rlciwgbm9uX2NoYXJhY3Rlcl9jb2RlcG9pbnRzKTtcbmNvbnN0IGJpZGlyZWN0aW9uYWxfcl9hbCA9IFsweDA1YmUsIDB4MDViZSwgMHgwNWMwLCAweDA1YzAsIDB4MDVjMywgMHgwNWMzLCAweDA1ZDAsIDB4MDVlYSwgMHgwNWYwLCAweDA1ZjQsIDB4MDYxYiwgMHgwNjFiLCAweDA2MWYsIDB4MDYxZiwgMHgwNjIxLCAweDA2M2EsIDB4MDY0MCwgMHgwNjRhLCAweDA2NmQsIDB4MDY2ZiwgMHgwNjcxLCAweDA2ZDUsIDB4MDZkZCwgMHgwNmRkLCAweDA2ZTUsIDB4MDZlNiwgMHgwNmZhLCAweDA2ZmUsIDB4MDcwMCwgMHgwNzBkLCAweDA3MTAsIDB4MDcxMCwgMHgwNzEyLCAweDA3MmMsIDB4MDc4MCwgMHgwN2E1LCAweDA3YjEsIDB4MDdiMSwgMHgyMDBmLCAweDIwMGYsIDB4ZmIxZCwgMHhmYjFkLCAweGZiMWYsIDB4ZmIyOCwgMHhmYjJhLCAweGZiMzYsIDB4ZmIzOCwgMHhmYjNjLCAweGZiM2UsIDB4ZmIzZSwgMHhmYjQwLCAweGZiNDEsIDB4ZmI0MywgMHhmYjQ0LCAweGZiNDYsIDB4ZmJiMSwgMHhmYmQzLCAweGZkM2QsIDB4ZmQ1MCwgMHhmZDhmLCAweGZkOTIsIDB4ZmRjNywgMHhmZGYwLCAweGZkZmMsIDB4ZmU3MCwgMHhmZTc0LCAweGZlNzYsIDB4ZmVmY107XG5jb25zdCBpc0JpZGlyZWN0aW9uYWxSQUwgPSBjaGFyYWN0ZXIgPT4gaW5SYW5nZShjaGFyYWN0ZXIsIGJpZGlyZWN0aW9uYWxfcl9hbCk7XG5jb25zdCBiaWRpcmVjdGlvbmFsX2wgPSBbMHgwMDQxLCAweDAwNWEsIDB4MDA2MSwgMHgwMDdhLCAweDAwYWEsIDB4MDBhYSwgMHgwMGI1LCAweDAwYjUsIDB4MDBiYSwgMHgwMGJhLCAweDAwYzAsIDB4MDBkNiwgMHgwMGQ4LCAweDAwZjYsIDB4MDBmOCwgMHgwMjIwLCAweDAyMjIsIDB4MDIzMywgMHgwMjUwLCAweDAyYWQsIDB4MDJiMCwgMHgwMmI4LCAweDAyYmIsIDB4MDJjMSwgMHgwMmQwLCAweDAyZDEsIDB4MDJlMCwgMHgwMmU0LCAweDAyZWUsIDB4MDJlZSwgMHgwMzdhLCAweDAzN2EsIDB4MDM4NiwgMHgwMzg2LCAweDAzODgsIDB4MDM4YSwgMHgwMzhjLCAweDAzOGMsIDB4MDM4ZSwgMHgwM2ExLCAweDAzYTMsIDB4MDNjZSwgMHgwM2QwLCAweDAzZjUsIDB4MDQwMCwgMHgwNDgyLCAweDA0OGEsIDB4MDRjZSwgMHgwNGQwLCAweDA0ZjUsIDB4MDRmOCwgMHgwNGY5LCAweDA1MDAsIDB4MDUwZiwgMHgwNTMxLCAweDA1NTYsIDB4MDU1OSwgMHgwNTVmLCAweDA1NjEsIDB4MDU4NywgMHgwNTg5LCAweDA1ODksIDB4MDkwMywgMHgwOTAzLCAweDA5MDUsIDB4MDkzOSwgMHgwOTNkLCAweDA5NDAsIDB4MDk0OSwgMHgwOTRjLCAweDA5NTAsIDB4MDk1MCwgMHgwOTU4LCAweDA5NjEsIDB4MDk2NCwgMHgwOTcwLCAweDA5ODIsIDB4MDk4MywgMHgwOTg1LCAweDA5OGMsIDB4MDk4ZiwgMHgwOTkwLCAweDA5OTMsIDB4MDlhOCwgMHgwOWFhLCAweDA5YjAsIDB4MDliMiwgMHgwOWIyLCAweDA5YjYsIDB4MDliOSwgMHgwOWJlLCAweDA5YzAsIDB4MDljNywgMHgwOWM4LCAweDA5Y2IsIDB4MDljYywgMHgwOWQ3LCAweDA5ZDcsIDB4MDlkYywgMHgwOWRkLCAweDA5ZGYsIDB4MDllMSwgMHgwOWU2LCAweDA5ZjEsIDB4MDlmNCwgMHgwOWZhLCAweDBhMDUsIDB4MGEwYSwgMHgwYTBmLCAweDBhMTAsIDB4MGExMywgMHgwYTI4LCAweDBhMmEsIDB4MGEzMCwgMHgwYTMyLCAweDBhMzMsIDB4MGEzNSwgMHgwYTM2LCAweDBhMzgsIDB4MGEzOSwgMHgwYTNlLCAweDBhNDAsIDB4MGE1OSwgMHgwYTVjLCAweDBhNWUsIDB4MGE1ZSwgMHgwYTY2LCAweDBhNmYsIDB4MGE3MiwgMHgwYTc0LCAweDBhODMsIDB4MGE4MywgMHgwYTg1LCAweDBhOGIsIDB4MGE4ZCwgMHgwYThkLCAweDBhOGYsIDB4MGE5MSwgMHgwYTkzLCAweDBhYTgsIDB4MGFhYSwgMHgwYWIwLCAweDBhYjIsIDB4MGFiMywgMHgwYWI1LCAweDBhYjksIDB4MGFiZCwgMHgwYWMwLCAweDBhYzksIDB4MGFjOSwgMHgwYWNiLCAweDBhY2MsIDB4MGFkMCwgMHgwYWQwLCAweDBhZTAsIDB4MGFlMCwgMHgwYWU2LCAweDBhZWYsIDB4MGIwMiwgMHgwYjAzLCAweDBiMDUsIDB4MGIwYywgMHgwYjBmLCAweDBiMTAsIDB4MGIxMywgMHgwYjI4LCAweDBiMmEsIDB4MGIzMCwgMHgwYjMyLCAweDBiMzMsIDB4MGIzNiwgMHgwYjM5LCAweDBiM2QsIDB4MGIzZSwgMHgwYjQwLCAweDBiNDAsIDB4MGI0NywgMHgwYjQ4LCAweDBiNGIsIDB4MGI0YywgMHgwYjU3LCAweDBiNTcsIDB4MGI1YywgMHgwYjVkLCAweDBiNWYsIDB4MGI2MSwgMHgwYjY2LCAweDBiNzAsIDB4MGI4MywgMHgwYjgzLCAweDBiODUsIDB4MGI4YSwgMHgwYjhlLCAweDBiOTAsIDB4MGI5MiwgMHgwYjk1LCAweDBiOTksIDB4MGI5YSwgMHgwYjljLCAweDBiOWMsIDB4MGI5ZSwgMHgwYjlmLCAweDBiYTMsIDB4MGJhNCwgMHgwYmE4LCAweDBiYWEsIDB4MGJhZSwgMHgwYmI1LCAweDBiYjcsIDB4MGJiOSwgMHgwYmJlLCAweDBiYmYsIDB4MGJjMSwgMHgwYmMyLCAweDBiYzYsIDB4MGJjOCwgMHgwYmNhLCAweDBiY2MsIDB4MGJkNywgMHgwYmQ3LCAweDBiZTcsIDB4MGJmMiwgMHgwYzAxLCAweDBjMDMsIDB4MGMwNSwgMHgwYzBjLCAweDBjMGUsIDB4MGMxMCwgMHgwYzEyLCAweDBjMjgsIDB4MGMyYSwgMHgwYzMzLCAweDBjMzUsIDB4MGMzOSwgMHgwYzQxLCAweDBjNDQsIDB4MGM2MCwgMHgwYzYxLCAweDBjNjYsIDB4MGM2ZiwgMHgwYzgyLCAweDBjODMsIDB4MGM4NSwgMHgwYzhjLCAweDBjOGUsIDB4MGM5MCwgMHgwYzkyLCAweDBjYTgsIDB4MGNhYSwgMHgwY2IzLCAweDBjYjUsIDB4MGNiOSwgMHgwY2JlLCAweDBjYmUsIDB4MGNjMCwgMHgwY2M0LCAweDBjYzcsIDB4MGNjOCwgMHgwY2NhLCAweDBjY2IsIDB4MGNkNSwgMHgwY2Q2LCAweDBjZGUsIDB4MGNkZSwgMHgwY2UwLCAweDBjZTEsIDB4MGNlNiwgMHgwY2VmLCAweDBkMDIsIDB4MGQwMywgMHgwZDA1LCAweDBkMGMsIDB4MGQwZSwgMHgwZDEwLCAweDBkMTIsIDB4MGQyOCwgMHgwZDJhLCAweDBkMzksIDB4MGQzZSwgMHgwZDQwLCAweDBkNDYsIDB4MGQ0OCwgMHgwZDRhLCAweDBkNGMsIDB4MGQ1NywgMHgwZDU3LCAweDBkNjAsIDB4MGQ2MSwgMHgwZDY2LCAweDBkNmYsIDB4MGQ4MiwgMHgwZDgzLCAweDBkODUsIDB4MGQ5NiwgMHgwZDlhLCAweDBkYjEsIDB4MGRiMywgMHgwZGJiLCAweDBkYmQsIDB4MGRiZCwgMHgwZGMwLCAweDBkYzYsIDB4MGRjZiwgMHgwZGQxLCAweDBkZDgsIDB4MGRkZiwgMHgwZGYyLCAweDBkZjQsIDB4MGUwMSwgMHgwZTMwLCAweDBlMzIsIDB4MGUzMywgMHgwZTQwLCAweDBlNDYsIDB4MGU0ZiwgMHgwZTViLCAweDBlODEsIDB4MGU4MiwgMHgwZTg0LCAweDBlODQsIDB4MGU4NywgMHgwZTg4LCAweDBlOGEsIDB4MGU4YSwgMHgwZThkLCAweDBlOGQsIDB4MGU5NCwgMHgwZTk3LCAweDBlOTksIDB4MGU5ZiwgMHgwZWExLCAweDBlYTMsIDB4MGVhNSwgMHgwZWE1LCAweDBlYTcsIDB4MGVhNywgMHgwZWFhLCAweDBlYWIsIDB4MGVhZCwgMHgwZWIwLCAweDBlYjIsIDB4MGViMywgMHgwZWJkLCAweDBlYmQsIDB4MGVjMCwgMHgwZWM0LCAweDBlYzYsIDB4MGVjNiwgMHgwZWQwLCAweDBlZDksIDB4MGVkYywgMHgwZWRkLCAweDBmMDAsIDB4MGYxNywgMHgwZjFhLCAweDBmMzQsIDB4MGYzNiwgMHgwZjM2LCAweDBmMzgsIDB4MGYzOCwgMHgwZjNlLCAweDBmNDcsIDB4MGY0OSwgMHgwZjZhLCAweDBmN2YsIDB4MGY3ZiwgMHgwZjg1LCAweDBmODUsIDB4MGY4OCwgMHgwZjhiLCAweDBmYmUsIDB4MGZjNSwgMHgwZmM3LCAweDBmY2MsIDB4MGZjZiwgMHgwZmNmLCAweDEwMDAsIDB4MTAyMSwgMHgxMDIzLCAweDEwMjcsIDB4MTAyOSwgMHgxMDJhLCAweDEwMmMsIDB4MTAyYywgMHgxMDMxLCAweDEwMzEsIDB4MTAzOCwgMHgxMDM4LCAweDEwNDAsIDB4MTA1NywgMHgxMGEwLCAweDEwYzUsIDB4MTBkMCwgMHgxMGY4LCAweDEwZmIsIDB4MTBmYiwgMHgxMTAwLCAweDExNTksIDB4MTE1ZiwgMHgxMWEyLCAweDExYTgsIDB4MTFmOSwgMHgxMjAwLCAweDEyMDYsIDB4MTIwOCwgMHgxMjQ2LCAweDEyNDgsIDB4MTI0OCwgMHgxMjRhLCAweDEyNGQsIDB4MTI1MCwgMHgxMjU2LCAweDEyNTgsIDB4MTI1OCwgMHgxMjVhLCAweDEyNWQsIDB4MTI2MCwgMHgxMjg2LCAweDEyODgsIDB4MTI4OCwgMHgxMjhhLCAweDEyOGQsIDB4MTI5MCwgMHgxMmFlLCAweDEyYjAsIDB4MTJiMCwgMHgxMmIyLCAweDEyYjUsIDB4MTJiOCwgMHgxMmJlLCAweDEyYzAsIDB4MTJjMCwgMHgxMmMyLCAweDEyYzUsIDB4MTJjOCwgMHgxMmNlLCAweDEyZDAsIDB4MTJkNiwgMHgxMmQ4LCAweDEyZWUsIDB4MTJmMCwgMHgxMzBlLCAweDEzMTAsIDB4MTMxMCwgMHgxMzEyLCAweDEzMTUsIDB4MTMxOCwgMHgxMzFlLCAweDEzMjAsIDB4MTM0NiwgMHgxMzQ4LCAweDEzNWEsIDB4MTM2MSwgMHgxMzdjLCAweDEzYTAsIDB4MTNmNCwgMHgxNDAxLCAweDE2NzYsIDB4MTY4MSwgMHgxNjlhLCAweDE2YTAsIDB4MTZmMCwgMHgxNzAwLCAweDE3MGMsIDB4MTcwZSwgMHgxNzExLCAweDE3MjAsIDB4MTczMSwgMHgxNzM1LCAweDE3MzYsIDB4MTc0MCwgMHgxNzUxLCAweDE3NjAsIDB4MTc2YywgMHgxNzZlLCAweDE3NzAsIDB4MTc4MCwgMHgxN2I2LCAweDE3YmUsIDB4MTdjNSwgMHgxN2M3LCAweDE3YzgsIDB4MTdkNCwgMHgxN2RhLCAweDE3ZGMsIDB4MTdkYywgMHgxN2UwLCAweDE3ZTksIDB4MTgxMCwgMHgxODE5LCAweDE4MjAsIDB4MTg3NywgMHgxODgwLCAweDE4YTgsIDB4MWUwMCwgMHgxZTliLCAweDFlYTAsIDB4MWVmOSwgMHgxZjAwLCAweDFmMTUsIDB4MWYxOCwgMHgxZjFkLCAweDFmMjAsIDB4MWY0NSwgMHgxZjQ4LCAweDFmNGQsIDB4MWY1MCwgMHgxZjU3LCAweDFmNTksIDB4MWY1OSwgMHgxZjViLCAweDFmNWIsIDB4MWY1ZCwgMHgxZjVkLCAweDFmNWYsIDB4MWY3ZCwgMHgxZjgwLCAweDFmYjQsIDB4MWZiNiwgMHgxZmJjLCAweDFmYmUsIDB4MWZiZSwgMHgxZmMyLCAweDFmYzQsIDB4MWZjNiwgMHgxZmNjLCAweDFmZDAsIDB4MWZkMywgMHgxZmQ2LCAweDFmZGIsIDB4MWZlMCwgMHgxZmVjLCAweDFmZjIsIDB4MWZmNCwgMHgxZmY2LCAweDFmZmMsIDB4MjAwZSwgMHgyMDBlLCAweDIwNzEsIDB4MjA3MSwgMHgyMDdmLCAweDIwN2YsIDB4MjEwMiwgMHgyMTAyLCAweDIxMDcsIDB4MjEwNywgMHgyMTBhLCAweDIxMTMsIDB4MjExNSwgMHgyMTE1LCAweDIxMTksIDB4MjExZCwgMHgyMTI0LCAweDIxMjQsIDB4MjEyNiwgMHgyMTI2LCAweDIxMjgsIDB4MjEyOCwgMHgyMTJhLCAweDIxMmQsIDB4MjEyZiwgMHgyMTMxLCAweDIxMzMsIDB4MjEzOSwgMHgyMTNkLCAweDIxM2YsIDB4MjE0NSwgMHgyMTQ5LCAweDIxNjAsIDB4MjE4MywgMHgyMzM2LCAweDIzN2EsIDB4MjM5NSwgMHgyMzk1LCAweDI0OWMsIDB4MjRlOSwgMHgzMDA1LCAweDMwMDcsIDB4MzAyMSwgMHgzMDI5LCAweDMwMzEsIDB4MzAzNSwgMHgzMDM4LCAweDMwM2MsIDB4MzA0MSwgMHgzMDk2LCAweDMwOWQsIDB4MzA5ZiwgMHgzMGExLCAweDMwZmEsIDB4MzBmYywgMHgzMGZmLCAweDMxMDUsIDB4MzEyYywgMHgzMTMxLCAweDMxOGUsIDB4MzE5MCwgMHgzMWI3LCAweDMxZjAsIDB4MzIxYywgMHgzMjIwLCAweDMyNDMsIDB4MzI2MCwgMHgzMjdiLCAweDMyN2YsIDB4MzJiMCwgMHgzMmMwLCAweDMyY2IsIDB4MzJkMCwgMHgzMmZlLCAweDMzMDAsIDB4MzM3NiwgMHgzMzdiLCAweDMzZGQsIDB4MzNlMCwgMHgzM2ZlLCAweDM0MDAsIDB4NGRiNSwgMHg0ZTAwLCAweDlmYTUsIDB4YTAwMCwgMHhhNDhjLCAweGFjMDAsIDB4ZDdhMywgMHhkODAwLCAweGZhMmQsIDB4ZmEzMCwgMHhmYTZhLCAweGZiMDAsIDB4ZmIwNiwgMHhmYjEzLCAweGZiMTcsIDB4ZmYyMSwgMHhmZjNhLCAweGZmNDEsIDB4ZmY1YSwgMHhmZjY2LCAweGZmYmUsIDB4ZmZjMiwgMHhmZmM3LCAweGZmY2EsIDB4ZmZjZiwgMHhmZmQyLCAweGZmZDcsIDB4ZmZkYSwgMHhmZmRjLCAweDEwMzAwLCAweDEwMzFlLCAweDEwMzIwLCAweDEwMzIzLCAweDEwMzMwLCAweDEwMzRhLCAweDEwNDAwLCAweDEwNDI1LCAweDEwNDI4LCAweDEwNDRkLCAweDFkMDAwLCAweDFkMGY1LCAweDFkMTAwLCAweDFkMTI2LCAweDFkMTJhLCAweDFkMTY2LCAweDFkMTZhLCAweDFkMTcyLCAweDFkMTgzLCAweDFkMTg0LCAweDFkMThjLCAweDFkMWE5LCAweDFkMWFlLCAweDFkMWRkLCAweDFkNDAwLCAweDFkNDU0LCAweDFkNDU2LCAweDFkNDljLCAweDFkNDllLCAweDFkNDlmLCAweDFkNGEyLCAweDFkNGEyLCAweDFkNGE1LCAweDFkNGE2LCAweDFkNGE5LCAweDFkNGFjLCAweDFkNGFlLCAweDFkNGI5LCAweDFkNGJiLCAweDFkNGJiLCAweDFkNGJkLCAweDFkNGMwLCAweDFkNGMyLCAweDFkNGMzLCAweDFkNGM1LCAweDFkNTA1LCAweDFkNTA3LCAweDFkNTBhLCAweDFkNTBkLCAweDFkNTE0LCAweDFkNTE2LCAweDFkNTFjLCAweDFkNTFlLCAweDFkNTM5LCAweDFkNTNiLCAweDFkNTNlLCAweDFkNTQwLCAweDFkNTQ0LCAweDFkNTQ2LCAweDFkNTQ2LCAweDFkNTRhLCAweDFkNTUwLCAweDFkNTUyLCAweDFkNmEzLCAweDFkNmE4LCAweDFkN2M5LCAweDIwMDAwLCAweDJhNmQ2LCAweDJmODAwLCAweDJmYTFkLCAweGYwMDAwLCAweGZmZmZkLCAweDEwMDAwMCwgMHgxMGZmZmRdO1xuY29uc3QgaXNCaWRpcmVjdGlvbmFsTCA9IGNoYXJhY3RlciA9PiBpblJhbmdlKGNoYXJhY3RlciwgYmlkaXJlY3Rpb25hbF9sKTtcblxuY29uc3QgbWFwcGluZzJzcGFjZSA9IGlzTm9uQVNDSUlTcGFjZUNoYXJhY3RlcjtcbmNvbnN0IG1hcHBpbmcybm90aGluZyA9IGlzQ29tbW9ubHlNYXBwZWRUb05vdGhpbmc7XG5jb25zdCBnZXRDb2RlUG9pbnQgPSBjaGFyYWN0ZXIgPT4gY2hhcmFjdGVyLmNvZGVQb2ludEF0KDApO1xuY29uc3QgZmlyc3QgPSB4ID0+IHhbMF07XG5jb25zdCBsYXN0ID0geCA9PiB4W3gubGVuZ3RoIC0gMV07XG5mdW5jdGlvbiB0b0NvZGVQb2ludHMoaW5wdXQpIHtcbiAgY29uc3QgY29kZXBvaW50cyA9IFtdO1xuICBjb25zdCBzaXplID0gaW5wdXQubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkgKz0gMSkge1xuICAgIGNvbnN0IGJlZm9yZSA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGJlZm9yZSA+PSAweGQ4MDAgJiYgYmVmb3JlIDw9IDB4ZGJmZiAmJiBzaXplID4gaSArIDEpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgIGlmIChuZXh0ID49IDB4ZGMwMCAmJiBuZXh0IDw9IDB4ZGZmZikge1xuICAgICAgICBjb2RlcG9pbnRzLnB1c2goKGJlZm9yZSAtIDB4ZDgwMCkgKiAweDQwMCArIG5leHQgLSAweGRjMDAgKyAweDEwMDAwKTtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29kZXBvaW50cy5wdXNoKGJlZm9yZSk7XG4gIH1cbiAgcmV0dXJuIGNvZGVwb2ludHM7XG59XG5mdW5jdGlvbiBzYXNscHJlcChpbnB1dCkge1xuICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgc3RyaW5nLicpO1xuICB9XG4gIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgY29uc3QgbWFwcGVkX2lucHV0ID0gdG9Db2RlUG9pbnRzKGlucHV0KS5tYXAoY2hhcmFjdGVyID0+IG1hcHBpbmcyc3BhY2UoY2hhcmFjdGVyKSA/IDB4MjAgOiBjaGFyYWN0ZXIpLmZpbHRlcihjaGFyYWN0ZXIgPT4gIW1hcHBpbmcybm90aGluZyhjaGFyYWN0ZXIpKTtcbiAgY29uc3Qgbm9ybWFsaXplZF9pbnB1dCA9IFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KG51bGwsIG1hcHBlZF9pbnB1dCkubm9ybWFsaXplKCdORktDJyk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRfbWFwID0gdG9Db2RlUG9pbnRzKG5vcm1hbGl6ZWRfaW5wdXQpO1xuICBjb25zdCBoYXNQcm9oaWJpdGVkID0gbm9ybWFsaXplZF9tYXAuc29tZShpc1Byb2hpYml0ZWRDaGFyYWN0ZXIpO1xuICBpZiAoaGFzUHJvaGliaXRlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJvaGliaXRlZCBjaGFyYWN0ZXIsIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDAxMyNzZWN0aW9uLTIuMycpO1xuICB9XG4gIGlmIChvcHRzLmFsbG93VW5hc3NpZ25lZCAhPT0gdHJ1ZSkge1xuICAgIGNvbnN0IGhhc1VuYXNzaWduZWQgPSBub3JtYWxpemVkX21hcC5zb21lKGlzVW5hc3NpZ25lZENvZGVQb2ludCk7XG4gICAgaWYgKGhhc1VuYXNzaWduZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hc3NpZ25lZCBjb2RlIHBvaW50LCBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQwMTMjc2VjdGlvbi0yLjUnKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaGFzQmlkaVJBTCA9IG5vcm1hbGl6ZWRfbWFwLnNvbWUoaXNCaWRpcmVjdGlvbmFsUkFMKTtcbiAgY29uc3QgaGFzQmlkaUwgPSBub3JtYWxpemVkX21hcC5zb21lKGlzQmlkaXJlY3Rpb25hbEwpO1xuICBpZiAoaGFzQmlkaVJBTCAmJiBoYXNCaWRpTCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3RyaW5nIG11c3Qgbm90IGNvbnRhaW4gUmFuZEFMQ2F0IGFuZCBMQ2F0IGF0IHRoZSBzYW1lIHRpbWUsJyArICcgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDU0I3NlY3Rpb24tNicpO1xuICB9XG4gIGNvbnN0IGlzRmlyc3RCaWRpUkFMID0gaXNCaWRpcmVjdGlvbmFsUkFMKGdldENvZGVQb2ludChmaXJzdChub3JtYWxpemVkX2lucHV0KSkpO1xuICBjb25zdCBpc0xhc3RCaWRpUkFMID0gaXNCaWRpcmVjdGlvbmFsUkFMKGdldENvZGVQb2ludChsYXN0KG5vcm1hbGl6ZWRfaW5wdXQpKSk7XG4gIGlmIChoYXNCaWRpUkFMICYmICEoaXNGaXJzdEJpZGlSQUwgJiYgaXNMYXN0QmlkaVJBTCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpZGlyZWN0aW9uYWwgUmFuZEFMQ2F0IGNoYXJhY3RlciBtdXN0IGJlIHRoZSBmaXJzdCBhbmQgdGhlIGxhc3QnICsgJyBjaGFyYWN0ZXIgb2YgdGhlIHN0cmluZywgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDU0I3NlY3Rpb24tNicpO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkX2lucHV0O1xufVxuXG5jbGFzcyBQREZTZWN1cml0eSB7XG4gIHN0YXRpYyBnZW5lcmF0ZUZpbGVJRCgpIHtcbiAgICBsZXQgaW5mbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgbGV0IGluZm9TdHIgPSBgJHtpbmZvLkNyZWF0aW9uRGF0ZS5nZXRUaW1lKCl9XFxuYDtcbiAgICBmb3IgKGxldCBrZXkgaW4gaW5mbykge1xuICAgICAgaWYgKCFpbmZvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpbmZvU3RyICs9IGAke2tleX06ICR7aW5mb1trZXldLnZhbHVlT2YoKX1cXG5gO1xuICAgIH1cbiAgICByZXR1cm4gd29yZEFycmF5VG9CdWZmZXIoQ3J5cHRvSlMuTUQ1KGluZm9TdHIpKTtcbiAgfVxuICBzdGF0aWMgZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkoYnl0ZXMpIHtcbiAgICByZXR1cm4gQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oYnl0ZXMpO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUoZG9jdW1lbnQpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgaWYgKCFvcHRpb25zLm93bmVyUGFzc3dvcmQgJiYgIW9wdGlvbnMudXNlclBhc3N3b3JkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQREZTZWN1cml0eShkb2N1bWVudCwgb3B0aW9ucyk7XG4gIH1cbiAgY29uc3RydWN0b3IoZG9jdW1lbnQpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgaWYgKCFvcHRpb25zLm93bmVyUGFzc3dvcmQgJiYgIW9wdGlvbnMudXNlclBhc3N3b3JkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbmUgb2Ygb3duZXIgcGFzc3dvcmQgYW5kIHVzZXIgcGFzc3dvcmQgaXMgZGVmaW5lZC4nKTtcbiAgICB9XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMuX3NldHVwRW5jcnlwdGlvbihvcHRpb25zKTtcbiAgfVxuICBfc2V0dXBFbmNyeXB0aW9uKG9wdGlvbnMpIHtcbiAgICBzd2l0Y2ggKG9wdGlvbnMucGRmVmVyc2lvbikge1xuICAgICAgY2FzZSAnMS40JzpcbiAgICAgIGNhc2UgJzEuNSc6XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnMS42JzpcbiAgICAgIGNhc2UgJzEuNyc6XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnMS43ZXh0Myc6XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IGVuY0RpY3QgPSB7XG4gICAgICBGaWx0ZXI6ICdTdGFuZGFyZCdcbiAgICB9O1xuICAgIHN3aXRjaCAodGhpcy52ZXJzaW9uKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICBjYXNlIDI6XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHRoaXMuX3NldHVwRW5jcnlwdGlvblYxVjJWNCh0aGlzLnZlcnNpb24sIGVuY0RpY3QsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgdGhpcy5fc2V0dXBFbmNyeXB0aW9uVjUoZW5jRGljdCwgb3B0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmRpY3Rpb25hcnkgPSB0aGlzLmRvY3VtZW50LnJlZihlbmNEaWN0KTtcbiAgfVxuICBfc2V0dXBFbmNyeXB0aW9uVjFWMlY0KHYsIGVuY0RpY3QsIG9wdGlvbnMpIHtcbiAgICBsZXQgciwgcGVybWlzc2lvbnM7XG4gICAgc3dpdGNoICh2KSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHIgPSAyO1xuICAgICAgICB0aGlzLmtleUJpdHMgPSA0MDtcbiAgICAgICAgcGVybWlzc2lvbnMgPSBnZXRQZXJtaXNzaW9uc1IyKG9wdGlvbnMucGVybWlzc2lvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgciA9IDM7XG4gICAgICAgIHRoaXMua2V5Qml0cyA9IDEyODtcbiAgICAgICAgcGVybWlzc2lvbnMgPSBnZXRQZXJtaXNzaW9uc1IzKG9wdGlvbnMucGVybWlzc2lvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgciA9IDQ7XG4gICAgICAgIHRoaXMua2V5Qml0cyA9IDEyODtcbiAgICAgICAgcGVybWlzc2lvbnMgPSBnZXRQZXJtaXNzaW9uc1IzKG9wdGlvbnMucGVybWlzc2lvbnMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgcGFkZGVkVXNlclBhc3N3b3JkID0gcHJvY2Vzc1Bhc3N3b3JkUjJSM1I0KG9wdGlvbnMudXNlclBhc3N3b3JkKTtcbiAgICBjb25zdCBwYWRkZWRPd25lclBhc3N3b3JkID0gb3B0aW9ucy5vd25lclBhc3N3b3JkID8gcHJvY2Vzc1Bhc3N3b3JkUjJSM1I0KG9wdGlvbnMub3duZXJQYXNzd29yZCkgOiBwYWRkZWRVc2VyUGFzc3dvcmQ7XG4gICAgY29uc3Qgb3duZXJQYXNzd29yZEVudHJ5ID0gZ2V0T3duZXJQYXNzd29yZFIyUjNSNChyLCB0aGlzLmtleUJpdHMsIHBhZGRlZFVzZXJQYXNzd29yZCwgcGFkZGVkT3duZXJQYXNzd29yZCk7XG4gICAgdGhpcy5lbmNyeXB0aW9uS2V5ID0gZ2V0RW5jcnlwdGlvbktleVIyUjNSNChyLCB0aGlzLmtleUJpdHMsIHRoaXMuZG9jdW1lbnQuX2lkLCBwYWRkZWRVc2VyUGFzc3dvcmQsIG93bmVyUGFzc3dvcmRFbnRyeSwgcGVybWlzc2lvbnMpO1xuICAgIGxldCB1c2VyUGFzc3dvcmRFbnRyeTtcbiAgICBpZiAociA9PT0gMikge1xuICAgICAgdXNlclBhc3N3b3JkRW50cnkgPSBnZXRVc2VyUGFzc3dvcmRSMih0aGlzLmVuY3J5cHRpb25LZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1c2VyUGFzc3dvcmRFbnRyeSA9IGdldFVzZXJQYXNzd29yZFIzUjQodGhpcy5kb2N1bWVudC5faWQsIHRoaXMuZW5jcnlwdGlvbktleSk7XG4gICAgfVxuICAgIGVuY0RpY3QuViA9IHY7XG4gICAgaWYgKHYgPj0gMikge1xuICAgICAgZW5jRGljdC5MZW5ndGggPSB0aGlzLmtleUJpdHM7XG4gICAgfVxuICAgIGlmICh2ID09PSA0KSB7XG4gICAgICBlbmNEaWN0LkNGID0ge1xuICAgICAgICBTdGRDRjoge1xuICAgICAgICAgIEF1dGhFdmVudDogJ0RvY09wZW4nLFxuICAgICAgICAgIENGTTogJ0FFU1YyJyxcbiAgICAgICAgICBMZW5ndGg6IHRoaXMua2V5Qml0cyAvIDhcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVuY0RpY3QuU3RtRiA9ICdTdGRDRic7XG4gICAgICBlbmNEaWN0LlN0ckYgPSAnU3RkQ0YnO1xuICAgIH1cbiAgICBlbmNEaWN0LlIgPSByO1xuICAgIGVuY0RpY3QuTyA9IHdvcmRBcnJheVRvQnVmZmVyKG93bmVyUGFzc3dvcmRFbnRyeSk7XG4gICAgZW5jRGljdC5VID0gd29yZEFycmF5VG9CdWZmZXIodXNlclBhc3N3b3JkRW50cnkpO1xuICAgIGVuY0RpY3QuUCA9IHBlcm1pc3Npb25zO1xuICB9XG4gIF9zZXR1cEVuY3J5cHRpb25WNShlbmNEaWN0LCBvcHRpb25zKSB7XG4gICAgdGhpcy5rZXlCaXRzID0gMjU2O1xuICAgIGNvbnN0IHBlcm1pc3Npb25zID0gZ2V0UGVybWlzc2lvbnNSMyhvcHRpb25zLnBlcm1pc3Npb25zKTtcbiAgICBjb25zdCBwcm9jZXNzZWRVc2VyUGFzc3dvcmQgPSBwcm9jZXNzUGFzc3dvcmRSNShvcHRpb25zLnVzZXJQYXNzd29yZCk7XG4gICAgY29uc3QgcHJvY2Vzc2VkT3duZXJQYXNzd29yZCA9IG9wdGlvbnMub3duZXJQYXNzd29yZCA/IHByb2Nlc3NQYXNzd29yZFI1KG9wdGlvbnMub3duZXJQYXNzd29yZCkgOiBwcm9jZXNzZWRVc2VyUGFzc3dvcmQ7XG4gICAgdGhpcy5lbmNyeXB0aW9uS2V5ID0gZ2V0RW5jcnlwdGlvbktleVI1KFBERlNlY3VyaXR5LmdlbmVyYXRlUmFuZG9tV29yZEFycmF5KTtcbiAgICBjb25zdCB1c2VyUGFzc3dvcmRFbnRyeSA9IGdldFVzZXJQYXNzd29yZFI1KHByb2Nlc3NlZFVzZXJQYXNzd29yZCwgUERGU2VjdXJpdHkuZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkpO1xuICAgIGNvbnN0IHVzZXJLZXlTYWx0ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUodXNlclBhc3N3b3JkRW50cnkud29yZHMuc2xpY2UoMTAsIDEyKSwgOCk7XG4gICAgY29uc3QgdXNlckVuY3J5cHRpb25LZXlFbnRyeSA9IGdldFVzZXJFbmNyeXB0aW9uS2V5UjUocHJvY2Vzc2VkVXNlclBhc3N3b3JkLCB1c2VyS2V5U2FsdCwgdGhpcy5lbmNyeXB0aW9uS2V5KTtcbiAgICBjb25zdCBvd25lclBhc3N3b3JkRW50cnkgPSBnZXRPd25lclBhc3N3b3JkUjUocHJvY2Vzc2VkT3duZXJQYXNzd29yZCwgdXNlclBhc3N3b3JkRW50cnksIFBERlNlY3VyaXR5LmdlbmVyYXRlUmFuZG9tV29yZEFycmF5KTtcbiAgICBjb25zdCBvd25lcktleVNhbHQgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShvd25lclBhc3N3b3JkRW50cnkud29yZHMuc2xpY2UoMTAsIDEyKSwgOCk7XG4gICAgY29uc3Qgb3duZXJFbmNyeXB0aW9uS2V5RW50cnkgPSBnZXRPd25lckVuY3J5cHRpb25LZXlSNShwcm9jZXNzZWRPd25lclBhc3N3b3JkLCBvd25lcktleVNhbHQsIHVzZXJQYXNzd29yZEVudHJ5LCB0aGlzLmVuY3J5cHRpb25LZXkpO1xuICAgIGNvbnN0IHBlcm1zRW50cnkgPSBnZXRFbmNyeXB0ZWRQZXJtaXNzaW9uc1I1KHBlcm1pc3Npb25zLCB0aGlzLmVuY3J5cHRpb25LZXksIFBERlNlY3VyaXR5LmdlbmVyYXRlUmFuZG9tV29yZEFycmF5KTtcbiAgICBlbmNEaWN0LlYgPSA1O1xuICAgIGVuY0RpY3QuTGVuZ3RoID0gdGhpcy5rZXlCaXRzO1xuICAgIGVuY0RpY3QuQ0YgPSB7XG4gICAgICBTdGRDRjoge1xuICAgICAgICBBdXRoRXZlbnQ6ICdEb2NPcGVuJyxcbiAgICAgICAgQ0ZNOiAnQUVTVjMnLFxuICAgICAgICBMZW5ndGg6IHRoaXMua2V5Qml0cyAvIDhcbiAgICAgIH1cbiAgICB9O1xuICAgIGVuY0RpY3QuU3RtRiA9ICdTdGRDRic7XG4gICAgZW5jRGljdC5TdHJGID0gJ1N0ZENGJztcbiAgICBlbmNEaWN0LlIgPSA1O1xuICAgIGVuY0RpY3QuTyA9IHdvcmRBcnJheVRvQnVmZmVyKG93bmVyUGFzc3dvcmRFbnRyeSk7XG4gICAgZW5jRGljdC5PRSA9IHdvcmRBcnJheVRvQnVmZmVyKG93bmVyRW5jcnlwdGlvbktleUVudHJ5KTtcbiAgICBlbmNEaWN0LlUgPSB3b3JkQXJyYXlUb0J1ZmZlcih1c2VyUGFzc3dvcmRFbnRyeSk7XG4gICAgZW5jRGljdC5VRSA9IHdvcmRBcnJheVRvQnVmZmVyKHVzZXJFbmNyeXB0aW9uS2V5RW50cnkpO1xuICAgIGVuY0RpY3QuUCA9IHBlcm1pc3Npb25zO1xuICAgIGVuY0RpY3QuUGVybXMgPSB3b3JkQXJyYXlUb0J1ZmZlcihwZXJtc0VudHJ5KTtcbiAgfVxuICBnZXRFbmNyeXB0Rm4ob2JqLCBnZW4pIHtcbiAgICBsZXQgZGlnZXN0O1xuICAgIGlmICh0aGlzLnZlcnNpb24gPCA1KSB7XG4gICAgICBkaWdlc3QgPSB0aGlzLmVuY3J5cHRpb25LZXkuY2xvbmUoKS5jb25jYXQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWyhvYmogJiAweGZmKSA8PCAyNCB8IChvYmogJiAweGZmMDApIDw8IDggfCBvYmogPj4gOCAmIDB4ZmYwMCB8IGdlbiAmIDB4ZmYsIChnZW4gJiAweGZmMDApIDw8IDE2XSwgNSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAxIHx8IHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgbGV0IGtleSA9IENyeXB0b0pTLk1ENShkaWdlc3QpO1xuICAgICAga2V5LnNpZ0J5dGVzID0gTWF0aC5taW4oMTYsIHRoaXMua2V5Qml0cyAvIDggKyA1KTtcbiAgICAgIHJldHVybiBidWZmZXIgPT4gd29yZEFycmF5VG9CdWZmZXIoQ3J5cHRvSlMuUkM0LmVuY3J5cHQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoYnVmZmVyKSwga2V5KS5jaXBoZXJ0ZXh0KTtcbiAgICB9XG4gICAgbGV0IGtleTtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSA0KSB7XG4gICAgICBrZXkgPSBDcnlwdG9KUy5NRDUoZGlnZXN0LmNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHg3MzQxNmM1NF0sIDQpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IHRoaXMuZW5jcnlwdGlvbktleTtcbiAgICB9XG4gICAgY29uc3QgaXYgPSBQREZTZWN1cml0eS5nZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSgxNik7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxuICAgICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLlBrY3M3LFxuICAgICAgaXZcbiAgICB9O1xuICAgIHJldHVybiBidWZmZXIgPT4gd29yZEFycmF5VG9CdWZmZXIoaXYuY2xvbmUoKS5jb25jYXQoQ3J5cHRvSlMuQUVTLmVuY3J5cHQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoYnVmZmVyKSwga2V5LCBvcHRpb25zKS5jaXBoZXJ0ZXh0KSk7XG4gIH1cbiAgZW5kKCkge1xuICAgIHRoaXMuZGljdGlvbmFyeS5lbmQoKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UGVybWlzc2lvbnNSMigpIHtcbiAgbGV0IHBlcm1pc3Npb25PYmplY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBsZXQgcGVybWlzc2lvbnMgPSAweGZmZmZmZmMwID4+IDA7XG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0LnByaW50aW5nKSB7XG4gICAgcGVybWlzc2lvbnMgfD0gMGIwMDAwMDAwMDAxMDA7XG4gIH1cbiAgaWYgKHBlcm1pc3Npb25PYmplY3QubW9kaWZ5aW5nKSB7XG4gICAgcGVybWlzc2lvbnMgfD0gMGIwMDAwMDAwMDEwMDA7XG4gIH1cbiAgaWYgKHBlcm1pc3Npb25PYmplY3QuY29weWluZykge1xuICAgIHBlcm1pc3Npb25zIHw9IDBiMDAwMDAwMDEwMDAwO1xuICB9XG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0LmFubm90YXRpbmcpIHtcbiAgICBwZXJtaXNzaW9ucyB8PSAwYjAwMDAwMDEwMDAwMDtcbiAgfVxuICByZXR1cm4gcGVybWlzc2lvbnM7XG59XG5mdW5jdGlvbiBnZXRQZXJtaXNzaW9uc1IzKCkge1xuICBsZXQgcGVybWlzc2lvbk9iamVjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGxldCBwZXJtaXNzaW9ucyA9IDB4ZmZmZmYwYzAgPj4gMDtcbiAgaWYgKHBlcm1pc3Npb25PYmplY3QucHJpbnRpbmcgPT09ICdsb3dSZXNvbHV0aW9uJykge1xuICAgIHBlcm1pc3Npb25zIHw9IDBiMDAwMDAwMDAwMTAwO1xuICB9XG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0LnByaW50aW5nID09PSAnaGlnaFJlc29sdXRpb24nKSB7XG4gICAgcGVybWlzc2lvbnMgfD0gMGIxMDAwMDAwMDAxMDA7XG4gIH1cbiAgaWYgKHBlcm1pc3Npb25PYmplY3QubW9kaWZ5aW5nKSB7XG4gICAgcGVybWlzc2lvbnMgfD0gMGIwMDAwMDAwMDEwMDA7XG4gIH1cbiAgaWYgKHBlcm1pc3Npb25PYmplY3QuY29weWluZykge1xuICAgIHBlcm1pc3Npb25zIHw9IDBiMDAwMDAwMDEwMDAwO1xuICB9XG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0LmFubm90YXRpbmcpIHtcbiAgICBwZXJtaXNzaW9ucyB8PSAwYjAwMDAwMDEwMDAwMDtcbiAgfVxuICBpZiAocGVybWlzc2lvbk9iamVjdC5maWxsaW5nRm9ybXMpIHtcbiAgICBwZXJtaXNzaW9ucyB8PSAwYjAwMDEwMDAwMDAwMDtcbiAgfVxuICBpZiAocGVybWlzc2lvbk9iamVjdC5jb250ZW50QWNjZXNzaWJpbGl0eSkge1xuICAgIHBlcm1pc3Npb25zIHw9IDBiMDAxMDAwMDAwMDAwO1xuICB9XG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0LmRvY3VtZW50QXNzZW1ibHkpIHtcbiAgICBwZXJtaXNzaW9ucyB8PSAwYjAxMDAwMDAwMDAwMDtcbiAgfVxuICByZXR1cm4gcGVybWlzc2lvbnM7XG59XG5mdW5jdGlvbiBnZXRVc2VyUGFzc3dvcmRSMihlbmNyeXB0aW9uS2V5KSB7XG4gIHJldHVybiBDcnlwdG9KUy5SQzQuZW5jcnlwdChwcm9jZXNzUGFzc3dvcmRSMlIzUjQoKSwgZW5jcnlwdGlvbktleSkuY2lwaGVydGV4dDtcbn1cbmZ1bmN0aW9uIGdldFVzZXJQYXNzd29yZFIzUjQoZG9jdW1lbnRJZCwgZW5jcnlwdGlvbktleSkge1xuICBjb25zdCBrZXkgPSBlbmNyeXB0aW9uS2V5LmNsb25lKCk7XG4gIGxldCBjaXBoZXIgPSBDcnlwdG9KUy5NRDUocHJvY2Vzc1Bhc3N3b3JkUjJSM1I0KCkuY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKGRvY3VtZW50SWQpKSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuICAgIGNvbnN0IHhvclJvdW5kID0gTWF0aC5jZWlsKGtleS5zaWdCeXRlcyAvIDQpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgeG9yUm91bmQ7IGorKykge1xuICAgICAga2V5LndvcmRzW2pdID0gZW5jcnlwdGlvbktleS53b3Jkc1tqXSBeIChpIHwgaSA8PCA4IHwgaSA8PCAxNiB8IGkgPDwgMjQpO1xuICAgIH1cbiAgICBjaXBoZXIgPSBDcnlwdG9KUy5SQzQuZW5jcnlwdChjaXBoZXIsIGtleSkuY2lwaGVydGV4dDtcbiAgfVxuICByZXR1cm4gY2lwaGVyLmNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShudWxsLCAxNikpO1xufVxuZnVuY3Rpb24gZ2V0T3duZXJQYXNzd29yZFIyUjNSNChyLCBrZXlCaXRzLCBwYWRkZWRVc2VyUGFzc3dvcmQsIHBhZGRlZE93bmVyUGFzc3dvcmQpIHtcbiAgbGV0IGRpZ2VzdCA9IHBhZGRlZE93bmVyUGFzc3dvcmQ7XG4gIGxldCByb3VuZCA9IHIgPj0gMyA/IDUxIDogMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3VuZDsgaSsrKSB7XG4gICAgZGlnZXN0ID0gQ3J5cHRvSlMuTUQ1KGRpZ2VzdCk7XG4gIH1cbiAgY29uc3Qga2V5ID0gZGlnZXN0LmNsb25lKCk7XG4gIGtleS5zaWdCeXRlcyA9IGtleUJpdHMgLyA4O1xuICBsZXQgY2lwaGVyID0gcGFkZGVkVXNlclBhc3N3b3JkO1xuICByb3VuZCA9IHIgPj0gMyA/IDIwIDogMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3VuZDsgaSsrKSB7XG4gICAgY29uc3QgeG9yUm91bmQgPSBNYXRoLmNlaWwoa2V5LnNpZ0J5dGVzIC8gNCk7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB4b3JSb3VuZDsgaisrKSB7XG4gICAgICBrZXkud29yZHNbal0gPSBkaWdlc3Qud29yZHNbal0gXiAoaSB8IGkgPDwgOCB8IGkgPDwgMTYgfCBpIDw8IDI0KTtcbiAgICB9XG4gICAgY2lwaGVyID0gQ3J5cHRvSlMuUkM0LmVuY3J5cHQoY2lwaGVyLCBrZXkpLmNpcGhlcnRleHQ7XG4gIH1cbiAgcmV0dXJuIGNpcGhlcjtcbn1cbmZ1bmN0aW9uIGdldEVuY3J5cHRpb25LZXlSMlIzUjQociwga2V5Qml0cywgZG9jdW1lbnRJZCwgcGFkZGVkVXNlclBhc3N3b3JkLCBvd25lclBhc3N3b3JkRW50cnksIHBlcm1pc3Npb25zKSB7XG4gIGxldCBrZXkgPSBwYWRkZWRVc2VyUGFzc3dvcmQuY2xvbmUoKS5jb25jYXQob3duZXJQYXNzd29yZEVudHJ5KS5jb25jYXQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoW2xzYkZpcnN0V29yZChwZXJtaXNzaW9ucyldLCA0KSkuY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKGRvY3VtZW50SWQpKTtcbiAgY29uc3Qgcm91bmQgPSByID49IDMgPyA1MSA6IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91bmQ7IGkrKykge1xuICAgIGtleSA9IENyeXB0b0pTLk1ENShrZXkpO1xuICAgIGtleS5zaWdCeXRlcyA9IGtleUJpdHMgLyA4O1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiBnZXRVc2VyUGFzc3dvcmRSNShwcm9jZXNzZWRVc2VyUGFzc3dvcmQsIGdlbmVyYXRlUmFuZG9tV29yZEFycmF5KSB7XG4gIGNvbnN0IHZhbGlkYXRpb25TYWx0ID0gZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkoOCk7XG4gIGNvbnN0IGtleVNhbHQgPSBnZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSg4KTtcbiAgcmV0dXJuIENyeXB0b0pTLlNIQTI1Nihwcm9jZXNzZWRVc2VyUGFzc3dvcmQuY2xvbmUoKS5jb25jYXQodmFsaWRhdGlvblNhbHQpKS5jb25jYXQodmFsaWRhdGlvblNhbHQpLmNvbmNhdChrZXlTYWx0KTtcbn1cbmZ1bmN0aW9uIGdldFVzZXJFbmNyeXB0aW9uS2V5UjUocHJvY2Vzc2VkVXNlclBhc3N3b3JkLCB1c2VyS2V5U2FsdCwgZW5jcnlwdGlvbktleSkge1xuICBjb25zdCBrZXkgPSBDcnlwdG9KUy5TSEEyNTYocHJvY2Vzc2VkVXNlclBhc3N3b3JkLmNsb25lKCkuY29uY2F0KHVzZXJLZXlTYWx0KSk7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXG4gICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLk5vUGFkZGluZyxcbiAgICBpdjogQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUobnVsbCwgMTYpXG4gIH07XG4gIHJldHVybiBDcnlwdG9KUy5BRVMuZW5jcnlwdChlbmNyeXB0aW9uS2V5LCBrZXksIG9wdGlvbnMpLmNpcGhlcnRleHQ7XG59XG5mdW5jdGlvbiBnZXRPd25lclBhc3N3b3JkUjUocHJvY2Vzc2VkT3duZXJQYXNzd29yZCwgdXNlclBhc3N3b3JkRW50cnksIGdlbmVyYXRlUmFuZG9tV29yZEFycmF5KSB7XG4gIGNvbnN0IHZhbGlkYXRpb25TYWx0ID0gZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkoOCk7XG4gIGNvbnN0IGtleVNhbHQgPSBnZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSg4KTtcbiAgcmV0dXJuIENyeXB0b0pTLlNIQTI1Nihwcm9jZXNzZWRPd25lclBhc3N3b3JkLmNsb25lKCkuY29uY2F0KHZhbGlkYXRpb25TYWx0KS5jb25jYXQodXNlclBhc3N3b3JkRW50cnkpKS5jb25jYXQodmFsaWRhdGlvblNhbHQpLmNvbmNhdChrZXlTYWx0KTtcbn1cbmZ1bmN0aW9uIGdldE93bmVyRW5jcnlwdGlvbktleVI1KHByb2Nlc3NlZE93bmVyUGFzc3dvcmQsIG93bmVyS2V5U2FsdCwgdXNlclBhc3N3b3JkRW50cnksIGVuY3J5cHRpb25LZXkpIHtcbiAgY29uc3Qga2V5ID0gQ3J5cHRvSlMuU0hBMjU2KHByb2Nlc3NlZE93bmVyUGFzc3dvcmQuY2xvbmUoKS5jb25jYXQob3duZXJLZXlTYWx0KS5jb25jYXQodXNlclBhc3N3b3JkRW50cnkpKTtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcbiAgICBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuTm9QYWRkaW5nLFxuICAgIGl2OiBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShudWxsLCAxNilcbiAgfTtcbiAgcmV0dXJuIENyeXB0b0pTLkFFUy5lbmNyeXB0KGVuY3J5cHRpb25LZXksIGtleSwgb3B0aW9ucykuY2lwaGVydGV4dDtcbn1cbmZ1bmN0aW9uIGdldEVuY3J5cHRpb25LZXlSNShnZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSkge1xuICByZXR1cm4gZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkoMzIpO1xufVxuZnVuY3Rpb24gZ2V0RW5jcnlwdGVkUGVybWlzc2lvbnNSNShwZXJtaXNzaW9ucywgZW5jcnlwdGlvbktleSwgZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkpIHtcbiAgY29uc3QgY2lwaGVyID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoW2xzYkZpcnN0V29yZChwZXJtaXNzaW9ucyksIDB4ZmZmZmZmZmYsIDB4NTQ2MTY0NjJdLCAxMikuY29uY2F0KGdlbmVyYXRlUmFuZG9tV29yZEFycmF5KDQpKTtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkVDQixcbiAgICBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuTm9QYWRkaW5nXG4gIH07XG4gIHJldHVybiBDcnlwdG9KUy5BRVMuZW5jcnlwdChjaXBoZXIsIGVuY3J5cHRpb25LZXksIG9wdGlvbnMpLmNpcGhlcnRleHQ7XG59XG5mdW5jdGlvbiBwcm9jZXNzUGFzc3dvcmRSMlIzUjQoKSB7XG4gIGxldCBwYXNzd29yZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gIGNvbnN0IG91dCA9IEJ1ZmZlci5hbGxvYygzMik7XG4gIGNvbnN0IGxlbmd0aCA9IHBhc3N3b3JkLmxlbmd0aDtcbiAgbGV0IGluZGV4ID0gMDtcbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoICYmIGluZGV4IDwgMzIpIHtcbiAgICBjb25zdCBjb2RlID0gcGFzc3dvcmQuY2hhckNvZGVBdChpbmRleCk7XG4gICAgaWYgKGNvZGUgPiAweGZmKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bhc3N3b3JkIGNvbnRhaW5zIG9uZSBvciBtb3JlIGludmFsaWQgY2hhcmFjdGVycy4nKTtcbiAgICB9XG4gICAgb3V0W2luZGV4XSA9IGNvZGU7XG4gICAgaW5kZXgrKztcbiAgfVxuICB3aGlsZSAoaW5kZXggPCAzMikge1xuICAgIG91dFtpbmRleF0gPSBQQVNTV09SRF9QQURESU5HW2luZGV4IC0gbGVuZ3RoXTtcbiAgICBpbmRleCsrO1xuICB9XG4gIHJldHVybiBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShvdXQpO1xufVxuZnVuY3Rpb24gcHJvY2Vzc1Bhc3N3b3JkUjUoKSB7XG4gIGxldCBwYXNzd29yZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gIHBhc3N3b3JkID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHNhc2xwcmVwKHBhc3N3b3JkKSkpO1xuICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbigxMjcsIHBhc3N3b3JkLmxlbmd0aCk7XG4gIGNvbnN0IG91dCA9IEJ1ZmZlci5hbGxvYyhsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgb3V0W2ldID0gcGFzc3dvcmQuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUob3V0KTtcbn1cbmZ1bmN0aW9uIGxzYkZpcnN0V29yZChkYXRhKSB7XG4gIHJldHVybiAoZGF0YSAmIDB4ZmYpIDw8IDI0IHwgKGRhdGEgJiAweGZmMDApIDw8IDggfCBkYXRhID4+IDggJiAweGZmMDAgfCBkYXRhID4+IDI0ICYgMHhmZjtcbn1cbmZ1bmN0aW9uIHdvcmRBcnJheVRvQnVmZmVyKHdvcmRBcnJheSkge1xuICBjb25zdCBieXRlQXJyYXkgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQXJyYXkuc2lnQnl0ZXM7IGkrKykge1xuICAgIGJ5dGVBcnJheS5wdXNoKHdvcmRBcnJheS53b3Jkc1tNYXRoLmZsb29yKGkgLyA0KV0gPj4gOCAqICgzIC0gaSAlIDQpICYgMHhmZik7XG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVBcnJheSk7XG59XG5jb25zdCBQQVNTV09SRF9QQURESU5HID0gWzB4MjgsIDB4YmYsIDB4NGUsIDB4NWUsIDB4NGUsIDB4NzUsIDB4OGEsIDB4NDEsIDB4NjQsIDB4MDAsIDB4NGUsIDB4NTYsIDB4ZmYsIDB4ZmEsIDB4MDEsIDB4MDgsIDB4MmUsIDB4MmUsIDB4MDAsIDB4YjYsIDB4ZDAsIDB4NjgsIDB4M2UsIDB4ODAsIDB4MmYsIDB4MGMsIDB4YTksIDB4ZmUsIDB4NjQsIDB4NTMsIDB4NjksIDB4N2FdO1xuXG5jb25zdCB7XG4gIG51bWJlcjogbnVtYmVyJDJcbn0gPSBQREZPYmplY3Q7XG5jbGFzcyBQREZHcmFkaWVudCQxIHtcbiAgY29uc3RydWN0b3IoZG9jKSB7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy5zdG9wcyA9IFtdO1xuICAgIHRoaXMuZW1iZWRkZWQgPSBmYWxzZTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgfVxuICBzdG9wKHBvcywgY29sb3IsIG9wYWNpdHkpIHtcbiAgICBpZiAob3BhY2l0eSA9PSBudWxsKSB7XG4gICAgICBvcGFjaXR5ID0gMTtcbiAgICB9XG4gICAgY29sb3IgPSB0aGlzLmRvYy5fbm9ybWFsaXplQ29sb3IoY29sb3IpO1xuICAgIGlmICh0aGlzLnN0b3BzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGNvbG9yLmxlbmd0aCA9PT0gMykge1xuICAgICAgICB0aGlzLl9jb2xvclNwYWNlID0gJ0RldmljZVJHQic7XG4gICAgICB9IGVsc2UgaWYgKGNvbG9yLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICB0aGlzLl9jb2xvclNwYWNlID0gJ0RldmljZUNNWUsnO1xuICAgICAgfSBlbHNlIGlmIChjb2xvci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5fY29sb3JTcGFjZSA9ICdEZXZpY2VHcmF5JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb2xvciBzcGFjZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fY29sb3JTcGFjZSA9PT0gJ0RldmljZVJHQicgJiYgY29sb3IubGVuZ3RoICE9PSAzIHx8IHRoaXMuX2NvbG9yU3BhY2UgPT09ICdEZXZpY2VDTVlLJyAmJiBjb2xvci5sZW5ndGggIT09IDQgfHwgdGhpcy5fY29sb3JTcGFjZSA9PT0gJ0RldmljZUdyYXknICYmIGNvbG9yLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbGwgZ3JhZGllbnQgc3RvcHMgbXVzdCB1c2UgdGhlIHNhbWUgY29sb3Igc3BhY2UnKTtcbiAgICB9XG4gICAgb3BhY2l0eSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIG9wYWNpdHkpKTtcbiAgICB0aGlzLnN0b3BzLnB1c2goW3BvcywgY29sb3IsIG9wYWNpdHldKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRUcmFuc2Zvcm0obTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHkpIHtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IFttMTEsIG0xMiwgbTIxLCBtMjIsIGR4LCBkeV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZW1iZWQobSkge1xuICAgIGxldCBmbjtcbiAgICBjb25zdCBzdG9wc0xlbmd0aCA9IHRoaXMuc3RvcHMubGVuZ3RoO1xuICAgIGlmIChzdG9wc0xlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtYmVkZGVkID0gdHJ1ZTtcbiAgICB0aGlzLm1hdHJpeCA9IG07XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuc3RvcHNbc3RvcHNMZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdFswXSA8IDEpIHtcbiAgICAgIHRoaXMuc3RvcHMucHVzaChbMSwgbGFzdFsxXSwgbGFzdFsyXV0pO1xuICAgIH1cbiAgICBjb25zdCBib3VuZHMgPSBbXTtcbiAgICBjb25zdCBlbmNvZGUgPSBbXTtcbiAgICBjb25zdCBzdG9wcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RvcHNMZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGVuY29kZS5wdXNoKDAsIDEpO1xuICAgICAgaWYgKGkgKyAyICE9PSBzdG9wc0xlbmd0aCkge1xuICAgICAgICBib3VuZHMucHVzaCh0aGlzLnN0b3BzW2kgKyAxXVswXSk7XG4gICAgICB9XG4gICAgICBmbiA9IHRoaXMuZG9jLnJlZih7XG4gICAgICAgIEZ1bmN0aW9uVHlwZTogMixcbiAgICAgICAgRG9tYWluOiBbMCwgMV0sXG4gICAgICAgIEMwOiB0aGlzLnN0b3BzW2kgKyAwXVsxXSxcbiAgICAgICAgQzE6IHRoaXMuc3RvcHNbaSArIDFdWzFdLFxuICAgICAgICBOOiAxXG4gICAgICB9KTtcbiAgICAgIHN0b3BzLnB1c2goZm4pO1xuICAgICAgZm4uZW5kKCk7XG4gICAgfVxuICAgIGlmIChzdG9wc0xlbmd0aCA9PT0gMSkge1xuICAgICAgZm4gPSBzdG9wc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4gPSB0aGlzLmRvYy5yZWYoe1xuICAgICAgICBGdW5jdGlvblR5cGU6IDMsXG4gICAgICAgIERvbWFpbjogWzAsIDFdLFxuICAgICAgICBGdW5jdGlvbnM6IHN0b3BzLFxuICAgICAgICBCb3VuZHM6IGJvdW5kcyxcbiAgICAgICAgRW5jb2RlOiBlbmNvZGVcbiAgICAgIH0pO1xuICAgICAgZm4uZW5kKCk7XG4gICAgfVxuICAgIHRoaXMuaWQgPSBgU2gkeysrdGhpcy5kb2MuX2dyYWRDb3VudH1gO1xuICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyKGZuKTtcbiAgICBzaGFkZXIuZW5kKCk7XG4gICAgY29uc3QgcGF0dGVybiA9IHRoaXMuZG9jLnJlZih7XG4gICAgICBUeXBlOiAnUGF0dGVybicsXG4gICAgICBQYXR0ZXJuVHlwZTogMixcbiAgICAgIFNoYWRpbmc6IHNoYWRlcixcbiAgICAgIE1hdHJpeDogdGhpcy5tYXRyaXgubWFwKG51bWJlciQyKVxuICAgIH0pO1xuICAgIHBhdHRlcm4uZW5kKCk7XG4gICAgaWYgKHRoaXMuc3RvcHMuc29tZShzdG9wID0+IHN0b3BbMl0gPCAxKSkge1xuICAgICAgbGV0IGdyYWQgPSB0aGlzLm9wYWNpdHlHcmFkaWVudCgpO1xuICAgICAgZ3JhZC5fY29sb3JTcGFjZSA9ICdEZXZpY2VHcmF5JztcbiAgICAgIGZvciAobGV0IHN0b3Agb2YgdGhpcy5zdG9wcykge1xuICAgICAgICBncmFkLnN0b3Aoc3RvcFswXSwgW3N0b3BbMl1dKTtcbiAgICAgIH1cbiAgICAgIGdyYWQgPSBncmFkLmVtYmVkKHRoaXMubWF0cml4KTtcbiAgICAgIGNvbnN0IHBhZ2VCQm94ID0gWzAsIDAsIHRoaXMuZG9jLnBhZ2Uud2lkdGgsIHRoaXMuZG9jLnBhZ2UuaGVpZ2h0XTtcbiAgICAgIGNvbnN0IGZvcm0gPSB0aGlzLmRvYy5yZWYoe1xuICAgICAgICBUeXBlOiAnWE9iamVjdCcsXG4gICAgICAgIFN1YnR5cGU6ICdGb3JtJyxcbiAgICAgICAgRm9ybVR5cGU6IDEsXG4gICAgICAgIEJCb3g6IHBhZ2VCQm94LFxuICAgICAgICBHcm91cDoge1xuICAgICAgICAgIFR5cGU6ICdHcm91cCcsXG4gICAgICAgICAgUzogJ1RyYW5zcGFyZW5jeScsXG4gICAgICAgICAgQ1M6ICdEZXZpY2VHcmF5J1xuICAgICAgICB9LFxuICAgICAgICBSZXNvdXJjZXM6IHtcbiAgICAgICAgICBQcm9jU2V0OiBbJ1BERicsICdUZXh0JywgJ0ltYWdlQicsICdJbWFnZUMnLCAnSW1hZ2VJJ10sXG4gICAgICAgICAgUGF0dGVybjoge1xuICAgICAgICAgICAgU2gxOiBncmFkXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGZvcm0ud3JpdGUoJy9QYXR0ZXJuIGNzIC9TaDEgc2NuJyk7XG4gICAgICBmb3JtLmVuZChgJHtwYWdlQkJveC5qb2luKCcgJyl9IHJlIGZgKTtcbiAgICAgIGNvbnN0IGdzdGF0ZSA9IHRoaXMuZG9jLnJlZih7XG4gICAgICAgIFR5cGU6ICdFeHRHU3RhdGUnLFxuICAgICAgICBTTWFzazoge1xuICAgICAgICAgIFR5cGU6ICdNYXNrJyxcbiAgICAgICAgICBTOiAnTHVtaW5vc2l0eScsXG4gICAgICAgICAgRzogZm9ybVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGdzdGF0ZS5lbmQoKTtcbiAgICAgIGNvbnN0IG9wYWNpdHlQYXR0ZXJuID0gdGhpcy5kb2MucmVmKHtcbiAgICAgICAgVHlwZTogJ1BhdHRlcm4nLFxuICAgICAgICBQYXR0ZXJuVHlwZTogMSxcbiAgICAgICAgUGFpbnRUeXBlOiAxLFxuICAgICAgICBUaWxpbmdUeXBlOiAyLFxuICAgICAgICBCQm94OiBwYWdlQkJveCxcbiAgICAgICAgWFN0ZXA6IHBhZ2VCQm94WzJdLFxuICAgICAgICBZU3RlcDogcGFnZUJCb3hbM10sXG4gICAgICAgIFJlc291cmNlczoge1xuICAgICAgICAgIFByb2NTZXQ6IFsnUERGJywgJ1RleHQnLCAnSW1hZ2VCJywgJ0ltYWdlQycsICdJbWFnZUknXSxcbiAgICAgICAgICBQYXR0ZXJuOiB7XG4gICAgICAgICAgICBTaDE6IHBhdHRlcm5cbiAgICAgICAgICB9LFxuICAgICAgICAgIEV4dEdTdGF0ZToge1xuICAgICAgICAgICAgR3MxOiBnc3RhdGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb3BhY2l0eVBhdHRlcm4ud3JpdGUoJy9HczEgZ3MgL1BhdHRlcm4gY3MgL1NoMSBzY24nKTtcbiAgICAgIG9wYWNpdHlQYXR0ZXJuLmVuZChgJHtwYWdlQkJveC5qb2luKCcgJyl9IHJlIGZgKTtcbiAgICAgIHRoaXMuZG9jLnBhZ2UucGF0dGVybnNbdGhpcy5pZF0gPSBvcGFjaXR5UGF0dGVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kb2MucGFnZS5wYXR0ZXJuc1t0aGlzLmlkXSA9IHBhdHRlcm47XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG4gIGFwcGx5KHN0cm9rZSkge1xuICAgIGNvbnN0IFttMCwgbTEsIG0yLCBtMywgbTQsIG01XSA9IHRoaXMuZG9jLl9jdG07XG4gICAgY29uc3QgW20xMSwgbTEyLCBtMjEsIG0yMiwgZHgsIGR5XSA9IHRoaXMudHJhbnNmb3JtO1xuICAgIGNvbnN0IG0gPSBbbTAgKiBtMTEgKyBtMiAqIG0xMiwgbTEgKiBtMTEgKyBtMyAqIG0xMiwgbTAgKiBtMjEgKyBtMiAqIG0yMiwgbTEgKiBtMjEgKyBtMyAqIG0yMiwgbTAgKiBkeCArIG0yICogZHkgKyBtNCwgbTEgKiBkeCArIG0zICogZHkgKyBtNV07XG4gICAgaWYgKCF0aGlzLmVtYmVkZGVkIHx8IG0uam9pbignICcpICE9PSB0aGlzLm1hdHJpeC5qb2luKCcgJykpIHtcbiAgICAgIHRoaXMuZW1iZWQobSk7XG4gICAgfVxuICAgIHRoaXMuZG9jLl9zZXRDb2xvclNwYWNlKCdQYXR0ZXJuJywgc3Ryb2tlKTtcbiAgICBjb25zdCBvcCA9IHN0cm9rZSA/ICdTQ04nIDogJ3Njbic7XG4gICAgcmV0dXJuIHRoaXMuZG9jLmFkZENvbnRlbnQoYC8ke3RoaXMuaWR9ICR7b3B9YCk7XG4gIH1cbn1cbmNsYXNzIFBERkxpbmVhckdyYWRpZW50JDEgZXh0ZW5kcyBQREZHcmFkaWVudCQxIHtcbiAgY29uc3RydWN0b3IoZG9jLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIHN1cGVyKGRvYyk7XG4gICAgdGhpcy54MSA9IHgxO1xuICAgIHRoaXMueTEgPSB5MTtcbiAgICB0aGlzLngyID0geDI7XG4gICAgdGhpcy55MiA9IHkyO1xuICB9XG4gIHNoYWRlcihmbikge1xuICAgIHJldHVybiB0aGlzLmRvYy5yZWYoe1xuICAgICAgU2hhZGluZ1R5cGU6IDIsXG4gICAgICBDb2xvclNwYWNlOiB0aGlzLl9jb2xvclNwYWNlLFxuICAgICAgQ29vcmRzOiBbdGhpcy54MSwgdGhpcy55MSwgdGhpcy54MiwgdGhpcy55Ml0sXG4gICAgICBGdW5jdGlvbjogZm4sXG4gICAgICBFeHRlbmQ6IFt0cnVlLCB0cnVlXVxuICAgIH0pO1xuICB9XG4gIG9wYWNpdHlHcmFkaWVudCgpIHtcbiAgICByZXR1cm4gbmV3IFBERkxpbmVhckdyYWRpZW50JDEodGhpcy5kb2MsIHRoaXMueDEsIHRoaXMueTEsIHRoaXMueDIsIHRoaXMueTIpO1xuICB9XG59XG5jbGFzcyBQREZSYWRpYWxHcmFkaWVudCQxIGV4dGVuZHMgUERGR3JhZGllbnQkMSB7XG4gIGNvbnN0cnVjdG9yKGRvYywgeDEsIHkxLCByMSwgeDIsIHkyLCByMikge1xuICAgIHN1cGVyKGRvYyk7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy54MSA9IHgxO1xuICAgIHRoaXMueTEgPSB5MTtcbiAgICB0aGlzLnIxID0gcjE7XG4gICAgdGhpcy54MiA9IHgyO1xuICAgIHRoaXMueTIgPSB5MjtcbiAgICB0aGlzLnIyID0gcjI7XG4gIH1cbiAgc2hhZGVyKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9jLnJlZih7XG4gICAgICBTaGFkaW5nVHlwZTogMyxcbiAgICAgIENvbG9yU3BhY2U6IHRoaXMuX2NvbG9yU3BhY2UsXG4gICAgICBDb29yZHM6IFt0aGlzLngxLCB0aGlzLnkxLCB0aGlzLnIxLCB0aGlzLngyLCB0aGlzLnkyLCB0aGlzLnIyXSxcbiAgICAgIEZ1bmN0aW9uOiBmbixcbiAgICAgIEV4dGVuZDogW3RydWUsIHRydWVdXG4gICAgfSk7XG4gIH1cbiAgb3BhY2l0eUdyYWRpZW50KCkge1xuICAgIHJldHVybiBuZXcgUERGUmFkaWFsR3JhZGllbnQkMSh0aGlzLmRvYywgdGhpcy54MSwgdGhpcy55MSwgdGhpcy5yMSwgdGhpcy54MiwgdGhpcy55MiwgdGhpcy5yMik7XG4gIH1cbn1cbnZhciBHcmFkaWVudCA9IHtcbiAgUERGR3JhZGllbnQ6IFBERkdyYWRpZW50JDEsXG4gIFBERkxpbmVhckdyYWRpZW50OiBQREZMaW5lYXJHcmFkaWVudCQxLFxuICBQREZSYWRpYWxHcmFkaWVudDogUERGUmFkaWFsR3JhZGllbnQkMVxufTtcblxuY29uc3QgdW5kZXJseWluZ0NvbG9yU3BhY2VzID0gWydEZXZpY2VDTVlLJywgJ0RldmljZVJHQiddO1xuY2xhc3MgUERGVGlsaW5nUGF0dGVybiQxIHtcbiAgY29uc3RydWN0b3IoZG9jLCBiQm94LCB4U3RlcCwgeVN0ZXAsIHN0cmVhbSkge1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMuYkJveCA9IGJCb3g7XG4gICAgdGhpcy54U3RlcCA9IHhTdGVwO1xuICAgIHRoaXMueVN0ZXAgPSB5U3RlcDtcbiAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgfVxuICBjcmVhdGVQYXR0ZXJuKCkge1xuICAgIGNvbnN0IHJlc291cmNlcyA9IHRoaXMuZG9jLnJlZigpO1xuICAgIHJlc291cmNlcy5lbmQoKTtcbiAgICBjb25zdCBbbTAsIG0xLCBtMiwgbTMsIG00LCBtNV0gPSB0aGlzLmRvYy5fY3RtO1xuICAgIGNvbnN0IFttMTEsIG0xMiwgbTIxLCBtMjIsIGR4LCBkeV0gPSBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgY29uc3QgbSA9IFttMCAqIG0xMSArIG0yICogbTEyLCBtMSAqIG0xMSArIG0zICogbTEyLCBtMCAqIG0yMSArIG0yICogbTIyLCBtMSAqIG0yMSArIG0zICogbTIyLCBtMCAqIGR4ICsgbTIgKiBkeSArIG00LCBtMSAqIGR4ICsgbTMgKiBkeSArIG01XTtcbiAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5kb2MucmVmKHtcbiAgICAgIFR5cGU6ICdQYXR0ZXJuJyxcbiAgICAgIFBhdHRlcm5UeXBlOiAxLFxuICAgICAgUGFpbnRUeXBlOiAyLFxuICAgICAgVGlsaW5nVHlwZTogMixcbiAgICAgIEJCb3g6IHRoaXMuYkJveCxcbiAgICAgIFhTdGVwOiB0aGlzLnhTdGVwLFxuICAgICAgWVN0ZXA6IHRoaXMueVN0ZXAsXG4gICAgICBNYXRyaXg6IG0ubWFwKHYgPT4gK3YudG9GaXhlZCg1KSksXG4gICAgICBSZXNvdXJjZXM6IHJlc291cmNlc1xuICAgIH0pO1xuICAgIHBhdHRlcm4uZW5kKHRoaXMuc3RyZWFtKTtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICBlbWJlZFBhdHRlcm5Db2xvclNwYWNlcygpIHtcbiAgICB1bmRlcmx5aW5nQ29sb3JTcGFjZXMuZm9yRWFjaChjc05hbWUgPT4ge1xuICAgICAgY29uc3QgY3NJZCA9IHRoaXMuZ2V0UGF0dGVybkNvbG9yU3BhY2VJZChjc05hbWUpO1xuICAgICAgaWYgKHRoaXMuZG9jLnBhZ2UuY29sb3JTcGFjZXNbY3NJZF0pIHJldHVybjtcbiAgICAgIGNvbnN0IGNzID0gdGhpcy5kb2MucmVmKFsnUGF0dGVybicsIGNzTmFtZV0pO1xuICAgICAgY3MuZW5kKCk7XG4gICAgICB0aGlzLmRvYy5wYWdlLmNvbG9yU3BhY2VzW2NzSWRdID0gY3M7XG4gICAgfSk7XG4gIH1cbiAgZ2V0UGF0dGVybkNvbG9yU3BhY2VJZCh1bmRlcmx5aW5nQ29sb3JzcGFjZSkge1xuICAgIHJldHVybiBgQ3NQJHt1bmRlcmx5aW5nQ29sb3JzcGFjZX1gO1xuICB9XG4gIGVtYmVkKCkge1xuICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgdGhpcy5kb2MuX3BhdHRlcm5Db3VudCA9IHRoaXMuZG9jLl9wYXR0ZXJuQ291bnQgKyAxO1xuICAgICAgdGhpcy5pZCA9ICdQJyArIHRoaXMuZG9jLl9wYXR0ZXJuQ291bnQ7XG4gICAgICB0aGlzLnBhdHRlcm4gPSB0aGlzLmNyZWF0ZVBhdHRlcm4oKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmRvYy5wYWdlLnBhdHRlcm5zW3RoaXMuaWRdKSB7XG4gICAgICB0aGlzLmRvYy5wYWdlLnBhdHRlcm5zW3RoaXMuaWRdID0gdGhpcy5wYXR0ZXJuO1xuICAgIH1cbiAgfVxuICBhcHBseShzdHJva2UsIHBhdHRlcm5Db2xvcikge1xuICAgIHRoaXMuZW1iZWRQYXR0ZXJuQ29sb3JTcGFjZXMoKTtcbiAgICB0aGlzLmVtYmVkKCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZENvbG9yID0gdGhpcy5kb2MuX25vcm1hbGl6ZUNvbG9yKHBhdHRlcm5Db2xvcik7XG4gICAgaWYgKCFub3JtYWxpemVkQ29sb3IpIHRocm93IEVycm9yKGBpbnZhbGlkIHBhdHRlcm4gY29sb3IuICh2YWx1ZTogJHtwYXR0ZXJuQ29sb3J9KWApO1xuICAgIGNvbnN0IGNzSWQgPSB0aGlzLmdldFBhdHRlcm5Db2xvclNwYWNlSWQodGhpcy5kb2MuX2dldENvbG9yU3BhY2Uobm9ybWFsaXplZENvbG9yKSk7XG4gICAgdGhpcy5kb2MuX3NldENvbG9yU3BhY2UoY3NJZCwgc3Ryb2tlKTtcbiAgICBjb25zdCBvcCA9IHN0cm9rZSA/ICdTQ04nIDogJ3Njbic7XG4gICAgcmV0dXJuIHRoaXMuZG9jLmFkZENvbnRlbnQoYCR7bm9ybWFsaXplZENvbG9yLmpvaW4oJyAnKX0gLyR7dGhpcy5pZH0gJHtvcH1gKTtcbiAgfVxufVxudmFyIHBhdHRlcm4gPSB7XG4gIFBERlRpbGluZ1BhdHRlcm46IFBERlRpbGluZ1BhdHRlcm4kMVxufTtcblxuY29uc3Qge1xuICBQREZHcmFkaWVudCxcbiAgUERGTGluZWFyR3JhZGllbnQsXG4gIFBERlJhZGlhbEdyYWRpZW50XG59ID0gR3JhZGllbnQ7XG5jb25zdCB7XG4gIFBERlRpbGluZ1BhdHRlcm5cbn0gPSBwYXR0ZXJuO1xudmFyIENvbG9yTWl4aW4gPSB7XG4gIGluaXRDb2xvcigpIHtcbiAgICB0aGlzLnNwb3RDb2xvcnMgPSB7fTtcbiAgICB0aGlzLl9vcGFjaXR5UmVnaXN0cnkgPSB7fTtcbiAgICB0aGlzLl9vcGFjaXR5Q291bnQgPSAwO1xuICAgIHRoaXMuX3BhdHRlcm5Db3VudCA9IDA7XG4gICAgdGhpcy5fZ3JhZENvdW50ID0gMDtcbiAgfSxcbiAgX25vcm1hbGl6ZUNvbG9yKGNvbG9yKSB7XG4gICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChjb2xvci5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICBpZiAoY29sb3IubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgY29sb3IgPSBjb2xvci5yZXBsYWNlKC8jKFswLTlBLUZdKShbMC05QS1GXSkoWzAtOUEtRl0pL2ksICcjJDEkMSQyJDIkMyQzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGV4ID0gcGFyc2VJbnQoY29sb3Iuc2xpY2UoMSksIDE2KTtcbiAgICAgICAgY29sb3IgPSBbaGV4ID4+IDE2LCBoZXggPj4gOCAmIDB4ZmYsIGhleCAmIDB4ZmZdO1xuICAgICAgfSBlbHNlIGlmIChuYW1lZENvbG9yc1tjb2xvcl0pIHtcbiAgICAgICAgY29sb3IgPSBuYW1lZENvbG9yc1tjb2xvcl07XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3BvdENvbG9yc1tjb2xvcl0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BvdENvbG9yc1tjb2xvcl07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbG9yKSkge1xuICAgICAgaWYgKGNvbG9yLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBjb2xvciA9IGNvbG9yLm1hcChwYXJ0ID0+IHBhcnQgLyAyNTUpO1xuICAgICAgfSBlbHNlIGlmIChjb2xvci5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgY29sb3IgPSBjb2xvci5tYXAocGFydCA9PiBwYXJ0IC8gMTAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIF9zZXRDb2xvcihjb2xvciwgc3Ryb2tlKSB7XG4gICAgaWYgKGNvbG9yIGluc3RhbmNlb2YgUERGR3JhZGllbnQpIHtcbiAgICAgIGNvbG9yLmFwcGx5KHN0cm9rZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29sb3IpICYmIGNvbG9yWzBdIGluc3RhbmNlb2YgUERGVGlsaW5nUGF0dGVybikge1xuICAgICAgY29sb3JbMF0uYXBwbHkoc3Ryb2tlLCBjb2xvclsxXSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NldENvbG9yQ29yZShjb2xvciwgc3Ryb2tlKTtcbiAgfSxcbiAgX3NldENvbG9yQ29yZShjb2xvciwgc3Ryb2tlKSB7XG4gICAgY29sb3IgPSB0aGlzLl9ub3JtYWxpemVDb2xvcihjb2xvcik7XG4gICAgaWYgKCFjb2xvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBvcCA9IHN0cm9rZSA/ICdTQ04nIDogJ3Njbic7XG4gICAgY29uc3Qgc3BhY2UgPSB0aGlzLl9nZXRDb2xvclNwYWNlKGNvbG9yKTtcbiAgICB0aGlzLl9zZXRDb2xvclNwYWNlKHNwYWNlLCBzdHJva2UpO1xuICAgIGlmIChjb2xvciBpbnN0YW5jZW9mIFNwb3RDb2xvcikge1xuICAgICAgdGhpcy5wYWdlLmNvbG9yU3BhY2VzW2NvbG9yLmlkXSA9IGNvbG9yLnJlZjtcbiAgICAgIHRoaXMuYWRkQ29udGVudChgMSAke29wfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZENvbnRlbnQoYCR7Y29sb3Iuam9pbignICcpfSAke29wfWApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgX3NldENvbG9yU3BhY2Uoc3BhY2UsIHN0cm9rZSkge1xuICAgIGNvbnN0IG9wID0gc3Ryb2tlID8gJ0NTJyA6ICdjcyc7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChgLyR7c3BhY2V9ICR7b3B9YCk7XG4gIH0sXG4gIF9nZXRDb2xvclNwYWNlKGNvbG9yKSB7XG4gICAgaWYgKGNvbG9yIGluc3RhbmNlb2YgU3BvdENvbG9yKSB7XG4gICAgICByZXR1cm4gY29sb3IuaWQ7XG4gICAgfVxuICAgIHJldHVybiBjb2xvci5sZW5ndGggPT09IDQgPyAnRGV2aWNlQ01ZSycgOiAnRGV2aWNlUkdCJztcbiAgfSxcbiAgZmlsbENvbG9yKGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgY29uc3Qgc2V0ID0gdGhpcy5fc2V0Q29sb3IoY29sb3IsIGZhbHNlKTtcbiAgICBpZiAoc2V0KSB7XG4gICAgICB0aGlzLmZpbGxPcGFjaXR5KG9wYWNpdHkpO1xuICAgIH1cbiAgICB0aGlzLl9maWxsQ29sb3IgPSBbY29sb3IsIG9wYWNpdHldO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzdHJva2VDb2xvcihjb2xvciwgb3BhY2l0eSkge1xuICAgIGNvbnN0IHNldCA9IHRoaXMuX3NldENvbG9yKGNvbG9yLCB0cnVlKTtcbiAgICBpZiAoc2V0KSB7XG4gICAgICB0aGlzLnN0cm9rZU9wYWNpdHkob3BhY2l0eSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBvcGFjaXR5KG9wYWNpdHkpIHtcbiAgICB0aGlzLl9kb09wYWNpdHkob3BhY2l0eSwgb3BhY2l0eSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGZpbGxPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICB0aGlzLl9kb09wYWNpdHkob3BhY2l0eSwgbnVsbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHN0cm9rZU9wYWNpdHkob3BhY2l0eSkge1xuICAgIHRoaXMuX2RvT3BhY2l0eShudWxsLCBvcGFjaXR5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2RvT3BhY2l0eShmaWxsT3BhY2l0eSwgc3Ryb2tlT3BhY2l0eSkge1xuICAgIGxldCBkaWN0aW9uYXJ5LCBuYW1lO1xuICAgIGlmIChmaWxsT3BhY2l0eSA9PSBudWxsICYmIHN0cm9rZU9wYWNpdHkgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZmlsbE9wYWNpdHkgIT0gbnVsbCkge1xuICAgICAgZmlsbE9wYWNpdHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBmaWxsT3BhY2l0eSkpO1xuICAgIH1cbiAgICBpZiAoc3Ryb2tlT3BhY2l0eSAhPSBudWxsKSB7XG4gICAgICBzdHJva2VPcGFjaXR5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgc3Ryb2tlT3BhY2l0eSkpO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBgJHtmaWxsT3BhY2l0eX1fJHtzdHJva2VPcGFjaXR5fWA7XG4gICAgaWYgKHRoaXMuX29wYWNpdHlSZWdpc3RyeVtrZXldKSB7XG4gICAgICBbZGljdGlvbmFyeSwgbmFtZV0gPSB0aGlzLl9vcGFjaXR5UmVnaXN0cnlba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdGlvbmFyeSA9IHtcbiAgICAgICAgVHlwZTogJ0V4dEdTdGF0ZSdcbiAgICAgIH07XG4gICAgICBpZiAoZmlsbE9wYWNpdHkgIT0gbnVsbCkge1xuICAgICAgICBkaWN0aW9uYXJ5LmNhID0gZmlsbE9wYWNpdHk7XG4gICAgICB9XG4gICAgICBpZiAoc3Ryb2tlT3BhY2l0eSAhPSBudWxsKSB7XG4gICAgICAgIGRpY3Rpb25hcnkuQ0EgPSBzdHJva2VPcGFjaXR5O1xuICAgICAgfVxuICAgICAgZGljdGlvbmFyeSA9IHRoaXMucmVmKGRpY3Rpb25hcnkpO1xuICAgICAgZGljdGlvbmFyeS5lbmQoKTtcbiAgICAgIGNvbnN0IGlkID0gKyt0aGlzLl9vcGFjaXR5Q291bnQ7XG4gICAgICBuYW1lID0gYEdzJHtpZH1gO1xuICAgICAgdGhpcy5fb3BhY2l0eVJlZ2lzdHJ5W2tleV0gPSBbZGljdGlvbmFyeSwgbmFtZV07XG4gICAgfVxuICAgIHRoaXMucGFnZS5leHRfZ3N0YXRlc1tuYW1lXSA9IGRpY3Rpb25hcnk7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChgLyR7bmFtZX0gZ3NgKTtcbiAgfSxcbiAgbGluZWFyR3JhZGllbnQoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gbmV3IFBERkxpbmVhckdyYWRpZW50KHRoaXMsIHgxLCB5MSwgeDIsIHkyKTtcbiAgfSxcbiAgcmFkaWFsR3JhZGllbnQoeDEsIHkxLCByMSwgeDIsIHkyLCByMikge1xuICAgIHJldHVybiBuZXcgUERGUmFkaWFsR3JhZGllbnQodGhpcywgeDEsIHkxLCByMSwgeDIsIHkyLCByMik7XG4gIH0sXG4gIHBhdHRlcm4oYmJveCwgeFN0ZXAsIHlTdGVwLCBzdHJlYW0pIHtcbiAgICByZXR1cm4gbmV3IFBERlRpbGluZ1BhdHRlcm4odGhpcywgYmJveCwgeFN0ZXAsIHlTdGVwLCBzdHJlYW0pO1xuICB9LFxuICBhZGRTcG90Q29sb3IobmFtZSwgQywgTSwgWSwgSykge1xuICAgIGNvbnN0IGNvbG9yID0gbmV3IFNwb3RDb2xvcih0aGlzLCBuYW1lLCBDLCBNLCBZLCBLKTtcbiAgICB0aGlzLnNwb3RDb2xvcnNbbmFtZV0gPSBjb2xvcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBuYW1lZENvbG9ycyA9IHtcbiAgYWxpY2VibHVlOiBbMjQwLCAyNDgsIDI1NV0sXG4gIGFudGlxdWV3aGl0ZTogWzI1MCwgMjM1LCAyMTVdLFxuICBhcXVhOiBbMCwgMjU1LCAyNTVdLFxuICBhcXVhbWFyaW5lOiBbMTI3LCAyNTUsIDIxMl0sXG4gIGF6dXJlOiBbMjQwLCAyNTUsIDI1NV0sXG4gIGJlaWdlOiBbMjQ1LCAyNDUsIDIyMF0sXG4gIGJpc3F1ZTogWzI1NSwgMjI4LCAxOTZdLFxuICBibGFjazogWzAsIDAsIDBdLFxuICBibGFuY2hlZGFsbW9uZDogWzI1NSwgMjM1LCAyMDVdLFxuICBibHVlOiBbMCwgMCwgMjU1XSxcbiAgYmx1ZXZpb2xldDogWzEzOCwgNDMsIDIyNl0sXG4gIGJyb3duOiBbMTY1LCA0MiwgNDJdLFxuICBidXJseXdvb2Q6IFsyMjIsIDE4NCwgMTM1XSxcbiAgY2FkZXRibHVlOiBbOTUsIDE1OCwgMTYwXSxcbiAgY2hhcnRyZXVzZTogWzEyNywgMjU1LCAwXSxcbiAgY2hvY29sYXRlOiBbMjEwLCAxMDUsIDMwXSxcbiAgY29yYWw6IFsyNTUsIDEyNywgODBdLFxuICBjb3JuZmxvd2VyYmx1ZTogWzEwMCwgMTQ5LCAyMzddLFxuICBjb3Juc2lsazogWzI1NSwgMjQ4LCAyMjBdLFxuICBjcmltc29uOiBbMjIwLCAyMCwgNjBdLFxuICBjeWFuOiBbMCwgMjU1LCAyNTVdLFxuICBkYXJrYmx1ZTogWzAsIDAsIDEzOV0sXG4gIGRhcmtjeWFuOiBbMCwgMTM5LCAxMzldLFxuICBkYXJrZ29sZGVucm9kOiBbMTg0LCAxMzQsIDExXSxcbiAgZGFya2dyYXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgZGFya2dyZWVuOiBbMCwgMTAwLCAwXSxcbiAgZGFya2dyZXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgZGFya2toYWtpOiBbMTg5LCAxODMsIDEwN10sXG4gIGRhcmttYWdlbnRhOiBbMTM5LCAwLCAxMzldLFxuICBkYXJrb2xpdmVncmVlbjogWzg1LCAxMDcsIDQ3XSxcbiAgZGFya29yYW5nZTogWzI1NSwgMTQwLCAwXSxcbiAgZGFya29yY2hpZDogWzE1MywgNTAsIDIwNF0sXG4gIGRhcmtyZWQ6IFsxMzksIDAsIDBdLFxuICBkYXJrc2FsbW9uOiBbMjMzLCAxNTAsIDEyMl0sXG4gIGRhcmtzZWFncmVlbjogWzE0MywgMTg4LCAxNDNdLFxuICBkYXJrc2xhdGVibHVlOiBbNzIsIDYxLCAxMzldLFxuICBkYXJrc2xhdGVncmF5OiBbNDcsIDc5LCA3OV0sXG4gIGRhcmtzbGF0ZWdyZXk6IFs0NywgNzksIDc5XSxcbiAgZGFya3R1cnF1b2lzZTogWzAsIDIwNiwgMjA5XSxcbiAgZGFya3Zpb2xldDogWzE0OCwgMCwgMjExXSxcbiAgZGVlcHBpbms6IFsyNTUsIDIwLCAxNDddLFxuICBkZWVwc2t5Ymx1ZTogWzAsIDE5MSwgMjU1XSxcbiAgZGltZ3JheTogWzEwNSwgMTA1LCAxMDVdLFxuICBkaW1ncmV5OiBbMTA1LCAxMDUsIDEwNV0sXG4gIGRvZGdlcmJsdWU6IFszMCwgMTQ0LCAyNTVdLFxuICBmaXJlYnJpY2s6IFsxNzgsIDM0LCAzNF0sXG4gIGZsb3JhbHdoaXRlOiBbMjU1LCAyNTAsIDI0MF0sXG4gIGZvcmVzdGdyZWVuOiBbMzQsIDEzOSwgMzRdLFxuICBmdWNoc2lhOiBbMjU1LCAwLCAyNTVdLFxuICBnYWluc2Jvcm86IFsyMjAsIDIyMCwgMjIwXSxcbiAgZ2hvc3R3aGl0ZTogWzI0OCwgMjQ4LCAyNTVdLFxuICBnb2xkOiBbMjU1LCAyMTUsIDBdLFxuICBnb2xkZW5yb2Q6IFsyMTgsIDE2NSwgMzJdLFxuICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIGdyZXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICBncmVlbnllbGxvdzogWzE3MywgMjU1LCA0N10sXG4gIGhvbmV5ZGV3OiBbMjQwLCAyNTUsIDI0MF0sXG4gIGhvdHBpbms6IFsyNTUsIDEwNSwgMTgwXSxcbiAgaW5kaWFucmVkOiBbMjA1LCA5MiwgOTJdLFxuICBpbmRpZ286IFs3NSwgMCwgMTMwXSxcbiAgaXZvcnk6IFsyNTUsIDI1NSwgMjQwXSxcbiAga2hha2k6IFsyNDAsIDIzMCwgMTQwXSxcbiAgbGF2ZW5kZXI6IFsyMzAsIDIzMCwgMjUwXSxcbiAgbGF2ZW5kZXJibHVzaDogWzI1NSwgMjQwLCAyNDVdLFxuICBsYXduZ3JlZW46IFsxMjQsIDI1MiwgMF0sXG4gIGxlbW9uY2hpZmZvbjogWzI1NSwgMjUwLCAyMDVdLFxuICBsaWdodGJsdWU6IFsxNzMsIDIxNiwgMjMwXSxcbiAgbGlnaHRjb3JhbDogWzI0MCwgMTI4LCAxMjhdLFxuICBsaWdodGN5YW46IFsyMjQsIDI1NSwgMjU1XSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsIDI1MCwgMjEwXSxcbiAgbGlnaHRncmF5OiBbMjExLCAyMTEsIDIxMV0sXG4gIGxpZ2h0Z3JlZW46IFsxNDQsIDIzOCwgMTQ0XSxcbiAgbGlnaHRncmV5OiBbMjExLCAyMTEsIDIxMV0sXG4gIGxpZ2h0cGluazogWzI1NSwgMTgyLCAxOTNdLFxuICBsaWdodHNhbG1vbjogWzI1NSwgMTYwLCAxMjJdLFxuICBsaWdodHNlYWdyZWVuOiBbMzIsIDE3OCwgMTcwXSxcbiAgbGlnaHRza3libHVlOiBbMTM1LCAyMDYsIDI1MF0sXG4gIGxpZ2h0c2xhdGVncmF5OiBbMTE5LCAxMzYsIDE1M10sXG4gIGxpZ2h0c2xhdGVncmV5OiBbMTE5LCAxMzYsIDE1M10sXG4gIGxpZ2h0c3RlZWxibHVlOiBbMTc2LCAxOTYsIDIyMl0sXG4gIGxpZ2h0eWVsbG93OiBbMjU1LCAyNTUsIDIyNF0sXG4gIGxpbWU6IFswLCAyNTUsIDBdLFxuICBsaW1lZ3JlZW46IFs1MCwgMjA1LCA1MF0sXG4gIGxpbmVuOiBbMjUwLCAyNDAsIDIzMF0sXG4gIG1hZ2VudGE6IFsyNTUsIDAsIDI1NV0sXG4gIG1hcm9vbjogWzEyOCwgMCwgMF0sXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsIDIwNSwgMTcwXSxcbiAgbWVkaXVtYmx1ZTogWzAsIDAsIDIwNV0sXG4gIG1lZGl1bW9yY2hpZDogWzE4NiwgODUsIDIxMV0sXG4gIG1lZGl1bXB1cnBsZTogWzE0NywgMTEyLCAyMTldLFxuICBtZWRpdW1zZWFncmVlbjogWzYwLCAxNzksIDExM10sXG4gIG1lZGl1bXNsYXRlYmx1ZTogWzEyMywgMTA0LCAyMzhdLFxuICBtZWRpdW1zcHJpbmdncmVlbjogWzAsIDI1MCwgMTU0XSxcbiAgbWVkaXVtdHVycXVvaXNlOiBbNzIsIDIwOSwgMjA0XSxcbiAgbWVkaXVtdmlvbGV0cmVkOiBbMTk5LCAyMSwgMTMzXSxcbiAgbWlkbmlnaHRibHVlOiBbMjUsIDI1LCAxMTJdLFxuICBtaW50Y3JlYW06IFsyNDUsIDI1NSwgMjUwXSxcbiAgbWlzdHlyb3NlOiBbMjU1LCAyMjgsIDIyNV0sXG4gIG1vY2Nhc2luOiBbMjU1LCAyMjgsIDE4MV0sXG4gIG5hdmFqb3doaXRlOiBbMjU1LCAyMjIsIDE3M10sXG4gIG5hdnk6IFswLCAwLCAxMjhdLFxuICBvbGRsYWNlOiBbMjUzLCAyNDUsIDIzMF0sXG4gIG9saXZlOiBbMTI4LCAxMjgsIDBdLFxuICBvbGl2ZWRyYWI6IFsxMDcsIDE0MiwgMzVdLFxuICBvcmFuZ2U6IFsyNTUsIDE2NSwgMF0sXG4gIG9yYW5nZXJlZDogWzI1NSwgNjksIDBdLFxuICBvcmNoaWQ6IFsyMTgsIDExMiwgMjE0XSxcbiAgcGFsZWdvbGRlbnJvZDogWzIzOCwgMjMyLCAxNzBdLFxuICBwYWxlZ3JlZW46IFsxNTIsIDI1MSwgMTUyXSxcbiAgcGFsZXR1cnF1b2lzZTogWzE3NSwgMjM4LCAyMzhdLFxuICBwYWxldmlvbGV0cmVkOiBbMjE5LCAxMTIsIDE0N10sXG4gIHBhcGF5YXdoaXA6IFsyNTUsIDIzOSwgMjEzXSxcbiAgcGVhY2hwdWZmOiBbMjU1LCAyMTgsIDE4NV0sXG4gIHBlcnU6IFsyMDUsIDEzMywgNjNdLFxuICBwaW5rOiBbMjU1LCAxOTIsIDIwM10sXG4gIHBsdW06IFsyMjEsIDE2MCwgMjIxXSxcbiAgcG93ZGVyYmx1ZTogWzE3NiwgMjI0LCAyMzBdLFxuICBwdXJwbGU6IFsxMjgsIDAsIDEyOF0sXG4gIHJlZDogWzI1NSwgMCwgMF0sXG4gIHJvc3licm93bjogWzE4OCwgMTQzLCAxNDNdLFxuICByb3lhbGJsdWU6IFs2NSwgMTA1LCAyMjVdLFxuICBzYWRkbGVicm93bjogWzEzOSwgNjksIDE5XSxcbiAgc2FsbW9uOiBbMjUwLCAxMjgsIDExNF0sXG4gIHNhbmR5YnJvd246IFsyNDQsIDE2NCwgOTZdLFxuICBzZWFncmVlbjogWzQ2LCAxMzksIDg3XSxcbiAgc2Vhc2hlbGw6IFsyNTUsIDI0NSwgMjM4XSxcbiAgc2llbm5hOiBbMTYwLCA4MiwgNDVdLFxuICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgc2t5Ymx1ZTogWzEzNSwgMjA2LCAyMzVdLFxuICBzbGF0ZWJsdWU6IFsxMDYsIDkwLCAyMDVdLFxuICBzbGF0ZWdyYXk6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgc2xhdGVncmV5OiBbMTEyLCAxMjgsIDE0NF0sXG4gIHNub3c6IFsyNTUsIDI1MCwgMjUwXSxcbiAgc3ByaW5nZ3JlZW46IFswLCAyNTUsIDEyN10sXG4gIHN0ZWVsYmx1ZTogWzcwLCAxMzAsIDE4MF0sXG4gIHRhbjogWzIxMCwgMTgwLCAxNDBdLFxuICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICB0aGlzdGxlOiBbMjE2LCAxOTEsIDIxNl0sXG4gIHRvbWF0bzogWzI1NSwgOTksIDcxXSxcbiAgdHVycXVvaXNlOiBbNjQsIDIyNCwgMjA4XSxcbiAgdmlvbGV0OiBbMjM4LCAxMzAsIDIzOF0sXG4gIHdoZWF0OiBbMjQ1LCAyMjIsIDE3OV0sXG4gIHdoaXRlOiBbMjU1LCAyNTUsIDI1NV0sXG4gIHdoaXRlc21va2U6IFsyNDUsIDI0NSwgMjQ1XSxcbiAgeWVsbG93OiBbMjU1LCAyNTUsIDBdLFxuICB5ZWxsb3dncmVlbjogWzE1NCwgMjA1LCA1MF1cbn07XG5cbmxldCBjeCwgY3ksIHB4LCBweSwgc3gsIHN5O1xuY3ggPSBjeSA9IHB4ID0gcHkgPSBzeCA9IHN5ID0gMDtcbmNvbnN0IHBhcmFtZXRlcnMgPSB7XG4gIEE6IDcsXG4gIGE6IDcsXG4gIEM6IDYsXG4gIGM6IDYsXG4gIEg6IDEsXG4gIGg6IDEsXG4gIEw6IDIsXG4gIGw6IDIsXG4gIE06IDIsXG4gIG06IDIsXG4gIFE6IDQsXG4gIHE6IDQsXG4gIFM6IDQsXG4gIHM6IDQsXG4gIFQ6IDIsXG4gIHQ6IDIsXG4gIFY6IDEsXG4gIHY6IDEsXG4gIFo6IDAsXG4gIHo6IDBcbn07XG5jb25zdCBwYXJzZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGxldCBjbWQ7XG4gIGNvbnN0IHJldCA9IFtdO1xuICBsZXQgYXJncyA9IFtdO1xuICBsZXQgY3VyQXJnID0gJyc7XG4gIGxldCBmb3VuZERlY2ltYWwgPSBmYWxzZTtcbiAgbGV0IHBhcmFtcyA9IDA7XG4gIGZvciAobGV0IGMgb2YgcGF0aCkge1xuICAgIGlmIChwYXJhbWV0ZXJzW2NdICE9IG51bGwpIHtcbiAgICAgIHBhcmFtcyA9IHBhcmFtZXRlcnNbY107XG4gICAgICBpZiAoY21kKSB7XG4gICAgICAgIGlmIChjdXJBcmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGFyZ3NbYXJncy5sZW5ndGhdID0gK2N1ckFyZztcbiAgICAgICAgfVxuICAgICAgICByZXRbcmV0Lmxlbmd0aF0gPSB7XG4gICAgICAgICAgY21kLFxuICAgICAgICAgIGFyZ3NcbiAgICAgICAgfTtcbiAgICAgICAgYXJncyA9IFtdO1xuICAgICAgICBjdXJBcmcgPSAnJztcbiAgICAgICAgZm91bmREZWNpbWFsID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjbWQgPSBjO1xuICAgIH0gZWxzZSBpZiAoWycgJywgJywnXS5pbmNsdWRlcyhjKSB8fCBjID09PSAnLScgJiYgY3VyQXJnLmxlbmd0aCA+IDAgJiYgY3VyQXJnW2N1ckFyZy5sZW5ndGggLSAxXSAhPT0gJ2UnIHx8IGMgPT09ICcuJyAmJiBmb3VuZERlY2ltYWwpIHtcbiAgICAgIGlmIChjdXJBcmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSBwYXJhbXMpIHtcbiAgICAgICAgcmV0W3JldC5sZW5ndGhdID0ge1xuICAgICAgICAgIGNtZCxcbiAgICAgICAgICBhcmdzXG4gICAgICAgIH07XG4gICAgICAgIGFyZ3MgPSBbK2N1ckFyZ107XG4gICAgICAgIGlmIChjbWQgPT09ICdNJykge1xuICAgICAgICAgIGNtZCA9ICdMJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY21kID09PSAnbScpIHtcbiAgICAgICAgICBjbWQgPSAnbCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3NbYXJncy5sZW5ndGhdID0gK2N1ckFyZztcbiAgICAgIH1cbiAgICAgIGZvdW5kRGVjaW1hbCA9IGMgPT09ICcuJztcbiAgICAgIGN1ckFyZyA9IFsnLScsICcuJ10uaW5jbHVkZXMoYykgPyBjIDogJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1ckFyZyArPSBjO1xuICAgICAgaWYgKGMgPT09ICcuJykge1xuICAgICAgICBmb3VuZERlY2ltYWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoY3VyQXJnLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IHBhcmFtcykge1xuICAgICAgcmV0W3JldC5sZW5ndGhdID0ge1xuICAgICAgICBjbWQsXG4gICAgICAgIGFyZ3NcbiAgICAgIH07XG4gICAgICBhcmdzID0gWytjdXJBcmddO1xuICAgICAgaWYgKGNtZCA9PT0gJ00nKSB7XG4gICAgICAgIGNtZCA9ICdMJztcbiAgICAgIH1cbiAgICAgIGlmIChjbWQgPT09ICdtJykge1xuICAgICAgICBjbWQgPSAnbCc7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3NbYXJncy5sZW5ndGhdID0gK2N1ckFyZztcbiAgICB9XG4gIH1cbiAgcmV0W3JldC5sZW5ndGhdID0ge1xuICAgIGNtZCxcbiAgICBhcmdzXG4gIH07XG4gIHJldHVybiByZXQ7XG59O1xuY29uc3QgYXBwbHkgPSBmdW5jdGlvbiAoY29tbWFuZHMsIGRvYykge1xuICBjeCA9IGN5ID0gcHggPSBweSA9IHN4ID0gc3kgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYyA9IGNvbW1hbmRzW2ldO1xuICAgIGlmICh0eXBlb2YgcnVubmVyc1tjLmNtZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJ1bm5lcnNbYy5jbWRdKGRvYywgYy5hcmdzKTtcbiAgICB9XG4gIH1cbn07XG5jb25zdCBydW5uZXJzID0ge1xuICBNKGRvYywgYSkge1xuICAgIGN4ID0gYVswXTtcbiAgICBjeSA9IGFbMV07XG4gICAgcHggPSBweSA9IG51bGw7XG4gICAgc3ggPSBjeDtcbiAgICBzeSA9IGN5O1xuICAgIHJldHVybiBkb2MubW92ZVRvKGN4LCBjeSk7XG4gIH0sXG4gIG0oZG9jLCBhKSB7XG4gICAgY3ggKz0gYVswXTtcbiAgICBjeSArPSBhWzFdO1xuICAgIHB4ID0gcHkgPSBudWxsO1xuICAgIHN4ID0gY3g7XG4gICAgc3kgPSBjeTtcbiAgICByZXR1cm4gZG9jLm1vdmVUbyhjeCwgY3kpO1xuICB9LFxuICBDKGRvYywgYSkge1xuICAgIGN4ID0gYVs0XTtcbiAgICBjeSA9IGFbNV07XG4gICAgcHggPSBhWzJdO1xuICAgIHB5ID0gYVszXTtcbiAgICByZXR1cm4gZG9jLmJlemllckN1cnZlVG8oLi4uYSk7XG4gIH0sXG4gIGMoZG9jLCBhKSB7XG4gICAgZG9jLmJlemllckN1cnZlVG8oYVswXSArIGN4LCBhWzFdICsgY3ksIGFbMl0gKyBjeCwgYVszXSArIGN5LCBhWzRdICsgY3gsIGFbNV0gKyBjeSk7XG4gICAgcHggPSBjeCArIGFbMl07XG4gICAgcHkgPSBjeSArIGFbM107XG4gICAgY3ggKz0gYVs0XTtcbiAgICByZXR1cm4gY3kgKz0gYVs1XTtcbiAgfSxcbiAgUyhkb2MsIGEpIHtcbiAgICBpZiAocHggPT09IG51bGwpIHtcbiAgICAgIHB4ID0gY3g7XG4gICAgICBweSA9IGN5O1xuICAgIH1cbiAgICBkb2MuYmV6aWVyQ3VydmVUbyhjeCAtIChweCAtIGN4KSwgY3kgLSAocHkgLSBjeSksIGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xuICAgIHB4ID0gYVswXTtcbiAgICBweSA9IGFbMV07XG4gICAgY3ggPSBhWzJdO1xuICAgIHJldHVybiBjeSA9IGFbM107XG4gIH0sXG4gIHMoZG9jLCBhKSB7XG4gICAgaWYgKHB4ID09PSBudWxsKSB7XG4gICAgICBweCA9IGN4O1xuICAgICAgcHkgPSBjeTtcbiAgICB9XG4gICAgZG9jLmJlemllckN1cnZlVG8oY3ggLSAocHggLSBjeCksIGN5IC0gKHB5IC0gY3kpLCBjeCArIGFbMF0sIGN5ICsgYVsxXSwgY3ggKyBhWzJdLCBjeSArIGFbM10pO1xuICAgIHB4ID0gY3ggKyBhWzBdO1xuICAgIHB5ID0gY3kgKyBhWzFdO1xuICAgIGN4ICs9IGFbMl07XG4gICAgcmV0dXJuIGN5ICs9IGFbM107XG4gIH0sXG4gIFEoZG9jLCBhKSB7XG4gICAgcHggPSBhWzBdO1xuICAgIHB5ID0gYVsxXTtcbiAgICBjeCA9IGFbMl07XG4gICAgY3kgPSBhWzNdO1xuICAgIHJldHVybiBkb2MucXVhZHJhdGljQ3VydmVUbyhhWzBdLCBhWzFdLCBjeCwgY3kpO1xuICB9LFxuICBxKGRvYywgYSkge1xuICAgIGRvYy5xdWFkcmF0aWNDdXJ2ZVRvKGFbMF0gKyBjeCwgYVsxXSArIGN5LCBhWzJdICsgY3gsIGFbM10gKyBjeSk7XG4gICAgcHggPSBjeCArIGFbMF07XG4gICAgcHkgPSBjeSArIGFbMV07XG4gICAgY3ggKz0gYVsyXTtcbiAgICByZXR1cm4gY3kgKz0gYVszXTtcbiAgfSxcbiAgVChkb2MsIGEpIHtcbiAgICBpZiAocHggPT09IG51bGwpIHtcbiAgICAgIHB4ID0gY3g7XG4gICAgICBweSA9IGN5O1xuICAgIH0gZWxzZSB7XG4gICAgICBweCA9IGN4IC0gKHB4IC0gY3gpO1xuICAgICAgcHkgPSBjeSAtIChweSAtIGN5KTtcbiAgICB9XG4gICAgZG9jLnF1YWRyYXRpY0N1cnZlVG8ocHgsIHB5LCBhWzBdLCBhWzFdKTtcbiAgICBweCA9IGN4IC0gKHB4IC0gY3gpO1xuICAgIHB5ID0gY3kgLSAocHkgLSBjeSk7XG4gICAgY3ggPSBhWzBdO1xuICAgIHJldHVybiBjeSA9IGFbMV07XG4gIH0sXG4gIHQoZG9jLCBhKSB7XG4gICAgaWYgKHB4ID09PSBudWxsKSB7XG4gICAgICBweCA9IGN4O1xuICAgICAgcHkgPSBjeTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHggPSBjeCAtIChweCAtIGN4KTtcbiAgICAgIHB5ID0gY3kgLSAocHkgLSBjeSk7XG4gICAgfVxuICAgIGRvYy5xdWFkcmF0aWNDdXJ2ZVRvKHB4LCBweSwgY3ggKyBhWzBdLCBjeSArIGFbMV0pO1xuICAgIGN4ICs9IGFbMF07XG4gICAgcmV0dXJuIGN5ICs9IGFbMV07XG4gIH0sXG4gIEEoZG9jLCBhKSB7XG4gICAgc29sdmVBcmMoZG9jLCBjeCwgY3ksIGEpO1xuICAgIGN4ID0gYVs1XTtcbiAgICByZXR1cm4gY3kgPSBhWzZdO1xuICB9LFxuICBhKGRvYywgYSkge1xuICAgIGFbNV0gKz0gY3g7XG4gICAgYVs2XSArPSBjeTtcbiAgICBzb2x2ZUFyYyhkb2MsIGN4LCBjeSwgYSk7XG4gICAgY3ggPSBhWzVdO1xuICAgIHJldHVybiBjeSA9IGFbNl07XG4gIH0sXG4gIEwoZG9jLCBhKSB7XG4gICAgY3ggPSBhWzBdO1xuICAgIGN5ID0gYVsxXTtcbiAgICBweCA9IHB5ID0gbnVsbDtcbiAgICByZXR1cm4gZG9jLmxpbmVUbyhjeCwgY3kpO1xuICB9LFxuICBsKGRvYywgYSkge1xuICAgIGN4ICs9IGFbMF07XG4gICAgY3kgKz0gYVsxXTtcbiAgICBweCA9IHB5ID0gbnVsbDtcbiAgICByZXR1cm4gZG9jLmxpbmVUbyhjeCwgY3kpO1xuICB9LFxuICBIKGRvYywgYSkge1xuICAgIGN4ID0gYVswXTtcbiAgICBweCA9IHB5ID0gbnVsbDtcbiAgICByZXR1cm4gZG9jLmxpbmVUbyhjeCwgY3kpO1xuICB9LFxuICBoKGRvYywgYSkge1xuICAgIGN4ICs9IGFbMF07XG4gICAgcHggPSBweSA9IG51bGw7XG4gICAgcmV0dXJuIGRvYy5saW5lVG8oY3gsIGN5KTtcbiAgfSxcbiAgVihkb2MsIGEpIHtcbiAgICBjeSA9IGFbMF07XG4gICAgcHggPSBweSA9IG51bGw7XG4gICAgcmV0dXJuIGRvYy5saW5lVG8oY3gsIGN5KTtcbiAgfSxcbiAgdihkb2MsIGEpIHtcbiAgICBjeSArPSBhWzBdO1xuICAgIHB4ID0gcHkgPSBudWxsO1xuICAgIHJldHVybiBkb2MubGluZVRvKGN4LCBjeSk7XG4gIH0sXG4gIFooZG9jKSB7XG4gICAgZG9jLmNsb3NlUGF0aCgpO1xuICAgIGN4ID0gc3g7XG4gICAgcmV0dXJuIGN5ID0gc3k7XG4gIH0sXG4gIHooZG9jKSB7XG4gICAgZG9jLmNsb3NlUGF0aCgpO1xuICAgIGN4ID0gc3g7XG4gICAgcmV0dXJuIGN5ID0gc3k7XG4gIH1cbn07XG5jb25zdCBzb2x2ZUFyYyA9IGZ1bmN0aW9uIChkb2MsIHgsIHksIGNvb3Jkcykge1xuICBjb25zdCBbcngsIHJ5LCByb3QsIGxhcmdlLCBzd2VlcCwgZXgsIGV5XSA9IGNvb3JkcztcbiAgY29uc3Qgc2VncyA9IGFyY1RvU2VnbWVudHMoZXgsIGV5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90LCB4LCB5KTtcbiAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICBjb25zdCBiZXogPSBzZWdtZW50VG9CZXppZXIoLi4uc2VnKTtcbiAgICBkb2MuYmV6aWVyQ3VydmVUbyguLi5iZXopO1xuICB9XG59O1xuY29uc3QgYXJjVG9TZWdtZW50cyA9IGZ1bmN0aW9uICh4LCB5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90YXRlWCwgb3gsIG95KSB7XG4gIGNvbnN0IHRoID0gcm90YXRlWCAqIChNYXRoLlBJIC8gMTgwKTtcbiAgY29uc3Qgc2luX3RoID0gTWF0aC5zaW4odGgpO1xuICBjb25zdCBjb3NfdGggPSBNYXRoLmNvcyh0aCk7XG4gIHJ4ID0gTWF0aC5hYnMocngpO1xuICByeSA9IE1hdGguYWJzKHJ5KTtcbiAgcHggPSBjb3NfdGggKiAob3ggLSB4KSAqIDAuNSArIHNpbl90aCAqIChveSAtIHkpICogMC41O1xuICBweSA9IGNvc190aCAqIChveSAtIHkpICogMC41IC0gc2luX3RoICogKG94IC0geCkgKiAwLjU7XG4gIGxldCBwbCA9IHB4ICogcHggLyAocnggKiByeCkgKyBweSAqIHB5IC8gKHJ5ICogcnkpO1xuICBpZiAocGwgPiAxKSB7XG4gICAgcGwgPSBNYXRoLnNxcnQocGwpO1xuICAgIHJ4ICo9IHBsO1xuICAgIHJ5ICo9IHBsO1xuICB9XG4gIGNvbnN0IGEwMCA9IGNvc190aCAvIHJ4O1xuICBjb25zdCBhMDEgPSBzaW5fdGggLyByeDtcbiAgY29uc3QgYTEwID0gLXNpbl90aCAvIHJ5O1xuICBjb25zdCBhMTEgPSBjb3NfdGggLyByeTtcbiAgY29uc3QgeDAgPSBhMDAgKiBveCArIGEwMSAqIG95O1xuICBjb25zdCB5MCA9IGExMCAqIG94ICsgYTExICogb3k7XG4gIGNvbnN0IHgxID0gYTAwICogeCArIGEwMSAqIHk7XG4gIGNvbnN0IHkxID0gYTEwICogeCArIGExMSAqIHk7XG4gIGNvbnN0IGQgPSAoeDEgLSB4MCkgKiAoeDEgLSB4MCkgKyAoeTEgLSB5MCkgKiAoeTEgLSB5MCk7XG4gIGxldCBzZmFjdG9yX3NxID0gMSAvIGQgLSAwLjI1O1xuICBpZiAoc2ZhY3Rvcl9zcSA8IDApIHtcbiAgICBzZmFjdG9yX3NxID0gMDtcbiAgfVxuICBsZXQgc2ZhY3RvciA9IE1hdGguc3FydChzZmFjdG9yX3NxKTtcbiAgaWYgKHN3ZWVwID09PSBsYXJnZSkge1xuICAgIHNmYWN0b3IgPSAtc2ZhY3RvcjtcbiAgfVxuICBjb25zdCB4YyA9IDAuNSAqICh4MCArIHgxKSAtIHNmYWN0b3IgKiAoeTEgLSB5MCk7XG4gIGNvbnN0IHljID0gMC41ICogKHkwICsgeTEpICsgc2ZhY3RvciAqICh4MSAtIHgwKTtcbiAgY29uc3QgdGgwID0gTWF0aC5hdGFuMih5MCAtIHljLCB4MCAtIHhjKTtcbiAgY29uc3QgdGgxID0gTWF0aC5hdGFuMih5MSAtIHljLCB4MSAtIHhjKTtcbiAgbGV0IHRoX2FyYyA9IHRoMSAtIHRoMDtcbiAgaWYgKHRoX2FyYyA8IDAgJiYgc3dlZXAgPT09IDEpIHtcbiAgICB0aF9hcmMgKz0gMiAqIE1hdGguUEk7XG4gIH0gZWxzZSBpZiAodGhfYXJjID4gMCAmJiBzd2VlcCA9PT0gMCkge1xuICAgIHRoX2FyYyAtPSAyICogTWF0aC5QSTtcbiAgfVxuICBjb25zdCBzZWdtZW50cyA9IE1hdGguY2VpbChNYXRoLmFicyh0aF9hcmMgLyAoTWF0aC5QSSAqIDAuNSArIDAuMDAxKSkpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50czsgaSsrKSB7XG4gICAgY29uc3QgdGgyID0gdGgwICsgaSAqIHRoX2FyYyAvIHNlZ21lbnRzO1xuICAgIGNvbnN0IHRoMyA9IHRoMCArIChpICsgMSkgKiB0aF9hcmMgLyBzZWdtZW50cztcbiAgICByZXN1bHRbaV0gPSBbeGMsIHljLCB0aDIsIHRoMywgcngsIHJ5LCBzaW5fdGgsIGNvc190aF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCBzZWdtZW50VG9CZXppZXIgPSBmdW5jdGlvbiAoY3gsIGN5LCB0aDAsIHRoMSwgcngsIHJ5LCBzaW5fdGgsIGNvc190aCkge1xuICBjb25zdCBhMDAgPSBjb3NfdGggKiByeDtcbiAgY29uc3QgYTAxID0gLXNpbl90aCAqIHJ5O1xuICBjb25zdCBhMTAgPSBzaW5fdGggKiByeDtcbiAgY29uc3QgYTExID0gY29zX3RoICogcnk7XG4gIGNvbnN0IHRoX2hhbGYgPSAwLjUgKiAodGgxIC0gdGgwKTtcbiAgY29uc3QgdCA9IDggLyAzICogTWF0aC5zaW4odGhfaGFsZiAqIDAuNSkgKiBNYXRoLnNpbih0aF9oYWxmICogMC41KSAvIE1hdGguc2luKHRoX2hhbGYpO1xuICBjb25zdCB4MSA9IGN4ICsgTWF0aC5jb3ModGgwKSAtIHQgKiBNYXRoLnNpbih0aDApO1xuICBjb25zdCB5MSA9IGN5ICsgTWF0aC5zaW4odGgwKSArIHQgKiBNYXRoLmNvcyh0aDApO1xuICBjb25zdCB4MyA9IGN4ICsgTWF0aC5jb3ModGgxKTtcbiAgY29uc3QgeTMgPSBjeSArIE1hdGguc2luKHRoMSk7XG4gIGNvbnN0IHgyID0geDMgKyB0ICogTWF0aC5zaW4odGgxKTtcbiAgY29uc3QgeTIgPSB5MyAtIHQgKiBNYXRoLmNvcyh0aDEpO1xuICByZXR1cm4gW2EwMCAqIHgxICsgYTAxICogeTEsIGExMCAqIHgxICsgYTExICogeTEsIGEwMCAqIHgyICsgYTAxICogeTIsIGExMCAqIHgyICsgYTExICogeTIsIGEwMCAqIHgzICsgYTAxICogeTMsIGExMCAqIHgzICsgYTExICogeTNdO1xufTtcbmNsYXNzIFNWR1BhdGgge1xuICBzdGF0aWMgYXBwbHkoZG9jLCBwYXRoKSB7XG4gICAgY29uc3QgY29tbWFuZHMgPSBwYXJzZShwYXRoKTtcbiAgICBhcHBseShjb21tYW5kcywgZG9jKTtcbiAgfVxufVxuXG5jb25zdCB7XG4gIG51bWJlcjogbnVtYmVyJDFcbn0gPSBQREZPYmplY3Q7XG5jb25zdCBLQVBQQSA9IDQuMCAqICgoTWF0aC5zcXJ0KDIpIC0gMS4wKSAvIDMuMCk7XG52YXIgVmVjdG9yTWl4aW4gPSB7XG4gIGluaXRWZWN0b3IoKSB7XG4gICAgdGhpcy5fY3RtID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIHRoaXMuX2N0bVN0YWNrID0gW107XG4gIH0sXG4gIHNhdmUoKSB7XG4gICAgdGhpcy5fY3RtU3RhY2sucHVzaCh0aGlzLl9jdG0uc2xpY2UoKSk7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudCgncScpO1xuICB9LFxuICByZXN0b3JlKCkge1xuICAgIHRoaXMuX2N0bSA9IHRoaXMuX2N0bVN0YWNrLnBvcCgpIHx8IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KCdRJyk7XG4gIH0sXG4gIGNsb3NlUGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KCdoJyk7XG4gIH0sXG4gIGxpbmVXaWR0aCh3KSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChgJHtudW1iZXIkMSh3KX0gd2ApO1xuICB9LFxuICBfQ0FQX1NUWUxFUzoge1xuICAgIEJVVFQ6IDAsXG4gICAgUk9VTkQ6IDEsXG4gICAgU1FVQVJFOiAyXG4gIH0sXG4gIGxpbmVDYXAoYykge1xuICAgIGlmICh0eXBlb2YgYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGMgPSB0aGlzLl9DQVBfU1RZTEVTW2MudG9VcHBlckNhc2UoKV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoYCR7Y30gSmApO1xuICB9LFxuICBfSk9JTl9TVFlMRVM6IHtcbiAgICBNSVRFUjogMCxcbiAgICBST1VORDogMSxcbiAgICBCRVZFTDogMlxuICB9LFxuICBsaW5lSm9pbihqKSB7XG4gICAgaWYgKHR5cGVvZiBqID09PSAnc3RyaW5nJykge1xuICAgICAgaiA9IHRoaXMuX0pPSU5fU1RZTEVTW2oudG9VcHBlckNhc2UoKV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoYCR7an0gamApO1xuICB9LFxuICBtaXRlckxpbWl0KG0pIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGAke251bWJlciQxKG0pfSBNYCk7XG4gIH0sXG4gIGRhc2gobGVuZ3RoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNvbnN0IG9yaWdpbmFsTGVuZ3RoID0gbGVuZ3RoO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBbbGVuZ3RoLCBvcHRpb25zLnNwYWNlIHx8IGxlbmd0aF07XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkID0gbGVuZ3RoLmV2ZXJ5KHggPT4gTnVtYmVyLmlzRmluaXRlKHgpICYmIHggPiAwKTtcbiAgICBpZiAoIXZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGRhc2goJHtKU09OLnN0cmluZ2lmeShvcmlnaW5hbExlbmd0aCl9LCAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMpfSkgaW52YWxpZCwgbGVuZ3RocyBtdXN0IGJlIG51bWVyaWMgYW5kIGdyZWF0ZXIgdGhhbiB6ZXJvYCk7XG4gICAgfVxuICAgIGxlbmd0aCA9IGxlbmd0aC5tYXAobnVtYmVyJDEpLmpvaW4oJyAnKTtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGBbJHtsZW5ndGh9XSAke251bWJlciQxKG9wdGlvbnMucGhhc2UgfHwgMCl9IGRgKTtcbiAgfSxcbiAgdW5kYXNoKCkge1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoJ1tdIDAgZCcpO1xuICB9LFxuICBtb3ZlVG8oeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoYCR7bnVtYmVyJDEoeCl9ICR7bnVtYmVyJDEoeSl9IG1gKTtcbiAgfSxcbiAgbGluZVRvKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGAke251bWJlciQxKHgpfSAke251bWJlciQxKHkpfSBsYCk7XG4gIH0sXG4gIGJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoYCR7bnVtYmVyJDEoY3AxeCl9ICR7bnVtYmVyJDEoY3AxeSl9ICR7bnVtYmVyJDEoY3AyeCl9ICR7bnVtYmVyJDEoY3AyeSl9ICR7bnVtYmVyJDEoeCl9ICR7bnVtYmVyJDEoeSl9IGNgKTtcbiAgfSxcbiAgcXVhZHJhdGljQ3VydmVUbyhjcHgsIGNweSwgeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoYCR7bnVtYmVyJDEoY3B4KX0gJHtudW1iZXIkMShjcHkpfSAke251bWJlciQxKHgpfSAke251bWJlciQxKHkpfSB2YCk7XG4gIH0sXG4gIHJlY3QoeCwgeSwgdywgaCkge1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoYCR7bnVtYmVyJDEoeCl9ICR7bnVtYmVyJDEoeSl9ICR7bnVtYmVyJDEodyl9ICR7bnVtYmVyJDEoaCl9IHJlYCk7XG4gIH0sXG4gIHJvdW5kZWRSZWN0KHgsIHksIHcsIGgsIHIpIHtcbiAgICBpZiAociA9PSBudWxsKSB7XG4gICAgICByID0gMDtcbiAgICB9XG4gICAgciA9IE1hdGgubWluKHIsIDAuNSAqIHcsIDAuNSAqIGgpO1xuICAgIGNvbnN0IGMgPSByICogKDEuMCAtIEtBUFBBKTtcbiAgICB0aGlzLm1vdmVUbyh4ICsgciwgeSk7XG4gICAgdGhpcy5saW5lVG8oeCArIHcgLSByLCB5KTtcbiAgICB0aGlzLmJlemllckN1cnZlVG8oeCArIHcgLSBjLCB5LCB4ICsgdywgeSArIGMsIHggKyB3LCB5ICsgcik7XG4gICAgdGhpcy5saW5lVG8oeCArIHcsIHkgKyBoIC0gcik7XG4gICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHggKyB3LCB5ICsgaCAtIGMsIHggKyB3IC0gYywgeSArIGgsIHggKyB3IC0gciwgeSArIGgpO1xuICAgIHRoaXMubGluZVRvKHggKyByLCB5ICsgaCk7XG4gICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHggKyBjLCB5ICsgaCwgeCwgeSArIGggLSBjLCB4LCB5ICsgaCAtIHIpO1xuICAgIHRoaXMubGluZVRvKHgsIHkgKyByKTtcbiAgICB0aGlzLmJlemllckN1cnZlVG8oeCwgeSArIGMsIHggKyBjLCB5LCB4ICsgciwgeSk7XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH0sXG4gIGVsbGlwc2UoeCwgeSwgcjEsIHIyKSB7XG4gICAgaWYgKHIyID09IG51bGwpIHtcbiAgICAgIHIyID0gcjE7XG4gICAgfVxuICAgIHggLT0gcjE7XG4gICAgeSAtPSByMjtcbiAgICBjb25zdCBveCA9IHIxICogS0FQUEE7XG4gICAgY29uc3Qgb3kgPSByMiAqIEtBUFBBO1xuICAgIGNvbnN0IHhlID0geCArIHIxICogMjtcbiAgICBjb25zdCB5ZSA9IHkgKyByMiAqIDI7XG4gICAgY29uc3QgeG0gPSB4ICsgcjE7XG4gICAgY29uc3QgeW0gPSB5ICsgcjI7XG4gICAgdGhpcy5tb3ZlVG8oeCwgeW0pO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4LCB5bSAtIG95LCB4bSAtIG94LCB5LCB4bSwgeSk7XG4gICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhtICsgb3gsIHksIHhlLCB5bSAtIG95LCB4ZSwgeW0pO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4ZSwgeW0gKyBveSwgeG0gKyBveCwgeWUsIHhtLCB5ZSk7XG4gICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhtIC0gb3gsIHllLCB4LCB5bSArIG95LCB4LCB5bSk7XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH0sXG4gIGNpcmNsZSh4LCB5LCByYWRpdXMpIHtcbiAgICByZXR1cm4gdGhpcy5lbGxpcHNlKHgsIHksIHJhZGl1cyk7XG4gIH0sXG4gIGFyYyh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKSB7XG4gICAgaWYgKGFudGljbG9ja3dpc2UgPT0gbnVsbCkge1xuICAgICAgYW50aWNsb2Nrd2lzZSA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBUV09fUEkgPSAyLjAgKiBNYXRoLlBJO1xuICAgIGNvbnN0IEhBTEZfUEkgPSAwLjUgKiBNYXRoLlBJO1xuICAgIGxldCBkZWx0YUFuZyA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgICBpZiAoTWF0aC5hYnMoZGVsdGFBbmcpID4gVFdPX1BJKSB7XG4gICAgICBkZWx0YUFuZyA9IFRXT19QSTtcbiAgICB9IGVsc2UgaWYgKGRlbHRhQW5nICE9PSAwICYmIGFudGljbG9ja3dpc2UgIT09IGRlbHRhQW5nIDwgMCkge1xuICAgICAgY29uc3QgZGlyID0gYW50aWNsb2Nrd2lzZSA/IC0xIDogMTtcbiAgICAgIGRlbHRhQW5nID0gZGlyICogVFdPX1BJICsgZGVsdGFBbmc7XG4gICAgfVxuICAgIGNvbnN0IG51bVNlZ3MgPSBNYXRoLmNlaWwoTWF0aC5hYnMoZGVsdGFBbmcpIC8gSEFMRl9QSSk7XG4gICAgY29uc3Qgc2VnQW5nID0gZGVsdGFBbmcgLyBudW1TZWdzO1xuICAgIGNvbnN0IGhhbmRsZUxlbiA9IHNlZ0FuZyAvIEhBTEZfUEkgKiBLQVBQQSAqIHJhZGl1cztcbiAgICBsZXQgY3VyQW5nID0gc3RhcnRBbmdsZTtcbiAgICBsZXQgZGVsdGFDeCA9IC1NYXRoLnNpbihjdXJBbmcpICogaGFuZGxlTGVuO1xuICAgIGxldCBkZWx0YUN5ID0gTWF0aC5jb3MoY3VyQW5nKSAqIGhhbmRsZUxlbjtcbiAgICBsZXQgYXggPSB4ICsgTWF0aC5jb3MoY3VyQW5nKSAqIHJhZGl1cztcbiAgICBsZXQgYXkgPSB5ICsgTWF0aC5zaW4oY3VyQW5nKSAqIHJhZGl1cztcbiAgICB0aGlzLm1vdmVUbyhheCwgYXkpO1xuICAgIGZvciAobGV0IHNlZ0lkeCA9IDA7IHNlZ0lkeCA8IG51bVNlZ3M7IHNlZ0lkeCsrKSB7XG4gICAgICBjb25zdCBjcDF4ID0gYXggKyBkZWx0YUN4O1xuICAgICAgY29uc3QgY3AxeSA9IGF5ICsgZGVsdGFDeTtcbiAgICAgIGN1ckFuZyArPSBzZWdBbmc7XG4gICAgICBheCA9IHggKyBNYXRoLmNvcyhjdXJBbmcpICogcmFkaXVzO1xuICAgICAgYXkgPSB5ICsgTWF0aC5zaW4oY3VyQW5nKSAqIHJhZGl1cztcbiAgICAgIGRlbHRhQ3ggPSAtTWF0aC5zaW4oY3VyQW5nKSAqIGhhbmRsZUxlbjtcbiAgICAgIGRlbHRhQ3kgPSBNYXRoLmNvcyhjdXJBbmcpICogaGFuZGxlTGVuO1xuICAgICAgY29uc3QgY3AyeCA9IGF4IC0gZGVsdGFDeDtcbiAgICAgIGNvbnN0IGNwMnkgPSBheSAtIGRlbHRhQ3k7XG4gICAgICB0aGlzLmJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgYXgsIGF5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHBvbHlnb24oKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBvaW50cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHBvaW50c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgdGhpcy5tb3ZlVG8oLi4uKHBvaW50cy5zaGlmdCgpIHx8IFtdKSk7XG4gICAgZm9yIChsZXQgcG9pbnQgb2YgcG9pbnRzKSB7XG4gICAgICB0aGlzLmxpbmVUbyguLi4ocG9pbnQgfHwgW10pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH0sXG4gIHBhdGgocGF0aCkge1xuICAgIFNWR1BhdGguYXBwbHkodGhpcywgcGF0aCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF93aW5kaW5nUnVsZShydWxlKSB7XG4gICAgaWYgKC9ldmVuLT9vZGQvLnRlc3QocnVsZSkpIHtcbiAgICAgIHJldHVybiAnKic7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSxcbiAgZmlsbChjb2xvciwgcnVsZSkge1xuICAgIGlmICgvKGV2ZW4tP29kZCl8KG5vbi0/emVybykvLnRlc3QoY29sb3IpKSB7XG4gICAgICBydWxlID0gY29sb3I7XG4gICAgICBjb2xvciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChjb2xvcikge1xuICAgICAgdGhpcy5maWxsQ29sb3IoY29sb3IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGBmJHt0aGlzLl93aW5kaW5nUnVsZShydWxlKX1gKTtcbiAgfSxcbiAgc3Ryb2tlKGNvbG9yKSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICB0aGlzLnN0cm9rZUNvbG9yKGNvbG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudCgnUycpO1xuICB9LFxuICBmaWxsQW5kU3Ryb2tlKGZpbGxDb2xvciwgc3Ryb2tlQ29sb3IsIHJ1bGUpIHtcbiAgICBpZiAoc3Ryb2tlQ29sb3IgPT0gbnVsbCkge1xuICAgICAgc3Ryb2tlQ29sb3IgPSBmaWxsQ29sb3I7XG4gICAgfVxuICAgIGNvbnN0IGlzRmlsbFJ1bGUgPSAvKGV2ZW4tP29kZCl8KG5vbi0/emVybykvO1xuICAgIGlmIChpc0ZpbGxSdWxlLnRlc3QoZmlsbENvbG9yKSkge1xuICAgICAgcnVsZSA9IGZpbGxDb2xvcjtcbiAgICAgIGZpbGxDb2xvciA9IG51bGw7XG4gICAgfVxuICAgIGlmIChpc0ZpbGxSdWxlLnRlc3Qoc3Ryb2tlQ29sb3IpKSB7XG4gICAgICBydWxlID0gc3Ryb2tlQ29sb3I7XG4gICAgICBzdHJva2VDb2xvciA9IGZpbGxDb2xvcjtcbiAgICB9XG4gICAgaWYgKGZpbGxDb2xvcikge1xuICAgICAgdGhpcy5maWxsQ29sb3IoZmlsbENvbG9yKTtcbiAgICAgIHRoaXMuc3Ryb2tlQ29sb3Ioc3Ryb2tlQ29sb3IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KGBCJHt0aGlzLl93aW5kaW5nUnVsZShydWxlKX1gKTtcbiAgfSxcbiAgY2xpcChydWxlKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChgVyR7dGhpcy5fd2luZGluZ1J1bGUocnVsZSl9IG5gKTtcbiAgfSxcbiAgdHJhbnNmb3JtKG0xMSwgbTEyLCBtMjEsIG0yMiwgZHgsIGR5KSB7XG4gICAgaWYgKG0xMSA9PT0gMSAmJiBtMTIgPT09IDAgJiYgbTIxID09PSAwICYmIG0yMiA9PT0gMSAmJiBkeCA9PT0gMCAmJiBkeSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IG0gPSB0aGlzLl9jdG07XG4gICAgY29uc3QgW20wLCBtMSwgbTIsIG0zLCBtNCwgbTVdID0gbTtcbiAgICBtWzBdID0gbTAgKiBtMTEgKyBtMiAqIG0xMjtcbiAgICBtWzFdID0gbTEgKiBtMTEgKyBtMyAqIG0xMjtcbiAgICBtWzJdID0gbTAgKiBtMjEgKyBtMiAqIG0yMjtcbiAgICBtWzNdID0gbTEgKiBtMjEgKyBtMyAqIG0yMjtcbiAgICBtWzRdID0gbTAgKiBkeCArIG0yICogZHkgKyBtNDtcbiAgICBtWzVdID0gbTEgKiBkeCArIG0zICogZHkgKyBtNTtcbiAgICBjb25zdCB2YWx1ZXMgPSBbbTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHldLm1hcCh2ID0+IG51bWJlciQxKHYpKS5qb2luKCcgJyk7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChgJHt2YWx1ZXN9IGNtYCk7XG4gIH0sXG4gIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKDEsIDAsIDAsIDEsIHgsIHkpO1xuICB9LFxuICByb3RhdGUoYW5nbGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgbGV0IHk7XG4gICAgY29uc3QgcmFkID0gYW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKHJhZCk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4ocmFkKTtcbiAgICBsZXQgeCA9IHkgPSAwO1xuICAgIGlmIChvcHRpb25zLm9yaWdpbiAhPSBudWxsKSB7XG4gICAgICBbeCwgeV0gPSBvcHRpb25zLm9yaWdpbjtcbiAgICAgIGNvbnN0IHgxID0geCAqIGNvcyAtIHkgKiBzaW47XG4gICAgICBjb25zdCB5MSA9IHggKiBzaW4gKyB5ICogY29zO1xuICAgICAgeCAtPSB4MTtcbiAgICAgIHkgLT0geTE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShjb3MsIHNpbiwgLXNpbiwgY29zLCB4LCB5KTtcbiAgfSxcbiAgc2NhbGUoeEZhY3RvciwgeUZhY3Rvcikge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBsZXQgeTtcbiAgICBpZiAoeUZhY3RvciA9PSBudWxsKSB7XG4gICAgICB5RmFjdG9yID0geEZhY3RvcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB5RmFjdG9yID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IHlGYWN0b3I7XG4gICAgICB5RmFjdG9yID0geEZhY3RvcjtcbiAgICB9XG4gICAgbGV0IHggPSB5ID0gMDtcbiAgICBpZiAob3B0aW9ucy5vcmlnaW4gIT0gbnVsbCkge1xuICAgICAgW3gsIHldID0gb3B0aW9ucy5vcmlnaW47XG4gICAgICB4IC09IHhGYWN0b3IgKiB4O1xuICAgICAgeSAtPSB5RmFjdG9yICogeTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHhGYWN0b3IsIDAsIDAsIHlGYWN0b3IsIHgsIHkpO1xuICB9XG59O1xuXG5jb25zdCBXSU5fQU5TSV9NQVAgPSB7XG4gIDQwMjogMTMxLFxuICA4MjExOiAxNTAsXG4gIDgyMTI6IDE1MSxcbiAgODIxNjogMTQ1LFxuICA4MjE3OiAxNDYsXG4gIDgyMTg6IDEzMCxcbiAgODIyMDogMTQ3LFxuICA4MjIxOiAxNDgsXG4gIDgyMjI6IDEzMixcbiAgODIyNDogMTM0LFxuICA4MjI1OiAxMzUsXG4gIDgyMjY6IDE0OSxcbiAgODIzMDogMTMzLFxuICA4MzY0OiAxMjgsXG4gIDgyNDA6IDEzNyxcbiAgODI0OTogMTM5LFxuICA4MjUwOiAxNTUsXG4gIDcxMDogMTM2LFxuICA4NDgyOiAxNTMsXG4gIDMzODogMTQwLFxuICAzMzk6IDE1NixcbiAgNzMyOiAxNTIsXG4gIDM1MjogMTM4LFxuICAzNTM6IDE1NCxcbiAgMzc2OiAxNTksXG4gIDM4MTogMTQyLFxuICAzODI6IDE1OFxufTtcbmNvbnN0IGNoYXJhY3RlcnMgPSBgXFxcbi5ub3RkZWYgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZlxuLm5vdGRlZiAgICAgICAubm90ZGVmICAgICAgICAubm90ZGVmICAgICAgICAubm90ZGVmXG4ubm90ZGVmICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWZcbi5ub3RkZWYgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZlxuLm5vdGRlZiAgICAgICAubm90ZGVmICAgICAgICAubm90ZGVmICAgICAgICAubm90ZGVmXG4ubm90ZGVmICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWZcbi5ub3RkZWYgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZiAgICAgICAgLm5vdGRlZlxuLm5vdGRlZiAgICAgICAubm90ZGVmICAgICAgICAubm90ZGVmICAgICAgICAubm90ZGVmXG4gIFxuc3BhY2UgICAgICAgICBleGNsYW0gICAgICAgICBxdW90ZWRibCAgICAgICBudW1iZXJzaWduXG5kb2xsYXIgICAgICAgIHBlcmNlbnQgICAgICAgIGFtcGVyc2FuZCAgICAgIHF1b3Rlc2luZ2xlXG5wYXJlbmxlZnQgICAgIHBhcmVucmlnaHQgICAgIGFzdGVyaXNrICAgICAgIHBsdXNcbmNvbW1hICAgICAgICAgaHlwaGVuICAgICAgICAgcGVyaW9kICAgICAgICAgc2xhc2hcbnplcm8gICAgICAgICAgb25lICAgICAgICAgICAgdHdvICAgICAgICAgICAgdGhyZWVcbmZvdXIgICAgICAgICAgZml2ZSAgICAgICAgICAgc2l4ICAgICAgICAgICAgc2V2ZW5cbmVpZ2h0ICAgICAgICAgbmluZSAgICAgICAgICAgY29sb24gICAgICAgICAgc2VtaWNvbG9uXG5sZXNzICAgICAgICAgIGVxdWFsICAgICAgICAgIGdyZWF0ZXIgICAgICAgIHF1ZXN0aW9uXG4gIFxuYXQgICAgICAgICAgICBBICAgICAgICAgICAgICBCICAgICAgICAgICAgICBDXG5EICAgICAgICAgICAgIEUgICAgICAgICAgICAgIEYgICAgICAgICAgICAgIEdcbkggICAgICAgICAgICAgSSAgICAgICAgICAgICAgSiAgICAgICAgICAgICAgS1xuTCAgICAgICAgICAgICBNICAgICAgICAgICAgICBOICAgICAgICAgICAgICBPXG5QICAgICAgICAgICAgIFEgICAgICAgICAgICAgIFIgICAgICAgICAgICAgIFNcblQgICAgICAgICAgICAgVSAgICAgICAgICAgICAgViAgICAgICAgICAgICAgV1xuWCAgICAgICAgICAgICBZICAgICAgICAgICAgICBaICAgICAgICAgICAgICBicmFja2V0bGVmdFxuYmFja3NsYXNoICAgICBicmFja2V0cmlnaHQgICBhc2NpaWNpcmN1bSAgICB1bmRlcnNjb3JlXG4gIFxuZ3JhdmUgICAgICAgICBhICAgICAgICAgICAgICBiICAgICAgICAgICAgICBjXG5kICAgICAgICAgICAgIGUgICAgICAgICAgICAgIGYgICAgICAgICAgICAgIGdcbmggICAgICAgICAgICAgaSAgICAgICAgICAgICAgaiAgICAgICAgICAgICAga1xubCAgICAgICAgICAgICBtICAgICAgICAgICAgICBuICAgICAgICAgICAgICBvXG5wICAgICAgICAgICAgIHEgICAgICAgICAgICAgIHIgICAgICAgICAgICAgIHNcbnQgICAgICAgICAgICAgdSAgICAgICAgICAgICAgdiAgICAgICAgICAgICAgd1xueCAgICAgICAgICAgICB5ICAgICAgICAgICAgICB6ICAgICAgICAgICAgICBicmFjZWxlZnRcbmJhciAgICAgICAgICAgYnJhY2VyaWdodCAgICAgYXNjaWl0aWxkZSAgICAgLm5vdGRlZlxuICBcbkV1cm8gICAgICAgICAgLm5vdGRlZiAgICAgICAgcXVvdGVzaW5nbGJhc2UgZmxvcmluXG5xdW90ZWRibGJhc2UgIGVsbGlwc2lzICAgICAgIGRhZ2dlciAgICAgICAgIGRhZ2dlcmRibFxuY2lyY3VtZmxleCAgICBwZXJ0aG91c2FuZCAgICBTY2Fyb24gICAgICAgICBndWlsc2luZ2xsZWZ0XG5PRSAgICAgICAgICAgIC5ub3RkZWYgICAgICAgIFpjYXJvbiAgICAgICAgIC5ub3RkZWZcbi5ub3RkZWYgICAgICAgcXVvdGVsZWZ0ICAgICAgcXVvdGVyaWdodCAgICAgcXVvdGVkYmxsZWZ0XG5xdW90ZWRibHJpZ2h0IGJ1bGxldCAgICAgICAgIGVuZGFzaCAgICAgICAgIGVtZGFzaFxudGlsZGUgICAgICAgICB0cmFkZW1hcmsgICAgICBzY2Fyb24gICAgICAgICBndWlsc2luZ2xyaWdodFxub2UgICAgICAgICAgICAubm90ZGVmICAgICAgICB6Y2Fyb24gICAgICAgICB5ZGllcmVzaXNcbiAgXG5zcGFjZSAgICAgICAgIGV4Y2xhbWRvd24gICAgIGNlbnQgICAgICAgICAgIHN0ZXJsaW5nXG5jdXJyZW5jeSAgICAgIHllbiAgICAgICAgICAgIGJyb2tlbmJhciAgICAgIHNlY3Rpb25cbmRpZXJlc2lzICAgICAgY29weXJpZ2h0ICAgICAgb3JkZmVtaW5pbmUgICAgZ3VpbGxlbW90bGVmdFxubG9naWNhbG5vdCAgICBoeXBoZW4gICAgICAgICByZWdpc3RlcmVkICAgICBtYWNyb25cbmRlZ3JlZSAgICAgICAgcGx1c21pbnVzICAgICAgdHdvc3VwZXJpb3IgICAgdGhyZWVzdXBlcmlvclxuYWN1dGUgICAgICAgICBtdSAgICAgICAgICAgICBwYXJhZ3JhcGggICAgICBwZXJpb2RjZW50ZXJlZFxuY2VkaWxsYSAgICAgICBvbmVzdXBlcmlvciAgICBvcmRtYXNjdWxpbmUgICBndWlsbGVtb3RyaWdodFxub25lcXVhcnRlciAgICBvbmVoYWxmICAgICAgICB0aHJlZXF1YXJ0ZXJzICBxdWVzdGlvbmRvd25cbiAgXG5BZ3JhdmUgICAgICAgIEFhY3V0ZSAgICAgICAgIEFjaXJjdW1mbGV4ICAgIEF0aWxkZVxuQWRpZXJlc2lzICAgICBBcmluZyAgICAgICAgICBBRSAgICAgICAgICAgICBDY2VkaWxsYVxuRWdyYXZlICAgICAgICBFYWN1dGUgICAgICAgICBFY2lyY3VtZmxleCAgICBFZGllcmVzaXNcbklncmF2ZSAgICAgICAgSWFjdXRlICAgICAgICAgSWNpcmN1bWZsZXggICAgSWRpZXJlc2lzXG5FdGggICAgICAgICAgIE50aWxkZSAgICAgICAgIE9ncmF2ZSAgICAgICAgIE9hY3V0ZVxuT2NpcmN1bWZsZXggICBPdGlsZGUgICAgICAgICBPZGllcmVzaXMgICAgICBtdWx0aXBseVxuT3NsYXNoICAgICAgICBVZ3JhdmUgICAgICAgICBVYWN1dGUgICAgICAgICBVY2lyY3VtZmxleFxuVWRpZXJlc2lzICAgICBZYWN1dGUgICAgICAgICBUaG9ybiAgICAgICAgICBnZXJtYW5kYmxzXG4gIFxuYWdyYXZlICAgICAgICBhYWN1dGUgICAgICAgICBhY2lyY3VtZmxleCAgICBhdGlsZGVcbmFkaWVyZXNpcyAgICAgYXJpbmcgICAgICAgICAgYWUgICAgICAgICAgICAgY2NlZGlsbGFcbmVncmF2ZSAgICAgICAgZWFjdXRlICAgICAgICAgZWNpcmN1bWZsZXggICAgZWRpZXJlc2lzXG5pZ3JhdmUgICAgICAgIGlhY3V0ZSAgICAgICAgIGljaXJjdW1mbGV4ICAgIGlkaWVyZXNpc1xuZXRoICAgICAgICAgICBudGlsZGUgICAgICAgICBvZ3JhdmUgICAgICAgICBvYWN1dGVcbm9jaXJjdW1mbGV4ICAgb3RpbGRlICAgICAgICAgb2RpZXJlc2lzICAgICAgZGl2aWRlXG5vc2xhc2ggICAgICAgIHVncmF2ZSAgICAgICAgIHVhY3V0ZSAgICAgICAgIHVjaXJjdW1mbGV4XG51ZGllcmVzaXMgICAgIHlhY3V0ZSAgICAgICAgIHRob3JuICAgICAgICAgIHlkaWVyZXNpc1xcXG5gLnNwbGl0KC9cXHMrLyk7XG5jbGFzcyBBRk1Gb250IHtcbiAgY29uc3RydWN0b3IoY29udGVudHMpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLmdseXBoV2lkdGhzID0ge307XG4gICAgdGhpcy5ib3VuZGluZ0JveGVzID0ge307XG4gICAgdGhpcy5rZXJuUGFpcnMgPSB7fTtcbiAgICB0aGlzLnBhcnNlKGNvbnRlbnRzKTtcbiAgICB0aGlzLmJib3ggPSB0aGlzLmF0dHJpYnV0ZXNbJ0ZvbnRCQm94J10uc3BsaXQoL1xccysvKS5tYXAoZSA9PiArZSk7XG4gICAgdGhpcy5hc2NlbmRlciA9ICsodGhpcy5hdHRyaWJ1dGVzWydBc2NlbmRlciddIHx8IDApO1xuICAgIHRoaXMuZGVzY2VuZGVyID0gKyh0aGlzLmF0dHJpYnV0ZXNbJ0Rlc2NlbmRlciddIHx8IDApO1xuICAgIHRoaXMueEhlaWdodCA9ICsodGhpcy5hdHRyaWJ1dGVzWydYSGVpZ2h0J10gfHwgMCk7XG4gICAgdGhpcy5jYXBIZWlnaHQgPSArKHRoaXMuYXR0cmlidXRlc1snQ2FwSGVpZ2h0J10gfHwgMCk7XG4gICAgdGhpcy5saW5lR2FwID0gdGhpcy5iYm94WzNdIC0gdGhpcy5iYm94WzFdIC0gKHRoaXMuYXNjZW5kZXIgLSB0aGlzLmRlc2NlbmRlcik7XG4gIH1cbiAgcGFyc2UoY29udGVudHMpIHtcbiAgICBsZXQgc2VjdGlvbiA9ICcnO1xuICAgIGZvciAobGV0IGxpbmUgb2YgY29udGVudHMuc3BsaXQoJ1xcbicpKSB7XG4gICAgICB2YXIgbWF0Y2g7XG4gICAgICB2YXIgYTtcbiAgICAgIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goL15TdGFydChcXHcrKS8pKSB7XG4gICAgICAgIHNlY3Rpb24gPSBtYXRjaFsxXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoID0gbGluZS5tYXRjaCgvXkVuZChcXHcrKS8pKSB7XG4gICAgICAgIHNlY3Rpb24gPSAnJztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHNlY3Rpb24pIHtcbiAgICAgICAgY2FzZSAnRm9udE1ldHJpY3MnOlxuICAgICAgICAgIG1hdGNoID0gbGluZS5tYXRjaCgvKF5cXHcrKVxccysoLiopLyk7XG4gICAgICAgICAgdmFyIGtleSA9IG1hdGNoWzFdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG1hdGNoWzJdO1xuICAgICAgICAgIGlmIChhID0gdGhpcy5hdHRyaWJ1dGVzW2tleV0pIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICAgICAgICBhID0gdGhpcy5hdHRyaWJ1dGVzW2tleV0gPSBbYV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhLnB1c2godmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQ2hhck1ldHJpY3MnOlxuICAgICAgICAgIGlmICghL15DSD9cXHMvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbmFtZSA9IGxpbmUubWF0Y2goL1xcYk5cXHMrKFxcLj9cXHcrKVxccyo7LylbMV07XG4gICAgICAgICAgdGhpcy5nbHlwaFdpZHRoc1tuYW1lXSA9ICtsaW5lLm1hdGNoKC9cXGJXWFxccysoXFxkKylcXHMqOy8pWzFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdLZXJuUGFpcnMnOlxuICAgICAgICAgIG1hdGNoID0gbGluZS5tYXRjaCgvXktQWFxccysoXFwuP1xcdyspXFxzKyhcXC4/XFx3KylcXHMrKC0/XFxkKykvKTtcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRoaXMua2VyblBhaXJzW21hdGNoWzFdICsgJ1xcMCcgKyBtYXRjaFsyXV0gPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbmNvZGVUZXh0KHRleHQpIHtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGV4dC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGV0IGNoYXIgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICBjaGFyID0gV0lOX0FOU0lfTUFQW2NoYXJdIHx8IGNoYXI7XG4gICAgICByZXMucHVzaChjaGFyLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgZ2x5cGhzRm9yU3RyaW5nKHN0cmluZykge1xuICAgIGNvbnN0IGdseXBocyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXJDb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICBnbHlwaHMucHVzaCh0aGlzLmNoYXJhY3RlclRvR2x5cGgoY2hhckNvZGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGdseXBocztcbiAgfVxuICBjaGFyYWN0ZXJUb0dseXBoKGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXJzW1dJTl9BTlNJX01BUFtjaGFyYWN0ZXJdIHx8IGNoYXJhY3Rlcl0gfHwgJy5ub3RkZWYnO1xuICB9XG4gIHdpZHRoT2ZHbHlwaChnbHlwaCkge1xuICAgIHJldHVybiB0aGlzLmdseXBoV2lkdGhzW2dseXBoXSB8fCAwO1xuICB9XG4gIGdldEtlcm5QYWlyKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMua2VyblBhaXJzW2xlZnQgKyAnXFwwJyArIHJpZ2h0XSB8fCAwO1xuICB9XG4gIGFkdmFuY2VzRm9yR2x5cGhzKGdseXBocykge1xuICAgIGNvbnN0IGFkdmFuY2VzID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGdseXBocy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IGxlZnQgPSBnbHlwaHNbaW5kZXhdO1xuICAgICAgY29uc3QgcmlnaHQgPSBnbHlwaHNbaW5kZXggKyAxXTtcbiAgICAgIGFkdmFuY2VzLnB1c2godGhpcy53aWR0aE9mR2x5cGgobGVmdCkgKyB0aGlzLmdldEtlcm5QYWlyKGxlZnQsIHJpZ2h0KSk7XG4gICAgfVxuICAgIHJldHVybiBhZHZhbmNlcztcbiAgfVxufVxuXG5jbGFzcyBQREZGb250IHtcbiAgY29uc3RydWN0b3IoKSB7fVxuICBlbmNvZGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMnKTtcbiAgfVxuICB3aWR0aE9mU3RyaW5nKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzJyk7XG4gIH1cbiAgcmVmKCkge1xuICAgIHJldHVybiB0aGlzLmRpY3Rpb25hcnkgIT0gbnVsbCA/IHRoaXMuZGljdGlvbmFyeSA6IHRoaXMuZGljdGlvbmFyeSA9IHRoaXMuZG9jdW1lbnQucmVmKCk7XG4gIH1cbiAgZmluYWxpemUoKSB7XG4gICAgaWYgKHRoaXMuZW1iZWRkZWQgfHwgdGhpcy5kaWN0aW9uYXJ5ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWJlZCgpO1xuICAgIHRoaXMuZW1iZWRkZWQgPSB0cnVlO1xuICB9XG4gIGVtYmVkKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzJyk7XG4gIH1cbiAgbGluZUhlaWdodChzaXplKSB7XG4gICAgbGV0IGluY2x1ZGVHYXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIGNvbnN0IGdhcCA9IGluY2x1ZGVHYXAgPyB0aGlzLmxpbmVHYXAgOiAwO1xuICAgIHJldHVybiAodGhpcy5hc2NlbmRlciArIGdhcCAtIHRoaXMuZGVzY2VuZGVyKSAvIDEwMDAgKiBzaXplO1xuICB9XG59XG5cbmNvbnN0IFNUQU5EQVJEX0ZPTlRTID0ge1xuICBDb3VyaWVyKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL0NvdXJpZXIuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgJ0NvdXJpZXItQm9sZCcoKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyAnL2RhdGEvQ291cmllci1Cb2xkLmFmbScsICd1dGY4Jyk7XG4gIH0sXG4gICdDb3VyaWVyLU9ibGlxdWUnKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL0NvdXJpZXItT2JsaXF1ZS5hZm0nLCAndXRmOCcpO1xuICB9LFxuICAnQ291cmllci1Cb2xkT2JsaXF1ZScoKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyAnL2RhdGEvQ291cmllci1Cb2xkT2JsaXF1ZS5hZm0nLCAndXRmOCcpO1xuICB9LFxuICBIZWx2ZXRpY2EoKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyAnL2RhdGEvSGVsdmV0aWNhLmFmbScsICd1dGY4Jyk7XG4gIH0sXG4gICdIZWx2ZXRpY2EtQm9sZCcoKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyAnL2RhdGEvSGVsdmV0aWNhLUJvbGQuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgJ0hlbHZldGljYS1PYmxpcXVlJygpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArICcvZGF0YS9IZWx2ZXRpY2EtT2JsaXF1ZS5hZm0nLCAndXRmOCcpO1xuICB9LFxuICAnSGVsdmV0aWNhLUJvbGRPYmxpcXVlJygpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArICcvZGF0YS9IZWx2ZXRpY2EtQm9sZE9ibGlxdWUuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgJ1RpbWVzLVJvbWFuJygpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArICcvZGF0YS9UaW1lcy1Sb21hbi5hZm0nLCAndXRmOCcpO1xuICB9LFxuICAnVGltZXMtQm9sZCcoKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyAnL2RhdGEvVGltZXMtQm9sZC5hZm0nLCAndXRmOCcpO1xuICB9LFxuICAnVGltZXMtSXRhbGljJygpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArICcvZGF0YS9UaW1lcy1JdGFsaWMuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgJ1RpbWVzLUJvbGRJdGFsaWMnKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL1RpbWVzLUJvbGRJdGFsaWMuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgU3ltYm9sKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL1N5bWJvbC5hZm0nLCAndXRmOCcpO1xuICB9LFxuICBaYXBmRGluZ2JhdHMoKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyAnL2RhdGEvWmFwZkRpbmdiYXRzLmFmbScsICd1dGY4Jyk7XG4gIH1cbn07XG5jbGFzcyBTdGFuZGFyZEZvbnQgZXh0ZW5kcyBQREZGb250IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5hbWUsIGlkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5mb250ID0gbmV3IEFGTUZvbnQoU1RBTkRBUkRfRk9OVFNbdGhpcy5uYW1lXSgpKTtcbiAgICAoe1xuICAgICAgYXNjZW5kZXI6IHRoaXMuYXNjZW5kZXIsXG4gICAgICBkZXNjZW5kZXI6IHRoaXMuZGVzY2VuZGVyLFxuICAgICAgYmJveDogdGhpcy5iYm94LFxuICAgICAgbGluZUdhcDogdGhpcy5saW5lR2FwLFxuICAgICAgeEhlaWdodDogdGhpcy54SGVpZ2h0LFxuICAgICAgY2FwSGVpZ2h0OiB0aGlzLmNhcEhlaWdodFxuICAgIH0gPSB0aGlzLmZvbnQpO1xuICB9XG4gIGVtYmVkKCkge1xuICAgIHRoaXMuZGljdGlvbmFyeS5kYXRhID0ge1xuICAgICAgVHlwZTogJ0ZvbnQnLFxuICAgICAgQmFzZUZvbnQ6IHRoaXMubmFtZSxcbiAgICAgIFN1YnR5cGU6ICdUeXBlMScsXG4gICAgICBFbmNvZGluZzogJ1dpbkFuc2lFbmNvZGluZydcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmRpY3Rpb25hcnkuZW5kKCk7XG4gIH1cbiAgZW5jb2RlKHRleHQpIHtcbiAgICBjb25zdCBlbmNvZGVkID0gdGhpcy5mb250LmVuY29kZVRleHQodGV4dCk7XG4gICAgY29uc3QgZ2x5cGhzID0gdGhpcy5mb250LmdseXBoc0ZvclN0cmluZyhgJHt0ZXh0fWApO1xuICAgIGNvbnN0IGFkdmFuY2VzID0gdGhpcy5mb250LmFkdmFuY2VzRm9yR2x5cGhzKGdseXBocyk7XG4gICAgY29uc3QgcG9zaXRpb25zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgcG9zaXRpb25zLnB1c2goe1xuICAgICAgICB4QWR2YW5jZTogYWR2YW5jZXNbaV0sXG4gICAgICAgIHlBZHZhbmNlOiAwLFxuICAgICAgICB4T2Zmc2V0OiAwLFxuICAgICAgICB5T2Zmc2V0OiAwLFxuICAgICAgICBhZHZhbmNlV2lkdGg6IHRoaXMuZm9udC53aWR0aE9mR2x5cGgoZ2x5cGgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFtlbmNvZGVkLCBwb3NpdGlvbnNdO1xuICB9XG4gIHdpZHRoT2ZTdHJpbmcoc3RyaW5nLCBzaXplKSB7XG4gICAgY29uc3QgZ2x5cGhzID0gdGhpcy5mb250LmdseXBoc0ZvclN0cmluZyhgJHtzdHJpbmd9YCk7XG4gICAgY29uc3QgYWR2YW5jZXMgPSB0aGlzLmZvbnQuYWR2YW5jZXNGb3JHbHlwaHMoZ2x5cGhzKTtcbiAgICBsZXQgd2lkdGggPSAwO1xuICAgIGZvciAobGV0IGFkdmFuY2Ugb2YgYWR2YW5jZXMpIHtcbiAgICAgIHdpZHRoICs9IGFkdmFuY2U7XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlID0gc2l6ZSAvIDEwMDA7XG4gICAgcmV0dXJuIHdpZHRoICogc2NhbGU7XG4gIH1cbiAgc3RhdGljIGlzU3RhbmRhcmRGb250KG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSBpbiBTVEFOREFSRF9GT05UUztcbiAgfVxufVxuXG5jb25zdCB0b0hleCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgcmV0dXJuIGAwMDAwJHtudW0udG9TdHJpbmcoMTYpfWAuc2xpY2UoLTQpO1xufTtcbmNsYXNzIEVtYmVkZGVkRm9udCBleHRlbmRzIFBERkZvbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgZm9udCwgaWQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLmZvbnQgPSBmb250O1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnN1YnNldCA9IHRoaXMuZm9udC5jcmVhdGVTdWJzZXQoKTtcbiAgICB0aGlzLnVuaWNvZGUgPSBbWzBdXTtcbiAgICB0aGlzLndpZHRocyA9IFt0aGlzLmZvbnQuZ2V0R2x5cGgoMCkuYWR2YW5jZVdpZHRoXTtcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmZvbnQucG9zdHNjcmlwdE5hbWU7XG4gICAgdGhpcy5zY2FsZSA9IDEwMDAgLyB0aGlzLmZvbnQudW5pdHNQZXJFbTtcbiAgICB0aGlzLmFzY2VuZGVyID0gdGhpcy5mb250LmFzY2VudCAqIHRoaXMuc2NhbGU7XG4gICAgdGhpcy5kZXNjZW5kZXIgPSB0aGlzLmZvbnQuZGVzY2VudCAqIHRoaXMuc2NhbGU7XG4gICAgdGhpcy54SGVpZ2h0ID0gdGhpcy5mb250LnhIZWlnaHQgKiB0aGlzLnNjYWxlO1xuICAgIHRoaXMuY2FwSGVpZ2h0ID0gdGhpcy5mb250LmNhcEhlaWdodCAqIHRoaXMuc2NhbGU7XG4gICAgdGhpcy5saW5lR2FwID0gdGhpcy5mb250LmxpbmVHYXAgKiB0aGlzLnNjYWxlO1xuICAgIHRoaXMuYmJveCA9IHRoaXMuZm9udC5iYm94O1xuICAgIGlmIChkb2N1bWVudC5vcHRpb25zLmZvbnRMYXlvdXRDYWNoZSAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMubGF5b3V0Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgfVxuICBsYXlvdXRSdW4odGV4dCwgZmVhdHVyZXMpIHtcbiAgICBjb25zdCBydW4gPSB0aGlzLmZvbnQubGF5b3V0KHRleHQsIGZlYXR1cmVzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bi5wb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcnVuLnBvc2l0aW9uc1tpXTtcbiAgICAgIGZvciAobGV0IGtleSBpbiBwb3NpdGlvbikge1xuICAgICAgICBwb3NpdGlvbltrZXldICo9IHRoaXMuc2NhbGU7XG4gICAgICB9XG4gICAgICBwb3NpdGlvbi5hZHZhbmNlV2lkdGggPSBydW4uZ2x5cGhzW2ldLmFkdmFuY2VXaWR0aCAqIHRoaXMuc2NhbGU7XG4gICAgfVxuICAgIHJldHVybiBydW47XG4gIH1cbiAgbGF5b3V0Q2FjaGVkKHRleHQpIHtcbiAgICBpZiAoIXRoaXMubGF5b3V0Q2FjaGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmxheW91dFJ1bih0ZXh0KTtcbiAgICB9XG4gICAgbGV0IGNhY2hlZDtcbiAgICBpZiAoY2FjaGVkID0gdGhpcy5sYXlvdXRDYWNoZVt0ZXh0XSkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgY29uc3QgcnVuID0gdGhpcy5sYXlvdXRSdW4odGV4dCk7XG4gICAgdGhpcy5sYXlvdXRDYWNoZVt0ZXh0XSA9IHJ1bjtcbiAgICByZXR1cm4gcnVuO1xuICB9XG4gIGxheW91dCh0ZXh0LCBmZWF0dXJlcywgb25seVdpZHRoKSB7XG4gICAgaWYgKGZlYXR1cmVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXlvdXRSdW4odGV4dCwgZmVhdHVyZXMpO1xuICAgIH1cbiAgICBsZXQgZ2x5cGhzID0gb25seVdpZHRoID8gbnVsbCA6IFtdO1xuICAgIGxldCBwb3NpdGlvbnMgPSBvbmx5V2lkdGggPyBudWxsIDogW107XG4gICAgbGV0IGFkdmFuY2VXaWR0aCA9IDA7XG4gICAgbGV0IGxhc3QgPSAwO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGluZGV4IDw9IHRleHQubGVuZ3RoKSB7XG4gICAgICB2YXIgbmVlZGxlO1xuICAgICAgaWYgKGluZGV4ID09PSB0ZXh0Lmxlbmd0aCAmJiBsYXN0IDwgaW5kZXggfHwgKG5lZWRsZSA9IHRleHQuY2hhckF0KGluZGV4KSwgWycgJywgJ1xcdCddLmluY2x1ZGVzKG5lZWRsZSkpKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMubGF5b3V0Q2FjaGVkKHRleHQuc2xpY2UobGFzdCwgKytpbmRleCkpO1xuICAgICAgICBpZiAoIW9ubHlXaWR0aCkge1xuICAgICAgICAgIGdseXBocyA9IGdseXBocy5jb25jYXQocnVuLmdseXBocyk7XG4gICAgICAgICAgcG9zaXRpb25zID0gcG9zaXRpb25zLmNvbmNhdChydW4ucG9zaXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBhZHZhbmNlV2lkdGggKz0gcnVuLmFkdmFuY2VXaWR0aDtcbiAgICAgICAgbGFzdCA9IGluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGdseXBocyxcbiAgICAgIHBvc2l0aW9ucyxcbiAgICAgIGFkdmFuY2VXaWR0aFxuICAgIH07XG4gIH1cbiAgZW5jb2RlKHRleHQsIGZlYXR1cmVzKSB7XG4gICAgY29uc3Qge1xuICAgICAgZ2x5cGhzLFxuICAgICAgcG9zaXRpb25zXG4gICAgfSA9IHRoaXMubGF5b3V0KHRleHQsIGZlYXR1cmVzKTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICBjb25zdCBnaWQgPSB0aGlzLnN1YnNldC5pbmNsdWRlR2x5cGgoZ2x5cGguaWQpO1xuICAgICAgcmVzLnB1c2goYDAwMDAke2dpZC50b1N0cmluZygxNil9YC5zbGljZSgtNCkpO1xuICAgICAgaWYgKHRoaXMud2lkdGhzW2dpZF0gPT0gbnVsbCkge1xuICAgICAgICB0aGlzLndpZHRoc1tnaWRdID0gZ2x5cGguYWR2YW5jZVdpZHRoICogdGhpcy5zY2FsZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnVuaWNvZGVbZ2lkXSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudW5pY29kZVtnaWRdID0gZ2x5cGguY29kZVBvaW50cztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtyZXMsIHBvc2l0aW9uc107XG4gIH1cbiAgd2lkdGhPZlN0cmluZyhzdHJpbmcsIHNpemUsIGZlYXR1cmVzKSB7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmxheW91dChzdHJpbmcsIGZlYXR1cmVzLCB0cnVlKS5hZHZhbmNlV2lkdGg7XG4gICAgY29uc3Qgc2NhbGUgPSBzaXplIC8gMTAwMDtcbiAgICByZXR1cm4gd2lkdGggKiBzY2FsZTtcbiAgfVxuICBlbWJlZCgpIHtcbiAgICBjb25zdCBpc0NGRiA9IHRoaXMuc3Vic2V0LmNmZiAhPSBudWxsO1xuICAgIGNvbnN0IGZvbnRGaWxlID0gdGhpcy5kb2N1bWVudC5yZWYoKTtcbiAgICBpZiAoaXNDRkYpIHtcbiAgICAgIGZvbnRGaWxlLmRhdGEuU3VidHlwZSA9ICdDSURGb250VHlwZTBDJztcbiAgICB9XG4gICAgZm9udEZpbGUuZW5kKHRoaXMuc3Vic2V0LmVuY29kZSgpKTtcbiAgICBjb25zdCBmYW1pbHlDbGFzcyA9ICgodGhpcy5mb250WydPUy8yJ10gIT0gbnVsbCA/IHRoaXMuZm9udFsnT1MvMiddLnNGYW1pbHlDbGFzcyA6IHVuZGVmaW5lZCkgfHwgMCkgPj4gODtcbiAgICBsZXQgZmxhZ3MgPSAwO1xuICAgIGlmICh0aGlzLmZvbnQucG9zdC5pc0ZpeGVkUGl0Y2gpIHtcbiAgICAgIGZsYWdzIHw9IDEgPDwgMDtcbiAgICB9XG4gICAgaWYgKDEgPD0gZmFtaWx5Q2xhc3MgJiYgZmFtaWx5Q2xhc3MgPD0gNykge1xuICAgICAgZmxhZ3MgfD0gMSA8PCAxO1xuICAgIH1cbiAgICBmbGFncyB8PSAxIDw8IDI7XG4gICAgaWYgKGZhbWlseUNsYXNzID09PSAxMCkge1xuICAgICAgZmxhZ3MgfD0gMSA8PCAzO1xuICAgIH1cbiAgICBpZiAodGhpcy5mb250LmhlYWQubWFjU3R5bGUuaXRhbGljKSB7XG4gICAgICBmbGFncyB8PSAxIDw8IDY7XG4gICAgfVxuICAgIGNvbnN0IHRhZyA9IFsxLCAyLCAzLCA0LCA1LCA2XS5tYXAoaSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKCh0aGlzLmlkLmNoYXJDb2RlQXQoaSkgfHwgNzMpICsgMTcpKS5qb2luKCcnKTtcbiAgICBjb25zdCBuYW1lID0gdGFnICsgJysnICsgdGhpcy5mb250LnBvc3RzY3JpcHROYW1lPy5yZXBsYWNlQWxsKCcgJywgJ18nKTtcbiAgICBjb25zdCB7XG4gICAgICBiYm94XG4gICAgfSA9IHRoaXMuZm9udDtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5kb2N1bWVudC5yZWYoe1xuICAgICAgVHlwZTogJ0ZvbnREZXNjcmlwdG9yJyxcbiAgICAgIEZvbnROYW1lOiBuYW1lLFxuICAgICAgRmxhZ3M6IGZsYWdzLFxuICAgICAgRm9udEJCb3g6IFtiYm94Lm1pblggKiB0aGlzLnNjYWxlLCBiYm94Lm1pblkgKiB0aGlzLnNjYWxlLCBiYm94Lm1heFggKiB0aGlzLnNjYWxlLCBiYm94Lm1heFkgKiB0aGlzLnNjYWxlXSxcbiAgICAgIEl0YWxpY0FuZ2xlOiB0aGlzLmZvbnQuaXRhbGljQW5nbGUsXG4gICAgICBBc2NlbnQ6IHRoaXMuYXNjZW5kZXIsXG4gICAgICBEZXNjZW50OiB0aGlzLmRlc2NlbmRlcixcbiAgICAgIENhcEhlaWdodDogKHRoaXMuZm9udC5jYXBIZWlnaHQgfHwgdGhpcy5mb250LmFzY2VudCkgKiB0aGlzLnNjYWxlLFxuICAgICAgWEhlaWdodDogKHRoaXMuZm9udC54SGVpZ2h0IHx8IDApICogdGhpcy5zY2FsZSxcbiAgICAgIFN0ZW1WOiAwXG4gICAgfSk7XG4gICAgaWYgKGlzQ0ZGKSB7XG4gICAgICBkZXNjcmlwdG9yLmRhdGEuRm9udEZpbGUzID0gZm9udEZpbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc2NyaXB0b3IuZGF0YS5Gb250RmlsZTIgPSBmb250RmlsZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZG9jdW1lbnQuc3Vic2V0ICYmIHRoaXMuZG9jdW1lbnQuc3Vic2V0ID09PSAxKSB7XG4gICAgICBjb25zdCBDSURTZXQgPSBCdWZmZXIuZnJvbSgnRkZGRkZGRkZDMCcsICdoZXgnKTtcbiAgICAgIGNvbnN0IENJRFNldFJlZiA9IHRoaXMuZG9jdW1lbnQucmVmKCk7XG4gICAgICBDSURTZXRSZWYud3JpdGUoQ0lEU2V0KTtcbiAgICAgIENJRFNldFJlZi5lbmQoKTtcbiAgICAgIGRlc2NyaXB0b3IuZGF0YS5DSURTZXQgPSBDSURTZXRSZWY7XG4gICAgfVxuICAgIGRlc2NyaXB0b3IuZW5kKCk7XG4gICAgY29uc3QgZGVzY2VuZGFudEZvbnREYXRhID0ge1xuICAgICAgVHlwZTogJ0ZvbnQnLFxuICAgICAgU3VidHlwZTogJ0NJREZvbnRUeXBlMCcsXG4gICAgICBCYXNlRm9udDogbmFtZSxcbiAgICAgIENJRFN5c3RlbUluZm86IHtcbiAgICAgICAgUmVnaXN0cnk6IG5ldyBTdHJpbmcoJ0Fkb2JlJyksXG4gICAgICAgIE9yZGVyaW5nOiBuZXcgU3RyaW5nKCdJZGVudGl0eScpLFxuICAgICAgICBTdXBwbGVtZW50OiAwXG4gICAgICB9LFxuICAgICAgRm9udERlc2NyaXB0b3I6IGRlc2NyaXB0b3IsXG4gICAgICBXOiBbMCwgdGhpcy53aWR0aHNdXG4gICAgfTtcbiAgICBpZiAoIWlzQ0ZGKSB7XG4gICAgICBkZXNjZW5kYW50Rm9udERhdGEuU3VidHlwZSA9ICdDSURGb250VHlwZTInO1xuICAgICAgZGVzY2VuZGFudEZvbnREYXRhLkNJRFRvR0lETWFwID0gJ0lkZW50aXR5JztcbiAgICB9XG4gICAgY29uc3QgZGVzY2VuZGFudEZvbnQgPSB0aGlzLmRvY3VtZW50LnJlZihkZXNjZW5kYW50Rm9udERhdGEpO1xuICAgIGRlc2NlbmRhbnRGb250LmVuZCgpO1xuICAgIHRoaXMuZGljdGlvbmFyeS5kYXRhID0ge1xuICAgICAgVHlwZTogJ0ZvbnQnLFxuICAgICAgU3VidHlwZTogJ1R5cGUwJyxcbiAgICAgIEJhc2VGb250OiBuYW1lLFxuICAgICAgRW5jb2Rpbmc6ICdJZGVudGl0eS1IJyxcbiAgICAgIERlc2NlbmRhbnRGb250czogW2Rlc2NlbmRhbnRGb250XSxcbiAgICAgIFRvVW5pY29kZTogdGhpcy50b1VuaWNvZGVDbWFwKClcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmRpY3Rpb25hcnkuZW5kKCk7XG4gIH1cbiAgdG9Vbmljb2RlQ21hcCgpIHtcbiAgICBjb25zdCBjbWFwID0gdGhpcy5kb2N1bWVudC5yZWYoKTtcbiAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgZm9yIChsZXQgY29kZVBvaW50cyBvZiB0aGlzLnVuaWNvZGUpIHtcbiAgICAgIGNvbnN0IGVuY29kZWQgPSBbXTtcbiAgICAgIGZvciAobGV0IHZhbHVlIG9mIGNvZGVQb2ludHMpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gMHhmZmZmKSB7XG4gICAgICAgICAgdmFsdWUgLT0gMHgxMDAwMDtcbiAgICAgICAgICBlbmNvZGVkLnB1c2godG9IZXgodmFsdWUgPj4+IDEwICYgMHgzZmYgfCAweGQ4MDApKTtcbiAgICAgICAgICB2YWx1ZSA9IDB4ZGMwMCB8IHZhbHVlICYgMHgzZmY7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZC5wdXNoKHRvSGV4KHZhbHVlKSk7XG4gICAgICB9XG4gICAgICBlbnRyaWVzLnB1c2goYDwke2VuY29kZWQuam9pbignICcpfT5gKTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtTaXplID0gMjU2O1xuICAgIGNvbnN0IGNodW5rcyA9IE1hdGguY2VpbChlbnRyaWVzLmxlbmd0aCAvIGNodW5rU2l6ZSk7XG4gICAgY29uc3QgcmFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3M7IGkrKykge1xuICAgICAgY29uc3Qgc3RhcnQgPSBpICogY2h1bmtTaXplO1xuICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4oKGkgKyAxKSAqIGNodW5rU2l6ZSwgZW50cmllcy5sZW5ndGgpO1xuICAgICAgcmFuZ2VzLnB1c2goYDwke3RvSGV4KHN0YXJ0KX0+IDwke3RvSGV4KGVuZCAtIDEpfT4gWyR7ZW50cmllcy5zbGljZShzdGFydCwgZW5kKS5qb2luKCcgJyl9XWApO1xuICAgIH1cbiAgICBjbWFwLmVuZChgXFxcbi9DSURJbml0IC9Qcm9jU2V0IGZpbmRyZXNvdXJjZSBiZWdpblxuMTIgZGljdCBiZWdpblxuYmVnaW5jbWFwXG4vQ0lEU3lzdGVtSW5mbyA8PFxuICAvUmVnaXN0cnkgKEFkb2JlKVxuICAvT3JkZXJpbmcgKFVDUylcbiAgL1N1cHBsZW1lbnQgMFxuPj4gZGVmXG4vQ01hcE5hbWUgL0Fkb2JlLUlkZW50aXR5LVVDUyBkZWZcbi9DTWFwVHlwZSAyIGRlZlxuMSBiZWdpbmNvZGVzcGFjZXJhbmdlXG48MDAwMD48ZmZmZj5cbmVuZGNvZGVzcGFjZXJhbmdlXG4xIGJlZ2luYmZyYW5nZVxuJHtyYW5nZXMuam9pbignXFxuJyl9XG5lbmRiZnJhbmdlXG5lbmRjbWFwXG5DTWFwTmFtZSBjdXJyZW50ZGljdCAvQ01hcCBkZWZpbmVyZXNvdXJjZSBwb3BcbmVuZFxuZW5kXFxcbmApO1xuICAgIHJldHVybiBjbWFwO1xuICB9XG59XG5cbmNsYXNzIFBERkZvbnRGYWN0b3J5IHtcbiAgc3RhdGljIG9wZW4oZG9jdW1lbnQsIHNyYywgZmFtaWx5LCBpZCkge1xuICAgIGxldCBmb250O1xuICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKFN0YW5kYXJkRm9udC5pc1N0YW5kYXJkRm9udChzcmMpKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhbmRhcmRGb250KGRvY3VtZW50LCBzcmMsIGlkKTtcbiAgICAgIH1cbiAgICAgIHNyYyA9IGZzLnJlYWRGaWxlU3luYyhzcmMpO1xuICAgIH1cbiAgICBpZiAoc3JjIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgZm9udCA9IGZvbnRraXQuY3JlYXRlKHNyYywgZmFtaWx5KTtcbiAgICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBmb250ID0gZm9udGtpdC5jcmVhdGUobmV3IFVpbnQ4QXJyYXkoc3JjKSwgZmFtaWx5KTtcbiAgICB9XG4gICAgaWYgKGZvbnQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBzdXBwb3J0ZWQgZm9udCBmb3JtYXQgb3Igc3RhbmRhcmQgUERGIGZvbnQuJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRW1iZWRkZWRGb250KGRvY3VtZW50LCBmb250LCBpZCk7XG4gIH1cbn1cblxuY29uc3QgaXNFcXVhbEZvbnQgPSAoZm9udDEsIGZvbnQyKSA9PiB7XG4gIGlmIChmb250MS5mb250Ll90YWJsZXM/LmhlYWQ/LmNoZWNrU3VtQWRqdXN0bWVudCAhPT0gZm9udDIuZm9udC5fdGFibGVzPy5oZWFkPy5jaGVja1N1bUFkanVzdG1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKEpTT04uc3RyaW5naWZ5KGZvbnQxLmZvbnQuX3RhYmxlcz8ubmFtZT8ucmVjb3JkcykgIT09IEpTT04uc3RyaW5naWZ5KGZvbnQyLmZvbnQuX3RhYmxlcz8ubmFtZT8ucmVjb3JkcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZvbnRzTWl4aW4gPSB7XG4gIGluaXRGb250cygpIHtcbiAgICBsZXQgZGVmYXVsdEZvbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdIZWx2ZXRpY2EnO1xuICAgIGxldCBkZWZhdWx0Rm9udEZhbWlseSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICBsZXQgZGVmYXVsdEZvbnRTaXplID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxMjtcbiAgICB0aGlzLl9mb250RmFtaWxpZXMgPSB7fTtcbiAgICB0aGlzLl9mb250Q291bnQgPSAwO1xuICAgIHRoaXMuX2ZvbnRTb3VyY2UgPSBkZWZhdWx0Rm9udDtcbiAgICB0aGlzLl9mb250RmFtaWx5ID0gZGVmYXVsdEZvbnRGYW1pbHk7XG4gICAgdGhpcy5fZm9udFNpemUgPSBkZWZhdWx0Rm9udFNpemU7XG4gICAgdGhpcy5fZm9udCA9IG51bGw7XG4gICAgdGhpcy5fcmVtU2l6ZSA9IGRlZmF1bHRGb250U2l6ZTtcbiAgICB0aGlzLl9yZWdpc3RlcmVkRm9udHMgPSB7fTtcbiAgICBpZiAoZGVmYXVsdEZvbnQpIHtcbiAgICAgIHRoaXMuZm9udChkZWZhdWx0Rm9udCwgZGVmYXVsdEZvbnRGYW1pbHkpO1xuICAgIH1cbiAgfSxcbiAgZm9udChzcmMsIGZhbWlseSwgc2l6ZSkge1xuICAgIGxldCBjYWNoZUtleSwgZm9udDtcbiAgICBpZiAodHlwZW9mIGZhbWlseSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHNpemUgPSBmYW1pbHk7XG4gICAgICBmYW1pbHkgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgJiYgdGhpcy5fcmVnaXN0ZXJlZEZvbnRzW3NyY10pIHtcbiAgICAgIGNhY2hlS2V5ID0gc3JjO1xuICAgICAgKHtcbiAgICAgICAgc3JjLFxuICAgICAgICBmYW1pbHlcbiAgICAgIH0gPSB0aGlzLl9yZWdpc3RlcmVkRm9udHNbc3JjXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlS2V5ID0gZmFtaWx5IHx8IHNyYztcbiAgICAgIGlmICh0eXBlb2YgY2FjaGVLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNhY2hlS2V5ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZm9udFNvdXJjZSA9IHNyYztcbiAgICB0aGlzLl9mb250RmFtaWx5ID0gZmFtaWx5O1xuICAgIGlmIChzaXplICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZm9udFNpemUoc2l6ZSk7XG4gICAgfVxuICAgIGlmIChmb250ID0gdGhpcy5fZm9udEZhbWlsaWVzW2NhY2hlS2V5XSkge1xuICAgICAgdGhpcy5fZm9udCA9IGZvbnQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgaWQgPSBgRiR7Kyt0aGlzLl9mb250Q291bnR9YDtcbiAgICB0aGlzLl9mb250ID0gUERGRm9udEZhY3Rvcnkub3Blbih0aGlzLCBzcmMsIGZhbWlseSwgaWQpO1xuICAgIGlmICgoZm9udCA9IHRoaXMuX2ZvbnRGYW1pbGllc1t0aGlzLl9mb250Lm5hbWVdKSAmJiBpc0VxdWFsRm9udCh0aGlzLl9mb250LCBmb250KSkge1xuICAgICAgdGhpcy5fZm9udCA9IGZvbnQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICB0aGlzLl9mb250RmFtaWxpZXNbY2FjaGVLZXldID0gdGhpcy5fZm9udDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2ZvbnQubmFtZSkge1xuICAgICAgdGhpcy5fZm9udEZhbWlsaWVzW3RoaXMuX2ZvbnQubmFtZV0gPSB0aGlzLl9mb250O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZm9udFNpemUoX2ZvbnRTaXplKSB7XG4gICAgdGhpcy5fZm9udFNpemUgPSB0aGlzLnNpemVUb1BvaW50KF9mb250U2l6ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGN1cnJlbnRMaW5lSGVpZ2h0KGluY2x1ZGVHYXApIHtcbiAgICByZXR1cm4gdGhpcy5fZm9udC5saW5lSGVpZ2h0KHRoaXMuX2ZvbnRTaXplLCBpbmNsdWRlR2FwKTtcbiAgfSxcbiAgcmVnaXN0ZXJGb250KG5hbWUsIHNyYywgZmFtaWx5KSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJlZEZvbnRzW25hbWVdID0ge1xuICAgICAgc3JjLFxuICAgICAgZmFtaWx5XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc2l6ZVRvUG9pbnQoc2l6ZSkge1xuICAgIGxldCBkZWZhdWx0VmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgbGV0IHBhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMucGFnZTtcbiAgICBsZXQgcGVyY2VudGFnZVdpZHRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFwZXJjZW50YWdlV2lkdGgpIHBlcmNlbnRhZ2VXaWR0aCA9IHRoaXMuX2ZvbnRTaXplO1xuICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlICE9PSAnbnVtYmVyJykgZGVmYXVsdFZhbHVlID0gdGhpcy5zaXplVG9Qb2ludChkZWZhdWx0VmFsdWUpO1xuICAgIGlmIChzaXplID09PSB1bmRlZmluZWQpIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykgcmV0dXJuIHNpemU7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnYm9vbGVhbicpIHJldHVybiBOdW1iZXIoc2l6ZSk7XG4gICAgY29uc3QgbWF0Y2ggPSBTdHJpbmcoc2l6ZSkubWF0Y2goLygoXFxkKyk/KFxcLlxcZCspPykoZW18aW58cHh8Y218bW18cGN8ZXh8Y2h8cmVtfHZ3fHZofHZtaW58dm1heHwlfHB0KT8vKTtcbiAgICBpZiAoIW1hdGNoKSB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHNpemUgJyR7c2l6ZX0nYCk7XG4gICAgbGV0IG11bHRpcGxpZXI7XG4gICAgc3dpdGNoIChtYXRjaFs0XSkge1xuICAgICAgY2FzZSAnZW0nOlxuICAgICAgICBtdWx0aXBsaWVyID0gdGhpcy5fZm9udFNpemU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW4nOlxuICAgICAgICBtdWx0aXBsaWVyID0gSU5fVE9fUFQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncHgnOlxuICAgICAgICBtdWx0aXBsaWVyID0gUFhfVE9fSU4gKiBJTl9UT19QVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjbSc6XG4gICAgICAgIG11bHRpcGxpZXIgPSBDTV9UT19JTiAqIElOX1RPX1BUO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21tJzpcbiAgICAgICAgbXVsdGlwbGllciA9IE1NX1RPX0NNICogQ01fVE9fSU4gKiBJTl9UT19QVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwYyc6XG4gICAgICAgIG11bHRpcGxpZXIgPSBQQ19UT19QVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdleCc6XG4gICAgICAgIG11bHRpcGxpZXIgPSB0aGlzLmN1cnJlbnRMaW5lSGVpZ2h0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2gnOlxuICAgICAgICBtdWx0aXBsaWVyID0gdGhpcy53aWR0aE9mU3RyaW5nKCcwJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVtJzpcbiAgICAgICAgbXVsdGlwbGllciA9IHRoaXMuX3JlbVNpemU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndncnOlxuICAgICAgICBtdWx0aXBsaWVyID0gcGFnZS53aWR0aCAvIDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd2aCc6XG4gICAgICAgIG11bHRpcGxpZXIgPSBwYWdlLmhlaWdodCAvIDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd2bWluJzpcbiAgICAgICAgbXVsdGlwbGllciA9IE1hdGgubWluKHBhZ2Uud2lkdGgsIHBhZ2UuaGVpZ2h0KSAvIDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd2bWF4JzpcbiAgICAgICAgbXVsdGlwbGllciA9IE1hdGgubWF4KHBhZ2Uud2lkdGgsIHBhZ2UuaGVpZ2h0KSAvIDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICclJzpcbiAgICAgICAgbXVsdGlwbGllciA9IHBlcmNlbnRhZ2VXaWR0aCAvIDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwdCc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBtdWx0aXBsaWVyID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIG11bHRpcGxpZXIgKiBOdW1iZXIobWF0Y2hbMV0pO1xuICB9XG59O1xuXG5jb25zdCBTT0ZUX0hZUEhFTiA9ICdcXHUwMEFEJztcbmNvbnN0IEhZUEhFTiA9ICctJztcbmNsYXNzIExpbmVXcmFwcGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLmhvcml6b250YWxTY2FsaW5nID0gb3B0aW9ucy5ob3Jpem9udGFsU2NhbGluZyB8fCAxMDA7XG4gICAgdGhpcy5pbmRlbnQgPSAob3B0aW9ucy5pbmRlbnQgfHwgMCkgKiB0aGlzLmhvcml6b250YWxTY2FsaW5nIC8gMTAwO1xuICAgIHRoaXMuY2hhcmFjdGVyU3BhY2luZyA9IChvcHRpb25zLmNoYXJhY3RlclNwYWNpbmcgfHwgMCkgKiB0aGlzLmhvcml6b250YWxTY2FsaW5nIC8gMTAwO1xuICAgIHRoaXMud29yZFNwYWNpbmcgPSAob3B0aW9ucy53b3JkU3BhY2luZyA9PT0gMCkgKiB0aGlzLmhvcml6b250YWxTY2FsaW5nIC8gMTAwO1xuICAgIHRoaXMuY29sdW1ucyA9IG9wdGlvbnMuY29sdW1ucyB8fCAxO1xuICAgIHRoaXMuY29sdW1uR2FwID0gKG9wdGlvbnMuY29sdW1uR2FwICE9IG51bGwgPyBvcHRpb25zLmNvbHVtbkdhcCA6IDE4KSAqIHRoaXMuaG9yaXpvbnRhbFNjYWxpbmcgLyAxMDA7XG4gICAgdGhpcy5saW5lV2lkdGggPSAob3B0aW9ucy53aWR0aCAqIHRoaXMuaG9yaXpvbnRhbFNjYWxpbmcgLyAxMDAgLSB0aGlzLmNvbHVtbkdhcCAqICh0aGlzLmNvbHVtbnMgLSAxKSkgLyB0aGlzLmNvbHVtbnM7XG4gICAgdGhpcy5zcGFjZUxlZnQgPSB0aGlzLmxpbmVXaWR0aDtcbiAgICB0aGlzLnN0YXJ0WCA9IHRoaXMuZG9jdW1lbnQueDtcbiAgICB0aGlzLnN0YXJ0WSA9IHRoaXMuZG9jdW1lbnQueTtcbiAgICB0aGlzLmNvbHVtbiA9IDE7XG4gICAgdGhpcy5lbGxpcHNpcyA9IG9wdGlvbnMuZWxsaXBzaXM7XG4gICAgdGhpcy5jb250aW51ZWRYID0gMDtcbiAgICB0aGlzLmZlYXR1cmVzID0gb3B0aW9ucy5mZWF0dXJlcztcbiAgICBpZiAob3B0aW9ucy5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgICAgIHRoaXMubWF4WSA9IFBERk51bWJlcih0aGlzLnN0YXJ0WSArIG9wdGlvbnMuaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXhZID0gUERGTnVtYmVyKHRoaXMuZG9jdW1lbnQucGFnZS5tYXhZKCkpO1xuICAgIH1cbiAgICB0aGlzLm9uKCdmaXJzdExpbmUnLCBvcHRpb25zID0+IHtcbiAgICAgIGNvbnN0IGluZGVudCA9IHRoaXMuY29udGludWVkWCB8fCB0aGlzLmluZGVudDtcbiAgICAgIHRoaXMuZG9jdW1lbnQueCArPSBpbmRlbnQ7XG4gICAgICB0aGlzLmxpbmVXaWR0aCAtPSBpbmRlbnQ7XG4gICAgICBpZiAob3B0aW9ucy5pbmRlbnRBbGxMaW5lcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm9uY2UoJ2xpbmUnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQueCAtPSBpbmRlbnQ7XG4gICAgICAgIHRoaXMubGluZVdpZHRoICs9IGluZGVudDtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGludWVkICYmICF0aGlzLmNvbnRpbnVlZFgpIHtcbiAgICAgICAgICB0aGlzLmNvbnRpbnVlZFggPSB0aGlzLmluZGVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuY29udGludWVkKSB7XG4gICAgICAgICAgdGhpcy5jb250aW51ZWRYID0gMDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5vbignbGFzdExpbmUnLCBvcHRpb25zID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWxpZ25cbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgaWYgKGFsaWduID09PSAnanVzdGlmeScpIHtcbiAgICAgICAgb3B0aW9ucy5hbGlnbiA9ICdsZWZ0JztcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdExpbmUgPSB0cnVlO1xuICAgICAgdGhpcy5vbmNlKCdsaW5lJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmRvY3VtZW50LnkgKz0gb3B0aW9ucy5wYXJhZ3JhcGhHYXAgfHwgMDtcbiAgICAgICAgb3B0aW9ucy5hbGlnbiA9IGFsaWduO1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0TGluZSA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgd29yZFdpZHRoKHdvcmQpIHtcbiAgICByZXR1cm4gUERGTnVtYmVyKHRoaXMuZG9jdW1lbnQud2lkdGhPZlN0cmluZyh3b3JkLCB0aGlzKSArIHRoaXMuY2hhcmFjdGVyU3BhY2luZyArIHRoaXMud29yZFNwYWNpbmcpO1xuICB9XG4gIGNhbkZpdCh3b3JkLCB3KSB7XG4gICAgaWYgKHdvcmRbd29yZC5sZW5ndGggLSAxXSAhPSBTT0ZUX0hZUEhFTikge1xuICAgICAgcmV0dXJuIHcgPD0gdGhpcy5zcGFjZUxlZnQ7XG4gICAgfVxuICAgIHJldHVybiB3ICsgdGhpcy53b3JkV2lkdGgoSFlQSEVOKSA8PSB0aGlzLnNwYWNlTGVmdDtcbiAgfVxuICBlYWNoV29yZCh0ZXh0LCBmbikge1xuICAgIGxldCBiaztcbiAgICBjb25zdCBicmVha2VyID0gbmV3IExpbmVCcmVha2VyKHRleHQpO1xuICAgIGxldCBsYXN0ID0gbnVsbDtcbiAgICBjb25zdCB3b3JkV2lkdGhzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB3aGlsZSAoYmsgPSBicmVha2VyLm5leHRCcmVhaygpKSB7XG4gICAgICB2YXIgc2hvdWxkQ29udGludWU7XG4gICAgICBsZXQgd29yZCA9IHRleHQuc2xpY2UoKGxhc3QgIT0gbnVsbCA/IGxhc3QucG9zaXRpb24gOiB1bmRlZmluZWQpIHx8IDAsIGJrLnBvc2l0aW9uKTtcbiAgICAgIGxldCB3ID0gd29yZFdpZHRoc1t3b3JkXSAhPSBudWxsID8gd29yZFdpZHRoc1t3b3JkXSA6IHdvcmRXaWR0aHNbd29yZF0gPSB0aGlzLndvcmRXaWR0aCh3b3JkKTtcbiAgICAgIGlmICh3ID4gdGhpcy5saW5lV2lkdGggKyB0aGlzLmNvbnRpbnVlZFgpIHtcbiAgICAgICAgbGV0IGxiayA9IGxhc3Q7XG4gICAgICAgIGNvbnN0IGZiayA9IHt9O1xuICAgICAgICB3aGlsZSAod29yZC5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgbCwgbWlnaHRHcm93O1xuICAgICAgICAgIGlmICh3ID4gdGhpcy5zcGFjZUxlZnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLmNlaWwodGhpcy5zcGFjZUxlZnQgLyAodyAvIHdvcmQubGVuZ3RoKSk7XG4gICAgICAgICAgICB3ID0gdGhpcy53b3JkV2lkdGgod29yZC5zbGljZSgwLCBsKSk7XG4gICAgICAgICAgICBtaWdodEdyb3cgPSB3IDw9IHRoaXMuc3BhY2VMZWZ0ICYmIGwgPCB3b3JkLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IHdvcmQubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgbXVzdFNocmluayA9IHcgPiB0aGlzLnNwYWNlTGVmdCAmJiBsID4gMDtcbiAgICAgICAgICB3aGlsZSAobXVzdFNocmluayB8fCBtaWdodEdyb3cpIHtcbiAgICAgICAgICAgIGlmIChtdXN0U2hyaW5rKSB7XG4gICAgICAgICAgICAgIHcgPSB0aGlzLndvcmRXaWR0aCh3b3JkLnNsaWNlKDAsIC0tbCkpO1xuICAgICAgICAgICAgICBtdXN0U2hyaW5rID0gdyA+IHRoaXMuc3BhY2VMZWZ0ICYmIGwgPiAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdyA9IHRoaXMud29yZFdpZHRoKHdvcmQuc2xpY2UoMCwgKytsKSk7XG4gICAgICAgICAgICAgIG11c3RTaHJpbmsgPSB3ID4gdGhpcy5zcGFjZUxlZnQgJiYgbCA+IDA7XG4gICAgICAgICAgICAgIG1pZ2h0R3JvdyA9IHcgPD0gdGhpcy5zcGFjZUxlZnQgJiYgbCA8IHdvcmQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobCA9PT0gMCAmJiB0aGlzLnNwYWNlTGVmdCA9PT0gdGhpcy5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgIGwgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmYmsucmVxdWlyZWQgPSBiay5yZXF1aXJlZCB8fCBsIDwgd29yZC5sZW5ndGg7XG4gICAgICAgICAgc2hvdWxkQ29udGludWUgPSBmbih3b3JkLnNsaWNlKDAsIGwpLCB3LCBmYmssIGxiayk7XG4gICAgICAgICAgbGJrID0ge1xuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlXG4gICAgICAgICAgfTtcbiAgICAgICAgICB3b3JkID0gd29yZC5zbGljZShsKTtcbiAgICAgICAgICB3ID0gdGhpcy53b3JkV2lkdGgod29yZCk7XG4gICAgICAgICAgaWYgKHNob3VsZENvbnRpbnVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaG91bGRDb250aW51ZSA9IGZuKHdvcmQsIHcsIGJrLCBsYXN0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRDb250aW51ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsYXN0ID0gYms7XG4gICAgfVxuICB9XG4gIHdyYXAodGV4dCwgb3B0aW9ucykge1xuICAgIHRoaXMuaG9yaXpvbnRhbFNjYWxpbmcgPSBvcHRpb25zLmhvcml6b250YWxTY2FsaW5nIHx8IDEwMDtcbiAgICBpZiAob3B0aW9ucy5pbmRlbnQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5pbmRlbnQgPSBvcHRpb25zLmluZGVudCAqIHRoaXMuaG9yaXpvbnRhbFNjYWxpbmcgLyAxMDA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNoYXJhY3RlclNwYWNpbmcgIT0gbnVsbCkge1xuICAgICAgdGhpcy5jaGFyYWN0ZXJTcGFjaW5nID0gb3B0aW9ucy5jaGFyYWN0ZXJTcGFjaW5nICogdGhpcy5ob3Jpem9udGFsU2NhbGluZyAvIDEwMDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud29yZFNwYWNpbmcgIT0gbnVsbCkge1xuICAgICAgdGhpcy53b3JkU3BhY2luZyA9IG9wdGlvbnMud29yZFNwYWNpbmcgKiB0aGlzLmhvcml6b250YWxTY2FsaW5nIC8gMTAwO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5lbGxpcHNpcyAhPSBudWxsKSB7XG4gICAgICB0aGlzLmVsbGlwc2lzID0gb3B0aW9ucy5lbGxpcHNpcztcbiAgICB9XG4gICAgY29uc3QgbmV4dFkgPSB0aGlzLmRvY3VtZW50LnkgKyB0aGlzLmRvY3VtZW50LmN1cnJlbnRMaW5lSGVpZ2h0KHRydWUpO1xuICAgIGlmICh0aGlzLmRvY3VtZW50LnkgPiB0aGlzLm1heFkgfHwgbmV4dFkgPiB0aGlzLm1heFkpIHtcbiAgICAgIHRoaXMubmV4dFNlY3Rpb24oKTtcbiAgICB9XG4gICAgbGV0IGJ1ZmZlciA9ICcnO1xuICAgIGxldCB0ZXh0V2lkdGggPSAwO1xuICAgIGxldCB3YyA9IDA7XG4gICAgbGV0IGxjID0gMDtcbiAgICBsZXQge1xuICAgICAgeVxuICAgIH0gPSB0aGlzLmRvY3VtZW50O1xuICAgIGNvbnN0IGVtaXRMaW5lID0gKCkgPT4ge1xuICAgICAgb3B0aW9ucy50ZXh0V2lkdGggPSB0ZXh0V2lkdGggKyB0aGlzLndvcmRTcGFjaW5nICogKHdjIC0gMSk7XG4gICAgICBvcHRpb25zLndvcmRDb3VudCA9IHdjO1xuICAgICAgb3B0aW9ucy5saW5lV2lkdGggPSB0aGlzLmxpbmVXaWR0aDtcbiAgICAgICh7XG4gICAgICAgIHlcbiAgICAgIH0gPSB0aGlzLmRvY3VtZW50KTtcbiAgICAgIHRoaXMuZW1pdCgnbGluZScsIGJ1ZmZlciwgb3B0aW9ucywgdGhpcyk7XG4gICAgICByZXR1cm4gbGMrKztcbiAgICB9O1xuICAgIHRoaXMuZW1pdCgnc2VjdGlvblN0YXJ0Jywgb3B0aW9ucywgdGhpcyk7XG4gICAgdGhpcy5lYWNoV29yZCh0ZXh0LCAod29yZCwgdywgYmssIGxhc3QpID0+IHtcbiAgICAgIGlmIChsYXN0ID09IG51bGwgfHwgbGFzdC5yZXF1aXJlZCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2ZpcnN0TGluZScsIG9wdGlvbnMsIHRoaXMpO1xuICAgICAgICB0aGlzLnNwYWNlTGVmdCA9IHRoaXMubGluZVdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2FuRml0KHdvcmQsIHcpKSB7XG4gICAgICAgIGJ1ZmZlciArPSB3b3JkO1xuICAgICAgICB0ZXh0V2lkdGggKz0gdztcbiAgICAgICAgd2MrKztcbiAgICAgIH1cbiAgICAgIGlmIChiay5yZXF1aXJlZCB8fCAhdGhpcy5jYW5GaXQod29yZCwgdykpIHtcbiAgICAgICAgY29uc3QgbGggPSB0aGlzLmRvY3VtZW50LmN1cnJlbnRMaW5lSGVpZ2h0KHRydWUpO1xuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT0gbnVsbCAmJiB0aGlzLmVsbGlwc2lzICYmIFBERk51bWJlcih0aGlzLmRvY3VtZW50LnkgKyBsaCAqIDIpID4gdGhpcy5tYXhZICYmIHRoaXMuY29sdW1uID49IHRoaXMuY29sdW1ucykge1xuICAgICAgICAgIGlmICh0aGlzLmVsbGlwc2lzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmVsbGlwc2lzID0gJ+KApic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgICB0ZXh0V2lkdGggPSB0aGlzLndvcmRXaWR0aChidWZmZXIgKyB0aGlzLmVsbGlwc2lzKTtcbiAgICAgICAgICB3aGlsZSAoYnVmZmVyICYmIHRleHRXaWR0aCA+IHRoaXMubGluZVdpZHRoKSB7XG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgLTEpLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgICAgICAgICAgdGV4dFdpZHRoID0gdGhpcy53b3JkV2lkdGgoYnVmZmVyICsgdGhpcy5lbGxpcHNpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0ZXh0V2lkdGggPD0gdGhpcy5saW5lV2lkdGgpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlciArIHRoaXMuZWxsaXBzaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHRXaWR0aCA9IHRoaXMud29yZFdpZHRoKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJrLnJlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHcgPiB0aGlzLnNwYWNlTGVmdCkge1xuICAgICAgICAgICAgZW1pdExpbmUoKTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IHdvcmQ7XG4gICAgICAgICAgICB0ZXh0V2lkdGggPSB3O1xuICAgICAgICAgICAgd2MgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoJ2xhc3RMaW5lJywgb3B0aW9ucywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gMV0gPT0gU09GVF9IWVBIRU4pIHtcbiAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgLTEpICsgSFlQSEVOO1xuICAgICAgICAgIHRoaXMuc3BhY2VMZWZ0IC09IHRoaXMud29yZFdpZHRoKEhZUEhFTik7XG4gICAgICAgIH1cbiAgICAgICAgZW1pdExpbmUoKTtcbiAgICAgICAgaWYgKFBERk51bWJlcih0aGlzLmRvY3VtZW50LnkgKyBsaCkgPiB0aGlzLm1heFkpIHtcbiAgICAgICAgICBjb25zdCBzaG91bGRDb250aW51ZSA9IHRoaXMubmV4dFNlY3Rpb24oKTtcbiAgICAgICAgICBpZiAoIXNob3VsZENvbnRpbnVlKSB7XG4gICAgICAgICAgICB3YyA9IDA7XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJrLnJlcXVpcmVkKSB7XG4gICAgICAgICAgdGhpcy5zcGFjZUxlZnQgPSB0aGlzLmxpbmVXaWR0aDtcbiAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICB0ZXh0V2lkdGggPSAwO1xuICAgICAgICAgIHJldHVybiB3YyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zcGFjZUxlZnQgPSB0aGlzLmxpbmVXaWR0aCAtIHc7XG4gICAgICAgICAgYnVmZmVyID0gd29yZDtcbiAgICAgICAgICB0ZXh0V2lkdGggPSB3O1xuICAgICAgICAgIHJldHVybiB3YyA9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwYWNlTGVmdCAtPSB3O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh3YyA+IDApIHtcbiAgICAgIHRoaXMuZW1pdCgnbGFzdExpbmUnLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgIGVtaXRMaW5lKCk7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnc2VjdGlvbkVuZCcsIG9wdGlvbnMsIHRoaXMpO1xuICAgIGlmIChvcHRpb25zLmNvbnRpbnVlZCA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKGxjID4gMSkge1xuICAgICAgICB0aGlzLmNvbnRpbnVlZFggPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250aW51ZWRYICs9IG9wdGlvbnMudGV4dFdpZHRoIHx8IDA7XG4gICAgICB0aGlzLmRvY3VtZW50LnkgPSB5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvY3VtZW50LnggPSB0aGlzLnN0YXJ0WDtcbiAgICB9XG4gIH1cbiAgbmV4dFNlY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuZW1pdCgnc2VjdGlvbkVuZCcsIG9wdGlvbnMsIHRoaXMpO1xuICAgIGlmICgrK3RoaXMuY29sdW1uID4gdGhpcy5jb2x1bW5zKSB7XG4gICAgICBpZiAodGhpcy5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLmRvY3VtZW50LmNvbnRpbnVlT25OZXdQYWdlKCk7XG4gICAgICB0aGlzLmNvbHVtbiA9IDE7XG4gICAgICB0aGlzLnN0YXJ0WSA9IHRoaXMuZG9jdW1lbnQucGFnZS5tYXJnaW5zLnRvcDtcbiAgICAgIHRoaXMubWF4WSA9IHRoaXMuZG9jdW1lbnQucGFnZS5tYXhZKCk7XG4gICAgICB0aGlzLmRvY3VtZW50LnggPSB0aGlzLnN0YXJ0WDtcbiAgICAgIGlmICh0aGlzLmRvY3VtZW50Ll9maWxsQ29sb3IpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudC5maWxsQ29sb3IoLi4udGhpcy5kb2N1bWVudC5fZmlsbENvbG9yKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdCgncGFnZUJyZWFrJywgb3B0aW9ucywgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9jdW1lbnQueCArPSB0aGlzLmxpbmVXaWR0aCArIHRoaXMuY29sdW1uR2FwO1xuICAgICAgdGhpcy5kb2N1bWVudC55ID0gdGhpcy5zdGFydFk7XG4gICAgICB0aGlzLmVtaXQoJ2NvbHVtbkJyZWFrJywgb3B0aW9ucywgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnc2VjdGlvblN0YXJ0Jywgb3B0aW9ucywgdGhpcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuY29uc3Qge1xuICBudW1iZXJcbn0gPSBQREZPYmplY3Q7XG52YXIgVGV4dE1peGluID0ge1xuICBpbml0VGV4dCgpIHtcbiAgICB0aGlzLl9saW5lID0gdGhpcy5fbGluZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLl9saW5lR2FwID0gMDtcbiAgfSxcbiAgbGluZUdhcChfbGluZUdhcCkge1xuICAgIHRoaXMuX2xpbmVHYXAgPSBfbGluZUdhcDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbW92ZURvd24obGluZXMpIHtcbiAgICBpZiAobGluZXMgPT0gbnVsbCkge1xuICAgICAgbGluZXMgPSAxO1xuICAgIH1cbiAgICB0aGlzLnkgKz0gdGhpcy5jdXJyZW50TGluZUhlaWdodCh0cnVlKSAqIGxpbmVzICsgdGhpcy5fbGluZUdhcDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbW92ZVVwKGxpbmVzKSB7XG4gICAgaWYgKGxpbmVzID09IG51bGwpIHtcbiAgICAgIGxpbmVzID0gMTtcbiAgICB9XG4gICAgdGhpcy55IC09IHRoaXMuY3VycmVudExpbmVIZWlnaHQodHJ1ZSkgKiBsaW5lcyArIHRoaXMuX2xpbmVHYXA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF90ZXh0KHRleHQsIHgsIHksIG9wdGlvbnMsIGxpbmVDYWxsYmFjaykge1xuICAgIG9wdGlvbnMgPSB0aGlzLl9pbml0T3B0aW9ucyh4LCB5LCBvcHRpb25zKTtcbiAgICB0ZXh0ID0gdGV4dCA9PSBudWxsID8gJycgOiBgJHt0ZXh0fWA7XG4gICAgaWYgKG9wdGlvbnMud29yZFNwYWNpbmcpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcc3syLH0vZywgJyAnKTtcbiAgICB9XG4gICAgY29uc3QgYWRkU3RydWN0dXJlID0gKCkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMuc3RydWN0UGFyZW50KSB7XG4gICAgICAgIG9wdGlvbnMuc3RydWN0UGFyZW50LmFkZCh0aGlzLnN0cnVjdChvcHRpb25zLnN0cnVjdFR5cGUgfHwgJ1AnLCBbdGhpcy5tYXJrU3RydWN0dXJlQ29udGVudChvcHRpb25zLnN0cnVjdFR5cGUgfHwgJ1AnKV0pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChvcHRpb25zLnJvdGF0aW9uICE9PSAwKSB7XG4gICAgICB0aGlzLnNhdmUoKTtcbiAgICAgIHRoaXMucm90YXRlKC1vcHRpb25zLnJvdGF0aW9uLCB7XG4gICAgICAgIG9yaWdpbjogW3RoaXMueCwgdGhpcy55XVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndpZHRoKSB7XG4gICAgICBsZXQgd3JhcHBlciA9IHRoaXMuX3dyYXBwZXI7XG4gICAgICBpZiAoIXdyYXBwZXIpIHtcbiAgICAgICAgd3JhcHBlciA9IG5ldyBMaW5lV3JhcHBlcih0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgd3JhcHBlci5vbignbGluZScsIGxpbmVDYWxsYmFjayk7XG4gICAgICAgIHdyYXBwZXIub24oJ2ZpcnN0TGluZScsIGFkZFN0cnVjdHVyZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl93cmFwcGVyID0gb3B0aW9ucy5jb250aW51ZWQgPyB3cmFwcGVyIDogbnVsbDtcbiAgICAgIHRoaXMuX3RleHRPcHRpb25zID0gb3B0aW9ucy5jb250aW51ZWQgPyBvcHRpb25zIDogbnVsbDtcbiAgICAgIHdyYXBwZXIud3JhcCh0ZXh0LCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgbGluZSBvZiB0ZXh0LnNwbGl0KCdcXG4nKSkge1xuICAgICAgICBhZGRTdHJ1Y3R1cmUoKTtcbiAgICAgICAgbGluZUNhbGxiYWNrKGxpbmUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yb3RhdGlvbiAhPT0gMCkgdGhpcy5yZXN0b3JlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHRleHQodGV4dCwgeCwgeSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl90ZXh0KHRleHQsIHgsIHksIG9wdGlvbnMsIHRoaXMuX2xpbmUpO1xuICB9LFxuICB3aWR0aE9mU3RyaW5nKHN0cmluZykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjb25zdCBob3Jpem9udGFsU2NhbGluZyA9IG9wdGlvbnMuaG9yaXpvbnRhbFNjYWxpbmcgfHwgMTAwO1xuICAgIHJldHVybiAodGhpcy5fZm9udC53aWR0aE9mU3RyaW5nKHN0cmluZywgdGhpcy5fZm9udFNpemUsIG9wdGlvbnMuZmVhdHVyZXMpICsgKG9wdGlvbnMuY2hhcmFjdGVyU3BhY2luZyB8fCAwKSAqIChzdHJpbmcubGVuZ3RoIC0gMSkpICogaG9yaXpvbnRhbFNjYWxpbmcgLyAxMDA7XG4gIH0sXG4gIGJvdW5kc09mU3RyaW5nKHN0cmluZywgeCwgeSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB0aGlzLl9pbml0T3B0aW9ucyh4LCB5LCBvcHRpb25zKTtcbiAgICAoe1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcyk7XG4gICAgY29uc3QgbGluZUdhcCA9IG9wdGlvbnMubGluZUdhcCA/PyB0aGlzLl9saW5lR2FwID8/IDA7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IHRoaXMuY3VycmVudExpbmVIZWlnaHQodHJ1ZSkgKyBsaW5lR2FwO1xuICAgIGxldCBjb250ZW50V2lkdGggPSAwO1xuICAgIHN0cmluZyA9IFN0cmluZyhzdHJpbmcgPz8gJycpO1xuICAgIGlmIChvcHRpb25zLndvcmRTcGFjaW5nKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXFxzezIsfS9nLCAnICcpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy53aWR0aCkge1xuICAgICAgbGV0IHdyYXBwZXIgPSBuZXcgTGluZVdyYXBwZXIodGhpcywgb3B0aW9ucyk7XG4gICAgICB3cmFwcGVyLm9uKCdsaW5lJywgKHRleHQsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgdGhpcy55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbi9nLCAnJyk7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgIGxldCB3b3JkU3BhY2luZyA9IG9wdGlvbnMud29yZFNwYWNpbmcgPz8gMDtcbiAgICAgICAgICBjb25zdCBjaGFyYWN0ZXJTcGFjaW5nID0gb3B0aW9ucy5jaGFyYWN0ZXJTcGFjaW5nID8/IDA7XG4gICAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggJiYgb3B0aW9ucy5hbGlnbiA9PT0gJ2p1c3RpZnknKSB7XG4gICAgICAgICAgICBjb25zdCB3b3JkcyA9IHRleHQudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0V2lkdGggPSB0aGlzLndpZHRoT2ZTdHJpbmcodGV4dC5yZXBsYWNlKC9cXHMrL2csICcnKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBzcGFjZVdpZHRoID0gdGhpcy53aWR0aE9mU3RyaW5nKCcgJykgKyBjaGFyYWN0ZXJTcGFjaW5nO1xuICAgICAgICAgICAgd29yZFNwYWNpbmcgPSBNYXRoLm1heCgwLCAob3B0aW9ucy5saW5lV2lkdGggLSB0ZXh0V2lkdGgpIC8gTWF0aC5tYXgoMSwgd29yZHMubGVuZ3RoIC0gMSkgLSBzcGFjZVdpZHRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGVudFdpZHRoID0gTWF0aC5tYXgoY29udGVudFdpZHRoLCBvcHRpb25zLnRleHRXaWR0aCArIHdvcmRTcGFjaW5nICogKG9wdGlvbnMud29yZENvdW50IC0gMSkgKyBjaGFyYWN0ZXJTcGFjaW5nICogKHRleHQubGVuZ3RoIC0gMSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdyYXBwZXIud3JhcChzdHJpbmcsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBsaW5lIG9mIHN0cmluZy5zcGxpdCgnXFxuJykpIHtcbiAgICAgICAgY29uc3QgbGluZVdpZHRoID0gdGhpcy53aWR0aE9mU3RyaW5nKGxpbmUsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgY29udGVudFdpZHRoID0gTWF0aC5tYXgoY29udGVudFdpZHRoLCBsaW5lV2lkdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgY29udGVudEhlaWdodCA9IHRoaXMueSAtIHk7XG4gICAgaWYgKG9wdGlvbnMuaGVpZ2h0KSBjb250ZW50SGVpZ2h0ID0gTWF0aC5taW4oY29udGVudEhlaWdodCwgb3B0aW9ucy5oZWlnaHQpO1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICBpZiAob3B0aW9ucy5yb3RhdGlvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgd2lkdGg6IGNvbnRlbnRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjb250ZW50SGVpZ2h0XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yb3RhdGlvbiA9PT0gOTApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHkgLSBjb250ZW50V2lkdGgsXG4gICAgICAgIHdpZHRoOiBjb250ZW50SGVpZ2h0LFxuICAgICAgICBoZWlnaHQ6IGNvbnRlbnRXaWR0aFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMucm90YXRpb24gPT09IDE4MCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAtIGNvbnRlbnRXaWR0aCxcbiAgICAgICAgeTogeSAtIGNvbnRlbnRIZWlnaHQsXG4gICAgICAgIHdpZHRoOiBjb250ZW50V2lkdGgsXG4gICAgICAgIGhlaWdodDogY29udGVudEhlaWdodFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMucm90YXRpb24gPT09IDI3MCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAtIGNvbnRlbnRIZWlnaHQsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHdpZHRoOiBjb250ZW50SGVpZ2h0LFxuICAgICAgICBoZWlnaHQ6IGNvbnRlbnRXaWR0aFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY29zID0gY29zaW5lKG9wdGlvbnMucm90YXRpb24pO1xuICAgIGNvbnN0IHNpbiA9IHNpbmUob3B0aW9ucy5yb3RhdGlvbik7XG4gICAgY29uc3QgeDEgPSB4O1xuICAgIGNvbnN0IHkxID0geTtcbiAgICBjb25zdCB4MiA9IHggKyBjb250ZW50V2lkdGggKiBjb3M7XG4gICAgY29uc3QgeTIgPSB5IC0gY29udGVudFdpZHRoICogc2luO1xuICAgIGNvbnN0IHgzID0geCArIGNvbnRlbnRXaWR0aCAqIGNvcyArIGNvbnRlbnRIZWlnaHQgKiBzaW47XG4gICAgY29uc3QgeTMgPSB5IC0gY29udGVudFdpZHRoICogc2luICsgY29udGVudEhlaWdodCAqIGNvcztcbiAgICBjb25zdCB4NCA9IHggKyBjb250ZW50SGVpZ2h0ICogc2luO1xuICAgIGNvbnN0IHk0ID0geSArIGNvbnRlbnRIZWlnaHQgKiBjb3M7XG4gICAgY29uc3QgeE1pbiA9IE1hdGgubWluKHgxLCB4MiwgeDMsIHg0KTtcbiAgICBjb25zdCB4TWF4ID0gTWF0aC5tYXgoeDEsIHgyLCB4MywgeDQpO1xuICAgIGNvbnN0IHlNaW4gPSBNYXRoLm1pbih5MSwgeTIsIHkzLCB5NCk7XG4gICAgY29uc3QgeU1heCA9IE1hdGgubWF4KHkxLCB5MiwgeTMsIHk0KTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeE1pbixcbiAgICAgIHk6IHlNaW4sXG4gICAgICB3aWR0aDogeE1heCAtIHhNaW4sXG4gICAgICBoZWlnaHQ6IHlNYXggLSB5TWluXG4gICAgfTtcbiAgfSxcbiAgaGVpZ2h0T2ZTdHJpbmcodGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IHRoaXMuX2luaXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuaGVpZ2h0ID0gSW5maW5pdHk7XG4gICAgY29uc3QgbGluZUdhcCA9IG9wdGlvbnMubGluZUdhcCB8fCB0aGlzLl9saW5lR2FwIHx8IDA7XG4gICAgdGhpcy5fdGV4dCh0ZXh0LCB0aGlzLngsIHRoaXMueSwgb3B0aW9ucywgKCkgPT4ge1xuICAgICAgdGhpcy55ICs9IHRoaXMuY3VycmVudExpbmVIZWlnaHQodHJ1ZSkgKyBsaW5lR2FwO1xuICAgIH0pO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMueSAtIHk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHJldHVybiBoZWlnaHQ7XG4gIH0sXG4gIGxpc3QobGlzdCwgeCwgeSwgb3B0aW9ucywgd3JhcHBlcikge1xuICAgIG9wdGlvbnMgPSB0aGlzLl9pbml0T3B0aW9ucyh4LCB5LCBvcHRpb25zKTtcbiAgICBjb25zdCBsaXN0VHlwZSA9IG9wdGlvbnMubGlzdFR5cGUgfHwgJ2J1bGxldCc7XG4gICAgY29uc3QgdW5pdCA9IE1hdGgucm91bmQodGhpcy5fZm9udC5hc2NlbmRlciAvIDEwMDAgKiB0aGlzLl9mb250U2l6ZSk7XG4gICAgY29uc3QgbWlkTGluZSA9IHVuaXQgLyAyO1xuICAgIGNvbnN0IHIgPSBvcHRpb25zLmJ1bGxldFJhZGl1cyB8fCB1bml0IC8gMztcbiAgICBjb25zdCBpbmRlbnQgPSBvcHRpb25zLnRleHRJbmRlbnQgfHwgKGxpc3RUeXBlID09PSAnYnVsbGV0JyA/IHIgKiA1IDogdW5pdCAqIDIpO1xuICAgIGNvbnN0IGl0ZW1JbmRlbnQgPSBvcHRpb25zLmJ1bGxldEluZGVudCB8fCAobGlzdFR5cGUgPT09ICdidWxsZXQnID8gciAqIDggOiB1bml0ICogMik7XG4gICAgbGV0IGxldmVsID0gMTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IGxldmVscyA9IFtdO1xuICAgIGNvbnN0IG51bWJlcnMgPSBbXTtcbiAgICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICBsZXQgbiA9IDE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGxpc3RbaV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICBmbGF0dGVuKGl0ZW0pO1xuICAgICAgICAgIGxldmVsLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG4gICAgICAgICAgaWYgKGxpc3RUeXBlICE9PSAnYnVsbGV0Jykge1xuICAgICAgICAgICAgbnVtYmVycy5wdXNoKG4rKyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmbGF0dGVuKGxpc3QpO1xuICAgIGNvbnN0IGxhYmVsID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgIHN3aXRjaCAobGlzdFR5cGUpIHtcbiAgICAgICAgY2FzZSAnbnVtYmVyZWQnOlxuICAgICAgICAgIHJldHVybiBgJHtufS5gO1xuICAgICAgICBjYXNlICdsZXR0ZXJlZCc6XG4gICAgICAgICAgdmFyIGxldHRlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKG4gLSAxKSAlIDI2ICsgNjUpO1xuICAgICAgICAgIHZhciB0aW1lcyA9IE1hdGguZmxvb3IoKG4gLSAxKSAvIDI2ICsgMSk7XG4gICAgICAgICAgdmFyIHRleHQgPSBBcnJheSh0aW1lcyArIDEpLmpvaW4obGV0dGVyKTtcbiAgICAgICAgICByZXR1cm4gYCR7dGV4dH0uYDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGRyYXdMaXN0SXRlbSA9IGZ1bmN0aW9uIChsaXN0SXRlbSwgaSkge1xuICAgICAgd3JhcHBlciA9IG5ldyBMaW5lV3JhcHBlcih0aGlzLCBvcHRpb25zKTtcbiAgICAgIHdyYXBwZXIub24oJ2xpbmUnLCB0aGlzLl9saW5lKTtcbiAgICAgIGxldmVsID0gMTtcbiAgICAgIHdyYXBwZXIub25jZSgnZmlyc3RMaW5lJywgKCkgPT4ge1xuICAgICAgICBsZXQgaXRlbSwgaXRlbVR5cGUsIGxhYmVsVHlwZSwgYm9keVR5cGU7XG4gICAgICAgIGlmIChvcHRpb25zLnN0cnVjdFBhcmVudCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLnN0cnVjdFR5cGVzKSB7XG4gICAgICAgICAgICBbaXRlbVR5cGUsIGxhYmVsVHlwZSwgYm9keVR5cGVdID0gb3B0aW9ucy5zdHJ1Y3RUeXBlcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgW2l0ZW1UeXBlLCBsYWJlbFR5cGUsIGJvZHlUeXBlXSA9IFsnTEknLCAnTGJsJywgJ0xCb2R5J107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtVHlwZSkge1xuICAgICAgICAgIGl0ZW0gPSB0aGlzLnN0cnVjdChpdGVtVHlwZSk7XG4gICAgICAgICAgb3B0aW9ucy5zdHJ1Y3RQYXJlbnQuYWRkKGl0ZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc3RydWN0UGFyZW50KSB7XG4gICAgICAgICAgaXRlbSA9IG9wdGlvbnMuc3RydWN0UGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGxldCBsO1xuICAgICAgICBpZiAoKGwgPSBsZXZlbHNbaSsrXSkgIT09IGxldmVsKSB7XG4gICAgICAgICAgY29uc3QgZGlmZiA9IGl0ZW1JbmRlbnQgKiAobCAtIGxldmVsKTtcbiAgICAgICAgICB0aGlzLnggKz0gZGlmZjtcbiAgICAgICAgICB3cmFwcGVyLmxpbmVXaWR0aCAtPSBkaWZmO1xuICAgICAgICAgIGxldmVsID0gbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSAmJiAobGFiZWxUeXBlIHx8IGJvZHlUeXBlKSkge1xuICAgICAgICAgIGl0ZW0uYWRkKHRoaXMuc3RydWN0KGxhYmVsVHlwZSB8fCBib2R5VHlwZSwgW3RoaXMubWFya1N0cnVjdHVyZUNvbnRlbnQobGFiZWxUeXBlIHx8IGJvZHlUeXBlKV0pKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGxpc3RUeXBlKSB7XG4gICAgICAgICAgY2FzZSAnYnVsbGV0JzpcbiAgICAgICAgICAgIHRoaXMuY2lyY2xlKHRoaXMueCAtIGluZGVudCArIHIsIHRoaXMueSArIG1pZExpbmUsIHIpO1xuICAgICAgICAgICAgdGhpcy5maWxsKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdudW1iZXJlZCc6XG4gICAgICAgICAgY2FzZSAnbGV0dGVyZWQnOlxuICAgICAgICAgICAgdmFyIHRleHQgPSBsYWJlbChudW1iZXJzW2kgLSAxXSk7XG4gICAgICAgICAgICB0aGlzLl9mcmFnbWVudCh0ZXh0LCB0aGlzLnggLSBpbmRlbnQsIHRoaXMueSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbSAmJiBsYWJlbFR5cGUgJiYgYm9keVR5cGUpIHtcbiAgICAgICAgICBpdGVtLmFkZCh0aGlzLnN0cnVjdChib2R5VHlwZSwgW3RoaXMubWFya1N0cnVjdHVyZUNvbnRlbnQoYm9keVR5cGUpXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0gIT09IG9wdGlvbnMuc3RydWN0UGFyZW50KSB7XG4gICAgICAgICAgaXRlbS5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3cmFwcGVyLm9uKCdzZWN0aW9uU3RhcnQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGluZGVudCArIGl0ZW1JbmRlbnQgKiAobGV2ZWwgLSAxKTtcbiAgICAgICAgdGhpcy54ICs9IHBvcztcbiAgICAgICAgd3JhcHBlci5saW5lV2lkdGggLT0gcG9zO1xuICAgICAgfSk7XG4gICAgICB3cmFwcGVyLm9uKCdzZWN0aW9uRW5kJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSBpbmRlbnQgKyBpdGVtSW5kZW50ICogKGxldmVsIC0gMSk7XG4gICAgICAgIHRoaXMueCAtPSBwb3M7XG4gICAgICAgIHdyYXBwZXIubGluZVdpZHRoICs9IHBvcztcbiAgICAgIH0pO1xuICAgICAgd3JhcHBlci53cmFwKGxpc3RJdGVtLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRyYXdMaXN0SXRlbS5jYWxsKHRoaXMsIGl0ZW1zW2ldLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF9pbml0T3B0aW9ucygpIHtcbiAgICBsZXQgeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgbGV0IHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IHg7XG4gICAgICB4ID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgaWYgKHRoaXMuX3RleHRPcHRpb25zKSB7XG4gICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5fdGV4dE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy5fdGV4dE9wdGlvbnNba2V5XTtcbiAgICAgICAgaWYgKGtleSAhPT0gJ2NvbnRpbnVlZCcpIHtcbiAgICAgICAgICBpZiAocmVzdWx0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh4ICE9IG51bGwpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgfVxuICAgIGlmICh5ICE9IG51bGwpIHtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQubGluZUJyZWFrICE9PSBmYWxzZSkge1xuICAgICAgaWYgKHJlc3VsdC53aWR0aCA9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC53aWR0aCA9IHRoaXMucGFnZS53aWR0aCAtIHRoaXMueCAtIHRoaXMucGFnZS5tYXJnaW5zLnJpZ2h0O1xuICAgICAgfVxuICAgICAgcmVzdWx0LndpZHRoID0gTWF0aC5tYXgocmVzdWx0LndpZHRoLCAwKTtcbiAgICB9XG4gICAgaWYgKCFyZXN1bHQuY29sdW1ucykge1xuICAgICAgcmVzdWx0LmNvbHVtbnMgPSAwO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LmNvbHVtbkdhcCA9PSBudWxsKSB7XG4gICAgICByZXN1bHQuY29sdW1uR2FwID0gMTg7XG4gICAgfVxuICAgIHJlc3VsdC5yb3RhdGlvbiA9IE51bWJlcihvcHRpb25zLnJvdGF0aW9uID8/IDApICUgMzYwO1xuICAgIGlmIChyZXN1bHQucm90YXRpb24gPCAwKSByZXN1bHQucm90YXRpb24gKz0gMzYwO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIF9saW5lKHRleHQpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgbGV0IHdyYXBwZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mcmFnbWVudCh0ZXh0LCB0aGlzLngsIHRoaXMueSwgb3B0aW9ucyk7XG4gICAgY29uc3QgbGluZUdhcCA9IG9wdGlvbnMubGluZUdhcCB8fCB0aGlzLl9saW5lR2FwIHx8IDA7XG4gICAgaWYgKCF3cmFwcGVyKSB7XG4gICAgICB0aGlzLnggKz0gdGhpcy53aWR0aE9mU3RyaW5nKHRleHQsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnkgKz0gdGhpcy5jdXJyZW50TGluZUhlaWdodCh0cnVlKSArIGxpbmVHYXA7XG4gICAgfVxuICB9LFxuICBfZnJhZ21lbnQodGV4dCwgeCwgeSwgb3B0aW9ucykge1xuICAgIGxldCBkeSwgZW5jb2RlZCwgaSwgcG9zaXRpb25zLCB0ZXh0V2lkdGgsIHdvcmRzO1xuICAgIHRleHQgPSBgJHt0ZXh0fWAucmVwbGFjZSgvXFxuL2csICcnKTtcbiAgICBpZiAodGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWxpZ24gPSBvcHRpb25zLmFsaWduIHx8ICdsZWZ0JztcbiAgICBsZXQgd29yZFNwYWNpbmcgPSBvcHRpb25zLndvcmRTcGFjaW5nIHx8IDA7XG4gICAgY29uc3QgY2hhcmFjdGVyU3BhY2luZyA9IG9wdGlvbnMuY2hhcmFjdGVyU3BhY2luZyB8fCAwO1xuICAgIGNvbnN0IGhvcml6b250YWxTY2FsaW5nID0gb3B0aW9ucy5ob3Jpem9udGFsU2NhbGluZyB8fCAxMDA7XG4gICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIHRleHRXaWR0aCA9IHRoaXMud2lkdGhPZlN0cmluZyh0ZXh0LnJlcGxhY2UoL1xccyskLywgJycpLCBvcHRpb25zKTtcbiAgICAgICAgICB4ICs9IG9wdGlvbnMubGluZVdpZHRoIC0gdGV4dFdpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIHggKz0gb3B0aW9ucy5saW5lV2lkdGggLyAyIC0gb3B0aW9ucy50ZXh0V2lkdGggLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdqdXN0aWZ5JzpcbiAgICAgICAgICB3b3JkcyA9IHRleHQudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgdGV4dFdpZHRoID0gdGhpcy53aWR0aE9mU3RyaW5nKHRleHQucmVwbGFjZSgvXFxzKy9nLCAnJyksIG9wdGlvbnMpO1xuICAgICAgICAgIHZhciBzcGFjZVdpZHRoID0gdGhpcy53aWR0aE9mU3RyaW5nKCcgJykgKyBjaGFyYWN0ZXJTcGFjaW5nO1xuICAgICAgICAgIHdvcmRTcGFjaW5nID0gTWF0aC5tYXgoMCwgKG9wdGlvbnMubGluZVdpZHRoIC0gdGV4dFdpZHRoKSAvIE1hdGgubWF4KDEsIHdvcmRzLmxlbmd0aCAtIDEpIC0gc3BhY2VXaWR0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5iYXNlbGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGR5ID0gLW9wdGlvbnMuYmFzZWxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5iYXNlbGluZSkge1xuICAgICAgICBjYXNlICdzdmctbWlkZGxlJzpcbiAgICAgICAgICBkeSA9IDAuNSAqIHRoaXMuX2ZvbnQueEhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgY2FzZSAnc3ZnLWNlbnRyYWwnOlxuICAgICAgICAgIGR5ID0gMC41ICogKHRoaXMuX2ZvbnQuZGVzY2VuZGVyICsgdGhpcy5fZm9udC5hc2NlbmRlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIGNhc2UgJ2lkZW9ncmFwaGljJzpcbiAgICAgICAgICBkeSA9IHRoaXMuX2ZvbnQuZGVzY2VuZGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhbHBoYWJldGljJzpcbiAgICAgICAgICBkeSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21hdGhlbWF0aWNhbCc6XG4gICAgICAgICAgZHkgPSAwLjUgKiB0aGlzLl9mb250LmFzY2VuZGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdoYW5naW5nJzpcbiAgICAgICAgICBkeSA9IDAuOCAqIHRoaXMuX2ZvbnQuYXNjZW5kZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgZHkgPSB0aGlzLl9mb250LmFzY2VuZGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGR5ID0gdGhpcy5fZm9udC5hc2NlbmRlcjtcbiAgICAgIH1cbiAgICAgIGR5ID0gZHkgLyAxMDAwICogdGhpcy5fZm9udFNpemU7XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlcmVkV2lkdGggPSBvcHRpb25zLnRleHRXaWR0aCArIHdvcmRTcGFjaW5nICogKG9wdGlvbnMud29yZENvdW50IC0gMSkgKyBjaGFyYWN0ZXJTcGFjaW5nICogKHRleHQubGVuZ3RoIC0gMSk7XG4gICAgaWYgKG9wdGlvbnMubGluayAhPSBudWxsKSB7XG4gICAgICB0aGlzLmxpbmsoeCwgeSwgcmVuZGVyZWRXaWR0aCwgdGhpcy5jdXJyZW50TGluZUhlaWdodCgpLCBvcHRpb25zLmxpbmspO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5nb1RvICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZ29Ubyh4LCB5LCByZW5kZXJlZFdpZHRoLCB0aGlzLmN1cnJlbnRMaW5lSGVpZ2h0KCksIG9wdGlvbnMuZ29Ubyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRlc3RpbmF0aW9uICE9IG51bGwpIHtcbiAgICAgIHRoaXMuYWRkTmFtZWREZXN0aW5hdGlvbihvcHRpb25zLmRlc3RpbmF0aW9uLCAnWFlaJywgeCwgeSwgbnVsbCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnVuZGVybGluZSkge1xuICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICBpZiAoIW9wdGlvbnMuc3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuc3Ryb2tlQ29sb3IoLi4uKHRoaXMuX2ZpbGxDb2xvciB8fCBbXSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGluZVdpZHRoID0gdGhpcy5fZm9udFNpemUgPCAxMCA/IDAuNSA6IE1hdGguZmxvb3IodGhpcy5fZm9udFNpemUgLyAxMCk7XG4gICAgICB0aGlzLmxpbmVXaWR0aChsaW5lV2lkdGgpO1xuICAgICAgbGV0IGxpbmVZID0geSArIHRoaXMuY3VycmVudExpbmVIZWlnaHQoKSAtIGxpbmVXaWR0aDtcbiAgICAgIHRoaXMubW92ZVRvKHgsIGxpbmVZKTtcbiAgICAgIHRoaXMubGluZVRvKHggKyByZW5kZXJlZFdpZHRoLCBsaW5lWSk7XG4gICAgICB0aGlzLnN0cm9rZSgpO1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0cmlrZSkge1xuICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICBpZiAoIW9wdGlvbnMuc3Ryb2tlKSB7XG4gICAgICAgIHRoaXMuc3Ryb2tlQ29sb3IoLi4uKHRoaXMuX2ZpbGxDb2xvciB8fCBbXSkpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGluZVdpZHRoID0gdGhpcy5fZm9udFNpemUgPCAxMCA/IDAuNSA6IE1hdGguZmxvb3IodGhpcy5fZm9udFNpemUgLyAxMCk7XG4gICAgICB0aGlzLmxpbmVXaWR0aChsaW5lV2lkdGgpO1xuICAgICAgbGV0IGxpbmVZID0geSArIHRoaXMuY3VycmVudExpbmVIZWlnaHQoKSAvIDI7XG4gICAgICB0aGlzLm1vdmVUbyh4LCBsaW5lWSk7XG4gICAgICB0aGlzLmxpbmVUbyh4ICsgcmVuZGVyZWRXaWR0aCwgbGluZVkpO1xuICAgICAgdGhpcy5zdHJva2UoKTtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLnNhdmUoKTtcbiAgICBpZiAob3B0aW9ucy5vYmxpcXVlKSB7XG4gICAgICBsZXQgc2tldztcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5vYmxpcXVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBza2V3ID0gLU1hdGgudGFuKG9wdGlvbnMub2JsaXF1ZSAqIE1hdGguUEkgLyAxODApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2tldyA9IC0wLjI1O1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2Zvcm0oMSwgMCwgMCwgMSwgeCwgeSk7XG4gICAgICB0aGlzLnRyYW5zZm9ybSgxLCAwLCBza2V3LCAxLCAtc2tldyAqIGR5LCAwKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtKDEsIDAsIDAsIDEsIC14LCAteSk7XG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3JtKDEsIDAsIDAsIC0xLCAwLCB0aGlzLnBhZ2UuaGVpZ2h0KTtcbiAgICB5ID0gdGhpcy5wYWdlLmhlaWdodCAtIHkgLSBkeTtcbiAgICBpZiAodGhpcy5wYWdlLmZvbnRzW3RoaXMuX2ZvbnQuaWRdID09IG51bGwpIHtcbiAgICAgIHRoaXMucGFnZS5mb250c1t0aGlzLl9mb250LmlkXSA9IHRoaXMuX2ZvbnQucmVmKCk7XG4gICAgfVxuICAgIHRoaXMuYWRkQ29udGVudCgnQlQnKTtcbiAgICB0aGlzLmFkZENvbnRlbnQoYDEgMCAwIDEgJHtudW1iZXIoeCl9ICR7bnVtYmVyKHkpfSBUbWApO1xuICAgIHRoaXMuYWRkQ29udGVudChgLyR7dGhpcy5fZm9udC5pZH0gJHtudW1iZXIodGhpcy5fZm9udFNpemUpfSBUZmApO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLmZpbGwgJiYgb3B0aW9ucy5zdHJva2UgPyAyIDogb3B0aW9ucy5zdHJva2UgPyAxIDogMDtcbiAgICBpZiAobW9kZSkge1xuICAgICAgdGhpcy5hZGRDb250ZW50KGAke21vZGV9IFRyYCk7XG4gICAgfVxuICAgIGlmIChjaGFyYWN0ZXJTcGFjaW5nKSB7XG4gICAgICB0aGlzLmFkZENvbnRlbnQoYCR7bnVtYmVyKGNoYXJhY3RlclNwYWNpbmcpfSBUY2ApO1xuICAgIH1cbiAgICBpZiAoaG9yaXpvbnRhbFNjYWxpbmcgIT09IDEwMCkge1xuICAgICAgdGhpcy5hZGRDb250ZW50KGAke2hvcml6b250YWxTY2FsaW5nfSBUemApO1xuICAgIH1cbiAgICBpZiAod29yZFNwYWNpbmcpIHtcbiAgICAgIHdvcmRzID0gdGV4dC50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgICAgIHdvcmRTcGFjaW5nICs9IHRoaXMud2lkdGhPZlN0cmluZygnICcpICsgY2hhcmFjdGVyU3BhY2luZztcbiAgICAgIHdvcmRTcGFjaW5nICo9IDEwMDAgLyB0aGlzLl9mb250U2l6ZTtcbiAgICAgIGVuY29kZWQgPSBbXTtcbiAgICAgIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgZm9yIChsZXQgd29yZCBvZiB3b3Jkcykge1xuICAgICAgICBjb25zdCBbZW5jb2RlZFdvcmQsIHBvc2l0aW9uc1dvcmRdID0gdGhpcy5fZm9udC5lbmNvZGUod29yZCwgb3B0aW9ucy5mZWF0dXJlcyk7XG4gICAgICAgIGVuY29kZWQgPSBlbmNvZGVkLmNvbmNhdChlbmNvZGVkV29yZCk7XG4gICAgICAgIHBvc2l0aW9ucyA9IHBvc2l0aW9ucy5jb25jYXQocG9zaXRpb25zV29yZCk7XG4gICAgICAgIGNvbnN0IHNwYWNlID0ge307XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IHBvc2l0aW9uc1twb3NpdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBjb25zdCB2YWwgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICBzcGFjZVtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHNwYWNlLnhBZHZhbmNlICs9IHdvcmRTcGFjaW5nO1xuICAgICAgICBwb3NpdGlvbnNbcG9zaXRpb25zLmxlbmd0aCAtIDFdID0gc3BhY2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIFtlbmNvZGVkLCBwb3NpdGlvbnNdID0gdGhpcy5fZm9udC5lbmNvZGUodGV4dCwgb3B0aW9ucy5mZWF0dXJlcyk7XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fZm9udFNpemUgLyAxMDAwO1xuICAgIGNvbnN0IGNvbW1hbmRzID0gW107XG4gICAgbGV0IGxhc3QgPSAwO1xuICAgIGxldCBoYWRPZmZzZXQgPSBmYWxzZTtcbiAgICBjb25zdCBhZGRTZWdtZW50ID0gY3VyID0+IHtcbiAgICAgIGlmIChsYXN0IDwgY3VyKSB7XG4gICAgICAgIGNvbnN0IGhleCA9IGVuY29kZWQuc2xpY2UobGFzdCwgY3VyKS5qb2luKCcnKTtcbiAgICAgICAgY29uc3QgYWR2YW5jZSA9IHBvc2l0aW9uc1tjdXIgLSAxXS54QWR2YW5jZSAtIHBvc2l0aW9uc1tjdXIgLSAxXS5hZHZhbmNlV2lkdGg7XG4gICAgICAgIGNvbW1hbmRzLnB1c2goYDwke2hleH0+ICR7bnVtYmVyKC1hZHZhbmNlKX1gKTtcbiAgICAgIH1cbiAgICAgIGxhc3QgPSBjdXI7XG4gICAgfTtcbiAgICBjb25zdCBmbHVzaCA9IGkgPT4ge1xuICAgICAgYWRkU2VnbWVudChpKTtcbiAgICAgIGlmIChjb21tYW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuYWRkQ29udGVudChgWyR7Y29tbWFuZHMuam9pbignICcpfV0gVEpgKTtcbiAgICAgICAgY29tbWFuZHMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvcyA9IHBvc2l0aW9uc1tpXTtcbiAgICAgIGlmIChwb3MueE9mZnNldCB8fCBwb3MueU9mZnNldCkge1xuICAgICAgICBmbHVzaChpKTtcbiAgICAgICAgdGhpcy5hZGRDb250ZW50KGAxIDAgMCAxICR7bnVtYmVyKHggKyBwb3MueE9mZnNldCAqIHNjYWxlKX0gJHtudW1iZXIoeSArIHBvcy55T2Zmc2V0ICogc2NhbGUpfSBUbWApO1xuICAgICAgICBmbHVzaChpICsgMSk7XG4gICAgICAgIGhhZE9mZnNldCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaGFkT2Zmc2V0KSB7XG4gICAgICAgICAgdGhpcy5hZGRDb250ZW50KGAxIDAgMCAxICR7bnVtYmVyKHgpfSAke251bWJlcih5KX0gVG1gKTtcbiAgICAgICAgICBoYWRPZmZzZXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zLnhBZHZhbmNlIC0gcG9zLmFkdmFuY2VXaWR0aCAhPT0gMCkge1xuICAgICAgICAgIGFkZFNlZ21lbnQoaSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB4ICs9IHBvcy54QWR2YW5jZSAqIHNjYWxlO1xuICAgIH1cbiAgICBmbHVzaChpKTtcbiAgICB0aGlzLmFkZENvbnRlbnQoJ0VUJyk7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cbn07XG5cbmNvbnN0IE1BUktFUlMgPSBbMHhmZmMwLCAweGZmYzEsIDB4ZmZjMiwgMHhmZmMzLCAweGZmYzUsIDB4ZmZjNiwgMHhmZmM3LCAweGZmYzgsIDB4ZmZjOSwgMHhmZmNhLCAweGZmY2IsIDB4ZmZjYywgMHhmZmNkLCAweGZmY2UsIDB4ZmZjZl07XG5jb25zdCBDT0xPUl9TUEFDRV9NQVAgPSB7XG4gIDE6ICdEZXZpY2VHcmF5JyxcbiAgMzogJ0RldmljZVJHQicsXG4gIDQ6ICdEZXZpY2VDTVlLJ1xufTtcbmNsYXNzIEpQRUcge1xuICBjb25zdHJ1Y3RvcihkYXRhLCBsYWJlbCkge1xuICAgIGxldCBtYXJrZXI7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgaWYgKHRoaXMuZGF0YS5yZWFkVUludDE2QkUoMCkgIT09IDB4ZmZkOCkge1xuICAgICAgdGhyb3cgJ1NPSSBub3QgZm91bmQgaW4gSlBFRyc7XG4gICAgfVxuICAgIHRoaXMub3JpZW50YXRpb24gPSBleGlmLmZyb21CdWZmZXIodGhpcy5kYXRhKS5PcmllbnRhdGlvbiB8fCAxO1xuICAgIGxldCBwb3MgPSAyO1xuICAgIHdoaWxlIChwb3MgPCB0aGlzLmRhdGEubGVuZ3RoKSB7XG4gICAgICBtYXJrZXIgPSB0aGlzLmRhdGEucmVhZFVJbnQxNkJFKHBvcyk7XG4gICAgICBwb3MgKz0gMjtcbiAgICAgIGlmIChNQVJLRVJTLmluY2x1ZGVzKG1hcmtlcikpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwb3MgKz0gdGhpcy5kYXRhLnJlYWRVSW50MTZCRShwb3MpO1xuICAgIH1cbiAgICBpZiAoIU1BUktFUlMuaW5jbHVkZXMobWFya2VyKSkge1xuICAgICAgdGhyb3cgJ0ludmFsaWQgSlBFRy4nO1xuICAgIH1cbiAgICBwb3MgKz0gMjtcbiAgICB0aGlzLmJpdHMgPSB0aGlzLmRhdGFbcG9zKytdO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5kYXRhLnJlYWRVSW50MTZCRShwb3MpO1xuICAgIHBvcyArPSAyO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmRhdGEucmVhZFVJbnQxNkJFKHBvcyk7XG4gICAgcG9zICs9IDI7XG4gICAgY29uc3QgY2hhbm5lbHMgPSB0aGlzLmRhdGFbcG9zKytdO1xuICAgIHRoaXMuY29sb3JTcGFjZSA9IENPTE9SX1NQQUNFX01BUFtjaGFubmVsc107XG4gICAgdGhpcy5vYmogPSBudWxsO1xuICB9XG4gIGVtYmVkKGRvY3VtZW50KSB7XG4gICAgaWYgKHRoaXMub2JqKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub2JqID0gZG9jdW1lbnQucmVmKHtcbiAgICAgIFR5cGU6ICdYT2JqZWN0JyxcbiAgICAgIFN1YnR5cGU6ICdJbWFnZScsXG4gICAgICBCaXRzUGVyQ29tcG9uZW50OiB0aGlzLmJpdHMsXG4gICAgICBXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgIEhlaWdodDogdGhpcy5oZWlnaHQsXG4gICAgICBDb2xvclNwYWNlOiB0aGlzLmNvbG9yU3BhY2UsXG4gICAgICBGaWx0ZXI6ICdEQ1REZWNvZGUnXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuY29sb3JTcGFjZSA9PT0gJ0RldmljZUNNWUsnKSB7XG4gICAgICB0aGlzLm9iai5kYXRhWydEZWNvZGUnXSA9IFsxLjAsIDAuMCwgMS4wLCAwLjAsIDEuMCwgMC4wLCAxLjAsIDAuMF07XG4gICAgfVxuICAgIHRoaXMub2JqLmVuZCh0aGlzLmRhdGEpO1xuICAgIHJldHVybiB0aGlzLmRhdGEgPSBudWxsO1xuICB9XG59XG5cbmNsYXNzIFBOR0ltYWdlIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgbGFiZWwpIHtcbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgdGhpcy5pbWFnZSA9IG5ldyBQTkcoZGF0YSk7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuaW1hZ2Uud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmltYWdlLmhlaWdodDtcbiAgICB0aGlzLmltZ0RhdGEgPSB0aGlzLmltYWdlLmltZ0RhdGE7XG4gICAgdGhpcy5vYmogPSBudWxsO1xuICB9XG4gIGVtYmVkKGRvY3VtZW50KSB7XG4gICAgbGV0IGRhdGFEZWNvZGVkID0gZmFsc2U7XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIGlmICh0aGlzLm9iaikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYXNBbHBoYUNoYW5uZWwgPSB0aGlzLmltYWdlLmhhc0FscGhhQ2hhbm5lbDtcbiAgICBjb25zdCBpc0ludGVybGFjZWQgPSB0aGlzLmltYWdlLmludGVybGFjZU1ldGhvZCA9PT0gMTtcbiAgICB0aGlzLm9iaiA9IHRoaXMuZG9jdW1lbnQucmVmKHtcbiAgICAgIFR5cGU6ICdYT2JqZWN0JyxcbiAgICAgIFN1YnR5cGU6ICdJbWFnZScsXG4gICAgICBCaXRzUGVyQ29tcG9uZW50OiBoYXNBbHBoYUNoYW5uZWwgPyA4IDogdGhpcy5pbWFnZS5iaXRzLFxuICAgICAgV2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBIZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgRmlsdGVyOiAnRmxhdGVEZWNvZGUnXG4gICAgfSk7XG4gICAgaWYgKCFoYXNBbHBoYUNoYW5uZWwpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZG9jdW1lbnQucmVmKHtcbiAgICAgICAgUHJlZGljdG9yOiBpc0ludGVybGFjZWQgPyAxIDogMTUsXG4gICAgICAgIENvbG9yczogdGhpcy5pbWFnZS5jb2xvcnMsXG4gICAgICAgIEJpdHNQZXJDb21wb25lbnQ6IHRoaXMuaW1hZ2UuYml0cyxcbiAgICAgICAgQ29sdW1uczogdGhpcy53aWR0aFxuICAgICAgfSk7XG4gICAgICB0aGlzLm9iai5kYXRhWydEZWNvZGVQYXJtcyddID0gcGFyYW1zO1xuICAgICAgcGFyYW1zLmVuZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbWFnZS5wYWxldHRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5vYmouZGF0YVsnQ29sb3JTcGFjZSddID0gdGhpcy5pbWFnZS5jb2xvclNwYWNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwYWxldHRlID0gdGhpcy5kb2N1bWVudC5yZWYoKTtcbiAgICAgIHBhbGV0dGUuZW5kKEJ1ZmZlci5mcm9tKHRoaXMuaW1hZ2UucGFsZXR0ZSkpO1xuICAgICAgdGhpcy5vYmouZGF0YVsnQ29sb3JTcGFjZSddID0gWydJbmRleGVkJywgJ0RldmljZVJHQicsIHRoaXMuaW1hZ2UucGFsZXR0ZS5sZW5ndGggLyAzIC0gMSwgcGFsZXR0ZV07XG4gICAgfVxuICAgIGlmICh0aGlzLmltYWdlLnRyYW5zcGFyZW5jeS5ncmF5c2NhbGUgIT0gbnVsbCkge1xuICAgICAgY29uc3QgdmFsID0gdGhpcy5pbWFnZS50cmFuc3BhcmVuY3kuZ3JheXNjYWxlO1xuICAgICAgdGhpcy5vYmouZGF0YVsnTWFzayddID0gW3ZhbCwgdmFsXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaW1hZ2UudHJhbnNwYXJlbmN5LnJnYikge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZ2JcbiAgICAgIH0gPSB0aGlzLmltYWdlLnRyYW5zcGFyZW5jeTtcbiAgICAgIGNvbnN0IG1hc2sgPSBbXTtcbiAgICAgIGZvciAobGV0IHggb2YgcmdiKSB7XG4gICAgICAgIG1hc2sucHVzaCh4LCB4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JqLmRhdGFbJ01hc2snXSA9IG1hc2s7XG4gICAgfSBlbHNlIGlmICh0aGlzLmltYWdlLnRyYW5zcGFyZW5jeS5pbmRleGVkKSB7XG4gICAgICBkYXRhRGVjb2RlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5sb2FkSW5kZXhlZEFscGhhQ2hhbm5lbCgpO1xuICAgIH0gZWxzZSBpZiAoaGFzQWxwaGFDaGFubmVsKSB7XG4gICAgICBkYXRhRGVjb2RlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5zcGxpdEFscGhhQ2hhbm5lbCgpO1xuICAgIH1cbiAgICBpZiAoaXNJbnRlcmxhY2VkICYmICFkYXRhRGVjb2RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlRGF0YSgpO1xuICAgIH1cbiAgICB0aGlzLmZpbmFsaXplKCk7XG4gIH1cbiAgZmluYWxpemUoKSB7XG4gICAgaWYgKHRoaXMuYWxwaGFDaGFubmVsKSB7XG4gICAgICBjb25zdCBzTWFzayA9IHRoaXMuZG9jdW1lbnQucmVmKHtcbiAgICAgICAgVHlwZTogJ1hPYmplY3QnLFxuICAgICAgICBTdWJ0eXBlOiAnSW1hZ2UnLFxuICAgICAgICBIZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICBXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgQml0c1BlckNvbXBvbmVudDogOCxcbiAgICAgICAgRmlsdGVyOiAnRmxhdGVEZWNvZGUnLFxuICAgICAgICBDb2xvclNwYWNlOiAnRGV2aWNlR3JheScsXG4gICAgICAgIERlY29kZTogWzAsIDFdXG4gICAgICB9KTtcbiAgICAgIHNNYXNrLmVuZCh0aGlzLmFscGhhQ2hhbm5lbCk7XG4gICAgICB0aGlzLm9iai5kYXRhWydTTWFzayddID0gc01hc2s7XG4gICAgfVxuICAgIHRoaXMub2JqLmVuZCh0aGlzLmltZ0RhdGEpO1xuICAgIHRoaXMuaW1hZ2UgPSBudWxsO1xuICAgIHJldHVybiB0aGlzLmltZ0RhdGEgPSBudWxsO1xuICB9XG4gIHNwbGl0QWxwaGFDaGFubmVsKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlLmRlY29kZVBpeGVscyhwaXhlbHMgPT4ge1xuICAgICAgbGV0IGEsIHA7XG4gICAgICBjb25zdCBjb2xvckNvdW50ID0gdGhpcy5pbWFnZS5jb2xvcnM7XG4gICAgICBjb25zdCBwaXhlbENvdW50ID0gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuICAgICAgY29uc3QgaW1nRGF0YSA9IEJ1ZmZlci5hbGxvYyhwaXhlbENvdW50ICogY29sb3JDb3VudCk7XG4gICAgICBjb25zdCBhbHBoYUNoYW5uZWwgPSBCdWZmZXIuYWxsb2MocGl4ZWxDb3VudCk7XG4gICAgICBsZXQgaSA9IHAgPSBhID0gMDtcbiAgICAgIGNvbnN0IGxlbiA9IHBpeGVscy5sZW5ndGg7XG4gICAgICBjb25zdCBza2lwQnl0ZUNvdW50ID0gdGhpcy5pbWFnZS5iaXRzID09PSAxNiA/IDEgOiAwO1xuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgZm9yIChsZXQgY29sb3JJbmRleCA9IDA7IGNvbG9ySW5kZXggPCBjb2xvckNvdW50OyBjb2xvckluZGV4KyspIHtcbiAgICAgICAgICBpbWdEYXRhW3ArK10gPSBwaXhlbHNbaSsrXTtcbiAgICAgICAgICBpICs9IHNraXBCeXRlQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgYWxwaGFDaGFubmVsW2ErK10gPSBwaXhlbHNbaSsrXTtcbiAgICAgICAgaSArPSBza2lwQnl0ZUNvdW50O1xuICAgICAgfVxuICAgICAgdGhpcy5pbWdEYXRhID0gemxpYi5kZWZsYXRlU3luYyhpbWdEYXRhKTtcbiAgICAgIHRoaXMuYWxwaGFDaGFubmVsID0gemxpYi5kZWZsYXRlU3luYyhhbHBoYUNoYW5uZWwpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUoKTtcbiAgICB9KTtcbiAgfVxuICBsb2FkSW5kZXhlZEFscGhhQ2hhbm5lbCgpIHtcbiAgICBjb25zdCB0cmFuc3BhcmVuY3kgPSB0aGlzLmltYWdlLnRyYW5zcGFyZW5jeS5pbmRleGVkO1xuICAgIHJldHVybiB0aGlzLmltYWdlLmRlY29kZVBpeGVscyhwaXhlbHMgPT4ge1xuICAgICAgY29uc3QgYWxwaGFDaGFubmVsID0gQnVmZmVyLmFsbG9jKHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCk7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGxldCBqID0gMCwgZW5kID0gcGl4ZWxzLmxlbmd0aDsgaiA8IGVuZDsgaisrKSB7XG4gICAgICAgIGFscGhhQ2hhbm5lbFtpKytdID0gdHJhbnNwYXJlbmN5W3BpeGVsc1tqXV07XG4gICAgICB9XG4gICAgICB0aGlzLmFscGhhQ2hhbm5lbCA9IHpsaWIuZGVmbGF0ZVN5bmMoYWxwaGFDaGFubmVsKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplKCk7XG4gICAgfSk7XG4gIH1cbiAgZGVjb2RlRGF0YSgpIHtcbiAgICB0aGlzLmltYWdlLmRlY29kZVBpeGVscyhwaXhlbHMgPT4ge1xuICAgICAgdGhpcy5pbWdEYXRhID0gemxpYi5kZWZsYXRlU3luYyhwaXhlbHMpO1xuICAgICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFBERkltYWdlIHtcbiAgc3RhdGljIG9wZW4oc3JjLCBsYWJlbCkge1xuICAgIGxldCBkYXRhO1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3JjKSkge1xuICAgICAgZGF0YSA9IHNyYztcbiAgICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBkYXRhID0gQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkoc3JjKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gL15kYXRhOi4rPztiYXNlNjQsKC4qKSQvLmV4ZWMoc3JjKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20obWF0Y2hbMV0sICdiYXNlNjQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMoc3JjKTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhWzBdID09PSAweGZmICYmIGRhdGFbMV0gPT09IDB4ZDgpIHtcbiAgICAgIHJldHVybiBuZXcgSlBFRyhkYXRhLCBsYWJlbCk7XG4gICAgfSBlbHNlIGlmIChkYXRhWzBdID09PSAweDg5ICYmIGRhdGEudG9TdHJpbmcoJ2FzY2lpJywgMSwgNCkgPT09ICdQTkcnKSB7XG4gICAgICByZXR1cm4gbmV3IFBOR0ltYWdlKGRhdGEsIGxhYmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGltYWdlIGZvcm1hdC4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIEltYWdlc01peGluID0ge1xuICBpbml0SW1hZ2VzKCkge1xuICAgIHRoaXMuX2ltYWdlUmVnaXN0cnkgPSB7fTtcbiAgICB0aGlzLl9pbWFnZUNvdW50ID0gMDtcbiAgfSxcbiAgaW1hZ2Uoc3JjLCB4LCB5KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgIGxldCBiaCwgYnAsIGJ3LCBpbWFnZSwgaXAsIGxlZnQsIGxlZnQxLCBvcmlnaW5YLCBvcmlnaW5ZO1xuICAgIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMgPSB4O1xuICAgICAgeCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGlnbm9yZU9yaWVudGF0aW9uID0gb3B0aW9ucy5pZ25vcmVPcmllbnRhdGlvbiB8fCBvcHRpb25zLmlnbm9yZU9yaWVudGF0aW9uICE9PSBmYWxzZSAmJiB0aGlzLm9wdGlvbnMuaWdub3JlT3JpZW50YXRpb247XG4gICAgY29uc3QgaW5Eb2N1bWVudEZsb3cgPSB0eXBlb2YgeSAhPT0gJ251bWJlcic7XG4gICAgeCA9IChsZWZ0ID0geCAhPSBudWxsID8geCA6IG9wdGlvbnMueCkgIT0gbnVsbCA/IGxlZnQgOiB0aGlzLng7XG4gICAgeSA9IChsZWZ0MSA9IHkgIT0gbnVsbCA/IHkgOiBvcHRpb25zLnkpICE9IG51bGwgPyBsZWZ0MSA6IHRoaXMueTtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGltYWdlID0gdGhpcy5faW1hZ2VSZWdpc3RyeVtzcmNdO1xuICAgIH1cbiAgICBpZiAoIWltYWdlKSB7XG4gICAgICBpZiAoc3JjLndpZHRoICYmIHNyYy5oZWlnaHQpIHtcbiAgICAgICAgaW1hZ2UgPSBzcmM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWFnZSA9IHRoaXMub3BlbkltYWdlKHNyYyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaW1hZ2Uub2JqKSB7XG4gICAgICBpbWFnZS5lbWJlZCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFnZS54b2JqZWN0c1tpbWFnZS5sYWJlbF0gPT0gbnVsbCkge1xuICAgICAgdGhpcy5wYWdlLnhvYmplY3RzW2ltYWdlLmxhYmVsXSA9IGltYWdlLm9iajtcbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGltYWdlO1xuICAgIGlmICghaWdub3JlT3JpZW50YXRpb24gJiYgaW1hZ2Uub3JpZW50YXRpb24gPiA0KSB7XG4gICAgICBbd2lkdGgsIGhlaWdodF0gPSBbaGVpZ2h0LCB3aWR0aF07XG4gICAgfVxuICAgIGxldCB3ID0gb3B0aW9ucy53aWR0aCB8fCB3aWR0aDtcbiAgICBsZXQgaCA9IG9wdGlvbnMuaGVpZ2h0IHx8IGhlaWdodDtcbiAgICBpZiAob3B0aW9ucy53aWR0aCAmJiAhb3B0aW9ucy5oZWlnaHQpIHtcbiAgICAgIGNvbnN0IHdwID0gdyAvIHdpZHRoO1xuICAgICAgdyA9IHdpZHRoICogd3A7XG4gICAgICBoID0gaGVpZ2h0ICogd3A7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmhlaWdodCAmJiAhb3B0aW9ucy53aWR0aCkge1xuICAgICAgY29uc3QgaHAgPSBoIC8gaGVpZ2h0O1xuICAgICAgdyA9IHdpZHRoICogaHA7XG4gICAgICBoID0gaGVpZ2h0ICogaHA7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNjYWxlKSB7XG4gICAgICB3ID0gd2lkdGggKiBvcHRpb25zLnNjYWxlO1xuICAgICAgaCA9IGhlaWdodCAqIG9wdGlvbnMuc2NhbGU7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmZpdCkge1xuICAgICAgW2J3LCBiaF0gPSBvcHRpb25zLmZpdDtcbiAgICAgIGJwID0gYncgLyBiaDtcbiAgICAgIGlwID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgICBpZiAoaXAgPiBicCkge1xuICAgICAgICB3ID0gYnc7XG4gICAgICAgIGggPSBidyAvIGlwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaCA9IGJoO1xuICAgICAgICB3ID0gYmggKiBpcDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuY292ZXIpIHtcbiAgICAgIFtidywgYmhdID0gb3B0aW9ucy5jb3ZlcjtcbiAgICAgIGJwID0gYncgLyBiaDtcbiAgICAgIGlwID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgICBpZiAoaXAgPiBicCkge1xuICAgICAgICBoID0gYmg7XG4gICAgICAgIHcgPSBiaCAqIGlwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdyA9IGJ3O1xuICAgICAgICBoID0gYncgLyBpcDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZml0IHx8IG9wdGlvbnMuY292ZXIpIHtcbiAgICAgIGlmIChvcHRpb25zLmFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICB4ID0geCArIGJ3IC8gMiAtIHcgLyAyO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHggPSB4ICsgYncgLSB3O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudmFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICB5ID0geSArIGJoIC8gMiAtIGggLyAyO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnZhbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgeSA9IHkgKyBiaCAtIGg7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCByb3RhdGVBbmdsZSA9IDA7XG4gICAgbGV0IHhUcmFuc2Zvcm0gPSB4O1xuICAgIGxldCB5VHJhbnNmb3JtID0geTtcbiAgICBsZXQgaFRyYW5zZm9ybSA9IGg7XG4gICAgbGV0IHdUcmFuc2Zvcm0gPSB3O1xuICAgIGlmICghaWdub3JlT3JpZW50YXRpb24pIHtcbiAgICAgIHN3aXRjaCAoaW1hZ2Uub3JpZW50YXRpb24pIHtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGhUcmFuc2Zvcm0gPSAtaDtcbiAgICAgICAgICB5VHJhbnNmb3JtICs9IGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB3VHJhbnNmb3JtID0gLXc7XG4gICAgICAgICAgaFRyYW5zZm9ybSA9IC1oO1xuICAgICAgICAgIHhUcmFuc2Zvcm0gKz0gdztcbiAgICAgICAgICB5VHJhbnNmb3JtICs9IGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBvcmlnaW5YID0geDtcbiAgICAgICAgICBvcmlnaW5ZID0geTtcbiAgICAgICAgICBoVHJhbnNmb3JtID0gLWg7XG4gICAgICAgICAgeFRyYW5zZm9ybSAtPSB3O1xuICAgICAgICAgIHJvdGF0ZUFuZ2xlID0gMTgwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBvcmlnaW5YID0geDtcbiAgICAgICAgICBvcmlnaW5ZID0geTtcbiAgICAgICAgICB3VHJhbnNmb3JtID0gaDtcbiAgICAgICAgICBoVHJhbnNmb3JtID0gdztcbiAgICAgICAgICB5VHJhbnNmb3JtIC09IGhUcmFuc2Zvcm07XG4gICAgICAgICAgcm90YXRlQW5nbGUgPSA5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIG9yaWdpblggPSB4O1xuICAgICAgICAgIG9yaWdpblkgPSB5O1xuICAgICAgICAgIHdUcmFuc2Zvcm0gPSBoO1xuICAgICAgICAgIGhUcmFuc2Zvcm0gPSAtdztcbiAgICAgICAgICByb3RhdGVBbmdsZSA9IDkwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgb3JpZ2luWCA9IHg7XG4gICAgICAgICAgb3JpZ2luWSA9IHk7XG4gICAgICAgICAgaFRyYW5zZm9ybSA9IC13O1xuICAgICAgICAgIHdUcmFuc2Zvcm0gPSAtaDtcbiAgICAgICAgICB4VHJhbnNmb3JtICs9IGg7XG4gICAgICAgICAgcm90YXRlQW5nbGUgPSA5MDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIG9yaWdpblggPSB4O1xuICAgICAgICAgIG9yaWdpblkgPSB5O1xuICAgICAgICAgIHdUcmFuc2Zvcm0gPSBoO1xuICAgICAgICAgIGhUcmFuc2Zvcm0gPSAtdztcbiAgICAgICAgICB4VHJhbnNmb3JtIC09IGg7XG4gICAgICAgICAgeVRyYW5zZm9ybSArPSB3O1xuICAgICAgICAgIHJvdGF0ZUFuZ2xlID0gLTkwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBoVHJhbnNmb3JtID0gLWg7XG4gICAgICB5VHJhbnNmb3JtICs9IGg7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxpbmsgIT0gbnVsbCkge1xuICAgICAgdGhpcy5saW5rKHgsIHksIHcsIGgsIG9wdGlvbnMubGluayk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmdvVG8gIT0gbnVsbCkge1xuICAgICAgdGhpcy5nb1RvKHgsIHksIHcsIGgsIG9wdGlvbnMuZ29Ubyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRlc3RpbmF0aW9uICE9IG51bGwpIHtcbiAgICAgIHRoaXMuYWRkTmFtZWREZXN0aW5hdGlvbihvcHRpb25zLmRlc3RpbmF0aW9uLCAnWFlaJywgeCwgeSwgbnVsbCk7XG4gICAgfVxuICAgIGlmIChpbkRvY3VtZW50Rmxvdykge1xuICAgICAgdGhpcy55ICs9IGg7XG4gICAgfVxuICAgIHRoaXMuc2F2ZSgpO1xuICAgIGlmIChyb3RhdGVBbmdsZSkge1xuICAgICAgdGhpcy5yb3RhdGUocm90YXRlQW5nbGUsIHtcbiAgICAgICAgb3JpZ2luOiBbb3JpZ2luWCwgb3JpZ2luWV1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zZm9ybSh3VHJhbnNmb3JtLCAwLCAwLCBoVHJhbnNmb3JtLCB4VHJhbnNmb3JtLCB5VHJhbnNmb3JtKTtcbiAgICB0aGlzLmFkZENvbnRlbnQoYC8ke2ltYWdlLmxhYmVsfSBEb2ApO1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBvcGVuSW1hZ2Uoc3JjKSB7XG4gICAgbGV0IGltYWdlO1xuICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgaW1hZ2UgPSB0aGlzLl9pbWFnZVJlZ2lzdHJ5W3NyY107XG4gICAgfVxuICAgIGlmICghaW1hZ2UpIHtcbiAgICAgIGltYWdlID0gUERGSW1hZ2Uub3BlbihzcmMsIGBJJHsrK3RoaXMuX2ltYWdlQ291bnR9YCk7XG4gICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5faW1hZ2VSZWdpc3RyeVtzcmNdID0gaW1hZ2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbWFnZTtcbiAgfVxufTtcblxudmFyIEFubm90YXRpb25zTWl4aW4gPSB7XG4gIGFubm90YXRlKHgsIHksIHcsIGgsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLlR5cGUgPSAnQW5ub3QnO1xuICAgIG9wdGlvbnMuUmVjdCA9IHRoaXMuX2NvbnZlcnRSZWN0KHgsIHksIHcsIGgpO1xuICAgIG9wdGlvbnMuQm9yZGVyID0gWzAsIDAsIDBdO1xuICAgIGlmIChvcHRpb25zLlN1YnR5cGUgPT09ICdMaW5rJyAmJiB0eXBlb2Ygb3B0aW9ucy5GID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9ucy5GID0gMSA8PCAyO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5TdWJ0eXBlICE9PSAnTGluaycpIHtcbiAgICAgIGlmIChvcHRpb25zLkMgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLkMgPSB0aGlzLl9ub3JtYWxpemVDb2xvcihvcHRpb25zLmNvbG9yIHx8IFswLCAwLCAwXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZSBvcHRpb25zLmNvbG9yO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5EZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucy5EZXN0ID0gbmV3IFN0cmluZyhvcHRpb25zLkRlc3QpO1xuICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgY29uc3QgdmFsID0gb3B0aW9uc1trZXldO1xuICAgICAgb3B0aW9uc1trZXlbMF0udG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKV0gPSB2YWw7XG4gICAgfVxuICAgIGNvbnN0IHJlZiA9IHRoaXMucmVmKG9wdGlvbnMpO1xuICAgIHRoaXMucGFnZS5hbm5vdGF0aW9ucy5wdXNoKHJlZik7XG4gICAgcmVmLmVuZCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBub3RlKHgsIHksIHcsIGgsIGNvbnRlbnRzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdUZXh0JztcbiAgICBvcHRpb25zLkNvbnRlbnRzID0gbmV3IFN0cmluZyhjb250ZW50cyk7XG4gICAgaWYgKG9wdGlvbnMuTmFtZSA9PSBudWxsKSB7XG4gICAgICBvcHRpb25zLk5hbWUgPSAnQ29tbWVudCc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNvbG9yID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuY29sb3IgPSBbMjQzLCAyMjMsIDkyXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGUoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIGdvVG8oeCwgeSwgdywgaCwgbmFtZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgICBvcHRpb25zLlN1YnR5cGUgPSAnTGluayc7XG4gICAgb3B0aW9ucy5BID0gdGhpcy5yZWYoe1xuICAgICAgUzogJ0dvVG8nLFxuICAgICAgRDogbmV3IFN0cmluZyhuYW1lKVxuICAgIH0pO1xuICAgIG9wdGlvbnMuQS5lbmQoKTtcbiAgICByZXR1cm4gdGhpcy5hbm5vdGF0ZSh4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgbGluayh4LCB5LCB3LCBoLCB1cmwpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge307XG4gICAgb3B0aW9ucy5TdWJ0eXBlID0gJ0xpbmsnO1xuICAgIGlmICh0eXBlb2YgdXJsID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgcGFnZXMgPSB0aGlzLl9yb290LmRhdGEuUGFnZXMuZGF0YTtcbiAgICAgIGlmICh1cmwgPj0gMCAmJiB1cmwgPCBwYWdlcy5LaWRzLmxlbmd0aCkge1xuICAgICAgICBvcHRpb25zLkEgPSB0aGlzLnJlZih7XG4gICAgICAgICAgUzogJ0dvVG8nLFxuICAgICAgICAgIEQ6IFtwYWdlcy5LaWRzW3VybF0sICdYWVonLCBudWxsLCBudWxsLCBudWxsXVxuICAgICAgICB9KTtcbiAgICAgICAgb3B0aW9ucy5BLmVuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZG9jdW1lbnQgaGFzIG5vIHBhZ2UgJHt1cmx9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuQSA9IHRoaXMucmVmKHtcbiAgICAgICAgUzogJ1VSSScsXG4gICAgICAgIFVSSTogbmV3IFN0cmluZyh1cmwpXG4gICAgICB9KTtcbiAgICAgIG9wdGlvbnMuQS5lbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGUoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIF9tYXJrdXAoeCwgeSwgdywgaCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fTtcbiAgICBjb25zdCBbeDEsIHkxLCB4MiwgeTJdID0gdGhpcy5fY29udmVydFJlY3QoeCwgeSwgdywgaCk7XG4gICAgb3B0aW9ucy5RdWFkUG9pbnRzID0gW3gxLCB5MiwgeDIsIHkyLCB4MSwgeTEsIHgyLCB5MV07XG4gICAgb3B0aW9ucy5Db250ZW50cyA9IG5ldyBTdHJpbmcoKTtcbiAgICByZXR1cm4gdGhpcy5hbm5vdGF0ZSh4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgaGlnaGxpZ2h0KHgsIHksIHcsIGgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG4gICAgb3B0aW9ucy5TdWJ0eXBlID0gJ0hpZ2hsaWdodCc7XG4gICAgaWYgKG9wdGlvbnMuY29sb3IgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5jb2xvciA9IFsyNDEsIDIzOCwgMTQ4XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX21hcmt1cCh4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgdW5kZXJsaW5lKHgsIHksIHcsIGgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG4gICAgb3B0aW9ucy5TdWJ0eXBlID0gJ1VuZGVybGluZSc7XG4gICAgcmV0dXJuIHRoaXMuX21hcmt1cCh4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgc3RyaWtlKHgsIHksIHcsIGgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG4gICAgb3B0aW9ucy5TdWJ0eXBlID0gJ1N0cmlrZU91dCc7XG4gICAgcmV0dXJuIHRoaXMuX21hcmt1cCh4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgbGluZUFubm90YXRpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG4gICAgb3B0aW9ucy5TdWJ0eXBlID0gJ0xpbmUnO1xuICAgIG9wdGlvbnMuQ29udGVudHMgPSBuZXcgU3RyaW5nKCk7XG4gICAgb3B0aW9ucy5MID0gW3gxLCB0aGlzLnBhZ2UuaGVpZ2h0IC0geTEsIHgyLCB0aGlzLnBhZ2UuaGVpZ2h0IC0geTJdO1xuICAgIHJldHVybiB0aGlzLmFubm90YXRlKHgxLCB5MSwgeDIsIHkyLCBvcHRpb25zKTtcbiAgfSxcbiAgcmVjdEFubm90YXRpb24oeCwgeSwgdywgaCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fTtcbiAgICBvcHRpb25zLlN1YnR5cGUgPSAnU3F1YXJlJztcbiAgICBvcHRpb25zLkNvbnRlbnRzID0gbmV3IFN0cmluZygpO1xuICAgIHJldHVybiB0aGlzLmFubm90YXRlKHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBlbGxpcHNlQW5ub3RhdGlvbih4LCB5LCB3LCBoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdDaXJjbGUnO1xuICAgIG9wdGlvbnMuQ29udGVudHMgPSBuZXcgU3RyaW5nKCk7XG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGUoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIHRleHRBbm5vdGF0aW9uKHgsIHksIHcsIGgsIHRleHQpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge307XG4gICAgb3B0aW9ucy5TdWJ0eXBlID0gJ0ZyZWVUZXh0JztcbiAgICBvcHRpb25zLkNvbnRlbnRzID0gbmV3IFN0cmluZyh0ZXh0KTtcbiAgICBvcHRpb25zLkRBID0gbmV3IFN0cmluZygpO1xuICAgIHJldHVybiB0aGlzLmFubm90YXRlKHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBmaWxlQW5ub3RhdGlvbih4LCB5LCB3LCBoKSB7XG4gICAgbGV0IGZpbGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgICBjb25zdCBmaWxlc3BlYyA9IHRoaXMuZmlsZShmaWxlLnNyYywgT2JqZWN0LmFzc2lnbih7XG4gICAgICBoaWRkZW46IHRydWVcbiAgICB9LCBmaWxlKSk7XG4gICAgb3B0aW9ucy5TdWJ0eXBlID0gJ0ZpbGVBdHRhY2htZW50JztcbiAgICBvcHRpb25zLkZTID0gZmlsZXNwZWM7XG4gICAgaWYgKG9wdGlvbnMuQ29udGVudHMpIHtcbiAgICAgIG9wdGlvbnMuQ29udGVudHMgPSBuZXcgU3RyaW5nKG9wdGlvbnMuQ29udGVudHMpO1xuICAgIH0gZWxzZSBpZiAoZmlsZXNwZWMuZGF0YS5EZXNjKSB7XG4gICAgICBvcHRpb25zLkNvbnRlbnRzID0gZmlsZXNwZWMuZGF0YS5EZXNjO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbm5vdGF0ZSh4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgX2NvbnZlcnRSZWN0KHgxLCB5MSwgdywgaCkge1xuICAgIGxldCB5MiA9IHkxO1xuICAgIHkxICs9IGg7XG4gICAgbGV0IHgyID0geDEgKyB3O1xuICAgIGNvbnN0IFttMCwgbTEsIG0yLCBtMywgbTQsIG01XSA9IHRoaXMuX2N0bTtcbiAgICB4MSA9IG0wICogeDEgKyBtMiAqIHkxICsgbTQ7XG4gICAgeTEgPSBtMSAqIHgxICsgbTMgKiB5MSArIG01O1xuICAgIHgyID0gbTAgKiB4MiArIG0yICogeTIgKyBtNDtcbiAgICB5MiA9IG0xICogeDIgKyBtMyAqIHkyICsgbTU7XG4gICAgcmV0dXJuIFt4MSwgeTEsIHgyLCB5Ml07XG4gIH1cbn07XG5cbmNsYXNzIFBERk91dGxpbmUge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgcGFyZW50LCB0aXRsZSwgZGVzdCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7XG4gICAgICBleHBhbmRlZDogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMub3V0bGluZURhdGEgPSB7fTtcbiAgICBpZiAoZGVzdCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5vdXRsaW5lRGF0YVsnRGVzdCddID0gW2Rlc3QuZGljdGlvbmFyeSwgJ0ZpdCddO1xuICAgIH1cbiAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLm91dGxpbmVEYXRhWydQYXJlbnQnXSA9IHBhcmVudDtcbiAgICB9XG4gICAgaWYgKHRpdGxlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLm91dGxpbmVEYXRhWydUaXRsZSddID0gbmV3IFN0cmluZyh0aXRsZSk7XG4gICAgfVxuICAgIHRoaXMuZGljdGlvbmFyeSA9IHRoaXMuZG9jdW1lbnQucmVmKHRoaXMub3V0bGluZURhdGEpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgfVxuICBhZGRJdGVtKHRpdGxlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICAgIGV4cGFuZGVkOiBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFBERk91dGxpbmUodGhpcy5kb2N1bWVudCwgdGhpcy5kaWN0aW9uYXJ5LCB0aXRsZSwgdGhpcy5kb2N1bWVudC5wYWdlLCBvcHRpb25zKTtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2gocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGVuZE91dGxpbmUoKSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHBhbmRlZCkge1xuICAgICAgICB0aGlzLm91dGxpbmVEYXRhLkNvdW50ID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBjb25zdCBmaXJzdCA9IHRoaXMuY2hpbGRyZW5bMF0sXG4gICAgICAgIGxhc3QgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICB0aGlzLm91dGxpbmVEYXRhLkZpcnN0ID0gZmlyc3QuZGljdGlvbmFyeTtcbiAgICAgIHRoaXMub3V0bGluZURhdGEuTGFzdCA9IGxhc3QuZGljdGlvbmFyeTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgY2hpbGQub3V0bGluZURhdGEuUHJldiA9IHRoaXMuY2hpbGRyZW5baSAtIDFdLmRpY3Rpb25hcnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjaGlsZC5vdXRsaW5lRGF0YS5OZXh0ID0gdGhpcy5jaGlsZHJlbltpICsgMV0uZGljdGlvbmFyeTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZC5lbmRPdXRsaW5lKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpY3Rpb25hcnkuZW5kKCk7XG4gIH1cbn1cblxudmFyIE91dGxpbmVNaXhpbiA9IHtcbiAgaW5pdE91dGxpbmUoKSB7XG4gICAgdGhpcy5vdXRsaW5lID0gbmV3IFBERk91dGxpbmUodGhpcywgbnVsbCwgbnVsbCwgbnVsbCk7XG4gIH0sXG4gIGVuZE91dGxpbmUoKSB7XG4gICAgdGhpcy5vdXRsaW5lLmVuZE91dGxpbmUoKTtcbiAgICBpZiAodGhpcy5vdXRsaW5lLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5PdXRsaW5lcyA9IHRoaXMub3V0bGluZS5kaWN0aW9uYXJ5O1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QuZGF0YS5QYWdlTW9kZSA9ICdVc2VPdXRsaW5lcyc7XG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBQREZTdHJ1Y3R1cmVDb250ZW50IHtcbiAgY29uc3RydWN0b3IocGFnZVJlZiwgbWNpZCkge1xuICAgIHRoaXMucmVmcyA9IFt7XG4gICAgICBwYWdlUmVmLFxuICAgICAgbWNpZFxuICAgIH1dO1xuICB9XG4gIHB1c2goc3RydWN0Q29udGVudCkge1xuICAgIHN0cnVjdENvbnRlbnQucmVmcy5mb3JFYWNoKHJlZiA9PiB0aGlzLnJlZnMucHVzaChyZWYpKTtcbiAgfVxufVxuXG5jbGFzcyBQREZTdHJ1Y3R1cmVFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHR5cGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgbGV0IGNoaWxkcmVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLl9hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2VuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZmx1c2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGljdGlvbmFyeSA9IGRvY3VtZW50LnJlZih7XG4gICAgICBTOiB0eXBlXG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGljdGlvbmFyeS5kYXRhO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpIHx8IHRoaXMuX2lzVmFsaWRDaGlsZChvcHRpb25zKSkge1xuICAgICAgY2hpbGRyZW4gPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudGl0bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkYXRhLlQgPSBuZXcgU3RyaW5nKG9wdGlvbnMudGl0bGUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubGFuZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRhdGEuTGFuZyA9IG5ldyBTdHJpbmcob3B0aW9ucy5sYW5nKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRhdGEuQWx0ID0gbmV3IFN0cmluZyhvcHRpb25zLmFsdCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5leHBhbmRlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRhdGEuRSA9IG5ldyBTdHJpbmcob3B0aW9ucy5leHBhbmRlZCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hY3R1YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkYXRhLkFjdHVhbFRleHQgPSBuZXcgU3RyaW5nKG9wdGlvbnMuYWN0dWFsKTtcbiAgICB9XG4gICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBbY2hpbGRyZW5dO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB0aGlzLmFkZChjaGlsZCkpO1xuICAgICAgdGhpcy5lbmQoKTtcbiAgICB9XG4gIH1cbiAgYWRkKGNoaWxkKSB7XG4gICAgaWYgKHRoaXMuX2VuZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBhZGQgY2hpbGQgdG8gYWxyZWFkeS1lbmRlZCBzdHJ1Y3R1cmUgZWxlbWVudGApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2lzVmFsaWRDaGlsZChjaGlsZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdHJ1Y3R1cmUgZWxlbWVudCBjaGlsZGApO1xuICAgIH1cbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBQREZTdHJ1Y3R1cmVFbGVtZW50KSB7XG4gICAgICBjaGlsZC5zZXRQYXJlbnQodGhpcy5kaWN0aW9uYXJ5KTtcbiAgICAgIGlmICh0aGlzLl9hdHRhY2hlZCkge1xuICAgICAgICBjaGlsZC5zZXRBdHRhY2hlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBQREZTdHJ1Y3R1cmVDb250ZW50KSB7XG4gICAgICB0aGlzLl9hZGRDb250ZW50VG9QYXJlbnRUcmVlKGNoaWxkKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLl9hdHRhY2hlZCkge1xuICAgICAgY2hpbGQgPSB0aGlzLl9jb250ZW50Rm9yQ2xvc3VyZShjaGlsZCk7XG4gICAgfVxuICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9hZGRDb250ZW50VG9QYXJlbnRUcmVlKGNvbnRlbnQpIHtcbiAgICBjb250ZW50LnJlZnMuZm9yRWFjaChfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIHBhZ2VSZWYsXG4gICAgICAgIG1jaWRcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgY29uc3QgcGFnZVN0cnVjdFBhcmVudHMgPSB0aGlzLmRvY3VtZW50LmdldFN0cnVjdFBhcmVudFRyZWUoKS5nZXQocGFnZVJlZi5kYXRhLlN0cnVjdFBhcmVudHMpO1xuICAgICAgcGFnZVN0cnVjdFBhcmVudHNbbWNpZF0gPSB0aGlzLmRpY3Rpb25hcnk7XG4gICAgfSk7XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudFJlZikge1xuICAgIGlmICh0aGlzLmRpY3Rpb25hcnkuZGF0YS5QKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cnVjdHVyZSBlbGVtZW50IGFkZGVkIHRvIG1vcmUgdGhhbiBvbmUgcGFyZW50YCk7XG4gICAgfVxuICAgIHRoaXMuZGljdGlvbmFyeS5kYXRhLlAgPSBwYXJlbnRSZWY7XG4gICAgdGhpcy5fZmx1c2goKTtcbiAgfVxuICBzZXRBdHRhY2hlZCgpIHtcbiAgICBpZiAodGhpcy5fYXR0YWNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBQREZTdHJ1Y3R1cmVFbGVtZW50KSB7XG4gICAgICAgIGNoaWxkLnNldEF0dGFjaGVkKCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuW2luZGV4XSA9IHRoaXMuX2NvbnRlbnRGb3JDbG9zdXJlKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9hdHRhY2hlZCA9IHRydWU7XG4gICAgdGhpcy5fZmx1c2goKTtcbiAgfVxuICBlbmQoKSB7XG4gICAgaWYgKHRoaXMuX2VuZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NoaWxkcmVuLmZpbHRlcihjaGlsZCA9PiBjaGlsZCBpbnN0YW5jZW9mIFBERlN0cnVjdHVyZUVsZW1lbnQpLmZvckVhY2goY2hpbGQgPT4gY2hpbGQuZW5kKCkpO1xuICAgIHRoaXMuX2VuZGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9mbHVzaCgpO1xuICB9XG4gIF9pc1ZhbGlkQ2hpbGQoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQgaW5zdGFuY2VvZiBQREZTdHJ1Y3R1cmVFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2YgUERGU3RydWN0dXJlQ29udGVudCB8fCB0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbic7XG4gIH1cbiAgX2NvbnRlbnRGb3JDbG9zdXJlKGNsb3N1cmUpIHtcbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5kb2N1bWVudC5tYXJrU3RydWN0dXJlQ29udGVudCh0aGlzLmRpY3Rpb25hcnkuZGF0YS5TKTtcbiAgICBjbG9zdXJlKCk7XG4gICAgdGhpcy5kb2N1bWVudC5lbmRNYXJrZWRDb250ZW50KCk7XG4gICAgdGhpcy5fYWRkQ29udGVudFRvUGFyZW50VHJlZShjb250ZW50KTtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBfaXNGbHVzaGFibGUoKSB7XG4gICAgaWYgKCF0aGlzLmRpY3Rpb25hcnkuZGF0YS5QIHx8ICF0aGlzLl9lbmRlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBQREZTdHJ1Y3R1cmVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBjaGlsZC5faXNGbHVzaGFibGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIF9mbHVzaCgpIHtcbiAgICBpZiAodGhpcy5fZmx1c2hlZCB8fCAhdGhpcy5faXNGbHVzaGFibGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpY3Rpb25hcnkuZGF0YS5LID0gW107XG4gICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB0aGlzLl9mbHVzaENoaWxkKGNoaWxkKSk7XG4gICAgdGhpcy5kaWN0aW9uYXJ5LmVuZCgpO1xuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgdGhpcy5kaWN0aW9uYXJ5LmRhdGEuSyA9IG51bGw7XG4gICAgdGhpcy5fZmx1c2hlZCA9IHRydWU7XG4gIH1cbiAgX2ZsdXNoQ2hpbGQoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBQREZTdHJ1Y3R1cmVFbGVtZW50KSB7XG4gICAgICB0aGlzLmRpY3Rpb25hcnkuZGF0YS5LLnB1c2goY2hpbGQuZGljdGlvbmFyeSk7XG4gICAgfVxuICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFBERlN0cnVjdHVyZUNvbnRlbnQpIHtcbiAgICAgIGNoaWxkLnJlZnMuZm9yRWFjaChfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgcGFnZVJlZixcbiAgICAgICAgICBtY2lkXG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgaWYgKCF0aGlzLmRpY3Rpb25hcnkuZGF0YS5QZykge1xuICAgICAgICAgIHRoaXMuZGljdGlvbmFyeS5kYXRhLlBnID0gcGFnZVJlZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaWN0aW9uYXJ5LmRhdGEuUGcgPT09IHBhZ2VSZWYpIHtcbiAgICAgICAgICB0aGlzLmRpY3Rpb25hcnkuZGF0YS5LLnB1c2gobWNpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaWN0aW9uYXJ5LmRhdGEuSy5wdXNoKHtcbiAgICAgICAgICAgIFR5cGU6ICdNQ1InLFxuICAgICAgICAgICAgUGc6IHBhZ2VSZWYsXG4gICAgICAgICAgICBNQ0lEOiBtY2lkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBQREZOdW1iZXJUcmVlIGV4dGVuZHMgUERGVHJlZSB7XG4gIF9jb21wYXJlS2V5cyhhLCBiKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGEpIC0gcGFyc2VJbnQoYik7XG4gIH1cbiAgX2tleXNOYW1lKCkge1xuICAgIHJldHVybiAnTnVtcyc7XG4gIH1cbiAgX2RhdGFGb3JLZXkoaykge1xuICAgIHJldHVybiBwYXJzZUludChrKTtcbiAgfVxufVxuXG52YXIgTWFya2luZ3NNaXhpbiA9IHtcbiAgaW5pdE1hcmtpbmdzKG9wdGlvbnMpIHtcbiAgICB0aGlzLnN0cnVjdENoaWxkcmVuID0gW107XG4gICAgaWYgKG9wdGlvbnMudGFnZ2VkKSB7XG4gICAgICB0aGlzLmdldE1hcmtJbmZvRGljdGlvbmFyeSgpLmRhdGEuTWFya2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZ2V0U3RydWN0VHJlZVJvb3QoKTtcbiAgICB9XG4gIH0sXG4gIG1hcmtDb250ZW50KHRhZykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIGlmICh0YWcgPT09ICdBcnRpZmFjdCcgfHwgb3B0aW9ucyAmJiBvcHRpb25zLm1jaWQpIHtcbiAgICAgIGxldCB0b0Nsb3NlID0gMDtcbiAgICAgIHRoaXMucGFnZS5tYXJraW5ncy5mb3JFYWNoKG1hcmtpbmcgPT4ge1xuICAgICAgICBpZiAodG9DbG9zZSB8fCBtYXJraW5nLnN0cnVjdENvbnRlbnQgfHwgbWFya2luZy50YWcgPT09ICdBcnRpZmFjdCcpIHtcbiAgICAgICAgICB0b0Nsb3NlKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd2hpbGUgKHRvQ2xvc2UtLSkge1xuICAgICAgICB0aGlzLmVuZE1hcmtlZENvbnRlbnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICB0aGlzLnBhZ2UubWFya2luZ3MucHVzaCh7XG4gICAgICAgIHRhZ1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZENvbnRlbnQoYC8ke3RhZ30gQk1DYCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5wYWdlLm1hcmtpbmdzLnB1c2goe1xuICAgICAgdGFnLFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xuICAgIGNvbnN0IGRpY3Rpb25hcnkgPSB7fTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubWNpZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRpY3Rpb25hcnkuTUNJRCA9IG9wdGlvbnMubWNpZDtcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ0FydGlmYWN0Jykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRpY3Rpb25hcnkuVHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuYmJveCkpIHtcbiAgICAgICAgZGljdGlvbmFyeS5CQm94ID0gW29wdGlvbnMuYmJveFswXSwgdGhpcy5wYWdlLmhlaWdodCAtIG9wdGlvbnMuYmJveFszXSwgb3B0aW9ucy5iYm94WzJdLCB0aGlzLnBhZ2UuaGVpZ2h0IC0gb3B0aW9ucy5iYm94WzFdXTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuYXR0YWNoZWQpICYmIG9wdGlvbnMuYXR0YWNoZWQuZXZlcnkodmFsID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICBkaWN0aW9uYXJ5LkF0dGFjaGVkID0gb3B0aW9ucy5hdHRhY2hlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ1NwYW4nKSB7XG4gICAgICBpZiAob3B0aW9ucy5sYW5nKSB7XG4gICAgICAgIGRpY3Rpb25hcnkuTGFuZyA9IG5ldyBTdHJpbmcob3B0aW9ucy5sYW5nKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmFsdCkge1xuICAgICAgICBkaWN0aW9uYXJ5LkFsdCA9IG5ldyBTdHJpbmcob3B0aW9ucy5hbHQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZXhwYW5kZWQpIHtcbiAgICAgICAgZGljdGlvbmFyeS5FID0gbmV3IFN0cmluZyhvcHRpb25zLmV4cGFuZGVkKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmFjdHVhbCkge1xuICAgICAgICBkaWN0aW9uYXJ5LkFjdHVhbFRleHQgPSBuZXcgU3RyaW5nKG9wdGlvbnMuYWN0dWFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZGRDb250ZW50KGAvJHt0YWd9ICR7UERGT2JqZWN0LmNvbnZlcnQoZGljdGlvbmFyeSl9IEJEQ2ApO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBtYXJrU3RydWN0dXJlQ29udGVudCh0YWcpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY29uc3QgcGFnZVN0cnVjdFBhcmVudHMgPSB0aGlzLmdldFN0cnVjdFBhcmVudFRyZWUoKS5nZXQodGhpcy5wYWdlLnN0cnVjdFBhcmVudFRyZWVLZXkpO1xuICAgIGNvbnN0IG1jaWQgPSBwYWdlU3RydWN0UGFyZW50cy5sZW5ndGg7XG4gICAgcGFnZVN0cnVjdFBhcmVudHMucHVzaChudWxsKTtcbiAgICB0aGlzLm1hcmtDb250ZW50KHRhZywge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIG1jaWRcbiAgICB9KTtcbiAgICBjb25zdCBzdHJ1Y3RDb250ZW50ID0gbmV3IFBERlN0cnVjdHVyZUNvbnRlbnQodGhpcy5wYWdlLmRpY3Rpb25hcnksIG1jaWQpO1xuICAgIHRoaXMucGFnZS5tYXJraW5ncy5zbGljZSgtMSlbMF0uc3RydWN0Q29udGVudCA9IHN0cnVjdENvbnRlbnQ7XG4gICAgcmV0dXJuIHN0cnVjdENvbnRlbnQ7XG4gIH0sXG4gIGVuZE1hcmtlZENvbnRlbnQoKSB7XG4gICAgdGhpcy5wYWdlLm1hcmtpbmdzLnBvcCgpO1xuICAgIHRoaXMuYWRkQ29udGVudCgnRU1DJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHN0cnVjdCh0eXBlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGxldCBjaGlsZHJlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICByZXR1cm4gbmV3IFBERlN0cnVjdHVyZUVsZW1lbnQodGhpcywgdHlwZSwgb3B0aW9ucywgY2hpbGRyZW4pO1xuICB9LFxuICBhZGRTdHJ1Y3R1cmUoc3RydWN0RWxlbSkge1xuICAgIGNvbnN0IHN0cnVjdFRyZWVSb290ID0gdGhpcy5nZXRTdHJ1Y3RUcmVlUm9vdCgpO1xuICAgIHN0cnVjdEVsZW0uc2V0UGFyZW50KHN0cnVjdFRyZWVSb290KTtcbiAgICBzdHJ1Y3RFbGVtLnNldEF0dGFjaGVkKCk7XG4gICAgdGhpcy5zdHJ1Y3RDaGlsZHJlbi5wdXNoKHN0cnVjdEVsZW0pO1xuICAgIGlmICghc3RydWN0VHJlZVJvb3QuZGF0YS5LKSB7XG4gICAgICBzdHJ1Y3RUcmVlUm9vdC5kYXRhLksgPSBbXTtcbiAgICB9XG4gICAgc3RydWN0VHJlZVJvb3QuZGF0YS5LLnB1c2goc3RydWN0RWxlbS5kaWN0aW9uYXJ5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgaW5pdFBhZ2VNYXJraW5ncyhwYWdlTWFya2luZ3MpIHtcbiAgICBwYWdlTWFya2luZ3MuZm9yRWFjaChtYXJraW5nID0+IHtcbiAgICAgIGlmIChtYXJraW5nLnN0cnVjdENvbnRlbnQpIHtcbiAgICAgICAgY29uc3Qgc3RydWN0Q29udGVudCA9IG1hcmtpbmcuc3RydWN0Q29udGVudDtcbiAgICAgICAgY29uc3QgbmV3U3RydWN0Q29udGVudCA9IHRoaXMubWFya1N0cnVjdHVyZUNvbnRlbnQobWFya2luZy50YWcsIG1hcmtpbmcub3B0aW9ucyk7XG4gICAgICAgIHN0cnVjdENvbnRlbnQucHVzaChuZXdTdHJ1Y3RDb250ZW50KTtcbiAgICAgICAgdGhpcy5wYWdlLm1hcmtpbmdzLnNsaWNlKC0xKVswXS5zdHJ1Y3RDb250ZW50ID0gc3RydWN0Q29udGVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWFya0NvbnRlbnQobWFya2luZy50YWcsIG1hcmtpbmcub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGVuZFBhZ2VNYXJraW5ncyhwYWdlKSB7XG4gICAgY29uc3QgcGFnZU1hcmtpbmdzID0gcGFnZS5tYXJraW5ncztcbiAgICBwYWdlTWFya2luZ3MuZm9yRWFjaCgoKSA9PiBwYWdlLndyaXRlKCdFTUMnKSk7XG4gICAgcGFnZS5tYXJraW5ncyA9IFtdO1xuICAgIHJldHVybiBwYWdlTWFya2luZ3M7XG4gIH0sXG4gIGdldE1hcmtJbmZvRGljdGlvbmFyeSgpIHtcbiAgICBpZiAoIXRoaXMuX3Jvb3QuZGF0YS5NYXJrSW5mbykge1xuICAgICAgdGhpcy5fcm9vdC5kYXRhLk1hcmtJbmZvID0gdGhpcy5yZWYoe30pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdC5kYXRhLk1hcmtJbmZvO1xuICB9LFxuICBoYXNNYXJrSW5mb0RpY3Rpb25hcnkoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fcm9vdC5kYXRhLk1hcmtJbmZvO1xuICB9LFxuICBnZXRTdHJ1Y3RUcmVlUm9vdCgpIHtcbiAgICBpZiAoIXRoaXMuX3Jvb3QuZGF0YS5TdHJ1Y3RUcmVlUm9vdCkge1xuICAgICAgdGhpcy5fcm9vdC5kYXRhLlN0cnVjdFRyZWVSb290ID0gdGhpcy5yZWYoe1xuICAgICAgICBUeXBlOiAnU3RydWN0VHJlZVJvb3QnLFxuICAgICAgICBQYXJlbnRUcmVlOiBuZXcgUERGTnVtYmVyVHJlZSgpLFxuICAgICAgICBQYXJlbnRUcmVlTmV4dEtleTogMFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yb290LmRhdGEuU3RydWN0VHJlZVJvb3Q7XG4gIH0sXG4gIGdldFN0cnVjdFBhcmVudFRyZWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RydWN0VHJlZVJvb3QoKS5kYXRhLlBhcmVudFRyZWU7XG4gIH0sXG4gIGNyZWF0ZVN0cnVjdFBhcmVudFRyZWVOZXh0S2V5KCkge1xuICAgIHRoaXMuZ2V0TWFya0luZm9EaWN0aW9uYXJ5KCk7XG4gICAgY29uc3Qgc3RydWN0VHJlZVJvb3QgPSB0aGlzLmdldFN0cnVjdFRyZWVSb290KCk7XG4gICAgY29uc3Qga2V5ID0gc3RydWN0VHJlZVJvb3QuZGF0YS5QYXJlbnRUcmVlTmV4dEtleSsrO1xuICAgIHN0cnVjdFRyZWVSb290LmRhdGEuUGFyZW50VHJlZS5hZGQoa2V5LCBbXSk7XG4gICAgcmV0dXJuIGtleTtcbiAgfSxcbiAgZW5kTWFya2luZ3MoKSB7XG4gICAgY29uc3Qgc3RydWN0VHJlZVJvb3QgPSB0aGlzLl9yb290LmRhdGEuU3RydWN0VHJlZVJvb3Q7XG4gICAgaWYgKHN0cnVjdFRyZWVSb290KSB7XG4gICAgICBzdHJ1Y3RUcmVlUm9vdC5lbmQoKTtcbiAgICAgIHRoaXMuc3RydWN0Q2hpbGRyZW4uZm9yRWFjaChzdHJ1Y3RFbGVtID0+IHN0cnVjdEVsZW0uZW5kKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcm9vdC5kYXRhLk1hcmtJbmZvKSB7XG4gICAgICB0aGlzLl9yb290LmRhdGEuTWFya0luZm8uZW5kKCk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBGSUVMRF9GTEFHUyA9IHtcbiAgcmVhZE9ubHk6IDEsXG4gIHJlcXVpcmVkOiAyLFxuICBub0V4cG9ydDogNCxcbiAgbXVsdGlsaW5lOiAweDEwMDAsXG4gIHBhc3N3b3JkOiAweDIwMDAsXG4gIHRvZ2dsZVRvT2ZmQnV0dG9uOiAweDQwMDAsXG4gIHJhZGlvQnV0dG9uOiAweDgwMDAsXG4gIHB1c2hCdXR0b246IDB4MTAwMDAsXG4gIGNvbWJvOiAweDIwMDAwLFxuICBlZGl0OiAweDQwMDAwLFxuICBzb3J0OiAweDgwMDAwLFxuICBtdWx0aVNlbGVjdDogMHgyMDAwMDAsXG4gIG5vU3BlbGw6IDB4NDAwMDAwXG59O1xuY29uc3QgRklFTERfSlVTVElGWSA9IHtcbiAgbGVmdDogMCxcbiAgY2VudGVyOiAxLFxuICByaWdodDogMlxufTtcbmNvbnN0IFZBTFVFX01BUCA9IHtcbiAgdmFsdWU6ICdWJyxcbiAgZGVmYXVsdFZhbHVlOiAnRFYnXG59O1xuY29uc3QgRk9STUFUX1NQRUNJQUwgPSB7XG4gIHppcDogJzAnLFxuICB6aXBQbHVzNDogJzEnLFxuICB6aXA0OiAnMScsXG4gIHBob25lOiAnMicsXG4gIHNzbjogJzMnXG59O1xuY29uc3QgRk9STUFUX0RFRkFVTFQgPSB7XG4gIG51bWJlcjoge1xuICAgIG5EZWM6IDAsXG4gICAgc2VwQ29tbWE6IGZhbHNlLFxuICAgIG5lZ1N0eWxlOiAnTWludXNCbGFjaycsXG4gICAgY3VycmVuY3k6ICcnLFxuICAgIGN1cnJlbmN5UHJlcGVuZDogdHJ1ZVxuICB9LFxuICBwZXJjZW50OiB7XG4gICAgbkRlYzogMCxcbiAgICBzZXBDb21tYTogZmFsc2VcbiAgfVxufTtcbnZhciBBY3JvRm9ybU1peGluID0ge1xuICBpbml0Rm9ybSgpIHtcbiAgICBpZiAoIXRoaXMuX2ZvbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzZXQgYSBmb250IGJlZm9yZSBjYWxsaW5nIGluaXRGb3JtIG1ldGhvZCcpO1xuICAgIH1cbiAgICB0aGlzLl9hY3JvZm9ybSA9IHtcbiAgICAgIGZvbnRzOiB7fSxcbiAgICAgIGRlZmF1bHRGb250OiB0aGlzLl9mb250Lm5hbWVcbiAgICB9O1xuICAgIHRoaXMuX2Fjcm9mb3JtLmZvbnRzW3RoaXMuX2ZvbnQuaWRdID0gdGhpcy5fZm9udC5yZWYoKTtcbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgIEZpZWxkczogW10sXG4gICAgICBOZWVkQXBwZWFyYW5jZXM6IHRydWUsXG4gICAgICBEQTogbmV3IFN0cmluZyhgLyR7dGhpcy5fZm9udC5pZH0gMCBUZiAwIGdgKSxcbiAgICAgIERSOiB7XG4gICAgICAgIEZvbnQ6IHt9XG4gICAgICB9XG4gICAgfTtcbiAgICBkYXRhLkRSLkZvbnRbdGhpcy5fZm9udC5pZF0gPSB0aGlzLl9mb250LnJlZigpO1xuICAgIGNvbnN0IEFjcm9Gb3JtID0gdGhpcy5yZWYoZGF0YSk7XG4gICAgdGhpcy5fcm9vdC5kYXRhLkFjcm9Gb3JtID0gQWNyb0Zvcm07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVuZEFjcm9Gb3JtKCkge1xuICAgIGlmICh0aGlzLl9yb290LmRhdGEuQWNyb0Zvcm0pIHtcbiAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5fYWNyb2Zvcm0uZm9udHMpLmxlbmd0aCAmJiAhdGhpcy5fYWNyb2Zvcm0uZGVmYXVsdEZvbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBmb250cyBzcGVjaWZpZWQgZm9yIFBERiBmb3JtJyk7XG4gICAgICB9XG4gICAgICBsZXQgZm9udERpY3QgPSB0aGlzLl9yb290LmRhdGEuQWNyb0Zvcm0uZGF0YS5EUi5Gb250O1xuICAgICAgT2JqZWN0LmtleXModGhpcy5fYWNyb2Zvcm0uZm9udHMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGZvbnREaWN0W25hbWVdID0gdGhpcy5fYWNyb2Zvcm0uZm9udHNbbmFtZV07XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5BY3JvRm9ybS5kYXRhLkZpZWxkcy5mb3JFYWNoKGZpZWxkUmVmID0+IHtcbiAgICAgICAgdGhpcy5fZW5kQ2hpbGQoZmllbGRSZWYpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9yb290LmRhdGEuQWNyb0Zvcm0uZW5kKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfZW5kQ2hpbGQocmVmKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmLmRhdGEuS2lkcykpIHtcbiAgICAgIHJlZi5kYXRhLktpZHMuZm9yRWFjaChjaGlsZFJlZiA9PiB7XG4gICAgICAgIHRoaXMuX2VuZENoaWxkKGNoaWxkUmVmKTtcbiAgICAgIH0pO1xuICAgICAgcmVmLmVuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZm9ybUZpZWxkKG5hbWUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgbGV0IGZpZWxkRGljdCA9IHRoaXMuX2ZpZWxkRGljdChuYW1lLCBudWxsLCBvcHRpb25zKTtcbiAgICBsZXQgZmllbGRSZWYgPSB0aGlzLnJlZihmaWVsZERpY3QpO1xuICAgIHRoaXMuX2FkZFRvUGFyZW50KGZpZWxkUmVmKTtcbiAgICByZXR1cm4gZmllbGRSZWY7XG4gIH0sXG4gIGZvcm1Bbm5vdGF0aW9uKG5hbWUsIHR5cGUsIHgsIHksIHcsIGgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDoge307XG4gICAgbGV0IGZpZWxkRGljdCA9IHRoaXMuX2ZpZWxkRGljdChuYW1lLCB0eXBlLCBvcHRpb25zKTtcbiAgICBmaWVsZERpY3QuU3VidHlwZSA9ICdXaWRnZXQnO1xuICAgIGlmIChmaWVsZERpY3QuRiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaWVsZERpY3QuRiA9IDQ7XG4gICAgfVxuICAgIHRoaXMuYW5ub3RhdGUoeCwgeSwgdywgaCwgZmllbGREaWN0KTtcbiAgICBsZXQgYW5ub3RSZWYgPSB0aGlzLnBhZ2UuYW5ub3RhdGlvbnNbdGhpcy5wYWdlLmFubm90YXRpb25zLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiB0aGlzLl9hZGRUb1BhcmVudChhbm5vdFJlZik7XG4gIH0sXG4gIGZvcm1UZXh0KG5hbWUsIHgsIHksIHcsIGgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge307XG4gICAgcmV0dXJuIHRoaXMuZm9ybUFubm90YXRpb24obmFtZSwgJ3RleHQnLCB4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgZm9ybVB1c2hCdXR0b24obmFtZSwgeCwgeSwgdywgaCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgICByZXR1cm4gdGhpcy5mb3JtQW5ub3RhdGlvbihuYW1lLCAncHVzaEJ1dHRvbicsIHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBmb3JtQ29tYm8obmFtZSwgeCwgeSwgdywgaCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgICByZXR1cm4gdGhpcy5mb3JtQW5ub3RhdGlvbihuYW1lLCAnY29tYm8nLCB4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgZm9ybUxpc3QobmFtZSwgeCwgeSwgdywgaCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgICByZXR1cm4gdGhpcy5mb3JtQW5ub3RhdGlvbihuYW1lLCAnbGlzdCcsIHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBmb3JtUmFkaW9CdXR0b24obmFtZSwgeCwgeSwgdywgaCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgICByZXR1cm4gdGhpcy5mb3JtQW5ub3RhdGlvbihuYW1lLCAncmFkaW9CdXR0b24nLCB4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgZm9ybUNoZWNrYm94KG5hbWUsIHgsIHksIHcsIGgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge307XG4gICAgcmV0dXJuIHRoaXMuZm9ybUFubm90YXRpb24obmFtZSwgJ2NoZWNrYm94JywgeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIF9hZGRUb1BhcmVudChmaWVsZFJlZikge1xuICAgIGxldCBwYXJlbnQgPSBmaWVsZFJlZi5kYXRhLlBhcmVudDtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAoIXBhcmVudC5kYXRhLktpZHMpIHtcbiAgICAgICAgcGFyZW50LmRhdGEuS2lkcyA9IFtdO1xuICAgICAgfVxuICAgICAgcGFyZW50LmRhdGEuS2lkcy5wdXNoKGZpZWxkUmVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcm9vdC5kYXRhLkFjcm9Gb3JtLmRhdGEuRmllbGRzLnB1c2goZmllbGRSZWYpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2ZpZWxkRGljdChuYW1lLCB0eXBlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGlmICghdGhpcy5fYWNyb2Zvcm0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbCBkb2N1bWVudC5pbml0Rm9ybSgpIG1ldGhvZCBiZWZvcmUgYWRkaW5nIGZvcm0gZWxlbWVudHMgdG8gZG9jdW1lbnQnKTtcbiAgICB9XG4gICAgbGV0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBpZiAodHlwZSAhPT0gbnVsbCkge1xuICAgICAgb3B0cyA9IHRoaXMuX3Jlc29sdmVUeXBlKHR5cGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBvcHRzID0gdGhpcy5fcmVzb2x2ZUZsYWdzKG9wdHMpO1xuICAgIG9wdHMgPSB0aGlzLl9yZXNvbHZlSnVzdGlmeShvcHRzKTtcbiAgICBvcHRzID0gdGhpcy5fcmVzb2x2ZUZvbnQob3B0cyk7XG4gICAgb3B0cyA9IHRoaXMuX3Jlc29sdmVTdHJpbmdzKG9wdHMpO1xuICAgIG9wdHMgPSB0aGlzLl9yZXNvbHZlQ29sb3JzKG9wdHMpO1xuICAgIG9wdHMgPSB0aGlzLl9yZXNvbHZlRm9ybWF0KG9wdHMpO1xuICAgIG9wdHMuVCA9IG5ldyBTdHJpbmcobmFtZSk7XG4gICAgaWYgKG9wdHMucGFyZW50KSB7XG4gICAgICBvcHRzLlBhcmVudCA9IG9wdHMucGFyZW50O1xuICAgICAgZGVsZXRlIG9wdHMucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gb3B0cztcbiAgfSxcbiAgX3Jlc29sdmVUeXBlKHR5cGUsIG9wdHMpIHtcbiAgICBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBvcHRzLkZUID0gJ1R4JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdwdXNoQnV0dG9uJykge1xuICAgICAgb3B0cy5GVCA9ICdCdG4nO1xuICAgICAgb3B0cy5wdXNoQnV0dG9uID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdyYWRpb0J1dHRvbicpIHtcbiAgICAgIG9wdHMuRlQgPSAnQnRuJztcbiAgICAgIG9wdHMucmFkaW9CdXR0b24gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgb3B0cy5GVCA9ICdCdG4nO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NvbWJvJykge1xuICAgICAgb3B0cy5GVCA9ICdDaCc7XG4gICAgICBvcHRzLmNvbWJvID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgb3B0cy5GVCA9ICdDaCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmb3JtIGFubm90YXRpb24gdHlwZSAnJHt0eXBlfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdHM7XG4gIH0sXG4gIF9yZXNvbHZlRm9ybWF0KG9wdHMpIHtcbiAgICBjb25zdCBmID0gb3B0cy5mb3JtYXQ7XG4gICAgaWYgKGYgJiYgZi50eXBlKSB7XG4gICAgICBsZXQgZm5LZXlzdHJva2U7XG4gICAgICBsZXQgZm5Gb3JtYXQ7XG4gICAgICBsZXQgcGFyYW1zID0gJyc7XG4gICAgICBpZiAoRk9STUFUX1NQRUNJQUxbZi50eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZuS2V5c3Ryb2tlID0gYEFGU3BlY2lhbF9LZXlzdHJva2VgO1xuICAgICAgICBmbkZvcm1hdCA9IGBBRlNwZWNpYWxfRm9ybWF0YDtcbiAgICAgICAgcGFyYW1zID0gRk9STUFUX1NQRUNJQUxbZi50eXBlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBmb3JtYXQgPSBmLnR5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBmLnR5cGUuc2xpY2UoMSk7XG4gICAgICAgIGZuS2V5c3Ryb2tlID0gYEFGJHtmb3JtYXR9X0tleXN0cm9rZWA7XG4gICAgICAgIGZuRm9ybWF0ID0gYEFGJHtmb3JtYXR9X0Zvcm1hdGA7XG4gICAgICAgIGlmIChmLnR5cGUgPT09ICdkYXRlJykge1xuICAgICAgICAgIGZuS2V5c3Ryb2tlICs9ICdFeCc7XG4gICAgICAgICAgcGFyYW1zID0gU3RyaW5nKGYucGFyYW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGYudHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgICAgcGFyYW1zID0gU3RyaW5nKGYucGFyYW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGYudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBsZXQgcCA9IE9iamVjdC5hc3NpZ24oe30sIEZPUk1BVF9ERUZBVUxULm51bWJlciwgZik7XG4gICAgICAgICAgcGFyYW1zID0gU3RyaW5nKFtTdHJpbmcocC5uRGVjKSwgcC5zZXBDb21tYSA/ICcwJyA6ICcxJywgJ1wiJyArIHAubmVnU3R5bGUgKyAnXCInLCAnbnVsbCcsICdcIicgKyBwLmN1cnJlbmN5ICsgJ1wiJywgU3RyaW5nKHAuY3VycmVuY3lQcmVwZW5kKV0uam9pbignLCcpKTtcbiAgICAgICAgfSBlbHNlIGlmIChmLnR5cGUgPT09ICdwZXJjZW50Jykge1xuICAgICAgICAgIGxldCBwID0gT2JqZWN0LmFzc2lnbih7fSwgRk9STUFUX0RFRkFVTFQucGVyY2VudCwgZik7XG4gICAgICAgICAgcGFyYW1zID0gU3RyaW5nKFtTdHJpbmcocC5uRGVjKSwgcC5zZXBDb21tYSA/ICcwJyA6ICcxJ10uam9pbignLCcpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3B0cy5BQSA9IG9wdHMuQUEgPyBvcHRzLkFBIDoge307XG4gICAgICBvcHRzLkFBLksgPSB7XG4gICAgICAgIFM6ICdKYXZhU2NyaXB0JyxcbiAgICAgICAgSlM6IG5ldyBTdHJpbmcoYCR7Zm5LZXlzdHJva2V9KCR7cGFyYW1zfSk7YClcbiAgICAgIH07XG4gICAgICBvcHRzLkFBLkYgPSB7XG4gICAgICAgIFM6ICdKYXZhU2NyaXB0JyxcbiAgICAgICAgSlM6IG5ldyBTdHJpbmcoYCR7Zm5Gb3JtYXR9KCR7cGFyYW1zfSk7YClcbiAgICAgIH07XG4gICAgfVxuICAgIGRlbGV0ZSBvcHRzLmZvcm1hdDtcbiAgICByZXR1cm4gb3B0cztcbiAgfSxcbiAgX3Jlc29sdmVDb2xvcnMob3B0cykge1xuICAgIGxldCBjb2xvciA9IHRoaXMuX25vcm1hbGl6ZUNvbG9yKG9wdHMuYmFja2dyb3VuZENvbG9yKTtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGlmICghb3B0cy5NSykge1xuICAgICAgICBvcHRzLk1LID0ge307XG4gICAgICB9XG4gICAgICBvcHRzLk1LLkJHID0gY29sb3I7XG4gICAgfVxuICAgIGNvbG9yID0gdGhpcy5fbm9ybWFsaXplQ29sb3Iob3B0cy5ib3JkZXJDb2xvcik7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBpZiAoIW9wdHMuTUspIHtcbiAgICAgICAgb3B0cy5NSyA9IHt9O1xuICAgICAgfVxuICAgICAgb3B0cy5NSy5CQyA9IGNvbG9yO1xuICAgIH1cbiAgICBkZWxldGUgb3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgZGVsZXRlIG9wdHMuYm9yZGVyQ29sb3I7XG4gICAgcmV0dXJuIG9wdHM7XG4gIH0sXG4gIF9yZXNvbHZlRmxhZ3Mob3B0aW9ucykge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChGSUVMRF9GTEFHU1trZXldKSB7XG4gICAgICAgIGlmIChvcHRpb25zW2tleV0pIHtcbiAgICAgICAgICByZXN1bHQgfD0gRklFTERfRkxBR1Nba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgb3B0aW9uc1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyZXN1bHQgIT09IDApIHtcbiAgICAgIG9wdGlvbnMuRmYgPSBvcHRpb25zLkZmID8gb3B0aW9ucy5GZiA6IDA7XG4gICAgICBvcHRpb25zLkZmIHw9IHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH0sXG4gIF9yZXNvbHZlSnVzdGlmeShvcHRpb25zKSB7XG4gICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgaWYgKG9wdGlvbnMuYWxpZ24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBGSUVMRF9KVVNUSUZZW29wdGlvbnMuYWxpZ25dID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXN1bHQgPSBGSUVMRF9KVVNUSUZZW29wdGlvbnMuYWxpZ25dO1xuICAgICAgfVxuICAgICAgZGVsZXRlIG9wdGlvbnMuYWxpZ247XG4gICAgfVxuICAgIGlmIChyZXN1bHQgIT09IDApIHtcbiAgICAgIG9wdGlvbnMuUSA9IHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH0sXG4gIF9yZXNvbHZlRm9udChvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuX2Fjcm9mb3JtLmZvbnRzW3RoaXMuX2ZvbnQuaWRdID09IG51bGwpIHtcbiAgICAgIHRoaXMuX2Fjcm9mb3JtLmZvbnRzW3RoaXMuX2ZvbnQuaWRdID0gdGhpcy5fZm9udC5yZWYoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2Fjcm9mb3JtLmRlZmF1bHRGb250ICE9PSB0aGlzLl9mb250Lm5hbWUpIHtcbiAgICAgIG9wdGlvbnMuRFIgPSB7XG4gICAgICAgIEZvbnQ6IHt9XG4gICAgICB9O1xuICAgICAgY29uc3QgZm9udFNpemUgPSBvcHRpb25zLmZvbnRTaXplIHx8IDA7XG4gICAgICBvcHRpb25zLkRSLkZvbnRbdGhpcy5fZm9udC5pZF0gPSB0aGlzLl9mb250LnJlZigpO1xuICAgICAgb3B0aW9ucy5EQSA9IG5ldyBTdHJpbmcoYC8ke3RoaXMuX2ZvbnQuaWR9ICR7Zm9udFNpemV9IFRmIDAgZ2ApO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfSxcbiAgX3Jlc29sdmVTdHJpbmdzKG9wdGlvbnMpIHtcbiAgICBsZXQgc2VsZWN0ID0gW107XG4gICAgZnVuY3Rpb24gYXBwZW5kQ2hvaWNlcyhhKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBhLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFbaWR4XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNlbGVjdC5wdXNoKG5ldyBTdHJpbmcoYVtpZHhdKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdC5wdXNoKGFbaWR4XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGFwcGVuZENob2ljZXMob3B0aW9ucy5PcHQpO1xuICAgIGlmIChvcHRpb25zLnNlbGVjdCkge1xuICAgICAgYXBwZW5kQ2hvaWNlcyhvcHRpb25zLnNlbGVjdCk7XG4gICAgICBkZWxldGUgb3B0aW9ucy5zZWxlY3Q7XG4gICAgfVxuICAgIGlmIChzZWxlY3QubGVuZ3RoKSB7XG4gICAgICBvcHRpb25zLk9wdCA9IHNlbGVjdDtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoVkFMVUVfTUFQKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAob3B0aW9uc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9uc1tWQUxVRV9NQVBba2V5XV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgWydWJywgJ0RWJ10uZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zW2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnNba2V5XSA9IG5ldyBTdHJpbmcob3B0aW9uc1trZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5NSyAmJiBvcHRpb25zLk1LLkNBKSB7XG4gICAgICBvcHRpb25zLk1LLkNBID0gbmV3IFN0cmluZyhvcHRpb25zLk1LLkNBKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGFiZWwpIHtcbiAgICAgIG9wdGlvbnMuTUsgPSBvcHRpb25zLk1LID8gb3B0aW9ucy5NSyA6IHt9O1xuICAgICAgb3B0aW9ucy5NSy5DQSA9IG5ldyBTdHJpbmcob3B0aW9ucy5sYWJlbCk7XG4gICAgICBkZWxldGUgb3B0aW9ucy5sYWJlbDtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbn07XG5cbnZhciBBdHRhY2htZW50c01peGluID0ge1xuICBmaWxlKHNyYykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBvcHRpb25zLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgc3JjO1xuICAgIG9wdGlvbnMucmVsYXRpb25zaGlwID0gb3B0aW9ucy5yZWxhdGlvbnNoaXAgfHwgJ1Vuc3BlY2lmaWVkJztcbiAgICBjb25zdCByZWZCb2R5ID0ge1xuICAgICAgVHlwZTogJ0VtYmVkZGVkRmlsZScsXG4gICAgICBQYXJhbXM6IHt9XG4gICAgfTtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoIXNyYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzcmMgc3BlY2lmaWVkJyk7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3JjKSkge1xuICAgICAgZGF0YSA9IHNyYztcbiAgICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBkYXRhID0gQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkoc3JjKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gL15kYXRhOiguKj8pO2Jhc2U2NCwoLiopJC8uZXhlYyhzcmMpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgIHJlZkJvZHkuU3VidHlwZSA9IG1hdGNoWzFdLnJlcGxhY2UoJy8nLCAnIzJGJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKG1hdGNoWzJdLCAnYmFzZTY0Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gZnMucmVhZEZpbGVTeW5jKHNyYyk7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHJlYWQgY29udGVudHMgb2YgZmlsZSBhdCBmaWxlcGF0aCAke3NyY31gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYmlydGh0aW1lLFxuICAgICAgICAgIGN0aW1lXG4gICAgICAgIH0gPSBmcy5zdGF0U3luYyhzcmMpO1xuICAgICAgICByZWZCb2R5LlBhcmFtcy5DcmVhdGlvbkRhdGUgPSBiaXJ0aHRpbWU7XG4gICAgICAgIHJlZkJvZHkuUGFyYW1zLk1vZERhdGUgPSBjdGltZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY3JlYXRpb25EYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmVmQm9keS5QYXJhbXMuQ3JlYXRpb25EYXRlID0gb3B0aW9ucy5jcmVhdGlvbkRhdGU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm1vZGlmaWVkRGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJlZkJvZHkuUGFyYW1zLk1vZERhdGUgPSBvcHRpb25zLm1vZGlmaWVkRGF0ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudHlwZSkge1xuICAgICAgcmVmQm9keS5TdWJ0eXBlID0gb3B0aW9ucy50eXBlLnJlcGxhY2UoJy8nLCAnIzJGJyk7XG4gICAgfVxuICAgIGNvbnN0IGNoZWNrc3VtID0gQ3J5cHRvSlMuTUQ1KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKG5ldyBVaW50OEFycmF5KGRhdGEpKSk7XG4gICAgcmVmQm9keS5QYXJhbXMuQ2hlY2tTdW0gPSBuZXcgU3RyaW5nKGNoZWNrc3VtKTtcbiAgICByZWZCb2R5LlBhcmFtcy5TaXplID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIGxldCByZWY7XG4gICAgaWYgKCF0aGlzLl9maWxlUmVnaXN0cnkpIHRoaXMuX2ZpbGVSZWdpc3RyeSA9IHt9O1xuICAgIGxldCBmaWxlID0gdGhpcy5fZmlsZVJlZ2lzdHJ5W29wdGlvbnMubmFtZV07XG4gICAgaWYgKGZpbGUgJiYgaXNFcXVhbChyZWZCb2R5LCBmaWxlKSkge1xuICAgICAgcmVmID0gZmlsZS5yZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZiA9IHRoaXMucmVmKHJlZkJvZHkpO1xuICAgICAgcmVmLmVuZChkYXRhKTtcbiAgICAgIHRoaXMuX2ZpbGVSZWdpc3RyeVtvcHRpb25zLm5hbWVdID0ge1xuICAgICAgICAuLi5yZWZCb2R5LFxuICAgICAgICByZWZcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGZpbGVTcGVjQm9keSA9IHtcbiAgICAgIFR5cGU6ICdGaWxlc3BlYycsXG4gICAgICBBRlJlbGF0aW9uc2hpcDogb3B0aW9ucy5yZWxhdGlvbnNoaXAsXG4gICAgICBGOiBuZXcgU3RyaW5nKG9wdGlvbnMubmFtZSksXG4gICAgICBFRjoge1xuICAgICAgICBGOiByZWZcbiAgICAgIH0sXG4gICAgICBVRjogbmV3IFN0cmluZyhvcHRpb25zLm5hbWUpXG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5kZXNjcmlwdGlvbikge1xuICAgICAgZmlsZVNwZWNCb2R5LkRlc2MgPSBuZXcgU3RyaW5nKG9wdGlvbnMuZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmaWxlc3BlYyA9IHRoaXMucmVmKGZpbGVTcGVjQm9keSk7XG4gICAgZmlsZXNwZWMuZW5kKCk7XG4gICAgaWYgKCFvcHRpb25zLmhpZGRlbikge1xuICAgICAgdGhpcy5hZGROYW1lZEVtYmVkZGVkRmlsZShvcHRpb25zLm5hbWUsIGZpbGVzcGVjKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Jvb3QuZGF0YS5BRikge1xuICAgICAgdGhpcy5fcm9vdC5kYXRhLkFGLnB1c2goZmlsZXNwZWMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yb290LmRhdGEuQUYgPSBbZmlsZXNwZWNdO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZXNwZWM7XG4gIH1cbn07XG5mdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEuU3VidHlwZSA9PT0gYi5TdWJ0eXBlICYmIGEuUGFyYW1zLkNoZWNrU3VtLnRvU3RyaW5nKCkgPT09IGIuUGFyYW1zLkNoZWNrU3VtLnRvU3RyaW5nKCkgJiYgYS5QYXJhbXMuU2l6ZSA9PT0gYi5QYXJhbXMuU2l6ZSAmJiBhLlBhcmFtcy5DcmVhdGlvbkRhdGUuZ2V0VGltZSgpID09PSBiLlBhcmFtcy5DcmVhdGlvbkRhdGUuZ2V0VGltZSgpICYmIChhLlBhcmFtcy5Nb2REYXRlID09PSB1bmRlZmluZWQgJiYgYi5QYXJhbXMuTW9kRGF0ZSA9PT0gdW5kZWZpbmVkIHx8IGEuUGFyYW1zLk1vZERhdGUuZ2V0VGltZSgpID09PSBiLlBhcmFtcy5Nb2REYXRlLmdldFRpbWUoKSk7XG59XG5cbnZhciBQREZBID0ge1xuICBpbml0UERGQShwU3Vic2V0KSB7XG4gICAgaWYgKHBTdWJzZXQuY2hhckF0KHBTdWJzZXQubGVuZ3RoIC0gMykgPT09ICctJykge1xuICAgICAgdGhpcy5zdWJzZXRfY29uZm9ybWFuY2UgPSBwU3Vic2V0LmNoYXJBdChwU3Vic2V0Lmxlbmd0aCAtIDEpLnRvVXBwZXJDYXNlKCk7XG4gICAgICB0aGlzLnN1YnNldCA9IHBhcnNlSW50KHBTdWJzZXQuY2hhckF0KHBTdWJzZXQubGVuZ3RoIC0gMikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN1YnNldF9jb25mb3JtYW5jZSA9ICdCJztcbiAgICAgIHRoaXMuc3Vic2V0ID0gcGFyc2VJbnQocFN1YnNldC5jaGFyQXQocFN1YnNldC5sZW5ndGggLSAxKSk7XG4gICAgfVxuICB9LFxuICBlbmRTdWJzZXQoKSB7XG4gICAgdGhpcy5fYWRkUGRmYU1ldGFkYXRhKCk7XG4gICAgdGhpcy5fYWRkQ29sb3JPdXRwdXRJbnRlbnQoKTtcbiAgfSxcbiAgX2FkZENvbG9yT3V0cHV0SW50ZW50KCkge1xuICAgIGNvbnN0IGljY1Byb2ZpbGUgPSBmcy5yZWFkRmlsZVN5bmMoYCR7X19kaXJuYW1lfS9kYXRhL3NSR0JfSUVDNjE5NjZfMl8xLmljY2ApO1xuICAgIGNvbnN0IGNvbG9yUHJvZmlsZVJlZiA9IHRoaXMucmVmKHtcbiAgICAgIExlbmd0aDogaWNjUHJvZmlsZS5sZW5ndGgsXG4gICAgICBOOiAzXG4gICAgfSk7XG4gICAgY29sb3JQcm9maWxlUmVmLndyaXRlKGljY1Byb2ZpbGUpO1xuICAgIGNvbG9yUHJvZmlsZVJlZi5lbmQoKTtcbiAgICBjb25zdCBpbnRlbnRSZWYgPSB0aGlzLnJlZih7XG4gICAgICBUeXBlOiAnT3V0cHV0SW50ZW50JyxcbiAgICAgIFM6ICdHVFNfUERGQTEnLFxuICAgICAgSW5mbzogbmV3IFN0cmluZygnc1JHQiBJRUM2MTk2Ni0yLjEnKSxcbiAgICAgIE91dHB1dENvbmRpdGlvbklkZW50aWZpZXI6IG5ldyBTdHJpbmcoJ3NSR0IgSUVDNjE5NjYtMi4xJyksXG4gICAgICBEZXN0T3V0cHV0UHJvZmlsZTogY29sb3JQcm9maWxlUmVmXG4gICAgfSk7XG4gICAgaW50ZW50UmVmLmVuZCgpO1xuICAgIHRoaXMuX3Jvb3QuZGF0YS5PdXRwdXRJbnRlbnRzID0gW2ludGVudFJlZl07XG4gIH0sXG4gIF9nZXRQZGZhaWQoKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgPHJkZjpEZXNjcmlwdGlvbiB4bWxuczpwZGZhaWQ9XCJodHRwOi8vd3d3LmFpaW0ub3JnL3BkZmEvbnMvaWQvXCIgcmRmOmFib3V0PVwiXCI+XG4gICAgICAgICAgICA8cGRmYWlkOnBhcnQ+JHt0aGlzLnN1YnNldH08L3BkZmFpZDpwYXJ0PlxuICAgICAgICAgICAgPHBkZmFpZDpjb25mb3JtYW5jZT4ke3RoaXMuc3Vic2V0X2NvbmZvcm1hbmNlfTwvcGRmYWlkOmNvbmZvcm1hbmNlPlxuICAgICAgICA8L3JkZjpEZXNjcmlwdGlvbj5cbiAgICAgICAgYDtcbiAgfSxcbiAgX2FkZFBkZmFNZXRhZGF0YSgpIHtcbiAgICB0aGlzLmFwcGVuZFhNTCh0aGlzLl9nZXRQZGZhaWQoKSk7XG4gIH1cbn07XG5cbnZhciBQREZVQSA9IHtcbiAgaW5pdFBERlVBKCkge1xuICAgIHRoaXMuc3Vic2V0ID0gMTtcbiAgfSxcbiAgZW5kU3Vic2V0KCkge1xuICAgIHRoaXMuX2FkZFBkZnVhTWV0YWRhdGEoKTtcbiAgfSxcbiAgX2FkZFBkZnVhTWV0YWRhdGEoKSB7XG4gICAgdGhpcy5hcHBlbmRYTUwodGhpcy5fZ2V0UGRmdWFpZCgpKTtcbiAgfSxcbiAgX2dldFBkZnVhaWQoKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgPHJkZjpEZXNjcmlwdGlvbiB4bWxuczpwZGZ1YWlkPVwiaHR0cDovL3d3dy5haWltLm9yZy9wZGZ1YS9ucy9pZC9cIiByZGY6YWJvdXQ9XCJcIj5cbiAgICAgICAgICAgIDxwZGZ1YWlkOnBhcnQ+JHt0aGlzLnN1YnNldH08L3BkZnVhaWQ6cGFydD5cbiAgICAgICAgPC9yZGY6RGVzY3JpcHRpb24+XG4gICAgICAgIGA7XG4gIH1cbn07XG5cbnZhciBTdWJzZXRNaXhpbiA9IHtcbiAgX2ltcG9ydFN1YnNldChzdWJzZXQpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHN1YnNldCk7XG4gIH0sXG4gIGluaXRTdWJzZXQob3B0aW9ucykge1xuICAgIHN3aXRjaCAob3B0aW9ucy5zdWJzZXQpIHtcbiAgICAgIGNhc2UgJ1BERi9BLTEnOlxuICAgICAgY2FzZSAnUERGL0EtMWEnOlxuICAgICAgY2FzZSAnUERGL0EtMWInOlxuICAgICAgY2FzZSAnUERGL0EtMic6XG4gICAgICBjYXNlICdQREYvQS0yYSc6XG4gICAgICBjYXNlICdQREYvQS0yYic6XG4gICAgICBjYXNlICdQREYvQS0zJzpcbiAgICAgIGNhc2UgJ1BERi9BLTNhJzpcbiAgICAgIGNhc2UgJ1BERi9BLTNiJzpcbiAgICAgICAgdGhpcy5faW1wb3J0U3Vic2V0KFBERkEpO1xuICAgICAgICB0aGlzLmluaXRQREZBKG9wdGlvbnMuc3Vic2V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdQREYvVUEnOlxuICAgICAgICB0aGlzLl9pbXBvcnRTdWJzZXQoUERGVUEpO1xuICAgICAgICB0aGlzLmluaXRQREZVQSgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IFJPV19GSUVMRFMgPSBbJ2hlaWdodCcsICdtaW5IZWlnaHQnLCAnbWF4SGVpZ2h0J107XG5jb25zdCBDT0xVTU5fRklFTERTID0gWyd3aWR0aCcsICdtaW5XaWR0aCcsICdtYXhXaWR0aCddO1xuZnVuY3Rpb24gbWVtb2l6ZShmbiwgbWF4U2l6ZSkge1xuICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMF07XG4gICAgaWYgKCFjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgY2FjaGUuc2V0KGtleSwgZm4oLi4uYXJndW1lbnRzKSk7XG4gICAgICBpZiAoY2FjaGUuc2l6ZSA+IG1heFNpemUpIGNhY2hlLmRlbGV0ZShjYWNoZS5rZXlzKCkubmV4dCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICB9O1xufVxuZnVuY3Rpb24gaXNPYmplY3QoaXRlbSkge1xuICByZXR1cm4gaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaXRlbSk7XG59XG5mdW5jdGlvbiBkZWVwTWVyZ2UodGFyZ2V0KSB7XG4gIGlmICghaXNPYmplY3QodGFyZ2V0KSkgcmV0dXJuIHRhcmdldDtcbiAgdGFyZ2V0ID0gZGVlcENsb25lKHRhcmdldCk7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzb3VyY2VzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoaXNPYmplY3Qoc291cmNlW2tleV0pKSB7XG4gICAgICAgICAgaWYgKCEoa2V5IGluIHRhcmdldCkpIHRhcmdldFtrZXldID0ge307XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBkZWVwTWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Vba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBkZWVwQ2xvbmUoc291cmNlW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBkZWVwQ2xvbmUob2JqKSB7XG4gIGxldCByZXN1bHQgPSBvYmo7XG4gIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PSAnb2JqZWN0Jykge1xuICAgIHJlc3VsdCA9IEFycmF5LmlzQXJyYXkob2JqKSA/IFtdIDoge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSByZXN1bHRba2V5XSA9IGRlZXBDbG9uZShvYmpba2V5XSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplZERlZmF1bHRTdHlsZShkZWZhdWx0U3R5bGVJbnRlcm5hbCkge1xuICBsZXQgZGVmYXVsdFN0eWxlID0gZGVmYXVsdFN0eWxlSW50ZXJuYWw7XG4gIGlmICh0eXBlb2YgZGVmYXVsdFN0eWxlICE9PSAnb2JqZWN0JykgZGVmYXVsdFN0eWxlID0ge1xuICAgIHRleHQ6IGRlZmF1bHRTdHlsZVxuICB9O1xuICBjb25zdCBkZWZhdWx0Um93U3R5bGUgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoZGVmYXVsdFN0eWxlKS5maWx0ZXIoX3JlZiA9PiB7XG4gICAgbGV0IFtrXSA9IF9yZWY7XG4gICAgcmV0dXJuIFJPV19GSUVMRFMuaW5jbHVkZXMoayk7XG4gIH0pKTtcbiAgY29uc3QgZGVmYXVsdENvbFN0eWxlID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGRlZmF1bHRTdHlsZSkuZmlsdGVyKF9yZWYyID0+IHtcbiAgICBsZXQgW2tdID0gX3JlZjI7XG4gICAgcmV0dXJuIENPTFVNTl9GSUVMRFMuaW5jbHVkZXMoayk7XG4gIH0pKTtcbiAgZGVmYXVsdFN0eWxlLnBhZGRpbmcgPSBub3JtYWxpemVTaWRlcyhkZWZhdWx0U3R5bGUucGFkZGluZyk7XG4gIGRlZmF1bHRTdHlsZS5ib3JkZXIgPSBub3JtYWxpemVTaWRlcyhkZWZhdWx0U3R5bGUuYm9yZGVyKTtcbiAgZGVmYXVsdFN0eWxlLmJvcmRlckNvbG9yID0gbm9ybWFsaXplU2lkZXMoZGVmYXVsdFN0eWxlLmJvcmRlckNvbG9yKTtcbiAgZGVmYXVsdFN0eWxlLmFsaWduID0gbm9ybWFsaXplQWxpZ25tZW50KGRlZmF1bHRTdHlsZS5hbGlnbik7XG4gIHJldHVybiB7XG4gICAgZGVmYXVsdFN0eWxlLFxuICAgIGRlZmF1bHRSb3dTdHlsZSxcbiAgICBkZWZhdWx0Q29sU3R5bGVcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZWRSb3dTdHlsZShkZWZhdWx0Um93U3R5bGUsIHJvd1N0eWxlSW50ZXJuYWwsIGkpIHtcbiAgbGV0IHJvd1N0eWxlID0gcm93U3R5bGVJbnRlcm5hbChpKTtcbiAgaWYgKHJvd1N0eWxlID09IG51bGwgfHwgdHlwZW9mIHJvd1N0eWxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJvd1N0eWxlID0ge1xuICAgICAgaGVpZ2h0OiByb3dTdHlsZVxuICAgIH07XG4gIH1cbiAgcm93U3R5bGUucGFkZGluZyA9IG5vcm1hbGl6ZVNpZGVzKHJvd1N0eWxlLnBhZGRpbmcpO1xuICByb3dTdHlsZS5ib3JkZXIgPSBub3JtYWxpemVTaWRlcyhyb3dTdHlsZS5ib3JkZXIpO1xuICByb3dTdHlsZS5ib3JkZXJDb2xvciA9IG5vcm1hbGl6ZVNpZGVzKHJvd1N0eWxlLmJvcmRlckNvbG9yKTtcbiAgcm93U3R5bGUuYWxpZ24gPSBub3JtYWxpemVBbGlnbm1lbnQocm93U3R5bGUuYWxpZ24pO1xuICByb3dTdHlsZSA9IGRlZXBNZXJnZShkZWZhdWx0Um93U3R5bGUsIHJvd1N0eWxlKTtcbiAgY29uc3QgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50O1xuICBjb25zdCBwYWdlID0gZG9jdW1lbnQucGFnZTtcbiAgY29uc3QgY29udGVudEhlaWdodCA9IHBhZ2UuY29udGVudEhlaWdodDtcbiAgaWYgKHJvd1N0eWxlLmhlaWdodCA9PSBudWxsIHx8IHJvd1N0eWxlLmhlaWdodCA9PT0gJ2F1dG8nKSB7XG4gICAgcm93U3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICB9IGVsc2Uge1xuICAgIHJvd1N0eWxlLmhlaWdodCA9IGRvY3VtZW50LnNpemVUb1BvaW50KHJvd1N0eWxlLmhlaWdodCwgMCwgcGFnZSwgY29udGVudEhlaWdodCk7XG4gIH1cbiAgcm93U3R5bGUubWluSGVpZ2h0ID0gZG9jdW1lbnQuc2l6ZVRvUG9pbnQocm93U3R5bGUubWluSGVpZ2h0LCAwLCBwYWdlLCBjb250ZW50SGVpZ2h0KTtcbiAgcm93U3R5bGUubWF4SGVpZ2h0ID0gZG9jdW1lbnQuc2l6ZVRvUG9pbnQocm93U3R5bGUubWF4SGVpZ2h0LCAwLCBwYWdlLCBjb250ZW50SGVpZ2h0KTtcbiAgcmV0dXJuIHJvd1N0eWxlO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplZENvbHVtblN0eWxlKGRlZmF1bHRDb2xTdHlsZSwgY29sU3R5bGVJbnRlcm5hbCwgaSkge1xuICBsZXQgY29sU3R5bGUgPSBjb2xTdHlsZUludGVybmFsKGkpO1xuICBpZiAoY29sU3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgY29sU3R5bGUgIT09ICdvYmplY3QnKSB7XG4gICAgY29sU3R5bGUgPSB7XG4gICAgICB3aWR0aDogY29sU3R5bGVcbiAgICB9O1xuICB9XG4gIGNvbFN0eWxlLnBhZGRpbmcgPSBub3JtYWxpemVTaWRlcyhjb2xTdHlsZS5wYWRkaW5nKTtcbiAgY29sU3R5bGUuYm9yZGVyID0gbm9ybWFsaXplU2lkZXMoY29sU3R5bGUuYm9yZGVyKTtcbiAgY29sU3R5bGUuYm9yZGVyQ29sb3IgPSBub3JtYWxpemVTaWRlcyhjb2xTdHlsZS5ib3JkZXJDb2xvcik7XG4gIGNvbFN0eWxlLmFsaWduID0gbm9ybWFsaXplQWxpZ25tZW50KGNvbFN0eWxlLmFsaWduKTtcbiAgY29sU3R5bGUgPSBkZWVwTWVyZ2UoZGVmYXVsdENvbFN0eWxlLCBjb2xTdHlsZSk7XG4gIGlmIChjb2xTdHlsZS53aWR0aCA9PSBudWxsIHx8IGNvbFN0eWxlLndpZHRoID09PSAnKicpIHtcbiAgICBjb2xTdHlsZS53aWR0aCA9ICcqJztcbiAgfSBlbHNlIHtcbiAgICBjb2xTdHlsZS53aWR0aCA9IHRoaXMuZG9jdW1lbnQuc2l6ZVRvUG9pbnQoY29sU3R5bGUud2lkdGgsIDAsIHRoaXMuZG9jdW1lbnQucGFnZSwgdGhpcy5fbWF4V2lkdGgpO1xuICB9XG4gIGNvbFN0eWxlLm1pbldpZHRoID0gdGhpcy5kb2N1bWVudC5zaXplVG9Qb2ludChjb2xTdHlsZS5taW5XaWR0aCwgMCwgdGhpcy5kb2N1bWVudC5wYWdlLCB0aGlzLl9tYXhXaWR0aCk7XG4gIGNvbFN0eWxlLm1heFdpZHRoID0gdGhpcy5kb2N1bWVudC5zaXplVG9Qb2ludChjb2xTdHlsZS5tYXhXaWR0aCwgMCwgdGhpcy5kb2N1bWVudC5wYWdlLCB0aGlzLl9tYXhXaWR0aCk7XG4gIHJldHVybiBjb2xTdHlsZTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFsaWdubWVudChhbGlnbikge1xuICByZXR1cm4gYWxpZ24gPT0gbnVsbCB8fCB0eXBlb2YgYWxpZ24gPT09ICdzdHJpbmcnID8ge1xuICAgIHg6IGFsaWduLFxuICAgIHk6IGFsaWduXG4gIH0gOiBhbGlnbjtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVGFibGUoKSB7XG4gIGNvbnN0IGRvYyA9IHRoaXMuZG9jdW1lbnQ7XG4gIGNvbnN0IG9wdHMgPSB0aGlzLm9wdHM7XG4gIGxldCBpbmRleCA9IGRvYy5fdGFibGVJbmRleCsrO1xuICB0aGlzLl9pZCA9IG5ldyBTdHJpbmcob3B0cy5pZCA/PyBgdGFibGUtJHtpbmRleH1gKTtcbiAgdGhpcy5fcG9zaXRpb24gPSB7XG4gICAgeDogZG9jLnNpemVUb1BvaW50KG9wdHMucG9zaXRpb24/LngsIGRvYy54KSxcbiAgICB5OiBkb2Muc2l6ZVRvUG9pbnQob3B0cy5wb3NpdGlvbj8ueSwgZG9jLnkpXG4gIH07XG4gIHRoaXMuX21heFdpZHRoID0gZG9jLnNpemVUb1BvaW50KG9wdHMubWF4V2lkdGgsIGRvYy5wYWdlLndpZHRoIC0gZG9jLnBhZ2UubWFyZ2lucy5yaWdodCAtIHRoaXMuX3Bvc2l0aW9uLngpO1xuICBjb25zdCB7XG4gICAgZGVmYXVsdFN0eWxlLFxuICAgIGRlZmF1bHRDb2xTdHlsZSxcbiAgICBkZWZhdWx0Um93U3R5bGVcbiAgfSA9IG5vcm1hbGl6ZWREZWZhdWx0U3R5bGUob3B0cy5kZWZhdWx0U3R5bGUpO1xuICB0aGlzLl9kZWZhdWx0U3R5bGUgPSBkZWZhdWx0U3R5bGU7XG4gIGxldCBjb2xTdHlsZTtcbiAgaWYgKG9wdHMuY29sdW1uU3R5bGVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5jb2x1bW5TdHlsZXMpKSB7XG4gICAgICBjb2xTdHlsZSA9IGkgPT4gb3B0cy5jb2x1bW5TdHlsZXNbaV07XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5jb2x1bW5TdHlsZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbFN0eWxlID0gbWVtb2l6ZShpID0+IG9wdHMuY29sdW1uU3R5bGVzKGkpLCBJbmZpbml0eSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5jb2x1bW5TdHlsZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICBjb2xTdHlsZSA9ICgpID0+IG9wdHMuY29sdW1uU3R5bGVzO1xuICAgIH1cbiAgfVxuICBpZiAoIWNvbFN0eWxlKSBjb2xTdHlsZSA9ICgpID0+ICh7fSk7XG4gIHRoaXMuX2NvbFN0eWxlID0gbm9ybWFsaXplZENvbHVtblN0eWxlLmJpbmQodGhpcywgZGVmYXVsdENvbFN0eWxlLCBjb2xTdHlsZSk7XG4gIGxldCByb3dTdHlsZTtcbiAgaWYgKG9wdHMucm93U3R5bGVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5yb3dTdHlsZXMpKSB7XG4gICAgICByb3dTdHlsZSA9IGkgPT4gb3B0cy5yb3dTdHlsZXNbaV07XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5yb3dTdHlsZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJvd1N0eWxlID0gbWVtb2l6ZShpID0+IG9wdHMucm93U3R5bGVzKGkpLCAxMCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5yb3dTdHlsZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICByb3dTdHlsZSA9ICgpID0+IG9wdHMucm93U3R5bGVzO1xuICAgIH1cbiAgfVxuICBpZiAoIXJvd1N0eWxlKSByb3dTdHlsZSA9ICgpID0+ICh7fSk7XG4gIHRoaXMuX3Jvd1N0eWxlID0gbm9ybWFsaXplZFJvd1N0eWxlLmJpbmQodGhpcywgZGVmYXVsdFJvd1N0eWxlLCByb3dTdHlsZSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVUZXh0KHRleHQpIHtcbiAgaWYgKHRleHQgIT0gbnVsbCkgdGV4dCA9IGAke3RleHR9YDtcbiAgcmV0dXJuIHRleHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDZWxsKGNlbGwsIHJvd0luZGV4LCBjb2xJbmRleCkge1xuICBjb25zdCBjb2xTdHlsZSA9IHRoaXMuX2NvbFN0eWxlKGNvbEluZGV4KTtcbiAgbGV0IHJvd1N0eWxlID0gdGhpcy5fcm93U3R5bGUocm93SW5kZXgpO1xuICBjb25zdCBmb250ID0gZGVlcE1lcmdlKHt9LCBjb2xTdHlsZS5mb250LCByb3dTdHlsZS5mb250LCBjZWxsLmZvbnQpO1xuICBjb25zdCBjdXN0b21Gb250ID0gT2JqZWN0LnZhbHVlcyhmb250KS5maWx0ZXIodiA9PiB2ICE9IG51bGwpLmxlbmd0aCA+IDA7XG4gIGNvbnN0IGRvYyA9IHRoaXMuZG9jdW1lbnQ7XG4gIGNvbnN0IHJvbGxiYWNrRm9udCA9IGRvYy5fZm9udFNvdXJjZTtcbiAgY29uc3Qgcm9sbGJhY2tGb250U2l6ZSA9IGRvYy5fZm9udFNpemU7XG4gIGNvbnN0IHJvbGxiYWNrRm9udEZhbWlseSA9IGRvYy5fZm9udEZhbWlseTtcbiAgaWYgKGN1c3RvbUZvbnQpIHtcbiAgICBpZiAoZm9udC5zcmMpIGRvYy5mb250KGZvbnQuc3JjLCBmb250LmZhbWlseSk7XG4gICAgaWYgKGZvbnQuc2l6ZSkgZG9jLmZvbnRTaXplKGZvbnQuc2l6ZSk7XG4gICAgcm93U3R5bGUgPSB0aGlzLl9yb3dTdHlsZShyb3dJbmRleCk7XG4gIH1cbiAgY2VsbC5wYWRkaW5nID0gbm9ybWFsaXplU2lkZXMoY2VsbC5wYWRkaW5nKTtcbiAgY2VsbC5ib3JkZXIgPSBub3JtYWxpemVTaWRlcyhjZWxsLmJvcmRlcik7XG4gIGNlbGwuYm9yZGVyQ29sb3IgPSBub3JtYWxpemVTaWRlcyhjZWxsLmJvcmRlckNvbG9yKTtcbiAgY29uc3QgY29uZmlnID0gZGVlcE1lcmdlKHRoaXMuX2RlZmF1bHRTdHlsZSwgY29sU3R5bGUsIHJvd1N0eWxlLCBjZWxsKTtcbiAgY29uZmlnLnJvd0luZGV4ID0gcm93SW5kZXg7XG4gIGNvbmZpZy5jb2xJbmRleCA9IGNvbEluZGV4O1xuICBjb25maWcuZm9udCA9IGZvbnQgPz8ge307XG4gIGNvbmZpZy5jdXN0b21Gb250ID0gY3VzdG9tRm9udDtcbiAgY29uZmlnLnRleHQgPSBub3JtYWxpemVUZXh0KGNvbmZpZy50ZXh0KTtcbiAgY29uZmlnLnJvd1NwYW4gPSBjb25maWcucm93U3BhbiA/PyAxO1xuICBjb25maWcuY29sU3BhbiA9IGNvbmZpZy5jb2xTcGFuID8/IDE7XG4gIGNvbmZpZy5wYWRkaW5nID0gbm9ybWFsaXplU2lkZXMoY29uZmlnLnBhZGRpbmcsICcwLjI1ZW0nLCB4ID0+IGRvYy5zaXplVG9Qb2ludCh4LCAnMC4yNWVtJykpO1xuICBjb25maWcuYm9yZGVyID0gbm9ybWFsaXplU2lkZXMoY29uZmlnLmJvcmRlciwgMSwgeCA9PiBkb2Muc2l6ZVRvUG9pbnQoeCwgMSkpO1xuICBjb25maWcuYm9yZGVyQ29sb3IgPSBub3JtYWxpemVTaWRlcyhjb25maWcuYm9yZGVyQ29sb3IsICdibGFjaycsIHggPT4geCA/PyAnYmxhY2snKTtcbiAgY29uZmlnLmFsaWduID0gbm9ybWFsaXplQWxpZ25tZW50KGNvbmZpZy5hbGlnbik7XG4gIGNvbmZpZy5hbGlnbi54ID0gY29uZmlnLmFsaWduLnggPz8gJ2xlZnQnO1xuICBjb25maWcuYWxpZ24ueSA9IGNvbmZpZy5hbGlnbi55ID8/ICd0b3AnO1xuICBjb25maWcudGV4dFN0cm9rZSA9IGRvYy5zaXplVG9Qb2ludChjb25maWcudGV4dFN0cm9rZSwgMCk7XG4gIGNvbmZpZy50ZXh0U3Ryb2tlQ29sb3IgPSBjb25maWcudGV4dFN0cm9rZUNvbG9yID8/ICdibGFjayc7XG4gIGNvbmZpZy50ZXh0Q29sb3IgPSBjb25maWcudGV4dENvbG9yID8/ICdibGFjayc7XG4gIGNvbmZpZy50ZXh0T3B0aW9ucyA9IGNvbmZpZy50ZXh0T3B0aW9ucyA/PyB7fTtcbiAgY29uZmlnLmlkID0gbmV3IFN0cmluZyhjb25maWcuaWQgPz8gYCR7dGhpcy5faWR9LSR7cm93SW5kZXh9LSR7Y29sSW5kZXh9YCk7XG4gIGNvbmZpZy50eXBlID0gY29uZmlnLnR5cGU/LnRvVXBwZXJDYXNlKCkgPT09ICdUSCcgPyAnVEgnIDogJ1REJztcbiAgaWYgKGNvbmZpZy5zY29wZSkge1xuICAgIGNvbmZpZy5zY29wZSA9IGNvbmZpZy5zY29wZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChjb25maWcuc2NvcGUgPT09ICdyb3cnKSBjb25maWcuc2NvcGUgPSAnUm93JztlbHNlIGlmIChjb25maWcuc2NvcGUgPT09ICdib3RoJykgY29uZmlnLnNjb3BlID0gJ0JvdGgnO2Vsc2UgaWYgKGNvbmZpZy5zY29wZSA9PT0gJ2NvbHVtbicpIGNvbmZpZy5zY29wZSA9ICdDb2x1bW4nO1xuICB9XG4gIGlmICh0eXBlb2YgdGhpcy5vcHRzLmRlYnVnID09PSAnYm9vbGVhbicpIGNvbmZpZy5kZWJ1ZyA9IHRoaXMub3B0cy5kZWJ1ZztcbiAgaWYgKGN1c3RvbUZvbnQpIGRvYy5mb250KHJvbGxiYWNrRm9udCwgcm9sbGJhY2tGb250RmFtaWx5LCByb2xsYmFja0ZvbnRTaXplKTtcbiAgcmV0dXJuIGNvbmZpZztcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJvdyhyb3csIHJvd0luZGV4KSB7XG4gIGlmICghdGhpcy5fY2VsbENsYWltKSB0aGlzLl9jZWxsQ2xhaW0gPSBuZXcgU2V0KCk7XG4gIGxldCBjb2xJbmRleCA9IDA7XG4gIHJldHVybiByb3cubWFwKGNlbGwgPT4ge1xuICAgIGlmIChjZWxsID09IG51bGwgfHwgdHlwZW9mIGNlbGwgIT09ICdvYmplY3QnKSBjZWxsID0ge1xuICAgICAgdGV4dDogY2VsbFxuICAgIH07XG4gICAgd2hpbGUgKHRoaXMuX2NlbGxDbGFpbS5oYXMoYCR7cm93SW5kZXh9LCR7Y29sSW5kZXh9YCkpIHtcbiAgICAgIGNvbEluZGV4Kys7XG4gICAgfVxuICAgIGNlbGwgPSBub3JtYWxpemVDZWxsLmNhbGwodGhpcywgY2VsbCwgcm93SW5kZXgsIGNvbEluZGV4KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbGwucm93U3BhbjsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNlbGwuY29sU3BhbjsgaisrKSB7XG4gICAgICAgIHRoaXMuX2NlbGxDbGFpbS5hZGQoYCR7cm93SW5kZXggKyBpfSwke2NvbEluZGV4ICsgan1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29sSW5kZXggKz0gY2VsbC5jb2xTcGFuO1xuICAgIHJldHVybiBjZWxsO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlKHJvdykge1xuICB0aGlzLl9jb2x1bW5XaWR0aHMgPSBbXTtcbiAgZW5zdXJlQ29sdW1uV2lkdGhzLmNhbGwodGhpcywgcm93LnJlZHVjZSgoYSwgY2VsbCkgPT4gYSArIGNlbGwuY29sU3BhbiwgMCkpO1xuICB0aGlzLl9yb3dIZWlnaHRzID0gW107XG4gIHRoaXMuX3Jvd1lQb3MgPSBbdGhpcy5fcG9zaXRpb24ueV07XG4gIHRoaXMuX3Jvd0J1ZmZlciA9IG5ldyBTZXQoKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUNvbHVtbldpZHRocyhudW1Db2xzKSB7XG4gIGxldCBzdGFyQ29sdW1uSW5kZXhlcyA9IFtdO1xuICBsZXQgc3Rhck1pbkFjYyA9IDA7XG4gIGxldCB1bmNsYWltZWRXaWR0aCA9IHRoaXMuX21heFdpZHRoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvbHM7IGkrKykge1xuICAgIGxldCBjb2wgPSB0aGlzLl9jb2xTdHlsZShpKTtcbiAgICBpZiAoY29sLndpZHRoID09PSAnKicpIHtcbiAgICAgIHN0YXJDb2x1bW5JbmRleGVzW2ldID0gY29sO1xuICAgICAgc3Rhck1pbkFjYyArPSBjb2wubWluV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuY2xhaW1lZFdpZHRoIC09IGNvbC53aWR0aDtcbiAgICAgIHRoaXMuX2NvbHVtbldpZHRoc1tpXSA9IGNvbC53aWR0aDtcbiAgICB9XG4gIH1cbiAgbGV0IHN0YXJDb2xDb3VudCA9IHN0YXJDb2x1bW5JbmRleGVzLnJlZHVjZSh4ID0+IHggKyAxLCAwKTtcbiAgaWYgKHN0YXJNaW5BY2MgPj0gdW5jbGFpbWVkV2lkdGgpIHtcbiAgICBzdGFyQ29sdW1uSW5kZXhlcy5mb3JFYWNoKChjZWxsLCBpKSA9PiB7XG4gICAgICB0aGlzLl9jb2x1bW5XaWR0aHNbaV0gPSBjZWxsLm1pbldpZHRoO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHN0YXJDb2xDb3VudCA+IDApIHtcbiAgICBzdGFyQ29sdW1uSW5kZXhlcy5mb3JFYWNoKChjb2wsIGkpID0+IHtcbiAgICAgIGxldCBzdGFyU2l6ZSA9IHVuY2xhaW1lZFdpZHRoIC8gc3RhckNvbENvdW50O1xuICAgICAgdGhpcy5fY29sdW1uV2lkdGhzW2ldID0gTWF0aC5tYXgoc3RhclNpemUsIGNvbC5taW5XaWR0aCk7XG4gICAgICBpZiAoY29sLm1heFdpZHRoID4gMCkge1xuICAgICAgICB0aGlzLl9jb2x1bW5XaWR0aHNbaV0gPSBNYXRoLm1pbih0aGlzLl9jb2x1bW5XaWR0aHNbaV0sIGNvbC5tYXhXaWR0aCk7XG4gICAgICB9XG4gICAgICB1bmNsYWltZWRXaWR0aCAtPSB0aGlzLl9jb2x1bW5XaWR0aHNbaV07XG4gICAgICBzdGFyQ29sQ291bnQtLTtcbiAgICB9KTtcbiAgfVxuICBsZXQgdGVtcFggPSB0aGlzLl9wb3NpdGlvbi54O1xuICB0aGlzLl9jb2x1bW5YUG9zID0gQXJyYXkuZnJvbSh0aGlzLl9jb2x1bW5XaWR0aHMsIHYgPT4ge1xuICAgIGNvbnN0IHQgPSB0ZW1wWDtcbiAgICB0ZW1wWCArPSB2O1xuICAgIHJldHVybiB0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIG1lYXN1cmUocm93LCByb3dJbmRleCkge1xuICByb3cuZm9yRWFjaChjZWxsID0+IHRoaXMuX3Jvd0J1ZmZlci5hZGQoY2VsbCkpO1xuICBpZiAocm93SW5kZXggPiAwKSB7XG4gICAgdGhpcy5fcm93WVBvc1tyb3dJbmRleF0gPSB0aGlzLl9yb3dZUG9zW3Jvd0luZGV4IC0gMV0gKyB0aGlzLl9yb3dIZWlnaHRzW3Jvd0luZGV4IC0gMV07XG4gIH1cbiAgY29uc3Qgcm93U3R5bGUgPSB0aGlzLl9yb3dTdHlsZShyb3dJbmRleCk7XG4gIGxldCB0b1JlbmRlciA9IFtdO1xuICB0aGlzLl9yb3dCdWZmZXIuZm9yRWFjaChjZWxsID0+IHtcbiAgICBpZiAoY2VsbC5yb3dJbmRleCArIGNlbGwucm93U3BhbiAtIDEgPT09IHJvd0luZGV4KSB7XG4gICAgICB0b1JlbmRlci5wdXNoKG1lYXN1cmVDZWxsLmNhbGwodGhpcywgY2VsbCwgcm93U3R5bGUuaGVpZ2h0KSk7XG4gICAgICB0aGlzLl9yb3dCdWZmZXIuZGVsZXRlKGNlbGwpO1xuICAgIH1cbiAgfSk7XG4gIGxldCByb3dIZWlnaHQgPSByb3dTdHlsZS5oZWlnaHQ7XG4gIGlmIChyb3dIZWlnaHQgPT09ICdhdXRvJykge1xuICAgIHJvd0hlaWdodCA9IHRvUmVuZGVyLnJlZHVjZSgoYWNjLCBjZWxsKSA9PiB7XG4gICAgICBsZXQgbWluSGVpZ2h0ID0gY2VsbC50ZXh0Qm91bmRzLmhlaWdodCArIGNlbGwucGFkZGluZy50b3AgKyBjZWxsLnBhZGRpbmcuYm90dG9tO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxsLnJvd1NwYW4gLSAxOyBpKyspIHtcbiAgICAgICAgbWluSGVpZ2h0IC09IHRoaXMuX3Jvd0hlaWdodHNbY2VsbC5yb3dJbmRleCArIGldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGgubWF4KGFjYywgbWluSGVpZ2h0KTtcbiAgICB9LCAwKTtcbiAgfVxuICByb3dIZWlnaHQgPSBNYXRoLm1heChyb3dIZWlnaHQsIHJvd1N0eWxlLm1pbkhlaWdodCk7XG4gIGlmIChyb3dTdHlsZS5tYXhIZWlnaHQgPiAwKSB7XG4gICAgcm93SGVpZ2h0ID0gTWF0aC5taW4ocm93SGVpZ2h0LCByb3dTdHlsZS5tYXhIZWlnaHQpO1xuICB9XG4gIHRoaXMuX3Jvd0hlaWdodHNbcm93SW5kZXhdID0gcm93SGVpZ2h0O1xuICBsZXQgbmV3UGFnZSA9IGZhbHNlO1xuICBpZiAocm93SGVpZ2h0ID4gdGhpcy5kb2N1bWVudC5wYWdlLmNvbnRlbnRIZWlnaHQpIHtcbiAgICBjb25zb2xlLndhcm4obmV3IEVycm9yKGBSb3cgJHtyb3dJbmRleH0gcmVxdWVzdGVkIG1vcmUgdGhhbiB0aGUgc2FmZSBwYWdlIGhlaWdodCwgcm93IGhhcyBiZWVuIGNsYW1wZWRgKS5zdGFjay5zbGljZSg3KSk7XG4gICAgdGhpcy5fcm93SGVpZ2h0c1tyb3dJbmRleF0gPSB0aGlzLmRvY3VtZW50LnBhZ2UubWF4WSgpIC0gdGhpcy5fcm93WVBvc1tyb3dJbmRleF07XG4gIH0gZWxzZSBpZiAodGhpcy5fcm93WVBvc1tyb3dJbmRleF0gKyByb3dIZWlnaHQgPj0gdGhpcy5kb2N1bWVudC5wYWdlLm1heFkoKSkge1xuICAgIHRoaXMuX3Jvd1lQb3Nbcm93SW5kZXhdID0gdGhpcy5kb2N1bWVudC5wYWdlLm1hcmdpbnMudG9wO1xuICAgIG5ld1BhZ2UgPSB0cnVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmV3UGFnZSxcbiAgICB0b1JlbmRlcjogdG9SZW5kZXIubWFwKGNlbGwgPT4gbWVhc3VyZUNlbGwuY2FsbCh0aGlzLCBjZWxsLCByb3dIZWlnaHQpKVxuICB9O1xufVxuZnVuY3Rpb24gbWVhc3VyZUNlbGwoY2VsbCwgcm93SGVpZ2h0KSB7XG4gIGxldCBjZWxsV2lkdGggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbGwuY29sU3BhbjsgaSsrKSB7XG4gICAgY2VsbFdpZHRoICs9IHRoaXMuX2NvbHVtbldpZHRoc1tjZWxsLmNvbEluZGV4ICsgaV07XG4gIH1cbiAgbGV0IGNlbGxIZWlnaHQgPSByb3dIZWlnaHQ7XG4gIGlmIChjZWxsSGVpZ2h0ID09PSAnYXV0bycpIHtcbiAgICBjZWxsSGVpZ2h0ID0gdGhpcy5kb2N1bWVudC5wYWdlLmNvbnRlbnRIZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxsLnJvd1NwYW4gLSAxOyBpKyspIHtcbiAgICAgIGNlbGxIZWlnaHQgKz0gdGhpcy5fcm93SGVpZ2h0c1tjZWxsLnJvd0luZGV4ICsgaV07XG4gICAgfVxuICB9XG4gIGNvbnN0IHRleHRBbGxvY2F0ZWRXaWR0aCA9IGNlbGxXaWR0aCAtIGNlbGwucGFkZGluZy5sZWZ0IC0gY2VsbC5wYWRkaW5nLnJpZ2h0O1xuICBjb25zdCB0ZXh0QWxsb2NhdGVkSGVpZ2h0ID0gY2VsbEhlaWdodCAtIGNlbGwucGFkZGluZy50b3AgLSBjZWxsLnBhZGRpbmcuYm90dG9tO1xuICBjb25zdCByb3RhdGlvbiA9IGNlbGwudGV4dE9wdGlvbnMucm90YXRpb24gPz8gMDtcbiAgY29uc3Qge1xuICAgIHdpZHRoOiB0ZXh0TWF4V2lkdGgsXG4gICAgaGVpZ2h0OiB0ZXh0TWF4SGVpZ2h0XG4gIH0gPSBjb21wdXRlQm91bmRzKHJvdGF0aW9uLCB0ZXh0QWxsb2NhdGVkV2lkdGgsIHRleHRBbGxvY2F0ZWRIZWlnaHQpO1xuICBjb25zdCB0ZXh0T3B0aW9ucyA9IHtcbiAgICBhbGlnbjogY2VsbC5hbGlnbi54LFxuICAgIGVsbGlwc2lzOiB0cnVlLFxuICAgIHN0cm9rZTogY2VsbC50ZXh0U3Ryb2tlID4gMCxcbiAgICBmaWxsOiB0cnVlLFxuICAgIHdpZHRoOiB0ZXh0TWF4V2lkdGgsXG4gICAgaGVpZ2h0OiB0ZXh0TWF4SGVpZ2h0LFxuICAgIHJvdGF0aW9uLFxuICAgIC4uLmNlbGwudGV4dE9wdGlvbnNcbiAgfTtcbiAgbGV0IHRleHRCb3VuZHMgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9O1xuICBpZiAoY2VsbC50ZXh0KSB7XG4gICAgY29uc3Qgcm9sbGJhY2tGb250ID0gdGhpcy5kb2N1bWVudC5fZm9udFNvdXJjZTtcbiAgICBjb25zdCByb2xsYmFja0ZvbnRTaXplID0gdGhpcy5kb2N1bWVudC5fZm9udFNpemU7XG4gICAgY29uc3Qgcm9sbGJhY2tGb250RmFtaWx5ID0gdGhpcy5kb2N1bWVudC5fZm9udEZhbWlseTtcbiAgICBpZiAoY2VsbC5mb250Py5zcmMpIHRoaXMuZG9jdW1lbnQuZm9udChjZWxsLmZvbnQuc3JjLCBjZWxsLmZvbnQ/LmZhbWlseSk7XG4gICAgaWYgKGNlbGwuZm9udD8uc2l6ZSkgdGhpcy5kb2N1bWVudC5mb250U2l6ZShjZWxsLmZvbnQuc2l6ZSk7XG4gICAgY29uc3QgdW5Sb3RhdGVkVGV4dEJvdW5kcyA9IHRoaXMuZG9jdW1lbnQuYm91bmRzT2ZTdHJpbmcoY2VsbC50ZXh0LCAwLCAwLCB7XG4gICAgICAuLi50ZXh0T3B0aW9ucyxcbiAgICAgIHJvdGF0aW9uOiAwXG4gICAgfSk7XG4gICAgdGV4dE9wdGlvbnMud2lkdGggPSB1blJvdGF0ZWRUZXh0Qm91bmRzLndpZHRoO1xuICAgIHRleHRPcHRpb25zLmhlaWdodCA9IHVuUm90YXRlZFRleHRCb3VuZHMuaGVpZ2h0O1xuICAgIHRleHRCb3VuZHMgPSB0aGlzLmRvY3VtZW50LmJvdW5kc09mU3RyaW5nKGNlbGwudGV4dCwgMCwgMCwgdGV4dE9wdGlvbnMpO1xuICAgIHRoaXMuZG9jdW1lbnQuZm9udChyb2xsYmFja0ZvbnQsIHJvbGxiYWNrRm9udEZhbWlseSwgcm9sbGJhY2tGb250U2l6ZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5jZWxsLFxuICAgIHRleHRPcHRpb25zLFxuICAgIHg6IHRoaXMuX2NvbHVtblhQb3NbY2VsbC5jb2xJbmRleF0sXG4gICAgeTogdGhpcy5fcm93WVBvc1tjZWxsLnJvd0luZGV4XSxcbiAgICB0ZXh0WDogdGhpcy5fY29sdW1uWFBvc1tjZWxsLmNvbEluZGV4XSArIGNlbGwucGFkZGluZy5sZWZ0LFxuICAgIHRleHRZOiB0aGlzLl9yb3dZUG9zW2NlbGwucm93SW5kZXhdICsgY2VsbC5wYWRkaW5nLnRvcCxcbiAgICB3aWR0aDogY2VsbFdpZHRoLFxuICAgIGhlaWdodDogY2VsbEhlaWdodCxcbiAgICB0ZXh0QWxsb2NhdGVkSGVpZ2h0LFxuICAgIHRleHRBbGxvY2F0ZWRXaWR0aCxcbiAgICB0ZXh0Qm91bmRzXG4gIH07XG59XG5mdW5jdGlvbiBjb21wdXRlQm91bmRzKHJvdGF0aW9uLCBhbGxvY1dpZHRoLCBhbGxvY0hlaWdodCkge1xuICBsZXQgdGV4dE1heFdpZHRoLCB0ZXh0TWF4SGVpZ2h0O1xuICBjb25zdCBjb3MgPSBjb3NpbmUocm90YXRpb24pO1xuICBjb25zdCBzaW4gPSBzaW5lKHJvdGF0aW9uKTtcbiAgaWYgKHJvdGF0aW9uID09PSAwIHx8IHJvdGF0aW9uID09PSAxODApIHtcbiAgICB0ZXh0TWF4V2lkdGggPSBhbGxvY1dpZHRoO1xuICAgIHRleHRNYXhIZWlnaHQgPSBhbGxvY0hlaWdodDtcbiAgfSBlbHNlIGlmIChyb3RhdGlvbiA9PT0gOTAgfHwgcm90YXRpb24gPT09IDI3MCkge1xuICAgIHRleHRNYXhXaWR0aCA9IGFsbG9jSGVpZ2h0O1xuICAgIHRleHRNYXhIZWlnaHQgPSBhbGxvY1dpZHRoO1xuICB9IGVsc2UgaWYgKHJvdGF0aW9uIDwgOTAgfHwgcm90YXRpb24gPiAxODAgJiYgcm90YXRpb24gPCAyNzApIHtcbiAgICB0ZXh0TWF4V2lkdGggPSBhbGxvY1dpZHRoIC8gKDIgKiBjb3MpO1xuICAgIHRleHRNYXhIZWlnaHQgPSBhbGxvY1dpZHRoIC8gKDIgKiBzaW4pO1xuICB9IGVsc2Uge1xuICAgIHRleHRNYXhIZWlnaHQgPSBhbGxvY1dpZHRoIC8gKDIgKiBjb3MpO1xuICAgIHRleHRNYXhXaWR0aCA9IGFsbG9jV2lkdGggLyAoMiAqIHNpbik7XG4gIH1cbiAgY29uc3QgRUYgPSBzaW4gKiB0ZXh0TWF4V2lkdGg7XG4gIGNvbnN0IEZHID0gY29zICogdGV4dE1heEhlaWdodDtcbiAgaWYgKEVGICsgRkcgPiBhbGxvY0hlaWdodCkge1xuICAgIGNvbnN0IGRlbm9taW5hdG9yID0gY29zICogY29zIC0gc2luICogc2luO1xuICAgIGlmIChyb3RhdGlvbiA9PT0gMCB8fCByb3RhdGlvbiA9PT0gMTgwKSB7XG4gICAgICB0ZXh0TWF4V2lkdGggPSBhbGxvY1dpZHRoO1xuICAgICAgdGV4dE1heEhlaWdodCA9IGFsbG9jSGVpZ2h0O1xuICAgIH0gZWxzZSBpZiAocm90YXRpb24gPT09IDkwIHx8IHJvdGF0aW9uID09PSAyNzApIHtcbiAgICAgIHRleHRNYXhXaWR0aCA9IGFsbG9jSGVpZ2h0O1xuICAgICAgdGV4dE1heEhlaWdodCA9IGFsbG9jV2lkdGg7XG4gICAgfSBlbHNlIGlmIChyb3RhdGlvbiA8IDkwIHx8IHJvdGF0aW9uID4gMTgwICYmIHJvdGF0aW9uIDwgMjcwKSB7XG4gICAgICB0ZXh0TWF4V2lkdGggPSAoYWxsb2NXaWR0aCAqIGNvcyAtIGFsbG9jSGVpZ2h0ICogc2luKSAvIGRlbm9taW5hdG9yO1xuICAgICAgdGV4dE1heEhlaWdodCA9IChhbGxvY0hlaWdodCAqIGNvcyAtIGFsbG9jV2lkdGggKiBzaW4pIC8gZGVub21pbmF0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHRNYXhIZWlnaHQgPSAoYWxsb2NXaWR0aCAqIGNvcyAtIGFsbG9jSGVpZ2h0ICogc2luKSAvIGRlbm9taW5hdG9yO1xuICAgICAgdGV4dE1heFdpZHRoID0gKGFsbG9jSGVpZ2h0ICogY29zIC0gYWxsb2NXaWR0aCAqIHNpbikgLyBkZW5vbWluYXRvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogTWF0aC5hYnModGV4dE1heFdpZHRoKSxcbiAgICBoZWlnaHQ6IE1hdGguYWJzKHRleHRNYXhIZWlnaHQpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFjY29tbW9kYXRlVGFibGUoKSB7XG4gIGNvbnN0IHN0cnVjdFBhcmVudCA9IHRoaXMub3B0cy5zdHJ1Y3RQYXJlbnQ7XG4gIGlmIChzdHJ1Y3RQYXJlbnQpIHtcbiAgICB0aGlzLl90YWJsZVN0cnVjdCA9IHRoaXMuZG9jdW1lbnQuc3RydWN0KCdUYWJsZScpO1xuICAgIHRoaXMuX3RhYmxlU3RydWN0LmRpY3Rpb25hcnkuZGF0YS5JRCA9IHRoaXMuX2lkO1xuICAgIGlmIChzdHJ1Y3RQYXJlbnQgaW5zdGFuY2VvZiBQREZTdHJ1Y3R1cmVFbGVtZW50KSB7XG4gICAgICBzdHJ1Y3RQYXJlbnQuYWRkKHRoaXMuX3RhYmxlU3RydWN0KTtcbiAgICB9IGVsc2UgaWYgKHN0cnVjdFBhcmVudCBpbnN0YW5jZW9mIFBERkRvY3VtZW50KSB7XG4gICAgICBzdHJ1Y3RQYXJlbnQuYWRkU3RydWN0dXJlKHRoaXMuX3RhYmxlU3RydWN0KTtcbiAgICB9XG4gICAgdGhpcy5faGVhZGVyUm93TG9va3VwID0ge307XG4gICAgdGhpcy5faGVhZGVyQ29sdW1uTG9va3VwID0ge307XG4gIH1cbn1cbmZ1bmN0aW9uIGFjY29tbW9kYXRlQ2xlYW51cCgpIHtcbiAgaWYgKHRoaXMuX3RhYmxlU3RydWN0KSB0aGlzLl90YWJsZVN0cnVjdC5lbmQoKTtcbn1cbmZ1bmN0aW9uIGFjY2Vzc2libGVSb3cocm93LCByb3dJbmRleCwgcmVuZGVyQ2VsbCkge1xuICBjb25zdCByb3dTdHJ1Y3QgPSB0aGlzLmRvY3VtZW50LnN0cnVjdCgnVFInKTtcbiAgcm93U3RydWN0LmRpY3Rpb25hcnkuZGF0YS5JRCA9IG5ldyBTdHJpbmcoYCR7dGhpcy5faWR9LSR7cm93SW5kZXh9YCk7XG4gIHRoaXMuX3RhYmxlU3RydWN0LmFkZChyb3dTdHJ1Y3QpO1xuICByb3cuZm9yRWFjaChjZWxsID0+IHJlbmRlckNlbGwoY2VsbCwgcm93U3RydWN0KSk7XG4gIHJvd1N0cnVjdC5lbmQoKTtcbn1cbmZ1bmN0aW9uIGFjY2Vzc2libGVDZWxsKGNlbGwsIHJvd1N0cnVjdCwgY2FsbGJhY2spIHtcbiAgY29uc3QgZG9jID0gdGhpcy5kb2N1bWVudDtcbiAgY29uc3QgY2VsbFN0cnVjdCA9IGRvYy5zdHJ1Y3QoY2VsbC50eXBlLCB7XG4gICAgdGl0bGU6IGNlbGwudGl0bGVcbiAgfSk7XG4gIGNlbGxTdHJ1Y3QuZGljdGlvbmFyeS5kYXRhLklEID0gY2VsbC5pZDtcbiAgcm93U3RydWN0LmFkZChjZWxsU3RydWN0KTtcbiAgY29uc3QgcGFkZGluZyA9IGNlbGwucGFkZGluZztcbiAgY29uc3QgYm9yZGVyID0gY2VsbC5ib3JkZXI7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgTzogJ1RhYmxlJyxcbiAgICBXaWR0aDogY2VsbC53aWR0aCxcbiAgICBIZWlnaHQ6IGNlbGwuaGVpZ2h0LFxuICAgIFBhZGRpbmc6IFtwYWRkaW5nLnRvcCwgcGFkZGluZy5ib3R0b20sIHBhZGRpbmcubGVmdCwgcGFkZGluZy5yaWdodF0sXG4gICAgUm93U3BhbjogY2VsbC5yb3dTcGFuID4gMSA/IGNlbGwucm93U3BhbiA6IHVuZGVmaW5lZCxcbiAgICBDb2xTcGFuOiBjZWxsLmNvbFNwYW4gPiAxID8gY2VsbC5jb2xTcGFuIDogdW5kZWZpbmVkLFxuICAgIEJvcmRlclRoaWNrbmVzczogW2JvcmRlci50b3AsIGJvcmRlci5ib3R0b20sIGJvcmRlci5sZWZ0LCBib3JkZXIucmlnaHRdXG4gIH07XG4gIGlmIChjZWxsLnR5cGUgPT09ICdUSCcpIHtcbiAgICBpZiAoY2VsbC5zY29wZSA9PT0gJ1JvdycgfHwgY2VsbC5zY29wZSA9PT0gJ0JvdGgnKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbGwucm93U3BhbjsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5faGVhZGVyUm93TG9va3VwW2NlbGwucm93SW5kZXggKyBpXSkge1xuICAgICAgICAgIHRoaXMuX2hlYWRlclJvd0xvb2t1cFtjZWxsLnJvd0luZGV4ICsgaV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oZWFkZXJSb3dMb29rdXBbY2VsbC5yb3dJbmRleCArIGldLnB1c2goY2VsbC5pZCk7XG4gICAgICB9XG4gICAgICBhdHRyaWJ1dGVzLlNjb3BlID0gY2VsbC5zY29wZTtcbiAgICB9XG4gICAgaWYgKGNlbGwuc2NvcGUgPT09ICdDb2x1bW4nIHx8IGNlbGwuc2NvcGUgPT09ICdCb3RoJykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxsLmNvbFNwYW47IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMuX2hlYWRlckNvbHVtbkxvb2t1cFtjZWxsLmNvbEluZGV4ICsgaV0pIHtcbiAgICAgICAgICB0aGlzLl9oZWFkZXJDb2x1bW5Mb29rdXBbY2VsbC5jb2xJbmRleCArIGldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhZGVyQ29sdW1uTG9va3VwW2NlbGwuY29sSW5kZXggKyBpXS5wdXNoKGNlbGwuaWQpO1xuICAgICAgfVxuICAgICAgYXR0cmlidXRlcy5TY29wZSA9IGNlbGwuc2NvcGU7XG4gICAgfVxuICB9XG4gIGNvbnN0IEhlYWRlcnMgPSBuZXcgU2V0KFsuLi5BcnJheS5mcm9tKHtcbiAgICBsZW5ndGg6IGNlbGwuY29sU3BhblxuICB9LCAoXywgaSkgPT4gdGhpcy5faGVhZGVyQ29sdW1uTG9va3VwW2NlbGwuY29sSW5kZXggKyBpXSkuZmxhdCgpLCAuLi5BcnJheS5mcm9tKHtcbiAgICBsZW5ndGg6IGNlbGwucm93U3BhblxuICB9LCAoXywgaSkgPT4gdGhpcy5faGVhZGVyUm93TG9va3VwW2NlbGwucm93SW5kZXggKyBpXSkuZmxhdCgpXS5maWx0ZXIoQm9vbGVhbikpO1xuICBpZiAoSGVhZGVycy5zaXplKSBhdHRyaWJ1dGVzLkhlYWRlcnMgPSBBcnJheS5mcm9tKEhlYWRlcnMpO1xuICBjb25zdCBub3JtYWxpemVDb2xvciA9IGRvYy5fbm9ybWFsaXplQ29sb3I7XG4gIGlmIChjZWxsLmJhY2tncm91bmRDb2xvciAhPSBudWxsKSB7XG4gICAgYXR0cmlidXRlcy5CYWNrZ3JvdW5kQ29sb3IgPSBub3JtYWxpemVDb2xvcihjZWxsLmJhY2tncm91bmRDb2xvcik7XG4gIH1cbiAgY29uc3QgaGFzQm9yZGVyID0gW2JvcmRlci50b3AsIGJvcmRlci5ib3R0b20sIGJvcmRlci5sZWZ0LCBib3JkZXIucmlnaHRdO1xuICBpZiAoaGFzQm9yZGVyLnNvbWUoeCA9PiB4KSkge1xuICAgIGNvbnN0IGJvcmRlckNvbG9yID0gY2VsbC5ib3JkZXJDb2xvcjtcbiAgICBhdHRyaWJ1dGVzLkJvcmRlckNvbG9yID0gW2hhc0JvcmRlclswXSA/IG5vcm1hbGl6ZUNvbG9yKGJvcmRlckNvbG9yLnRvcCkgOiBudWxsLCBoYXNCb3JkZXJbMV0gPyBub3JtYWxpemVDb2xvcihib3JkZXJDb2xvci5ib3R0b20pIDogbnVsbCwgaGFzQm9yZGVyWzJdID8gbm9ybWFsaXplQ29sb3IoYm9yZGVyQ29sb3IubGVmdCkgOiBudWxsLCBoYXNCb3JkZXJbM10gPyBub3JtYWxpemVDb2xvcihib3JkZXJDb2xvci5yaWdodCkgOiBudWxsXTtcbiAgfVxuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGtleSA9PiBhdHRyaWJ1dGVzW2tleV0gPT09IHVuZGVmaW5lZCAmJiBkZWxldGUgYXR0cmlidXRlc1trZXldKTtcbiAgY2VsbFN0cnVjdC5kaWN0aW9uYXJ5LmRhdGEuQSA9IGRvYy5yZWYoYXR0cmlidXRlcyk7XG4gIGNlbGxTdHJ1Y3QuYWRkKGNhbGxiYWNrKTtcbiAgY2VsbFN0cnVjdC5lbmQoKTtcbiAgY2VsbFN0cnVjdC5kaWN0aW9uYXJ5LmRhdGEuQS5lbmQoKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUm93KHJvdywgcm93SW5kZXgpIHtcbiAgaWYgKHRoaXMuX3RhYmxlU3RydWN0KSB7XG4gICAgYWNjZXNzaWJsZVJvdy5jYWxsKHRoaXMsIHJvdywgcm93SW5kZXgsIHJlbmRlckNlbGwuYmluZCh0aGlzKSk7XG4gIH0gZWxzZSB7XG4gICAgcm93LmZvckVhY2goY2VsbCA9PiByZW5kZXJDZWxsLmNhbGwodGhpcywgY2VsbCkpO1xuICB9XG4gIHJldHVybiB0aGlzLl9yb3dZUG9zW3Jvd0luZGV4XSArIHRoaXMuX3Jvd0hlaWdodHNbcm93SW5kZXhdO1xufVxuZnVuY3Rpb24gcmVuZGVyQ2VsbChjZWxsLCByb3dTdHJ1Y3QpIHtcbiAgY29uc3QgY2VsbFJlbmRlcmVyID0gKCkgPT4ge1xuICAgIGlmIChjZWxsLmJhY2tncm91bmRDb2xvciAhPSBudWxsKSB7XG4gICAgICB0aGlzLmRvY3VtZW50LnNhdmUoKS5yZWN0KGNlbGwueCwgY2VsbC55LCBjZWxsLndpZHRoLCBjZWxsLmhlaWdodCkuZmlsbChjZWxsLmJhY2tncm91bmRDb2xvcikucmVzdG9yZSgpO1xuICAgIH1cbiAgICByZW5kZXJCb3JkZXIuY2FsbCh0aGlzLCBjZWxsLmJvcmRlciwgY2VsbC5ib3JkZXJDb2xvciwgY2VsbC54LCBjZWxsLnksIGNlbGwud2lkdGgsIGNlbGwuaGVpZ2h0KTtcbiAgICBpZiAoY2VsbC5kZWJ1Zykge1xuICAgICAgdGhpcy5kb2N1bWVudC5zYXZlKCk7XG4gICAgICB0aGlzLmRvY3VtZW50LmRhc2goMSwge1xuICAgICAgICBzcGFjZTogMVxuICAgICAgfSkubGluZVdpZHRoKDEpLnN0cm9rZU9wYWNpdHkoMC4zKTtcbiAgICAgIHRoaXMuZG9jdW1lbnQucmVjdChjZWxsLngsIGNlbGwueSwgY2VsbC53aWR0aCwgY2VsbC5oZWlnaHQpLnN0cm9rZSgnZ3JlZW4nKTtcbiAgICAgIHRoaXMuZG9jdW1lbnQucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAoY2VsbC50ZXh0KSByZW5kZXJDZWxsVGV4dC5jYWxsKHRoaXMsIGNlbGwpO1xuICB9O1xuICBpZiAocm93U3RydWN0KSBhY2Nlc3NpYmxlQ2VsbC5jYWxsKHRoaXMsIGNlbGwsIHJvd1N0cnVjdCwgY2VsbFJlbmRlcmVyKTtlbHNlIGNlbGxSZW5kZXJlcigpO1xufVxuZnVuY3Rpb24gcmVuZGVyQ2VsbFRleHQoY2VsbCkge1xuICBjb25zdCBkb2MgPSB0aGlzLmRvY3VtZW50O1xuICBjb25zdCByb2xsYmFja0ZvbnQgPSBkb2MuX2ZvbnRTb3VyY2U7XG4gIGNvbnN0IHJvbGxiYWNrRm9udFNpemUgPSBkb2MuX2ZvbnRTaXplO1xuICBjb25zdCByb2xsYmFja0ZvbnRGYW1pbHkgPSBkb2MuX2ZvbnRGYW1pbHk7XG4gIGlmIChjZWxsLmN1c3RvbUZvbnQpIHtcbiAgICBpZiAoY2VsbC5mb250LnNyYykgZG9jLmZvbnQoY2VsbC5mb250LnNyYywgY2VsbC5mb250LmZhbWlseSk7XG4gICAgaWYgKGNlbGwuZm9udC5zaXplKSBkb2MuZm9udFNpemUoY2VsbC5mb250LnNpemUpO1xuICB9XG4gIGNvbnN0IHggPSBjZWxsLnRleHRYO1xuICBjb25zdCB5ID0gY2VsbC50ZXh0WTtcbiAgY29uc3QgQWggPSBjZWxsLnRleHRBbGxvY2F0ZWRIZWlnaHQ7XG4gIGNvbnN0IEF3ID0gY2VsbC50ZXh0QWxsb2NhdGVkV2lkdGg7XG4gIGNvbnN0IEN3ID0gY2VsbC50ZXh0Qm91bmRzLndpZHRoO1xuICBjb25zdCBDaCA9IGNlbGwudGV4dEJvdW5kcy5oZWlnaHQ7XG4gIGNvbnN0IE94ID0gLWNlbGwudGV4dEJvdW5kcy54O1xuICBjb25zdCBPeSA9IC1jZWxsLnRleHRCb3VuZHMueTtcbiAgY29uc3QgUHhTY2FsZSA9IGNlbGwuYWxpZ24ueCA9PT0gJ3JpZ2h0JyA/IDEgOiBjZWxsLmFsaWduLnggPT09ICdjZW50ZXInID8gMC41IDogMDtcbiAgY29uc3QgUHggPSAoQXcgLSBDdykgKiBQeFNjYWxlO1xuICBjb25zdCBQeVNjYWxlID0gY2VsbC5hbGlnbi55ID09PSAnYm90dG9tJyA/IDEgOiBjZWxsLmFsaWduLnkgPT09ICdjZW50ZXInID8gMC41IDogMDtcbiAgY29uc3QgUHkgPSAoQWggLSBDaCkgKiBQeVNjYWxlO1xuICBjb25zdCBkeCA9IFB4ICsgT3g7XG4gIGNvbnN0IGR5ID0gUHkgKyBPeTtcbiAgaWYgKGNlbGwuZGVidWcpIHtcbiAgICBkb2Muc2F2ZSgpO1xuICAgIGRvYy5kYXNoKDEsIHtcbiAgICAgIHNwYWNlOiAxXG4gICAgfSkubGluZVdpZHRoKDEpLnN0cm9rZU9wYWNpdHkoMC4zKTtcbiAgICBpZiAoY2VsbC50ZXh0KSB7XG4gICAgICBkb2MubW92ZVRvKHggKyBQeCwgeSkubGluZVRvKHggKyBQeCwgeSArIEFoKS5tb3ZlVG8oeCArIFB4ICsgQ3csIHkpLmxpbmVUbyh4ICsgUHggKyBDdywgeSArIEFoKS5zdHJva2UoJ2JsdWUnKS5tb3ZlVG8oeCwgeSArIFB5KS5saW5lVG8oeCArIEF3LCB5ICsgUHkpLm1vdmVUbyh4LCB5ICsgUHkgKyBDaCkubGluZVRvKHggKyBBdywgeSArIFB5ICsgQ2gpLnN0cm9rZSgnZ3JlZW4nKTtcbiAgICB9XG4gICAgZG9jLnJlY3QoeCwgeSwgQXcsIEFoKS5zdHJva2UoJ29yYW5nZScpO1xuICAgIGRvYy5yZXN0b3JlKCk7XG4gIH1cbiAgZG9jLnNhdmUoKS5yZWN0KHgsIHksIEF3LCBBaCkuY2xpcCgpO1xuICBkb2MuZmlsbENvbG9yKGNlbGwudGV4dENvbG9yKS5zdHJva2VDb2xvcihjZWxsLnRleHRTdHJva2VDb2xvcik7XG4gIGlmIChjZWxsLnRleHRTdHJva2UgPiAwKSBkb2MubGluZVdpZHRoKGNlbGwudGV4dFN0cm9rZSk7XG4gIGRvYy50ZXh0KGNlbGwudGV4dCwgeCArIGR4LCB5ICsgZHksIGNlbGwudGV4dE9wdGlvbnMpO1xuICBkb2MucmVzdG9yZSgpO1xuICBpZiAoY2VsbC5mb250KSBkb2MuZm9udChyb2xsYmFja0ZvbnQsIHJvbGxiYWNrRm9udEZhbWlseSwgcm9sbGJhY2tGb250U2l6ZSk7XG59XG5mdW5jdGlvbiByZW5kZXJCb3JkZXIoYm9yZGVyLCBib3JkZXJDb2xvciwgeCwgeSwgd2lkdGgsIGhlaWdodCwgbWFzaykge1xuICBib3JkZXIgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoYm9yZGVyKS5tYXAoX3JlZiA9PiB7XG4gICAgbGV0IFtrLCB2XSA9IF9yZWY7XG4gICAgcmV0dXJuIFtrLCBtYXNrICYmICFtYXNrW2tdID8gMCA6IHZdO1xuICB9KSk7XG4gIGNvbnN0IGRvYyA9IHRoaXMuZG9jdW1lbnQ7XG4gIGlmIChbYm9yZGVyLnJpZ2h0LCBib3JkZXIuYm90dG9tLCBib3JkZXIubGVmdF0uZXZlcnkodmFsID0+IHZhbCA9PT0gYm9yZGVyLnRvcCkpIHtcbiAgICBpZiAoYm9yZGVyLnRvcCA+IDApIHtcbiAgICAgIGRvYy5zYXZlKCkubGluZVdpZHRoKGJvcmRlci50b3ApLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkuc3Ryb2tlKGJvcmRlckNvbG9yLnRvcCkucmVzdG9yZSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYm9yZGVyLnRvcCA+IDApIHtcbiAgICAgIGRvYy5zYXZlKCkubGluZVdpZHRoKGJvcmRlci50b3ApLm1vdmVUbyh4LCB5KS5saW5lVG8oeCArIHdpZHRoLCB5KS5zdHJva2UoYm9yZGVyQ29sb3IudG9wKS5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmIChib3JkZXIucmlnaHQgPiAwKSB7XG4gICAgICBkb2Muc2F2ZSgpLmxpbmVXaWR0aChib3JkZXIucmlnaHQpLm1vdmVUbyh4ICsgd2lkdGgsIHkpLmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpLnN0cm9rZShib3JkZXJDb2xvci5yaWdodCkucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAoYm9yZGVyLmJvdHRvbSA+IDApIHtcbiAgICAgIGRvYy5zYXZlKCkubGluZVdpZHRoKGJvcmRlci5ib3R0b20pLm1vdmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpLmxpbmVUbyh4LCB5ICsgaGVpZ2h0KS5zdHJva2UoYm9yZGVyQ29sb3IuYm90dG9tKS5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmIChib3JkZXIubGVmdCA+IDApIHtcbiAgICAgIGRvYy5zYXZlKCkubGluZVdpZHRoKGJvcmRlci5sZWZ0KS5tb3ZlVG8oeCwgeSArIGhlaWdodCkubGluZVRvKHgsIHkpLnN0cm9rZShib3JkZXJDb2xvci5sZWZ0KS5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFBERlRhYmxlIHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQpIHtcbiAgICBsZXQgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMub3B0cyA9IE9iamVjdC5mcmVlemUob3B0cyk7XG4gICAgbm9ybWFsaXplVGFibGUuY2FsbCh0aGlzKTtcbiAgICBhY2NvbW1vZGF0ZVRhYmxlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fY3VyclJvd0luZGV4ID0gMDtcbiAgICB0aGlzLl9lbmRlZCA9IGZhbHNlO1xuICAgIGlmIChvcHRzLmRhdGEpIHtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIG9wdHMuZGF0YSkgdGhpcy5yb3cocm93KTtcbiAgICAgIHJldHVybiB0aGlzLmVuZCgpO1xuICAgIH1cbiAgfVxuICByb3cocm93KSB7XG4gICAgbGV0IGxhc3RSb3cgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIGlmICh0aGlzLl9lbmRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYWJsZSB3YXMgbWFya2VkIGFzIGVuZGVkIG9uIHJvdyAke3RoaXMuX2N1cnJSb3dJbmRleH1gKTtcbiAgICB9XG4gICAgcm93ID0gQXJyYXkuZnJvbShyb3cpO1xuICAgIHJvdyA9IG5vcm1hbGl6ZVJvdy5jYWxsKHRoaXMsIHJvdywgdGhpcy5fY3VyclJvd0luZGV4KTtcbiAgICBpZiAodGhpcy5fY3VyclJvd0luZGV4ID09PSAwKSBlbnN1cmUuY2FsbCh0aGlzLCByb3cpO1xuICAgIGNvbnN0IHtcbiAgICAgIG5ld1BhZ2UsXG4gICAgICB0b1JlbmRlclxuICAgIH0gPSBtZWFzdXJlLmNhbGwodGhpcywgcm93LCB0aGlzLl9jdXJyUm93SW5kZXgpO1xuICAgIGlmIChuZXdQYWdlKSB0aGlzLmRvY3VtZW50LmNvbnRpbnVlT25OZXdQYWdlKCk7XG4gICAgY29uc3QgeVBvcyA9IHJlbmRlclJvdy5jYWxsKHRoaXMsIHRvUmVuZGVyLCB0aGlzLl9jdXJyUm93SW5kZXgpO1xuICAgIHRoaXMuZG9jdW1lbnQueCA9IHRoaXMuX3Bvc2l0aW9uLng7XG4gICAgdGhpcy5kb2N1bWVudC55ID0geVBvcztcbiAgICBpZiAobGFzdFJvdykgcmV0dXJuIHRoaXMuZW5kKCk7XG4gICAgdGhpcy5fY3VyclJvd0luZGV4Kys7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZW5kKCkge1xuICAgIHdoaWxlICh0aGlzLl9yb3dCdWZmZXI/LnNpemUpIHRoaXMucm93KFtdKTtcbiAgICB0aGlzLl9lbmRlZCA9IHRydWU7XG4gICAgYWNjb21tb2RhdGVDbGVhbnVwLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQ7XG4gIH1cbn1cblxudmFyIFRhYmxlTWl4aW4gPSB7XG4gIGluaXRUYWJsZXMoKSB7XG4gICAgdGhpcy5fdGFibGVJbmRleCA9IDA7XG4gIH0sXG4gIHRhYmxlKG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IFBERlRhYmxlKHRoaXMsIG9wdHMpO1xuICB9XG59O1xuXG5jbGFzcyBQREZNZXRhZGF0YSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX21ldGFkYXRhID0gYFxuICAgICAgICA8P3hwYWNrZXQgYmVnaW49XCJcXHVmZWZmXCIgaWQ9XCJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWRcIj8+XG4gICAgICAgICAgICA8eDp4bXBtZXRhIHhtbG5zOng9XCJhZG9iZTpuczptZXRhL1wiPlxuICAgICAgICAgICAgICAgIDxyZGY6UkRGIHhtbG5zOnJkZj1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcIj5cbiAgICAgICAgYDtcbiAgfVxuICBfY2xvc2VUYWdzKCkge1xuICAgIHRoaXMuX21ldGFkYXRhID0gdGhpcy5fbWV0YWRhdGEuY29uY2F0KGBcbiAgICAgICAgICAgICAgICA8L3JkZjpSREY+XG4gICAgICAgICAgICA8L3g6eG1wbWV0YT5cbiAgICAgICAgPD94cGFja2V0IGVuZD1cIndcIj8+XG4gICAgICAgIGApO1xuICB9XG4gIGFwcGVuZCh4bWwpIHtcbiAgICBsZXQgbmV3bGluZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICB0aGlzLl9tZXRhZGF0YSA9IHRoaXMuX21ldGFkYXRhLmNvbmNhdCh4bWwpO1xuICAgIGlmIChuZXdsaW5lKSB0aGlzLl9tZXRhZGF0YSA9IHRoaXMuX21ldGFkYXRhLmNvbmNhdCgnXFxuJyk7XG4gIH1cbiAgZ2V0WE1MKCkge1xuICAgIHJldHVybiB0aGlzLl9tZXRhZGF0YTtcbiAgfVxuICBnZXRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ldGFkYXRhLmxlbmd0aDtcbiAgfVxuICBlbmQoKSB7XG4gICAgdGhpcy5fY2xvc2VUYWdzKCk7XG4gICAgdGhpcy5fbWV0YWRhdGEgPSB0aGlzLl9tZXRhZGF0YS50cmltKCk7XG4gIH1cbn1cblxudmFyIE1ldGFkYXRhTWl4aW4gPSB7XG4gIGluaXRNZXRhZGF0YSgpIHtcbiAgICB0aGlzLm1ldGFkYXRhID0gbmV3IFBERk1ldGFkYXRhKCk7XG4gIH0sXG4gIGFwcGVuZFhNTCh4bWwpIHtcbiAgICBsZXQgbmV3bGluZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICB0aGlzLm1ldGFkYXRhLmFwcGVuZCh4bWwsIG5ld2xpbmUpO1xuICB9LFxuICBfYWRkSW5mbygpIHtcbiAgICB0aGlzLmFwcGVuZFhNTChgXG4gICAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PVwiXCIgeG1sbnM6eG1wPVwiaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL1wiPlxuICAgICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPiR7dGhpcy5pbmZvLkNyZWF0aW9uRGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCcuJylbMF0gKyAnWid9PC94bXA6Q3JlYXRlRGF0ZT5cbiAgICAgICAgICAgIDx4bXA6Q3JlYXRvclRvb2w+JHt0aGlzLmluZm8uQ3JlYXRvcn08L3htcDpDcmVhdG9yVG9vbD5cbiAgICAgICAgPC9yZGY6RGVzY3JpcHRpb24+XG4gICAgICAgIGApO1xuICAgIGlmICh0aGlzLmluZm8uVGl0bGUgfHwgdGhpcy5pbmZvLkF1dGhvciB8fCB0aGlzLmluZm8uU3ViamVjdCkge1xuICAgICAgdGhpcy5hcHBlbmRYTUwoYFxuICAgICAgICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9XCJcIiB4bWxuczpkYz1cImh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvXCI+XG4gICAgICAgICAgICBgKTtcbiAgICAgIGlmICh0aGlzLmluZm8uVGl0bGUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRYTUwoYFxuICAgICAgICAgICAgICAgIDxkYzp0aXRsZT5cbiAgICAgICAgICAgICAgICAgICAgPHJkZjpBbHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cmRmOmxpIHhtbDpsYW5nPVwieC1kZWZhdWx0XCI+JHt0aGlzLmluZm8uVGl0bGV9PC9yZGY6bGk+XG4gICAgICAgICAgICAgICAgICAgIDwvcmRmOkFsdD5cbiAgICAgICAgICAgICAgICA8L2RjOnRpdGxlPlxuICAgICAgICAgICAgICAgIGApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaW5mby5BdXRob3IpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRYTUwoYFxuICAgICAgICAgICAgICAgIDxkYzpjcmVhdG9yPlxuICAgICAgICAgICAgICAgICAgICA8cmRmOlNlcT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxyZGY6bGk+JHt0aGlzLmluZm8uQXV0aG9yfTwvcmRmOmxpPlxuICAgICAgICAgICAgICAgICAgICA8L3JkZjpTZXE+XG4gICAgICAgICAgICAgICAgPC9kYzpjcmVhdG9yPlxuICAgICAgICAgICAgICAgIGApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaW5mby5TdWJqZWN0KSB7XG4gICAgICAgIHRoaXMuYXBwZW5kWE1MKGBcbiAgICAgICAgICAgICAgICA8ZGM6ZGVzY3JpcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxyZGY6QWx0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPHJkZjpsaSB4bWw6bGFuZz1cIngtZGVmYXVsdFwiPiR7dGhpcy5pbmZvLlN1YmplY3R9PC9yZGY6bGk+XG4gICAgICAgICAgICAgICAgICAgIDwvcmRmOkFsdD5cbiAgICAgICAgICAgICAgICA8L2RjOmRlc2NyaXB0aW9uPlxuICAgICAgICAgICAgICAgIGApO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmRYTUwoYFxuICAgICAgICAgICAgPC9yZGY6RGVzY3JpcHRpb24+XG4gICAgICAgICAgICBgKTtcbiAgICB9XG4gICAgdGhpcy5hcHBlbmRYTUwoYFxuICAgICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD1cIlwiIHhtbG5zOnBkZj1cImh0dHA6Ly9ucy5hZG9iZS5jb20vcGRmLzEuMy9cIj5cbiAgICAgICAgICAgIDxwZGY6UHJvZHVjZXI+JHt0aGlzLmluZm8uQ3JlYXRvcn08L3BkZjpQcm9kdWNlcj5gLCBmYWxzZSk7XG4gICAgaWYgKHRoaXMuaW5mby5LZXl3b3Jkcykge1xuICAgICAgdGhpcy5hcHBlbmRYTUwoYFxuICAgICAgICAgICAgPHBkZjpLZXl3b3Jkcz4ke3RoaXMuaW5mby5LZXl3b3Jkc308L3BkZjpLZXl3b3Jkcz5gLCBmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kWE1MKGBcbiAgICAgICAgPC9yZGY6RGVzY3JpcHRpb24+XG4gICAgICAgIGApO1xuICB9LFxuICBlbmRNZXRhZGF0YSgpIHtcbiAgICB0aGlzLl9hZGRJbmZvKCk7XG4gICAgdGhpcy5tZXRhZGF0YS5lbmQoKTtcbiAgICBpZiAodGhpcy52ZXJzaW9uICE9IDEuMykge1xuICAgICAgdGhpcy5tZXRhZGF0YVJlZiA9IHRoaXMucmVmKHtcbiAgICAgICAgbGVuZ3RoOiB0aGlzLm1ldGFkYXRhLmdldExlbmd0aCgpLFxuICAgICAgICBUeXBlOiAnTWV0YWRhdGEnLFxuICAgICAgICBTdWJ0eXBlOiAnWE1MJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1ldGFkYXRhUmVmLmNvbXByZXNzID0gZmFsc2U7XG4gICAgICB0aGlzLm1ldGFkYXRhUmVmLndyaXRlKEJ1ZmZlci5mcm9tKHRoaXMubWV0YWRhdGEuZ2V0WE1MKCksICd1dGYtOCcpKTtcbiAgICAgIHRoaXMubWV0YWRhdGFSZWYuZW5kKCk7XG4gICAgICB0aGlzLl9yb290LmRhdGEuTWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhUmVmO1xuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgUERGRG9jdW1lbnQgZXh0ZW5kcyBzdHJlYW0uUmVhZGFibGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBzd2l0Y2ggKG9wdGlvbnMucGRmVmVyc2lvbikge1xuICAgICAgY2FzZSAnMS40JzpcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gMS40O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzEuNSc6XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDEuNTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcxLjYnOlxuICAgICAgICB0aGlzLnZlcnNpb24gPSAxLjY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnMS43JzpcbiAgICAgIGNhc2UgJzEuN2V4dDMnOlxuICAgICAgICB0aGlzLnZlcnNpb24gPSAxLjc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gMS4zO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5jb21wcmVzcyA9IHRoaXMub3B0aW9ucy5jb21wcmVzcyAhPSBudWxsID8gdGhpcy5vcHRpb25zLmNvbXByZXNzIDogdHJ1ZTtcbiAgICB0aGlzLl9wYWdlQnVmZmVyID0gW107XG4gICAgdGhpcy5fcGFnZUJ1ZmZlclN0YXJ0ID0gMDtcbiAgICB0aGlzLl9vZmZzZXRzID0gW107XG4gICAgdGhpcy5fd2FpdGluZyA9IDA7XG4gICAgdGhpcy5fZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9vZmZzZXQgPSAwO1xuICAgIGNvbnN0IFBhZ2VzID0gdGhpcy5yZWYoe1xuICAgICAgVHlwZTogJ1BhZ2VzJyxcbiAgICAgIENvdW50OiAwLFxuICAgICAgS2lkczogW11cbiAgICB9KTtcbiAgICBjb25zdCBOYW1lcyA9IHRoaXMucmVmKHtcbiAgICAgIERlc3RzOiBuZXcgUERGTmFtZVRyZWUoKVxuICAgIH0pO1xuICAgIHRoaXMuX3Jvb3QgPSB0aGlzLnJlZih7XG4gICAgICBUeXBlOiAnQ2F0YWxvZycsXG4gICAgICBQYWdlcyxcbiAgICAgIE5hbWVzXG4gICAgfSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sYW5nKSB7XG4gICAgICB0aGlzLl9yb290LmRhdGEuTGFuZyA9IG5ldyBTdHJpbmcodGhpcy5vcHRpb25zLmxhbmcpO1xuICAgIH1cbiAgICB0aGlzLnBhZ2UgPSBudWxsO1xuICAgIHRoaXMuaW5pdE1ldGFkYXRhKCk7XG4gICAgdGhpcy5pbml0Q29sb3IoKTtcbiAgICB0aGlzLmluaXRWZWN0b3IoKTtcbiAgICB0aGlzLmluaXRGb250cyhvcHRpb25zLmZvbnQpO1xuICAgIHRoaXMuaW5pdFRleHQoKTtcbiAgICB0aGlzLmluaXRJbWFnZXMoKTtcbiAgICB0aGlzLmluaXRPdXRsaW5lKCk7XG4gICAgdGhpcy5pbml0TWFya2luZ3Mob3B0aW9ucyk7XG4gICAgdGhpcy5pbml0VGFibGVzKCk7XG4gICAgdGhpcy5pbml0U3Vic2V0KG9wdGlvbnMpO1xuICAgIHRoaXMuaW5mbyA9IHtcbiAgICAgIFByb2R1Y2VyOiAnUERGS2l0JyxcbiAgICAgIENyZWF0b3I6ICdQREZLaXQnLFxuICAgICAgQ3JlYXRpb25EYXRlOiBuZXcgRGF0ZSgpXG4gICAgfTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmluZm8pIHtcbiAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLm9wdGlvbnMuaW5mbykge1xuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLm9wdGlvbnMuaW5mb1trZXldO1xuICAgICAgICB0aGlzLmluZm9ba2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXNwbGF5VGl0bGUpIHtcbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5WaWV3ZXJQcmVmZXJlbmNlcyA9IHRoaXMucmVmKHtcbiAgICAgICAgRGlzcGxheURvY1RpdGxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5faWQgPSBQREZTZWN1cml0eS5nZW5lcmF0ZUZpbGVJRCh0aGlzLmluZm8pO1xuICAgIHRoaXMuX3NlY3VyaXR5ID0gUERGU2VjdXJpdHkuY3JlYXRlKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuX3dyaXRlKGAlUERGLSR7dGhpcy52ZXJzaW9ufWApO1xuICAgIHRoaXMuX3dyaXRlKCclXFx4RkZcXHhGRlxceEZGXFx4RkYnKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9GaXJzdFBhZ2UgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFkZFBhZ2UoKTtcbiAgICB9XG4gIH1cbiAgYWRkUGFnZShvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgKHtcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSA9IHRoaXMpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5idWZmZXJQYWdlcykge1xuICAgICAgdGhpcy5mbHVzaFBhZ2VzKCk7XG4gICAgfVxuICAgIHRoaXMucGFnZSA9IG5ldyBQREZQYWdlKHRoaXMsIG9wdGlvbnMpO1xuICAgIHRoaXMuX3BhZ2VCdWZmZXIucHVzaCh0aGlzLnBhZ2UpO1xuICAgIGNvbnN0IHBhZ2VzID0gdGhpcy5fcm9vdC5kYXRhLlBhZ2VzLmRhdGE7XG4gICAgcGFnZXMuS2lkcy5wdXNoKHRoaXMucGFnZS5kaWN0aW9uYXJ5KTtcbiAgICBwYWdlcy5Db3VudCsrO1xuICAgIHRoaXMueCA9IHRoaXMucGFnZS5tYXJnaW5zLmxlZnQ7XG4gICAgdGhpcy55ID0gdGhpcy5wYWdlLm1hcmdpbnMudG9wO1xuICAgIHRoaXMuX2N0bSA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICB0aGlzLnRyYW5zZm9ybSgxLCAwLCAwLCAtMSwgMCwgdGhpcy5wYWdlLmhlaWdodCk7XG4gICAgdGhpcy5lbWl0KCdwYWdlQWRkZWQnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjb250aW51ZU9uTmV3UGFnZShvcHRpb25zKSB7XG4gICAgY29uc3QgcGFnZU1hcmtpbmdzID0gdGhpcy5lbmRQYWdlTWFya2luZ3ModGhpcy5wYWdlKTtcbiAgICB0aGlzLmFkZFBhZ2Uob3B0aW9ucyA/PyB0aGlzLnBhZ2UuX29wdGlvbnMpO1xuICAgIHRoaXMuaW5pdFBhZ2VNYXJraW5ncyhwYWdlTWFya2luZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGJ1ZmZlcmVkUGFnZVJhbmdlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogdGhpcy5fcGFnZUJ1ZmZlclN0YXJ0LFxuICAgICAgY291bnQ6IHRoaXMuX3BhZ2VCdWZmZXIubGVuZ3RoXG4gICAgfTtcbiAgfVxuICBzd2l0Y2hUb1BhZ2Uobikge1xuICAgIGxldCBwYWdlO1xuICAgIGlmICghKHBhZ2UgPSB0aGlzLl9wYWdlQnVmZmVyW24gLSB0aGlzLl9wYWdlQnVmZmVyU3RhcnRdKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBzd2l0Y2hUb1BhZ2UoJHtufSkgb3V0IG9mIGJvdW5kcywgY3VycmVudCBidWZmZXIgY292ZXJzIHBhZ2VzICR7dGhpcy5fcGFnZUJ1ZmZlclN0YXJ0fSB0byAke3RoaXMuX3BhZ2VCdWZmZXJTdGFydCArIHRoaXMuX3BhZ2VCdWZmZXIubGVuZ3RoIC0gMX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFnZSA9IHBhZ2U7XG4gIH1cbiAgZmx1c2hQYWdlcygpIHtcbiAgICBjb25zdCBwYWdlcyA9IHRoaXMuX3BhZ2VCdWZmZXI7XG4gICAgdGhpcy5fcGFnZUJ1ZmZlciA9IFtdO1xuICAgIHRoaXMuX3BhZ2VCdWZmZXJTdGFydCArPSBwYWdlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgcGFnZSBvZiBwYWdlcykge1xuICAgICAgdGhpcy5lbmRQYWdlTWFya2luZ3MocGFnZSk7XG4gICAgICBwYWdlLmVuZCgpO1xuICAgIH1cbiAgfVxuICBhZGROYW1lZERlc3RpbmF0aW9uKG5hbWUpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBhcmdzID0gWydYWVonLCBudWxsLCBudWxsLCBudWxsXTtcbiAgICB9XG4gICAgaWYgKGFyZ3NbMF0gPT09ICdYWVonICYmIGFyZ3NbMl0gIT09IG51bGwpIHtcbiAgICAgIGFyZ3NbMl0gPSB0aGlzLnBhZ2UuaGVpZ2h0IC0gYXJnc1syXTtcbiAgICB9XG4gICAgYXJncy51bnNoaWZ0KHRoaXMucGFnZS5kaWN0aW9uYXJ5KTtcbiAgICB0aGlzLl9yb290LmRhdGEuTmFtZXMuZGF0YS5EZXN0cy5hZGQobmFtZSwgYXJncyk7XG4gIH1cbiAgYWRkTmFtZWRFbWJlZGRlZEZpbGUobmFtZSwgcmVmKSB7XG4gICAgaWYgKCF0aGlzLl9yb290LmRhdGEuTmFtZXMuZGF0YS5FbWJlZGRlZEZpbGVzKSB7XG4gICAgICB0aGlzLl9yb290LmRhdGEuTmFtZXMuZGF0YS5FbWJlZGRlZEZpbGVzID0gbmV3IFBERk5hbWVUcmVlKHtcbiAgICAgICAgbGltaXRzOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3Jvb3QuZGF0YS5OYW1lcy5kYXRhLkVtYmVkZGVkRmlsZXMuYWRkKG5hbWUsIHJlZik7XG4gIH1cbiAgYWRkTmFtZWRKYXZhU2NyaXB0KG5hbWUsIGpzKSB7XG4gICAgaWYgKCF0aGlzLl9yb290LmRhdGEuTmFtZXMuZGF0YS5KYXZhU2NyaXB0KSB7XG4gICAgICB0aGlzLl9yb290LmRhdGEuTmFtZXMuZGF0YS5KYXZhU2NyaXB0ID0gbmV3IFBERk5hbWVUcmVlKCk7XG4gICAgfVxuICAgIGxldCBkYXRhID0ge1xuICAgICAgSlM6IG5ldyBTdHJpbmcoanMpLFxuICAgICAgUzogJ0phdmFTY3JpcHQnXG4gICAgfTtcbiAgICB0aGlzLl9yb290LmRhdGEuTmFtZXMuZGF0YS5KYXZhU2NyaXB0LmFkZChuYW1lLCBkYXRhKTtcbiAgfVxuICByZWYoZGF0YSkge1xuICAgIGNvbnN0IHJlZiA9IG5ldyBQREZSZWZlcmVuY2UodGhpcywgdGhpcy5fb2Zmc2V0cy5sZW5ndGggKyAxLCBkYXRhKTtcbiAgICB0aGlzLl9vZmZzZXRzLnB1c2gobnVsbCk7XG4gICAgdGhpcy5fd2FpdGluZysrO1xuICAgIHJldHVybiByZWY7XG4gIH1cbiAgX3JlYWQoKSB7fVxuICBfd3JpdGUoZGF0YSkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSArICdcXG4nLCAnYmluYXJ5Jyk7XG4gICAgfVxuICAgIHRoaXMucHVzaChkYXRhKTtcbiAgICB0aGlzLl9vZmZzZXQgKz0gZGF0YS5sZW5ndGg7XG4gIH1cbiAgYWRkQ29udGVudChkYXRhKSB7XG4gICAgdGhpcy5wYWdlLndyaXRlKGRhdGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9yZWZFbmQocmVmKSB7XG4gICAgdGhpcy5fb2Zmc2V0c1tyZWYuaWQgLSAxXSA9IHJlZi5vZmZzZXQ7XG4gICAgaWYgKC0tdGhpcy5fd2FpdGluZyA9PT0gMCAmJiB0aGlzLl9lbmRlZCkge1xuICAgICAgdGhpcy5fZmluYWxpemUoKTtcbiAgICAgIHRoaXMuX2VuZGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGVuZCgpIHtcbiAgICB0aGlzLmZsdXNoUGFnZXMoKTtcbiAgICB0aGlzLl9pbmZvID0gdGhpcy5yZWYoKTtcbiAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5pbmZvKSB7XG4gICAgICBsZXQgdmFsID0gdGhpcy5pbmZvW2tleV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsID0gbmV3IFN0cmluZyh2YWwpO1xuICAgICAgfVxuICAgICAgbGV0IGVudHJ5ID0gdGhpcy5yZWYodmFsKTtcbiAgICAgIGVudHJ5LmVuZCgpO1xuICAgICAgdGhpcy5faW5mby5kYXRhW2tleV0gPSBlbnRyeTtcbiAgICB9XG4gICAgdGhpcy5faW5mby5lbmQoKTtcbiAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuX2ZvbnRGYW1pbGllcykge1xuICAgICAgY29uc3QgZm9udCA9IHRoaXMuX2ZvbnRGYW1pbGllc1tuYW1lXTtcbiAgICAgIGZvbnQuZmluYWxpemUoKTtcbiAgICB9XG4gICAgdGhpcy5lbmRPdXRsaW5lKCk7XG4gICAgdGhpcy5lbmRNYXJraW5ncygpO1xuICAgIGlmICh0aGlzLnN1YnNldCkge1xuICAgICAgdGhpcy5lbmRTdWJzZXQoKTtcbiAgICB9XG4gICAgdGhpcy5lbmRNZXRhZGF0YSgpO1xuICAgIHRoaXMuX3Jvb3QuZW5kKCk7XG4gICAgdGhpcy5fcm9vdC5kYXRhLlBhZ2VzLmVuZCgpO1xuICAgIHRoaXMuX3Jvb3QuZGF0YS5OYW1lcy5lbmQoKTtcbiAgICB0aGlzLmVuZEFjcm9Gb3JtKCk7XG4gICAgaWYgKHRoaXMuX3Jvb3QuZGF0YS5WaWV3ZXJQcmVmZXJlbmNlcykge1xuICAgICAgdGhpcy5fcm9vdC5kYXRhLlZpZXdlclByZWZlcmVuY2VzLmVuZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc2VjdXJpdHkpIHtcbiAgICAgIHRoaXMuX3NlY3VyaXR5LmVuZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fd2FpdGluZyA9PT0gMCkge1xuICAgICAgdGhpcy5fZmluYWxpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZW5kZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBfZmluYWxpemUoKSB7XG4gICAgY29uc3QgeFJlZk9mZnNldCA9IHRoaXMuX29mZnNldDtcbiAgICB0aGlzLl93cml0ZSgneHJlZicpO1xuICAgIHRoaXMuX3dyaXRlKGAwICR7dGhpcy5fb2Zmc2V0cy5sZW5ndGggKyAxfWApO1xuICAgIHRoaXMuX3dyaXRlKCcwMDAwMDAwMDAwIDY1NTM1IGYgJyk7XG4gICAgZm9yIChsZXQgb2Zmc2V0IG9mIHRoaXMuX29mZnNldHMpIHtcbiAgICAgIG9mZnNldCA9IGAwMDAwMDAwMDAwJHtvZmZzZXR9YC5zbGljZSgtMTApO1xuICAgICAgdGhpcy5fd3JpdGUob2Zmc2V0ICsgJyAwMDAwMCBuICcpO1xuICAgIH1cbiAgICBjb25zdCB0cmFpbGVyID0ge1xuICAgICAgU2l6ZTogdGhpcy5fb2Zmc2V0cy5sZW5ndGggKyAxLFxuICAgICAgUm9vdDogdGhpcy5fcm9vdCxcbiAgICAgIEluZm86IHRoaXMuX2luZm8sXG4gICAgICBJRDogW3RoaXMuX2lkLCB0aGlzLl9pZF1cbiAgICB9O1xuICAgIGlmICh0aGlzLl9zZWN1cml0eSkge1xuICAgICAgdHJhaWxlci5FbmNyeXB0ID0gdGhpcy5fc2VjdXJpdHkuZGljdGlvbmFyeTtcbiAgICB9XG4gICAgdGhpcy5fd3JpdGUoJ3RyYWlsZXInKTtcbiAgICB0aGlzLl93cml0ZShQREZPYmplY3QuY29udmVydCh0cmFpbGVyKSk7XG4gICAgdGhpcy5fd3JpdGUoJ3N0YXJ0eHJlZicpO1xuICAgIHRoaXMuX3dyaXRlKGAke3hSZWZPZmZzZXR9YCk7XG4gICAgdGhpcy5fd3JpdGUoJyUlRU9GJyk7XG4gICAgdGhpcy5wdXNoKG51bGwpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnW29iamVjdCBQREZEb2N1bWVudF0nO1xuICB9XG59XG5jb25zdCBtaXhpbiA9IG1ldGhvZHMgPT4ge1xuICBPYmplY3QuYXNzaWduKFBERkRvY3VtZW50LnByb3RvdHlwZSwgbWV0aG9kcyk7XG59O1xubWl4aW4oTWV0YWRhdGFNaXhpbik7XG5taXhpbihDb2xvck1peGluKTtcbm1peGluKFZlY3Rvck1peGluKTtcbm1peGluKEZvbnRzTWl4aW4pO1xubWl4aW4oVGV4dE1peGluKTtcbm1peGluKEltYWdlc01peGluKTtcbm1peGluKEFubm90YXRpb25zTWl4aW4pO1xubWl4aW4oT3V0bGluZU1peGluKTtcbm1peGluKE1hcmtpbmdzTWl4aW4pO1xubWl4aW4oQWNyb0Zvcm1NaXhpbik7XG5taXhpbihBdHRhY2htZW50c01peGluKTtcbm1peGluKFN1YnNldE1peGluKTtcbm1peGluKFRhYmxlTWl4aW4pO1xuUERGRG9jdW1lbnQuTGluZVdyYXBwZXIgPSBMaW5lV3JhcHBlcjtcblxuZXhwb3J0IHsgUERGRG9jdW1lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGRma2l0LmVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfkit/js/pdfkit.es.js\n");

/***/ })

};
;