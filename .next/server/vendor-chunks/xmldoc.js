/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/xmldoc";
exports.ids = ["vendor-chunks/xmldoc"];
exports.modules = {

/***/ "(rsc)/./node_modules/xmldoc/lib/xmldoc.js":
/*!*******************************************!*\
  !*** ./node_modules/xmldoc/lib/xmldoc.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("(function () {\n  var sax;\n\n  if (\n     true &&\n    module.exports &&\n    !global.xmldocAssumeBrowser\n  ) {\n    // We're being used in a Node-like environment\n    sax = __webpack_require__(/*! sax */ \"(rsc)/./node_modules/sax/lib/sax.js\");\n  } else {\n    // assume it's attached to the Window object in a browser\n    sax = this.sax;\n\n    if (!sax) {\n      // no sax for you!\n      throw new Error(\n        \"Expected sax to be defined. Make sure you're including sax.js before this file.\",\n      );\n    }\n  }\n\n  /**\n   * XmlElement is our basic building block. Everything is an XmlElement; even XmlDocument\n   * behaves like an XmlElement by inheriting its attributes and functions.\n   */\n  function XmlElement(tag, parser) {\n    // If you didn't hand us a parser (common case) see if we can grab one\n    // from the current execution stack.\n    if (!parser) {\n      var delegate = delegates[delegates.length - 1];\n\n      if (delegate.parser) {\n        parser = delegate.parser;\n      }\n    }\n\n    this.name = tag.name;\n    this.attr = tag.attributes;\n    this.val = \"\";\n    this.children = [];\n    this.firstChild = null;\n    this.lastChild = null;\n\n    // Assign parse information\n    this.line = parser ? parser.line : null;\n    this.column = parser ? parser.column : null;\n    this.position = parser ? parser.position : null;\n    this.startTagPosition = parser ? parser.startTagPosition : null;\n  }\n\n  // Private methods\n\n  XmlElement.prototype._addChild = function (child) {\n    // add to our children array\n    this.children.push(child);\n\n    // update first/last pointers\n    if (!this.firstChild) this.firstChild = child;\n    this.lastChild = child;\n  };\n\n  // SaxParser handlers\n\n  XmlElement.prototype._opentag = function (tag) {\n    var child = new XmlElement(tag);\n\n    this._addChild(child);\n\n    delegates.unshift(child);\n  };\n\n  XmlElement.prototype._closetag = function () {\n    delegates.shift();\n  };\n\n  XmlElement.prototype._text = function (text) {\n    if (typeof this.children === \"undefined\") return;\n\n    this.val += text;\n\n    this._addChild(new XmlTextNode(text));\n  };\n\n  XmlElement.prototype._cdata = function (cdata) {\n    this.val += cdata;\n\n    this._addChild(new XmlCDataNode(cdata));\n  };\n\n  XmlElement.prototype._comment = function (comment) {\n    if (typeof this.children === \"undefined\") return;\n\n    this._addChild(new XmlCommentNode(comment));\n  };\n\n  XmlElement.prototype._error = function (err) {\n    throw err;\n  };\n\n  // Useful functions\n\n  XmlElement.prototype.eachChild = function (iterator, context) {\n    for (var i = 0, l = this.children.length; i < l; i++)\n      if (this.children[i].type === \"element\")\n        if (\n          iterator.call(context, this.children[i], i, this.children) === false\n        )\n          return;\n  };\n\n  XmlElement.prototype.childNamed = function (name) {\n    for (var i = 0, l = this.children.length; i < l; i++) {\n      var child = this.children[i];\n      if (child.name === name) return child;\n    }\n    return undefined;\n  };\n\n  XmlElement.prototype.childrenNamed = function (name) {\n    var matches = [];\n\n    for (var i = 0, l = this.children.length; i < l; i++)\n      if (this.children[i].name === name) matches.push(this.children[i]);\n\n    return matches;\n  };\n\n  XmlElement.prototype.childWithAttribute = function (name, value) {\n    for (var i = 0, l = this.children.length; i < l; i++) {\n      var child = this.children[i];\n      if (\n        child.type === \"element\" &&\n        ((value && child.attr[name] === value) || (!value && child.attr[name]))\n      )\n        return child;\n    }\n    return undefined;\n  };\n\n  XmlElement.prototype.descendantsNamed = function (name) {\n    var matches = [];\n\n    for (var i = 0, l = this.children.length; i < l; i++) {\n      var child = this.children[i];\n      if (child.type === \"element\") {\n        if (child.name === name) matches.push(child);\n        matches = matches.concat(child.descendantsNamed(name));\n      }\n    }\n\n    return matches;\n  };\n\n  XmlElement.prototype.descendantWithPath = function (path) {\n    var descendant = this;\n    var components = path.split(\".\");\n\n    for (var i = 0, l = components.length; i < l; i++)\n      if (descendant && descendant.type === \"element\")\n        descendant = descendant.childNamed(components[i]);\n      else return undefined;\n\n    return descendant;\n  };\n\n  XmlElement.prototype.valueWithPath = function (path) {\n    var components = path.split(\"@\");\n    var descendant = this.descendantWithPath(components[0]);\n    if (descendant)\n      return components.length > 1\n        ? descendant.attr[components[1]]\n        : descendant.val;\n    else return undefined;\n  };\n\n  // String formatting (for debugging)\n\n  XmlElement.prototype.toString = function (options) {\n    return this.toStringWithIndent(\"\", options);\n  };\n\n  XmlElement.prototype.toStringWithIndent = function (indent, options) {\n    var s = indent + \"<\" + this.name;\n    var linebreak = options && options.compressed ? \"\" : \"\\n\";\n    var preserveWhitespace = options && options.preserveWhitespace;\n\n    for (var name in this.attr)\n      if (Object.prototype.hasOwnProperty.call(this.attr, name))\n        s += \" \" + name + '=\"' + escapeXML(this.attr[name]) + '\"';\n\n    if (this.children.length === 1 && this.children[0].type !== \"element\") {\n      s += \">\" + this.children[0].toString(options) + \"</\" + this.name + \">\";\n    } else if (this.children.length) {\n      s += \">\" + linebreak;\n\n      var childIndent = indent + (options && options.compressed ? \"\" : \"  \");\n\n      for (var i = 0, l = this.children.length; i < l; i++) {\n        s +=\n          this.children[i].toStringWithIndent(childIndent, options) + linebreak;\n      }\n\n      s += indent + \"</\" + this.name + \">\";\n    } else if (options && options.html) {\n      var whiteList = [\n        \"area\",\n        \"base\",\n        \"br\",\n        \"col\",\n        \"embed\",\n        \"frame\",\n        \"hr\",\n        \"img\",\n        \"input\",\n        \"keygen\",\n        \"link\",\n        \"menuitem\",\n        \"meta\",\n        \"param\",\n        \"source\",\n        \"track\",\n        \"wbr\",\n      ];\n      if (whiteList.indexOf(this.name) !== -1) s += \"/>\";\n      else s += \"></\" + this.name + \">\";\n    } else {\n      s += \"/>\";\n    }\n\n    return s;\n  };\n\n  // Alternative XML nodes\n\n  function XmlTextNode(text) {\n    this.text = text;\n  }\n\n  XmlTextNode.prototype.toString = function (options) {\n    return formatText(escapeXML(this.text), options);\n  };\n\n  XmlTextNode.prototype.toStringWithIndent = function (indent, options) {\n    return indent + this.toString(options);\n  };\n\n  function XmlCDataNode(cdata) {\n    this.cdata = cdata;\n  }\n\n  XmlCDataNode.prototype.toString = function (options) {\n    return \"<![CDATA[\" + formatText(this.cdata, options) + \"]]>\";\n  };\n\n  XmlCDataNode.prototype.toStringWithIndent = function (indent, options) {\n    return indent + this.toString(options);\n  };\n\n  function XmlCommentNode(comment) {\n    this.comment = comment;\n  }\n\n  XmlCommentNode.prototype.toString = function (options) {\n    return \"<!--\" + formatText(escapeXML(this.comment), options) + \"-->\";\n  };\n\n  XmlCommentNode.prototype.toStringWithIndent = function (indent, options) {\n    return indent + this.toString(options);\n  };\n\n  // Node type tag\n\n  XmlElement.prototype.type = \"element\";\n  XmlTextNode.prototype.type = \"text\";\n  XmlCDataNode.prototype.type = \"cdata\";\n  XmlCommentNode.prototype.type = \"comment\";\n\n  /**\n   * XmlDocument is the class we expose to the user; it uses the sax parser to create a hierarchy\n   * of XmlElements.\n   */\n  function XmlDocument(xml) {\n    xml && (xml = xml.toString().trim());\n\n    if (!xml) throw new Error(\"No XML to parse!\");\n\n    // Stores doctype (if defined)\n    this.doctype = \"\";\n\n    // Expose the parser to the other delegates while the parser is running\n    this.parser = sax.parser(true); // strict\n    addParserEvents(this.parser);\n\n    // We'll use the file-scoped \"delegates\" var to remember what elements we're currently\n    // parsing; they will push and pop off the stack as we get deeper into the XML hierarchy.\n    // It's safe to use a global because JS is single-threaded.\n    delegates = [this];\n\n    try {\n      this.parser.write(xml);\n    } finally {\n      // Remove the parser as it is no longer needed and should not be exposed to clients\n      delete this.parser;\n    }\n  }\n\n  // make XmlDocument inherit XmlElement's methods\n  extend(XmlDocument.prototype, XmlElement.prototype);\n\n  XmlDocument.prototype._opentag = function (tag) {\n    if (typeof this.children === \"undefined\")\n      // the first tag we encounter should be the root - we'll \"become\" the root XmlElement\n      XmlElement.call(this, tag);\n    // all other tags will be the root element's children\n    else XmlElement.prototype._opentag.apply(this, arguments);\n  };\n\n  XmlDocument.prototype._doctype = function (doctype) {\n    this.doctype += doctype;\n  };\n\n  // file-scoped global stack of delegates\n  var delegates = null;\n\n  /*\n   * Helper functions\n   */\n\n  function addParserEvents(parser) {\n    parser.onopentag = parser_opentag;\n    parser.onclosetag = parser_closetag;\n    parser.ontext = parser_text;\n    parser.oncdata = parser_cdata;\n    parser.oncomment = parser_comment;\n    parser.ondoctype = parser_doctype;\n    parser.onerror = parser_error;\n  }\n\n  // create these closures and cache them by keeping them file-scoped\n  function parser_opentag() {\n    delegates[0] && delegates[0]._opentag.apply(delegates[0], arguments);\n  }\n  function parser_closetag() {\n    delegates[0] && delegates[0]._closetag.apply(delegates[0], arguments);\n  }\n  function parser_text() {\n    delegates[0] && delegates[0]._text.apply(delegates[0], arguments);\n  }\n  function parser_cdata() {\n    delegates[0] && delegates[0]._cdata.apply(delegates[0], arguments);\n  }\n  function parser_comment() {\n    delegates[0] && delegates[0]._comment.apply(delegates[0], arguments);\n  }\n  function parser_doctype() {\n    delegates[0] && delegates[0]._doctype.apply(delegates[0], arguments);\n  }\n  function parser_error() {\n    delegates[0] && delegates[0]._error.apply(delegates[0], arguments);\n  }\n\n  // a relatively standard extend method\n  function extend(destination, source) {\n    for (var prop in source)\n      if (source.hasOwnProperty(prop)) destination[prop] = source[prop];\n  }\n\n  // escapes XML entities like \"<\", \"&\", etc.\n  function escapeXML(value) {\n    return value\n      .toString()\n      .replace(/&/g, \"&amp;\")\n      .replace(/</g, \"&lt;\")\n      .replace(/>/g, \"&gt;\")\n      .replace(/'/g, \"&apos;\")\n      .replace(/\"/g, \"&quot;\");\n  }\n\n  // formats some text for debugging given a few options\n  function formatText(text, options) {\n    var finalText = text;\n\n    if (options && options.trimmed && text.length > 25) {\n      finalText = finalText.substring(0, 25).trim() + \"â€¦\";\n    }\n\n    if (!(options && options.preserveWhitespace)) {\n      finalText = finalText.trim();\n    }\n\n    return finalText;\n  }\n\n  // Are we being used in a Node-like environment?\n  if (\n     true &&\n    module.exports &&\n    !global.xmldocAssumeBrowser\n  ) {\n    module.exports.XmlDocument = XmlDocument;\n    module.exports.XmlElement = XmlElement;\n    module.exports.XmlTextNode = XmlTextNode;\n    module.exports.XmlCDataNode = XmlCDataNode;\n    module.exports.XmlCommentNode = XmlCommentNode;\n  } else {\n    this.XmlDocument = XmlDocument;\n    this.XmlElement = XmlElement;\n    this.XmlTextNode = XmlTextNode;\n    this.XmlCDataNode = XmlCDataNode;\n    this.XmlCommentNode = XmlCommentNode;\n  }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveG1sZG9jL2xpYi94bWxkb2MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBNkI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsZ0RBQUs7QUFDdkIsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLE9BQU87QUFDckQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLEtBQTZCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLElBQUksMEJBQTBCO0FBQzlCLElBQUkseUJBQXlCO0FBQzdCLElBQUksMEJBQTBCO0FBQzlCLElBQUksMkJBQTJCO0FBQy9CLElBQUksNkJBQTZCO0FBQ2pDLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyIvaG9tZS9nYXNjYXQvcHJpc21hcXVhbnQvcHJpc21hLXF1YW50dW0vbm9kZV9tb2R1bGVzL3htbGRvYy9saWIveG1sZG9jLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoKSB7XG4gIHZhciBzYXg7XG5cbiAgaWYgKFxuICAgIHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICBtb2R1bGUuZXhwb3J0cyAmJlxuICAgICFnbG9iYWwueG1sZG9jQXNzdW1lQnJvd3NlclxuICApIHtcbiAgICAvLyBXZSdyZSBiZWluZyB1c2VkIGluIGEgTm9kZS1saWtlIGVudmlyb25tZW50XG4gICAgc2F4ID0gcmVxdWlyZShcInNheFwiKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBhc3N1bWUgaXQncyBhdHRhY2hlZCB0byB0aGUgV2luZG93IG9iamVjdCBpbiBhIGJyb3dzZXJcbiAgICBzYXggPSB0aGlzLnNheDtcblxuICAgIGlmICghc2F4KSB7XG4gICAgICAvLyBubyBzYXggZm9yIHlvdSFcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBzYXggdG8gYmUgZGVmaW5lZC4gTWFrZSBzdXJlIHlvdSdyZSBpbmNsdWRpbmcgc2F4LmpzIGJlZm9yZSB0aGlzIGZpbGUuXCIsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBYbWxFbGVtZW50IGlzIG91ciBiYXNpYyBidWlsZGluZyBibG9jay4gRXZlcnl0aGluZyBpcyBhbiBYbWxFbGVtZW50OyBldmVuIFhtbERvY3VtZW50XG4gICAqIGJlaGF2ZXMgbGlrZSBhbiBYbWxFbGVtZW50IGJ5IGluaGVyaXRpbmcgaXRzIGF0dHJpYnV0ZXMgYW5kIGZ1bmN0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFhtbEVsZW1lbnQodGFnLCBwYXJzZXIpIHtcbiAgICAvLyBJZiB5b3UgZGlkbid0IGhhbmQgdXMgYSBwYXJzZXIgKGNvbW1vbiBjYXNlKSBzZWUgaWYgd2UgY2FuIGdyYWIgb25lXG4gICAgLy8gZnJvbSB0aGUgY3VycmVudCBleGVjdXRpb24gc3RhY2suXG4gICAgaWYgKCFwYXJzZXIpIHtcbiAgICAgIHZhciBkZWxlZ2F0ZSA9IGRlbGVnYXRlc1tkZWxlZ2F0ZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChkZWxlZ2F0ZS5wYXJzZXIpIHtcbiAgICAgICAgcGFyc2VyID0gZGVsZWdhdGUucGFyc2VyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IHRhZy5uYW1lO1xuICAgIHRoaXMuYXR0ciA9IHRhZy5hdHRyaWJ1dGVzO1xuICAgIHRoaXMudmFsID0gXCJcIjtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5maXJzdENoaWxkID0gbnVsbDtcbiAgICB0aGlzLmxhc3RDaGlsZCA9IG51bGw7XG5cbiAgICAvLyBBc3NpZ24gcGFyc2UgaW5mb3JtYXRpb25cbiAgICB0aGlzLmxpbmUgPSBwYXJzZXIgPyBwYXJzZXIubGluZSA6IG51bGw7XG4gICAgdGhpcy5jb2x1bW4gPSBwYXJzZXIgPyBwYXJzZXIuY29sdW1uIDogbnVsbDtcbiAgICB0aGlzLnBvc2l0aW9uID0gcGFyc2VyID8gcGFyc2VyLnBvc2l0aW9uIDogbnVsbDtcbiAgICB0aGlzLnN0YXJ0VGFnUG9zaXRpb24gPSBwYXJzZXIgPyBwYXJzZXIuc3RhcnRUYWdQb3NpdGlvbiA6IG51bGw7XG4gIH1cblxuICAvLyBQcml2YXRlIG1ldGhvZHNcblxuICBYbWxFbGVtZW50LnByb3RvdHlwZS5fYWRkQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAvLyBhZGQgdG8gb3VyIGNoaWxkcmVuIGFycmF5XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICAgIC8vIHVwZGF0ZSBmaXJzdC9sYXN0IHBvaW50ZXJzXG4gICAgaWYgKCF0aGlzLmZpcnN0Q2hpbGQpIHRoaXMuZmlyc3RDaGlsZCA9IGNoaWxkO1xuICAgIHRoaXMubGFzdENoaWxkID0gY2hpbGQ7XG4gIH07XG5cbiAgLy8gU2F4UGFyc2VyIGhhbmRsZXJzXG5cbiAgWG1sRWxlbWVudC5wcm90b3R5cGUuX29wZW50YWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgdmFyIGNoaWxkID0gbmV3IFhtbEVsZW1lbnQodGFnKTtcblxuICAgIHRoaXMuX2FkZENoaWxkKGNoaWxkKTtcblxuICAgIGRlbGVnYXRlcy51bnNoaWZ0KGNoaWxkKTtcbiAgfTtcblxuICBYbWxFbGVtZW50LnByb3RvdHlwZS5fY2xvc2V0YWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVsZWdhdGVzLnNoaWZ0KCk7XG4gIH07XG5cbiAgWG1sRWxlbWVudC5wcm90b3R5cGUuX3RleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5jaGlsZHJlbiA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuXG4gICAgdGhpcy52YWwgKz0gdGV4dDtcblxuICAgIHRoaXMuX2FkZENoaWxkKG5ldyBYbWxUZXh0Tm9kZSh0ZXh0KSk7XG4gIH07XG5cbiAgWG1sRWxlbWVudC5wcm90b3R5cGUuX2NkYXRhID0gZnVuY3Rpb24gKGNkYXRhKSB7XG4gICAgdGhpcy52YWwgKz0gY2RhdGE7XG5cbiAgICB0aGlzLl9hZGRDaGlsZChuZXcgWG1sQ0RhdGFOb2RlKGNkYXRhKSk7XG4gIH07XG5cbiAgWG1sRWxlbWVudC5wcm90b3R5cGUuX2NvbW1lbnQgPSBmdW5jdGlvbiAoY29tbWVudCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5jaGlsZHJlbiA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuXG4gICAgdGhpcy5fYWRkQ2hpbGQobmV3IFhtbENvbW1lbnROb2RlKGNvbW1lbnQpKTtcbiAgfTtcblxuICBYbWxFbGVtZW50LnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdGhyb3cgZXJyO1xuICB9O1xuXG4gIC8vIFVzZWZ1bCBmdW5jdGlvbnNcblxuICBYbWxFbGVtZW50LnByb3RvdHlwZS5lYWNoQ2hpbGQgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0udHlwZSA9PT0gXCJlbGVtZW50XCIpXG4gICAgICAgIGlmIChcbiAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHRoaXMuY2hpbGRyZW5baV0sIGksIHRoaXMuY2hpbGRyZW4pID09PSBmYWxzZVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuO1xuICB9O1xuXG4gIFhtbEVsZW1lbnQucHJvdG90eXBlLmNoaWxkTmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQubmFtZSA9PT0gbmFtZSkgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIFhtbEVsZW1lbnQucHJvdG90eXBlLmNoaWxkcmVuTmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBtYXRjaGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0ubmFtZSA9PT0gbmFtZSkgbWF0Y2hlcy5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH07XG5cbiAgWG1sRWxlbWVudC5wcm90b3R5cGUuY2hpbGRXaXRoQXR0cmlidXRlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChcbiAgICAgICAgY2hpbGQudHlwZSA9PT0gXCJlbGVtZW50XCIgJiZcbiAgICAgICAgKCh2YWx1ZSAmJiBjaGlsZC5hdHRyW25hbWVdID09PSB2YWx1ZSkgfHwgKCF2YWx1ZSAmJiBjaGlsZC5hdHRyW25hbWVdKSlcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIFhtbEVsZW1lbnQucHJvdG90eXBlLmRlc2NlbmRhbnRzTmFtZWQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBtYXRjaGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiZWxlbWVudFwiKSB7XG4gICAgICAgIGlmIChjaGlsZC5uYW1lID09PSBuYW1lKSBtYXRjaGVzLnB1c2goY2hpbGQpO1xuICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5jb25jYXQoY2hpbGQuZGVzY2VuZGFudHNOYW1lZChuYW1lKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH07XG5cbiAgWG1sRWxlbWVudC5wcm90b3R5cGUuZGVzY2VuZGFudFdpdGhQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgZGVzY2VuZGFudCA9IHRoaXM7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBwYXRoLnNwbGl0KFwiLlwiKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICBpZiAoZGVzY2VuZGFudCAmJiBkZXNjZW5kYW50LnR5cGUgPT09IFwiZWxlbWVudFwiKVxuICAgICAgICBkZXNjZW5kYW50ID0gZGVzY2VuZGFudC5jaGlsZE5hbWVkKGNvbXBvbmVudHNbaV0pO1xuICAgICAgZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIGRlc2NlbmRhbnQ7XG4gIH07XG5cbiAgWG1sRWxlbWVudC5wcm90b3R5cGUudmFsdWVXaXRoUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBwYXRoLnNwbGl0KFwiQFwiKTtcbiAgICB2YXIgZGVzY2VuZGFudCA9IHRoaXMuZGVzY2VuZGFudFdpdGhQYXRoKGNvbXBvbmVudHNbMF0pO1xuICAgIGlmIChkZXNjZW5kYW50KVxuICAgICAgcmV0dXJuIGNvbXBvbmVudHMubGVuZ3RoID4gMVxuICAgICAgICA/IGRlc2NlbmRhbnQuYXR0cltjb21wb25lbnRzWzFdXVxuICAgICAgICA6IGRlc2NlbmRhbnQudmFsO1xuICAgIGVsc2UgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICAvLyBTdHJpbmcgZm9ybWF0dGluZyAoZm9yIGRlYnVnZ2luZylcblxuICBYbWxFbGVtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmdXaXRoSW5kZW50KFwiXCIsIG9wdGlvbnMpO1xuICB9O1xuXG4gIFhtbEVsZW1lbnQucHJvdG90eXBlLnRvU3RyaW5nV2l0aEluZGVudCA9IGZ1bmN0aW9uIChpbmRlbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgcyA9IGluZGVudCArIFwiPFwiICsgdGhpcy5uYW1lO1xuICAgIHZhciBsaW5lYnJlYWsgPSBvcHRpb25zICYmIG9wdGlvbnMuY29tcHJlc3NlZCA/IFwiXCIgOiBcIlxcblwiO1xuICAgIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zICYmIG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLmF0dHIpXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0ciwgbmFtZSkpXG4gICAgICAgIHMgKz0gXCIgXCIgKyBuYW1lICsgJz1cIicgKyBlc2NhcGVYTUwodGhpcy5hdHRyW25hbWVdKSArICdcIic7XG5cbiAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgdGhpcy5jaGlsZHJlblswXS50eXBlICE9PSBcImVsZW1lbnRcIikge1xuICAgICAgcyArPSBcIj5cIiArIHRoaXMuY2hpbGRyZW5bMF0udG9TdHJpbmcob3B0aW9ucykgKyBcIjwvXCIgKyB0aGlzLm5hbWUgKyBcIj5cIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBzICs9IFwiPlwiICsgbGluZWJyZWFrO1xuXG4gICAgICB2YXIgY2hpbGRJbmRlbnQgPSBpbmRlbnQgKyAob3B0aW9ucyAmJiBvcHRpb25zLmNvbXByZXNzZWQgPyBcIlwiIDogXCIgIFwiKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBzICs9XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS50b1N0cmluZ1dpdGhJbmRlbnQoY2hpbGRJbmRlbnQsIG9wdGlvbnMpICsgbGluZWJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzICs9IGluZGVudCArIFwiPC9cIiArIHRoaXMubmFtZSArIFwiPlwiO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmh0bWwpIHtcbiAgICAgIHZhciB3aGl0ZUxpc3QgPSBbXG4gICAgICAgIFwiYXJlYVwiLFxuICAgICAgICBcImJhc2VcIixcbiAgICAgICAgXCJiclwiLFxuICAgICAgICBcImNvbFwiLFxuICAgICAgICBcImVtYmVkXCIsXG4gICAgICAgIFwiZnJhbWVcIixcbiAgICAgICAgXCJoclwiLFxuICAgICAgICBcImltZ1wiLFxuICAgICAgICBcImlucHV0XCIsXG4gICAgICAgIFwia2V5Z2VuXCIsXG4gICAgICAgIFwibGlua1wiLFxuICAgICAgICBcIm1lbnVpdGVtXCIsXG4gICAgICAgIFwibWV0YVwiLFxuICAgICAgICBcInBhcmFtXCIsXG4gICAgICAgIFwic291cmNlXCIsXG4gICAgICAgIFwidHJhY2tcIixcbiAgICAgICAgXCJ3YnJcIixcbiAgICAgIF07XG4gICAgICBpZiAod2hpdGVMaXN0LmluZGV4T2YodGhpcy5uYW1lKSAhPT0gLTEpIHMgKz0gXCIvPlwiO1xuICAgICAgZWxzZSBzICs9IFwiPjwvXCIgKyB0aGlzLm5hbWUgKyBcIj5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcyArPSBcIi8+XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHM7XG4gIH07XG5cbiAgLy8gQWx0ZXJuYXRpdmUgWE1MIG5vZGVzXG5cbiAgZnVuY3Rpb24gWG1sVGV4dE5vZGUodGV4dCkge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gIH1cblxuICBYbWxUZXh0Tm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBmb3JtYXRUZXh0KGVzY2FwZVhNTCh0aGlzLnRleHQpLCBvcHRpb25zKTtcbiAgfTtcblxuICBYbWxUZXh0Tm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoSW5kZW50ID0gZnVuY3Rpb24gKGluZGVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBpbmRlbnQgKyB0aGlzLnRvU3RyaW5nKG9wdGlvbnMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFhtbENEYXRhTm9kZShjZGF0YSkge1xuICAgIHRoaXMuY2RhdGEgPSBjZGF0YTtcbiAgfVxuXG4gIFhtbENEYXRhTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBcIjwhW0NEQVRBW1wiICsgZm9ybWF0VGV4dCh0aGlzLmNkYXRhLCBvcHRpb25zKSArIFwiXV0+XCI7XG4gIH07XG5cbiAgWG1sQ0RhdGFOb2RlLnByb3RvdHlwZS50b1N0cmluZ1dpdGhJbmRlbnQgPSBmdW5jdGlvbiAoaW5kZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGluZGVudCArIHRoaXMudG9TdHJpbmcob3B0aW9ucyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gWG1sQ29tbWVudE5vZGUoY29tbWVudCkge1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG4gIH1cblxuICBYbWxDb21tZW50Tm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBcIjwhLS1cIiArIGZvcm1hdFRleHQoZXNjYXBlWE1MKHRoaXMuY29tbWVudCksIG9wdGlvbnMpICsgXCItLT5cIjtcbiAgfTtcblxuICBYbWxDb21tZW50Tm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoSW5kZW50ID0gZnVuY3Rpb24gKGluZGVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBpbmRlbnQgKyB0aGlzLnRvU3RyaW5nKG9wdGlvbnMpO1xuICB9O1xuXG4gIC8vIE5vZGUgdHlwZSB0YWdcblxuICBYbWxFbGVtZW50LnByb3RvdHlwZS50eXBlID0gXCJlbGVtZW50XCI7XG4gIFhtbFRleHROb2RlLnByb3RvdHlwZS50eXBlID0gXCJ0ZXh0XCI7XG4gIFhtbENEYXRhTm9kZS5wcm90b3R5cGUudHlwZSA9IFwiY2RhdGFcIjtcbiAgWG1sQ29tbWVudE5vZGUucHJvdG90eXBlLnR5cGUgPSBcImNvbW1lbnRcIjtcblxuICAvKipcbiAgICogWG1sRG9jdW1lbnQgaXMgdGhlIGNsYXNzIHdlIGV4cG9zZSB0byB0aGUgdXNlcjsgaXQgdXNlcyB0aGUgc2F4IHBhcnNlciB0byBjcmVhdGUgYSBoaWVyYXJjaHlcbiAgICogb2YgWG1sRWxlbWVudHMuXG4gICAqL1xuICBmdW5jdGlvbiBYbWxEb2N1bWVudCh4bWwpIHtcbiAgICB4bWwgJiYgKHhtbCA9IHhtbC50b1N0cmluZygpLnRyaW0oKSk7XG5cbiAgICBpZiAoIXhtbCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gWE1MIHRvIHBhcnNlIVwiKTtcblxuICAgIC8vIFN0b3JlcyBkb2N0eXBlIChpZiBkZWZpbmVkKVxuICAgIHRoaXMuZG9jdHlwZSA9IFwiXCI7XG5cbiAgICAvLyBFeHBvc2UgdGhlIHBhcnNlciB0byB0aGUgb3RoZXIgZGVsZWdhdGVzIHdoaWxlIHRoZSBwYXJzZXIgaXMgcnVubmluZ1xuICAgIHRoaXMucGFyc2VyID0gc2F4LnBhcnNlcih0cnVlKTsgLy8gc3RyaWN0XG4gICAgYWRkUGFyc2VyRXZlbnRzKHRoaXMucGFyc2VyKTtcblxuICAgIC8vIFdlJ2xsIHVzZSB0aGUgZmlsZS1zY29wZWQgXCJkZWxlZ2F0ZXNcIiB2YXIgdG8gcmVtZW1iZXIgd2hhdCBlbGVtZW50cyB3ZSdyZSBjdXJyZW50bHlcbiAgICAvLyBwYXJzaW5nOyB0aGV5IHdpbGwgcHVzaCBhbmQgcG9wIG9mZiB0aGUgc3RhY2sgYXMgd2UgZ2V0IGRlZXBlciBpbnRvIHRoZSBYTUwgaGllcmFyY2h5LlxuICAgIC8vIEl0J3Mgc2FmZSB0byB1c2UgYSBnbG9iYWwgYmVjYXVzZSBKUyBpcyBzaW5nbGUtdGhyZWFkZWQuXG4gICAgZGVsZWdhdGVzID0gW3RoaXNdO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucGFyc2VyLndyaXRlKHhtbCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgcGFyc2VyIGFzIGl0IGlzIG5vIGxvbmdlciBuZWVkZWQgYW5kIHNob3VsZCBub3QgYmUgZXhwb3NlZCB0byBjbGllbnRzXG4gICAgICBkZWxldGUgdGhpcy5wYXJzZXI7XG4gICAgfVxuICB9XG5cbiAgLy8gbWFrZSBYbWxEb2N1bWVudCBpbmhlcml0IFhtbEVsZW1lbnQncyBtZXRob2RzXG4gIGV4dGVuZChYbWxEb2N1bWVudC5wcm90b3R5cGUsIFhtbEVsZW1lbnQucHJvdG90eXBlKTtcblxuICBYbWxEb2N1bWVudC5wcm90b3R5cGUuX29wZW50YWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmNoaWxkcmVuID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgLy8gdGhlIGZpcnN0IHRhZyB3ZSBlbmNvdW50ZXIgc2hvdWxkIGJlIHRoZSByb290IC0gd2UnbGwgXCJiZWNvbWVcIiB0aGUgcm9vdCBYbWxFbGVtZW50XG4gICAgICBYbWxFbGVtZW50LmNhbGwodGhpcywgdGFnKTtcbiAgICAvLyBhbGwgb3RoZXIgdGFncyB3aWxsIGJlIHRoZSByb290IGVsZW1lbnQncyBjaGlsZHJlblxuICAgIGVsc2UgWG1sRWxlbWVudC5wcm90b3R5cGUuX29wZW50YWcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICBYbWxEb2N1bWVudC5wcm90b3R5cGUuX2RvY3R5cGUgPSBmdW5jdGlvbiAoZG9jdHlwZSkge1xuICAgIHRoaXMuZG9jdHlwZSArPSBkb2N0eXBlO1xuICB9O1xuXG4gIC8vIGZpbGUtc2NvcGVkIGdsb2JhbCBzdGFjayBvZiBkZWxlZ2F0ZXNcbiAgdmFyIGRlbGVnYXRlcyA9IG51bGw7XG5cbiAgLypcbiAgICogSGVscGVyIGZ1bmN0aW9uc1xuICAgKi9cblxuICBmdW5jdGlvbiBhZGRQYXJzZXJFdmVudHMocGFyc2VyKSB7XG4gICAgcGFyc2VyLm9ub3BlbnRhZyA9IHBhcnNlcl9vcGVudGFnO1xuICAgIHBhcnNlci5vbmNsb3NldGFnID0gcGFyc2VyX2Nsb3NldGFnO1xuICAgIHBhcnNlci5vbnRleHQgPSBwYXJzZXJfdGV4dDtcbiAgICBwYXJzZXIub25jZGF0YSA9IHBhcnNlcl9jZGF0YTtcbiAgICBwYXJzZXIub25jb21tZW50ID0gcGFyc2VyX2NvbW1lbnQ7XG4gICAgcGFyc2VyLm9uZG9jdHlwZSA9IHBhcnNlcl9kb2N0eXBlO1xuICAgIHBhcnNlci5vbmVycm9yID0gcGFyc2VyX2Vycm9yO1xuICB9XG5cbiAgLy8gY3JlYXRlIHRoZXNlIGNsb3N1cmVzIGFuZCBjYWNoZSB0aGVtIGJ5IGtlZXBpbmcgdGhlbSBmaWxlLXNjb3BlZFxuICBmdW5jdGlvbiBwYXJzZXJfb3BlbnRhZygpIHtcbiAgICBkZWxlZ2F0ZXNbMF0gJiYgZGVsZWdhdGVzWzBdLl9vcGVudGFnLmFwcGx5KGRlbGVnYXRlc1swXSwgYXJndW1lbnRzKTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZXJfY2xvc2V0YWcoKSB7XG4gICAgZGVsZWdhdGVzWzBdICYmIGRlbGVnYXRlc1swXS5fY2xvc2V0YWcuYXBwbHkoZGVsZWdhdGVzWzBdLCBhcmd1bWVudHMpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlcl90ZXh0KCkge1xuICAgIGRlbGVnYXRlc1swXSAmJiBkZWxlZ2F0ZXNbMF0uX3RleHQuYXBwbHkoZGVsZWdhdGVzWzBdLCBhcmd1bWVudHMpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlcl9jZGF0YSgpIHtcbiAgICBkZWxlZ2F0ZXNbMF0gJiYgZGVsZWdhdGVzWzBdLl9jZGF0YS5hcHBseShkZWxlZ2F0ZXNbMF0sIGFyZ3VtZW50cyk7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VyX2NvbW1lbnQoKSB7XG4gICAgZGVsZWdhdGVzWzBdICYmIGRlbGVnYXRlc1swXS5fY29tbWVudC5hcHBseShkZWxlZ2F0ZXNbMF0sIGFyZ3VtZW50cyk7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VyX2RvY3R5cGUoKSB7XG4gICAgZGVsZWdhdGVzWzBdICYmIGRlbGVnYXRlc1swXS5fZG9jdHlwZS5hcHBseShkZWxlZ2F0ZXNbMF0sIGFyZ3VtZW50cyk7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VyX2Vycm9yKCkge1xuICAgIGRlbGVnYXRlc1swXSAmJiBkZWxlZ2F0ZXNbMF0uX2Vycm9yLmFwcGx5KGRlbGVnYXRlc1swXSwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8vIGEgcmVsYXRpdmVseSBzdGFuZGFyZCBleHRlbmQgbWV0aG9kXG4gIGZ1bmN0aW9uIGV4dGVuZChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSBkZXN0aW5hdGlvbltwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgfVxuXG4gIC8vIGVzY2FwZXMgWE1MIGVudGl0aWVzIGxpa2UgXCI8XCIsIFwiJlwiLCBldGMuXG4gIGZ1bmN0aW9uIGVzY2FwZVhNTCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZVxuICAgICAgLnRvU3RyaW5nKClcbiAgICAgIC5yZXBsYWNlKC8mL2csIFwiJmFtcDtcIilcbiAgICAgIC5yZXBsYWNlKC88L2csIFwiJmx0O1wiKVxuICAgICAgLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpXG4gICAgICAucmVwbGFjZSgvJy9nLCBcIiZhcG9zO1wiKVxuICAgICAgLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpO1xuICB9XG5cbiAgLy8gZm9ybWF0cyBzb21lIHRleHQgZm9yIGRlYnVnZ2luZyBnaXZlbiBhIGZldyBvcHRpb25zXG4gIGZ1bmN0aW9uIGZvcm1hdFRleHQodGV4dCwgb3B0aW9ucykge1xuICAgIHZhciBmaW5hbFRleHQgPSB0ZXh0O1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50cmltbWVkICYmIHRleHQubGVuZ3RoID4gMjUpIHtcbiAgICAgIGZpbmFsVGV4dCA9IGZpbmFsVGV4dC5zdWJzdHJpbmcoMCwgMjUpLnRyaW0oKSArIFwi4oCmXCI7XG4gICAgfVxuXG4gICAgaWYgKCEob3B0aW9ucyAmJiBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSkpIHtcbiAgICAgIGZpbmFsVGV4dCA9IGZpbmFsVGV4dC50cmltKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmFsVGV4dDtcbiAgfVxuXG4gIC8vIEFyZSB3ZSBiZWluZyB1c2VkIGluIGEgTm9kZS1saWtlIGVudmlyb25tZW50P1xuICBpZiAoXG4gICAgdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIG1vZHVsZS5leHBvcnRzICYmXG4gICAgIWdsb2JhbC54bWxkb2NBc3N1bWVCcm93c2VyXG4gICkge1xuICAgIG1vZHVsZS5leHBvcnRzLlhtbERvY3VtZW50ID0gWG1sRG9jdW1lbnQ7XG4gICAgbW9kdWxlLmV4cG9ydHMuWG1sRWxlbWVudCA9IFhtbEVsZW1lbnQ7XG4gICAgbW9kdWxlLmV4cG9ydHMuWG1sVGV4dE5vZGUgPSBYbWxUZXh0Tm9kZTtcbiAgICBtb2R1bGUuZXhwb3J0cy5YbWxDRGF0YU5vZGUgPSBYbWxDRGF0YU5vZGU7XG4gICAgbW9kdWxlLmV4cG9ydHMuWG1sQ29tbWVudE5vZGUgPSBYbWxDb21tZW50Tm9kZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLlhtbERvY3VtZW50ID0gWG1sRG9jdW1lbnQ7XG4gICAgdGhpcy5YbWxFbGVtZW50ID0gWG1sRWxlbWVudDtcbiAgICB0aGlzLlhtbFRleHROb2RlID0gWG1sVGV4dE5vZGU7XG4gICAgdGhpcy5YbWxDRGF0YU5vZGUgPSBYbWxDRGF0YU5vZGU7XG4gICAgdGhpcy5YbWxDb21tZW50Tm9kZSA9IFhtbENvbW1lbnROb2RlO1xuICB9XG59KSgpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/xmldoc/lib/xmldoc.js\n");

/***/ })

};
;